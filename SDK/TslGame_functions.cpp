#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TslGame

#include "Basic.hpp"

#include "TslGame_classes.hpp"
#include "TslGame_parameters.hpp"


namespace SDK
{

// Function TslGame.InteractionComponent.AllowInteractBy
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*                    Character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionComponent::AllowInteractBy(const class ATslCharacter* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "AllowInteractBy");

	Params::InteractionComponent_AllowInteractBy Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.InteractionComponent.GetInteractionVerb
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UInteractionComponent::GetInteractionVerb() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "GetInteractionVerb");

	Params::InteractionComponent_GetInteractionVerb Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.InteractionComponent.GetInteractiveObjectName
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UInteractionComponent::GetInteractiveObjectName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "GetInteractiveObjectName");

	Params::InteractionComponent_GetInteractiveObjectName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VivoxBaseComponent.ClientJoinGlobalChannel
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// class FString                           AccessToken                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVivoxBaseComponent::ClientJoinGlobalChannel(const class FString& AccessToken)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxBaseComponent", "ClientJoinGlobalChannel");

	Params::VivoxBaseComponent_ClientJoinGlobalChannel Parms{};

	Parms.AccessToken = std::move(AccessToken);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VivoxBaseComponent.ClientJoinTeamChannel
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// class FString                           AccessToken                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVivoxBaseComponent::ClientJoinTeamChannel(const class FString& AccessToken)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxBaseComponent", "ClientJoinTeamChannel");

	Params::VivoxBaseComponent_ClientJoinTeamChannel Parms{};

	Parms.AccessToken = std::move(AccessToken);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VivoxBaseComponent.ClientLeaveGlobalChannel
// (Net, NetReliable, Native, Event, Protected, NetClient)

void UVivoxBaseComponent::ClientLeaveGlobalChannel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxBaseComponent", "ClientLeaveGlobalChannel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VivoxBaseComponent.ClientLeaveTeamChannel
// (Net, NetReliable, Native, Event, Protected, NetClient)

void UVivoxBaseComponent::ClientLeaveTeamChannel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxBaseComponent", "ClientLeaveTeamChannel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VivoxBaseComponent.ClientLogin
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// class FString                           AccessToken                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVivoxBaseComponent::ClientLogin(const class FString& AccessToken)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxBaseComponent", "ClientLogin");

	Params::VivoxBaseComponent_ClientLogin Parms{};

	Parms.AccessToken = std::move(AccessToken);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VivoxBaseComponent.RefreshDevices
// (Final, Native, Private)

void UVivoxBaseComponent::RefreshDevices()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxBaseComponent", "RefreshDevices");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VivoxBaseComponent.ResetConnectionState
// (Final, Native, Private)

void UVivoxBaseComponent::ResetConnectionState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxBaseComponent", "ResetConnectionState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VivoxBaseComponent.ResetGlobalChannelJoinState
// (Final, Native, Private)

void UVivoxBaseComponent::ResetGlobalChannelJoinState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxBaseComponent", "ResetGlobalChannelJoinState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VivoxBaseComponent.ResetLoginState
// (Final, Native, Private)

void UVivoxBaseComponent::ResetLoginState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxBaseComponent", "ResetLoginState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VivoxBaseComponent.ResetTeamChannelJoinState
// (Final, Native, Private)

void UVivoxBaseComponent::ResetTeamChannelJoinState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxBaseComponent", "ResetTeamChannelJoinState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VivoxBaseComponent.ServerJoinGlobalChannel
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void UVivoxBaseComponent::ServerJoinGlobalChannel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxBaseComponent", "ServerJoinGlobalChannel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VivoxBaseComponent.ServerJoinTeamChannel
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void UVivoxBaseComponent::ServerJoinTeamChannel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxBaseComponent", "ServerJoinTeamChannel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VivoxBaseComponent.ServerLogin
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void UVivoxBaseComponent::ServerLogin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxBaseComponent", "ServerLogin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VivoxBaseComponent.SetLocalVoiceInputMuted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsMuted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVivoxBaseComponent::SetLocalVoiceInputMuted(bool bIsMuted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxBaseComponent", "SetLocalVoiceInputMuted");

	Params::VivoxBaseComponent_SetLocalVoiceInputMuted Parms{};

	Parms.bIsMuted = bIsMuted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VivoxBaseComponent.SetLocalVoiceInputVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   UserSettingVolume                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVivoxBaseComponent::SetLocalVoiceInputVolume(int32 UserSettingVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxBaseComponent", "SetLocalVoiceInputVolume");

	Params::VivoxBaseComponent_SetLocalVoiceInputVolume Parms{};

	Parms.UserSettingVolume = UserSettingVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VivoxBaseComponent.SetLocalVoiceOutputMuted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsMuted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVivoxBaseComponent::SetLocalVoiceOutputMuted(bool bIsMuted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxBaseComponent", "SetLocalVoiceOutputMuted");

	Params::VivoxBaseComponent_SetLocalVoiceOutputMuted Parms{};

	Parms.bIsMuted = bIsMuted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VivoxBaseComponent.SetLocalVoiceOutputVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   UserSettingVolume                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVivoxBaseComponent::SetLocalVoiceOutputVolume(int32 UserSettingVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxBaseComponent", "SetLocalVoiceOutputVolume");

	Params::VivoxBaseComponent_SetLocalVoiceOutputVolume Parms{};

	Parms.UserSettingVolume = UserSettingVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VivoxBaseComponent.SetVoiceChannelType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVivoxChannelType                       ChannelType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVivoxBaseComponent::SetVoiceChannelType(EVivoxChannelType ChannelType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxBaseComponent", "SetVoiceChannelType");

	Params::VivoxBaseComponent_SetVoiceChannelType Parms{};

	Parms.ChannelType = ChannelType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VivoxBaseComponent.UpdatePosition
// (Native, Protected)

void UVivoxBaseComponent::UpdatePosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxBaseComponent", "UpdatePosition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VivoxBaseComponent.CalculateInputVolumeFromModifiers
// (Final, Native, Protected, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UVivoxBaseComponent::CalculateInputVolumeFromModifiers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxBaseComponent", "CalculateInputVolumeFromModifiers");

	Params::VivoxBaseComponent_CalculateInputVolumeFromModifiers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VivoxBaseComponent.CalculateOutputVolumeFromModifiers
// (Final, Native, Protected, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UVivoxBaseComponent::CalculateOutputVolumeFromModifiers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxBaseComponent", "CalculateOutputVolumeFromModifiers");

	Params::VivoxBaseComponent_CalculateOutputVolumeFromModifiers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VivoxBaseComponent.GetLocalVoiceInputMuted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVivoxBaseComponent::GetLocalVoiceInputMuted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxBaseComponent", "GetLocalVoiceInputMuted");

	Params::VivoxBaseComponent_GetLocalVoiceInputMuted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VivoxBaseComponent.GetLocalVoiceInputVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UVivoxBaseComponent::GetLocalVoiceInputVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxBaseComponent", "GetLocalVoiceInputVolume");

	Params::VivoxBaseComponent_GetLocalVoiceInputVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VivoxBaseComponent.GetLocalVoiceOutputMuted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVivoxBaseComponent::GetLocalVoiceOutputMuted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxBaseComponent", "GetLocalVoiceOutputMuted");

	Params::VivoxBaseComponent_GetLocalVoiceOutputMuted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VivoxBaseComponent.GetLocalVoiceOutputVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UVivoxBaseComponent::GetLocalVoiceOutputVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxBaseComponent", "GetLocalVoiceOutputVolume");

	Params::VivoxBaseComponent_GetLocalVoiceOutputVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VivoxBaseComponent.GetVoiceChannelType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EVivoxChannelType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EVivoxChannelType UVivoxBaseComponent::GetVoiceChannelType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxBaseComponent", "GetVoiceChannelType");

	Params::VivoxBaseComponent_GetVoiceChannelType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.AnimDB.GetAnimSpeed
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAnimStanceType                         AnimStance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SprintAlpha                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAnimDB::GetAnimSpeed(EAnimStanceType AnimStance, float Direction, float InSpeed, float* PlayRate, float* SprintAlpha) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimDB", "GetAnimSpeed");

	Params::AnimDB_GetAnimSpeed Parms{};

	Parms.AnimStance = AnimStance;
	Parms.Direction = Direction;
	Parms.InSpeed = InSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PlayRate != nullptr)
		*PlayRate = Parms.PlayRate;

	if (SprintAlpha != nullptr)
		*SprintAlpha = Parms.SprintAlpha;

	return Parms.ReturnValue;
}


// Function TslGame.AnimDB.GetBlendSpace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAnimStanceType                         AnimStance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsFPP                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBlendSpace*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBlendSpace* UAnimDB::GetBlendSpace(EAnimStanceType AnimStance, bool bIsFPP) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimDB", "GetBlendSpace");

	Params::AnimDB_GetBlendSpace Parms{};

	Parms.AnimStance = AnimStance;
	Parms.bIsFPP = bIsFPP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.AnimDB.GetBlendSpaceRelaxed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAnimStanceType                         AnimStance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsFPP                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBlendSpace*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBlendSpace* UAnimDB::GetBlendSpaceRelaxed(EAnimStanceType AnimStance, bool bIsFPP) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimDB", "GetBlendSpaceRelaxed");

	Params::AnimDB_GetBlendSpaceRelaxed Parms{};

	Parms.AnimStance = AnimStance;
	Parms.bIsFPP = bIsFPP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.FlashBangCaptureActor.CaptureINIT
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    bDoDelay                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CaptureDelay                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            PlayerRef                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           RenderTexture                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPostProcessSettings             PP_Settings                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bHidePawn                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFlashBangCaptureActor::CaptureINIT(bool bDoDelay, float CaptureDelay, class APawn* PlayerRef, class UTextureRenderTarget2D* RenderTexture, const struct FPostProcessSettings& PP_Settings, bool bHidePawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashBangCaptureActor", "CaptureINIT");

	Params::FlashBangCaptureActor_CaptureINIT Parms{};

	Parms.bDoDelay = bDoDelay;
	Parms.CaptureDelay = CaptureDelay;
	Parms.PlayerRef = PlayerRef;
	Parms.RenderTexture = RenderTexture;
	Parms.PP_Settings = std::move(PP_Settings);
	Parms.bHidePawn = bHidePawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.FlashBangCaptureActor.CaptureScreen
// (Final, Native, Public)

void AFlashBangCaptureActor::CaptureScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlashBangCaptureActor", "CaptureScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VehicleSeatActor.AllowInteract
// (Final, Native, Protected)
// Parameters:
// class ATslCharacter*                    OtherCharacter                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVehicleSeatActor::AllowInteract(const class ATslCharacter* OtherCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatActor", "AllowInteract");

	Params::VehicleSeatActor_AllowInteract Parms{};

	Parms.OtherCharacter = OtherCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatActor.GetAdditionalMessage
// (Final, Native, Public)
// Parameters:
// class ATslCharacter*                    Character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText AVehicleSeatActor::GetAdditionalMessage(const class ATslCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatActor", "GetAdditionalMessage");

	Params::VehicleSeatActor_GetAdditionalMessage Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatActor.GetMaxPitchByYaw
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   CurrentYaw                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AVehicleSeatActor::GetMaxPitchByYaw(float CurrentYaw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatActor", "GetMaxPitchByYaw");

	Params::VehicleSeatActor_GetMaxPitchByYaw Parms{};

	Parms.CurrentYaw = CurrentYaw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatActor.GetMinPitchByYaw
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   CurrentYaw                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AVehicleSeatActor::GetMinPitchByYaw(float CurrentYaw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatActor", "GetMinPitchByYaw");

	Params::VehicleSeatActor_GetMinPitchByYaw Parms{};

	Parms.CurrentYaw = CurrentYaw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatActor.OnRep_Rider
// (Final, Native, Private)

void AVehicleSeatActor::OnRep_Rider()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatActor", "OnRep_Rider");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VehicleSeatActor.GetCanFireOnlyWhileAimed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVehicleSeatActor::GetCanFireOnlyWhileAimed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatActor", "GetCanFireOnlyWhileAimed");

	Params::VehicleSeatActor_GetCanFireOnlyWhileAimed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatActor.GetRider
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslCharacter* AVehicleSeatActor::GetRider() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatActor", "GetRider");

	Params::VehicleSeatActor_GetRider Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatActor.GetSeatAimingBlendspace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBlendSpaceBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBlendSpaceBase* AVehicleSeatActor::GetSeatAimingBlendspace() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatActor", "GetSeatAimingBlendspace");

	Params::VehicleSeatActor_GetSeatAimingBlendspace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatActor.GetSeatIdleAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimSequenceBase*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequenceBase* AVehicleSeatActor::GetSeatIdleAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatActor", "GetSeatIdleAnimation");

	Params::VehicleSeatActor_GetSeatIdleAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatActor.GetSeatIdleAO
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAimOffsetBlendSpace*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAimOffsetBlendSpace* AVehicleSeatActor::GetSeatIdleAO() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatActor", "GetSeatIdleAO");

	Params::VehicleSeatActor_GetSeatIdleAO Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatActor.GetTransitionInBlendspace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBlendSpaceBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBlendSpaceBase* AVehicleSeatActor::GetTransitionInBlendspace() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatActor", "GetTransitionInBlendspace");

	Params::VehicleSeatActor_GetTransitionInBlendspace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatActor.GetTransitionOutBlendspace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBlendSpaceBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBlendSpaceBase* AVehicleSeatActor::GetTransitionOutBlendspace() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatActor", "GetTransitionOutBlendspace");

	Params::VehicleSeatActor_GetTransitionOutBlendspace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatActor.GetVehicleAnimType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EVehicleAnimType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EVehicleAnimType AVehicleSeatActor::GetVehicleAnimType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatActor", "GetVehicleAnimType");

	Params::VehicleSeatActor_GetVehicleAnimType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatActor.GetVehicleInterface
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TScriptInterface<class ITslVehicleInterface>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

TScriptInterface<class ITslVehicleInterface> AVehicleSeatActor::GetVehicleInterface() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatActor", "GetVehicleInterface");

	Params::VehicleSeatActor_GetVehicleInterface Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatActor.GetVehiclePawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* AVehicleSeatActor::GetVehiclePawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatActor", "GetVehiclePawn");

	Params::VehicleSeatActor_GetVehiclePawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatActor.GetVehicleSeatComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTslVehicleSeatComponent*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTslVehicleSeatComponent* AVehicleSeatActor::GetVehicleSeatComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatActor", "GetVehicleSeatComponent");

	Params::VehicleSeatActor_GetVehicleSeatComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatActor.IsEntryAllowedByVelocity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVehicleSeatActor::IsEntryAllowedByVelocity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatActor", "IsEntryAllowedByVelocity");

	Params::VehicleSeatActor_IsEntryAllowedByVelocity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatActor.IsWeaponClassAllowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponClass                            InClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AVehicleSeatActor::IsWeaponClassAllowed(EWeaponClass InClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatActor", "IsWeaponClassAllowed");

	Params::VehicleSeatActor_IsWeaponClassAllowed Parms{};

	Parms.InClass = InClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPopupInterface.SetPopup
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EPopupStyle                             PopupStyle                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Message                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(EPopupButtonID ButtonID)>PressedDelegate                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ITslPopupInterface::SetPopup(EPopupStyle PopupStyle, const class FText& Message, const TDelegate<void(EPopupButtonID ButtonID)>& PressedDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPopupInterface", "SetPopup");

	Params::TslPopupInterface_SetPopup Parms{};

	Parms.PopupStyle = PopupStyle;
	Parms.Message = std::move(Message);
	Parms.PressedDelegate = PressedDelegate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TslGame.HackReporterComponent.ServerOnWallHackDetected
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHackReporterComponent::ServerOnWallHackDetected(float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HackReporterComponent", "ServerOnWallHackDetected");

	Params::HackReporterComponent_ServerOnWallHackDetected Parms{};

	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslBaseHUD.BindActionKeyDelegateEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputEvent                             InputEvent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       ActionKeyDelegate                                      (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void ATslBaseHUD::BindActionKeyDelegateEvent(FName ActionName, EInputEvent InputEvent, TDelegate<void()> ActionKeyDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBaseHUD", "BindActionKeyDelegateEvent");

	Params::TslBaseHUD_BindActionKeyDelegateEvent Parms{};

	Parms.ActionName = ActionName;
	Parms.InputEvent = InputEvent;
	Parms.ActionKeyDelegate = ActionKeyDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslBaseHUD.DestroyAllWidgets
// (Final, Native, Public, BlueprintCallable)

void ATslBaseHUD::DestroyAllWidgets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBaseHUD", "DestroyAllWidgets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslBaseHUD.GetMainUMGHud
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* ATslBaseHUD::GetMainUMGHud()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBaseHUD", "GetMainUMGHud");

	Params::TslBaseHUD_GetMainUMGHud Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslBaseHUD.HidePopupDialog
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           PopupWidgetName                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslBaseHUD::HidePopupDialog(const class FString& PopupWidgetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBaseHUD", "HidePopupDialog");

	Params::TslBaseHUD_HidePopupDialog Parms{};

	Parms.PopupWidgetName = std::move(PopupWidgetName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslBaseHUD.HideWidgetByEscape
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslBaseHUD::HideWidgetByEscape()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBaseHUD", "HideWidgetByEscape");

	Params::TslBaseHUD_HideWidgetByEscape Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslBaseHUD.ShowPopupDialog
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           PopupWidgetName                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPopupStyle                             PopupStyle                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Message                                                (Parm, NativeAccessSpecifierPublic)
// TDelegate<void(EPopupButtonID ButtonID)>PressedDelegate                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ATslBaseHUD::ShowPopupDialog(const class FString& PopupWidgetName, EPopupStyle PopupStyle, const class FText& Message, const TDelegate<void(EPopupButtonID ButtonID)>& PressedDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBaseHUD", "ShowPopupDialog");

	Params::TslBaseHUD_ShowPopupDialog Parms{};

	Parms.PopupWidgetName = std::move(PopupWidgetName);
	Parms.PopupStyle = PopupStyle;
	Parms.Message = std::move(Message);
	Parms.PressedDelegate = PressedDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslBaseHUD.UnbindActionKeyDelegateEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputEvent                             InputEvent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslBaseHUD::UnbindActionKeyDelegateEvent(FName ActionName, EInputEvent InputEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBaseHUD", "UnbindActionKeyDelegateEvent");

	Params::TslBaseHUD_UnbindActionKeyDelegateEvent Parms{};

	Parms.ActionName = ActionName;
	Parms.InputEvent = InputEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslBaseHUD.WidgetCreate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           WidgetName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTslWidgetConfig                 Config                                                 (Parm, NativeAccessSpecifierPublic)

void ATslBaseHUD::WidgetCreate(const class FString& WidgetName, const struct FTslWidgetConfig& Config)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBaseHUD", "WidgetCreate");

	Params::TslBaseHUD_WidgetCreate Parms{};

	Parms.WidgetName = std::move(WidgetName);
	Parms.Config = std::move(Config);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslBaseHUD.WidgetShow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           WidgetName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWidgetShowType                         ShowType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          OptionalParam                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslBaseHUD::WidgetShow(const class FString& WidgetName, EWidgetShowType ShowType, class UObject* OptionalParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBaseHUD", "WidgetShow");

	Params::TslBaseHUD_WidgetShow Parms{};

	Parms.WidgetName = std::move(WidgetName);
	Parms.ShowType = ShowType;
	Parms.OptionalParam = OptionalParam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslBaseHUD.WidgetToggle
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           WidgetName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslBaseHUD::WidgetToggle(const class FString& WidgetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBaseHUD", "WidgetToggle");

	Params::TslBaseHUD_WidgetToggle Parms{};

	Parms.WidgetName = std::move(WidgetName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslBaseHUD.GetWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           WidgetName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* ATslBaseHUD::GetWidget(const class FString& WidgetName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBaseHUD", "GetWidget");

	Params::TslBaseHUD_GetWidget Parms{};

	Parms.WidgetName = std::move(WidgetName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslBaseHUD.IsWidgetShow
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           WidgetName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslBaseHUD::IsWidgetShow(const class FString& WidgetName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBaseHUD", "IsWidgetShow");

	Params::TslBaseHUD_IsWidgetShow Parms{};

	Parms.WidgetName = std::move(WidgetName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.HighlightSession.Die
// (Final, Native, Private)
// Parameters:
// bool                                    bGroggy                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHighlightSession::Die(bool bGroggy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HighlightSession", "Die");

	Params::HighlightSession_Die Parms{};

	Parms.bGroggy = bGroggy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.HighlightSession.FinishRecord
// (Final, Native, Private)

void UHighlightSession::FinishRecord()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HighlightSession", "FinishRecord");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.HighlightSession.KillOtherPlayer
// (Final, Native, Private)
// Parameters:
// bool                                    bGroggy                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHighlightSession::KillOtherPlayer(bool bGroggy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HighlightSession", "KillOtherPlayer");

	Params::HighlightSession_KillOtherPlayer Parms{};

	Parms.bGroggy = bGroggy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.HighlightSession.MatchEnded
// (Final, Native, Private)

void UHighlightSession::MatchEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HighlightSession", "MatchEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.WeaponClone.Update
// (Final, Native, Public)

void UWeaponClone::Update()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponClone", "Update");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.DroppedItemActorComponent.AllowInteractDelegate
// (Final, Native, Protected)
// Parameters:
// class ATslCharacter*                    OtherCharacter                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDroppedItemActorComponent::AllowInteractDelegate(const class ATslCharacter* OtherCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DroppedItemActorComponent", "AllowInteractDelegate");

	Params::DroppedItemActorComponent_AllowInteractDelegate Parms{};

	Parms.OtherCharacter = OtherCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.DroppedItemActorComponent.OnInteractDelegate
// (Final, Native, Protected)
// Parameters:
// class ATslCharacter*                    OtherCharacter                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDroppedItemActorComponent::OnInteractDelegate(class ATslCharacter* OtherCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DroppedItemActorComponent", "OnInteractDelegate");

	Params::DroppedItemActorComponent_OnInteractDelegate Parms{};

	Parms.OtherCharacter = OtherCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.Item.GetIconTexture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTexture*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture* UItem::GetIconTexture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "GetIconTexture");

	Params::Item_GetIconTexture Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Item.PickUpBy
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ATslCharacter*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FName                             TargetContainer                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Options                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItem::PickUpBy(class ATslCharacter* Character, FName TargetContainer, const class FString& Options)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "PickUpBy");

	Params::Item_PickUpBy Parms{};

	Parms.Character = Character;
	Parms.TargetContainer = TargetContainer;
	Parms.Options = std::move(Options);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Item.UseBy
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ATslCharacter*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItem::UseBy(class ATslCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "UseBy");

	Params::Item_UseBy Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Item.IsAttachment
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItem::IsAttachment() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "IsAttachment");

	Params::Item_IsAttachment Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Item.IsCastableItem
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItem::IsCastableItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "IsCastableItem");

	Params::Item_IsCastableItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Item.IsEquipable
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItem::IsEquipable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "IsEquipable");

	Params::Item_IsEquipable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Item.IsPackageItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItem::IsPackageItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "IsPackageItem");

	Params::Item_IsPackageItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Item.IsToy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItem::IsToy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "IsToy");

	Params::Item_IsToy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Item.IsWeapon
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItem::IsWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "IsWeapon");

	Params::Item_IsWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.EquipableItem.CanEquipTo
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ATslCharacter*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEquipableItem::CanEquipTo(class ATslCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipableItem", "CanEquipTo");

	Params::EquipableItem_CanEquipTo Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.EquipableItem.EquipBy
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ATslCharacter*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEquipPosition                   Position                                               (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEquipableItem::EquipBy(class ATslCharacter* Character, const struct FEquipPosition& Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipableItem", "EquipBy");

	Params::EquipableItem_EquipBy Parms{};

	Parms.Character = Character;
	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.EquipableItem.UnequipBy
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class ATslCharacter*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipableItem::UnequipBy(class ATslCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipableItem", "UnequipBy");

	Params::EquipableItem_UnequipBy Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.AsyncStaticMeshComponent.ClearStaticMeshAsset
// (Final, Native, Public, BlueprintCallable)

void UAsyncStaticMeshComponent::ClearStaticMeshAsset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncStaticMeshComponent", "ClearStaticMeshAsset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.AsyncStaticMeshComponent.SetStaticMeshAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UStaticMesh>       Asset                                                  (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAsyncStaticMeshComponent::SetStaticMeshAsset(TSoftObjectPtr<class UStaticMesh> Asset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncStaticMeshComponent", "SetStaticMeshAsset");

	Params::AsyncStaticMeshComponent_SetStaticMeshAsset Parms{};

	Parms.Asset = Asset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.AsyncStaticMeshComponent.GetStaticMeshAsset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSoftObjectPtr<class UStaticMesh>       ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UStaticMesh> UAsyncStaticMeshComponent::GetStaticMeshAsset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncStaticMeshComponent", "GetStaticMeshAsset");

	Params::AsyncStaticMeshComponent_GetStaticMeshAsset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.AsyncStaticMeshComponent.IsSameMesh
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSoftObjectPtr<class UStaticMesh>       Asset                                                  (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAsyncStaticMeshComponent::IsSameMesh(const TSoftObjectPtr<class UStaticMesh>& Asset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncStaticMeshComponent", "IsSameMesh");

	Params::AsyncStaticMeshComponent_IsSameMesh Parms{};

	Parms.Asset = Asset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslBuff.CanApplyBuff
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslBuff::CanApplyBuff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBuff", "CanApplyBuff");

	Params::TslBuff_CanApplyBuff Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslBuff.StartBuffBlueprint
// (Event, Public, BlueprintEvent)

void ATslBuff::StartBuffBlueprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBuff", "StartBuffBlueprint");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TslGame.TslBuff.StopBuffBlueprint
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bCanceled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslBuff::StopBuffBlueprint(bool bCanceled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBuff", "StopBuffBlueprint");

	Params::TslBuff_StopBuffBlueprint Parms{};

	Parms.bCanceled = bCanceled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TslGame.TslBuff.TickBuff
// (Native, Event, Public, BlueprintEvent)

void ATslBuff::TickBuff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBuff", "TickBuff");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslBuff.GetAttackId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FAttackId                        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAttackId ATslBuff::GetAttackId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBuff", "GetAttackId");

	Params::TslBuff_GetAttackId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslBuff.GetOwnerPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* ATslBuff::GetOwnerPawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBuff", "GetOwnerPawn");

	Params::TslBuff_GetOwnerPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.BuffComponet.AddBuff
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class ATslBuff>             TslBuffClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATslBuff*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslBuff* UBuffComponet::AddBuff(TSubclassOf<class ATslBuff> TslBuffClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuffComponet", "AddBuff");

	Params::BuffComponet_AddBuff Parms{};

	Parms.TslBuffClass = TslBuffClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.BuffComponet.FindBuffWithOverlapId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// FName                             BuffOverlapId                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATslBuff*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslBuff* UBuffComponet::FindBuffWithOverlapId(FName BuffOverlapId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuffComponet", "FindBuffWithOverlapId");

	Params::BuffComponet_FindBuffWithOverlapId Parms{};

	Parms.BuffOverlapId = BuffOverlapId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.BuffComponet.RemoveBuff
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// FName                             OverlapId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBuffComponet::RemoveBuff(FName OverlapId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuffComponet", "RemoveBuff");

	Params::BuffComponet_RemoveBuff Parms{};

	Parms.OverlapId = OverlapId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.CastableInterface.GetCastConfig
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// struct FCastConfig                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCastConfig ICastableInterface::GetCastConfig() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CastableInterface", "GetCastConfig");

	Params::CastableInterface_GetCastConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CastableInterface.GetCastFailMessage
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*                    Character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ICastableInterface::GetCastFailMessage(const class ATslCharacter* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CastableInterface", "GetCastFailMessage");

	Params::CastableInterface_GetCastFailMessage Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CastableInterface.IsCastable
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICastableInterface::IsCastable(class ATslCharacter* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CastableInterface", "IsCastable");

	Params::CastableInterface_IsCastable Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CastComponent.CancelCast
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCastComponent::CancelCast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CastComponent", "CancelCast");

	Params::CastComponent_CancelCast Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CastComponent.StartCast
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class ICastableInterface>CastableInterface                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCastComponent::StartCast(TScriptInterface<class ICastableInterface> CastableInterface)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CastComponent", "StartCast");

	Params::CastComponent_StartCast Parms{};

	Parms.CastableInterface = CastableInterface;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CastComponent.GetCastAnim
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECastAnim                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECastAnim UCastComponent::GetCastAnim() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CastComponent", "GetCastAnim");

	Params::CastComponent_GetCastAnim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CastComponent.GetCastLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECastLevel                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECastLevel UCastComponent::GetCastLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CastComponent", "GetCastLevel");

	Params::CastComponent_GetCastLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CastComponent.GetCastName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UCastComponent::GetCastName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CastComponent", "GetCastName");

	Params::CastComponent_GetCastName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CastComponent.GetCastObject
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UCastComponent::GetCastObject() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CastComponent", "GetCastObject");

	Params::CastComponent_GetCastObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CastComponent.GetCastPriority
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECastPriority                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECastPriority UCastComponent::GetCastPriority() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CastComponent", "GetCastPriority");

	Params::CastComponent_GetCastPriority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CastComponent.GetElapsedCastTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCastComponent::GetElapsedCastTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CastComponent", "GetElapsedCastTime");

	Params::CastComponent_GetElapsedCastTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CastComponent.GetTotalCastTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCastComponent::GetTotalCastTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CastComponent", "GetTotalCastTime");

	Params::CastComponent_GetTotalCastTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CharacterBreathComponent.AddBreath
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterBreathComponent::AddBreath(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBreathComponent", "AddBreath");

	Params::CharacterBreathComponent_AddBreath Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.CharacterBreathComponent.OnRep_Breath
// (Final, Native, Private)
// Parameters:
// float                                   LastBreath                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterBreathComponent::OnRep_Breath(float LastBreath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBreathComponent", "OnRep_Breath");

	Params::CharacterBreathComponent_OnRep_Breath Parms{};

	Parms.LastBreath = LastBreath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.CharacterBreathComponent.CanStartHoldingBreath
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterBreathComponent::CanStartHoldingBreath() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBreathComponent", "CanStartHoldingBreath");

	Params::CharacterBreathComponent_CanStartHoldingBreath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CharacterBreathComponent.CanStartSprinting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterBreathComponent::CanStartSprinting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBreathComponent", "CanStartSprinting");

	Params::CharacterBreathComponent_CanStartSprinting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CharacterBreathComponent.GetBreath
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterBreathComponent::GetBreath() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBreathComponent", "GetBreath");

	Params::CharacterBreathComponent_GetBreath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CharacterBreathComponent.GetBreathMax
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterBreathComponent::GetBreathMax() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBreathComponent", "GetBreathMax");

	Params::CharacterBreathComponent_GetBreathMax Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CharacterBreathComponent.GetBreathRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCharacterBreathComponent::GetBreathRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBreathComponent", "GetBreathRatio");

	Params::CharacterBreathComponent_GetBreathRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CharacterBreathComponent.IsConsuming
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterBreathComponent::IsConsuming() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBreathComponent", "IsConsuming");

	Params::CharacterBreathComponent_IsConsuming Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CharacterBreathComponent.IsInApnea
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterBreathComponent::IsInApnea() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBreathComponent", "IsInApnea");

	Params::CharacterBreathComponent_IsInApnea Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CharacterStudio.AddYaw
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Yaw                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterStudio::AddYaw(float Yaw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStudio", "AddYaw");

	Params::CharacterStudio_AddYaw Parms{};

	Parms.Yaw = Yaw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.CharacterStudio.GetCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ATslCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslCharacter* ACharacterStudio::GetCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStudio", "GetCharacter");

	Params::CharacterStudio_GetCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CharacterStudio.GetSceneCaptureMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* ACharacterStudio::GetSceneCaptureMaterial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStudio", "GetSceneCaptureMaterial");

	Params::CharacterStudio_GetSceneCaptureMaterial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CharacterStudio.SetCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ATslCharacter*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterStudio::SetCharacter(class ATslCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStudio", "SetCharacter");

	Params::CharacterStudio_SetCharacter Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.CharacterStudio.SetSceneCaptureMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         Mid                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterStudio::SetSceneCaptureMaterial(class UMaterialInstanceDynamic* Mid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStudio", "SetSceneCaptureMaterial");

	Params::CharacterStudio_SetSceneCaptureMaterial Parms{};

	Parms.Mid = Mid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.CharacterStudio.Update
// (Final, Native, Public, BlueprintCallable)

void ACharacterStudio::Update()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStudio", "Update");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.CharacterStudio.IsCharacterValid
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterStudio::IsCharacterValid() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStudio", "IsCharacterValid");

	Params::CharacterStudio_IsCharacterValid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CharacterStudio.IsUsingDynamicResolution
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterStudio::IsUsingDynamicResolution() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStudio", "IsUsingDynamicResolution");

	Params::CharacterStudio_IsUsingDynamicResolution Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CoherentCommonBinder.BindDelegate
// (Native, Protected)

void UCoherentCommonBinder::BindDelegate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoherentCommonBinder", "BindDelegate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.CoherentCommonBinder.BindUI
// (Native, Protected)

void UCoherentCommonBinder::BindUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoherentCommonBinder", "BindUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.CoherentCommonBinder.OnWebPageOnPlatformFailed
// (Final, Native, Private)

void UCoherentCommonBinder::OnWebPageOnPlatformFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoherentCommonBinder", "OnWebPageOnPlatformFailed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.CoherentCommonBinder.Test
// (Final, Native, Private)

void UCoherentCommonBinder::Test()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CoherentCommonBinder", "Test");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.Admin
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           ServerAdminCommand                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::Admin(const class FString& ServerAdminCommand)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "Admin");

	Params::TslPlayerController_Admin Parms{};

	Parms.ServerAdminCommand = std::move(ServerAdminCommand);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.BEClient
// (Final, Exec, Native, Private)
// Parameters:
// class FString                           Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::BEClient(const class FString& Command)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "BEClient");

	Params::TslPlayerController_BEClient Parms{};

	Parms.Command = std::move(Command);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.BEServer
// (Final, Exec, Native, Private)
// Parameters:
// class FString                           Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Arg0                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Arg1                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Arg2                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::BEServer(const class FString& Command, const class FString& Arg0, const class FString& Arg1, const class FString& Arg2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "BEServer");

	Params::TslPlayerController_BEServer Parms{};

	Parms.Command = std::move(Command);
	Parms.Arg0 = std::move(Arg0);
	Parms.Arg1 = std::move(Arg1);
	Parms.Arg2 = std::move(Arg2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.BP_Test_SpawnVehicle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   VehicleIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::BP_Test_SpawnVehicle(int32 VehicleIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "BP_Test_SpawnVehicle");

	Params::TslPlayerController_BP_Test_SpawnVehicle Parms{};

	Parms.VehicleIndex = VehicleIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.Cheat_ServerSpawnVehicle
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// int32                                   VehicleIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::Cheat_ServerSpawnVehicle(int32 VehicleIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "Cheat_ServerSpawnVehicle");

	Params::TslPlayerController_Cheat_ServerSpawnVehicle Parms{};

	Parms.VehicleIndex = VehicleIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ClientAdminCopyString
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// class FString                           inString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ClientAdminCopyString(const class FString& inString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ClientAdminCopyString");

	Params::TslPlayerController_ClientAdminCopyString Parms{};

	Parms.inString = std::move(inString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ClientEndOnlineGame
// (Net, NetReliable, Native, Event, Public, NetClient)

void ATslPlayerController::ClientEndOnlineGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ClientEndOnlineGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ClientGameStarted
// (Net, NetReliable, Native, Event, Public, NetClient)

void ATslPlayerController::ClientGameStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ClientGameStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ClientInteract
// (Net, Native, Event, Public, NetClient)
// Parameters:
// class AActor*                           TargetObject                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ClientInteract(class AActor* TargetObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ClientInteract");

	Params::TslPlayerController_ClientInteract Parms{};

	Parms.TargetObject = TargetObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ClientInteractByComponent
// (Net, Native, Event, Public, NetClient)
// Parameters:
// class UActorComponent*                  TargetComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ClientInteractByComponent(class UActorComponent* TargetComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ClientInteractByComponent");

	Params::TslPlayerController_ClientInteractByComponent Parms{};

	Parms.TargetComponent = TargetComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ClientNotifyHeal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   HealthStart                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Health                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ClientNotifyHeal(float HealthStart, float Health, float MaxHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ClientNotifyHeal");

	Params::TslPlayerController_ClientNotifyHeal Parms{};

	Parms.HealthStart = HealthStart;
	Parms.Health = Health;
	Parms.MaxHealth = MaxHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ClientNotifyHeal_Reliable
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// float                                   HealthStart                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Health                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ClientNotifyHeal_Reliable(float HealthStart, float Health, float MaxHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ClientNotifyHeal_Reliable");

	Params::TslPlayerController_ClientNotifyHeal_Reliable Parms{};

	Parms.HealthStart = HealthStart;
	Parms.Health = Health;
	Parms.MaxHealth = MaxHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ClientNotifyHeal_Unreliable
// (Net, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// float                                   HealthStart                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Health                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ClientNotifyHeal_Unreliable(float HealthStart, float Health, float MaxHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ClientNotifyHeal_Unreliable");

	Params::TslPlayerController_ClientNotifyHeal_Unreliable Parms{};

	Parms.HealthStart = HealthStart;
	Parms.Health = Health;
	Parms.MaxHealth = MaxHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ClientNotifyHealAmount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Heal                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ClientNotifyHealAmount(float Heal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ClientNotifyHealAmount");

	Params::TslPlayerController_ClientNotifyHealAmount Parms{};

	Parms.Heal = Heal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ClientNotifyHealAmount_Reliable
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// float                                   Heal                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ClientNotifyHealAmount_Reliable(float Heal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ClientNotifyHealAmount_Reliable");

	Params::TslPlayerController_ClientNotifyHealAmount_Reliable Parms{};

	Parms.Heal = Heal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ClientNotifyHealAmount_Unreliable
// (Net, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// float                                   Heal                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ClientNotifyHealAmount_Unreliable(float Heal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ClientNotifyHealAmount_Unreliable");

	Params::TslPlayerController_ClientNotifyHealAmount_Unreliable Parms{};

	Parms.Heal = Heal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ClientNotifyNextGasIn
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// struct FVector_NetQuantize              PoisonGasWarningPosition                               (Parm, NativeAccessSpecifierPublic)
// float                                   PoisonGasWarningRadius                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ClientNotifyNextGasIn(const struct FVector_NetQuantize& PoisonGasWarningPosition, float PoisonGasWarningRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ClientNotifyNextGasIn");

	Params::TslPlayerController_ClientNotifyNextGasIn Parms{};

	Parms.PoisonGasWarningPosition = std::move(PoisonGasWarningPosition);
	Parms.PoisonGasWarningRadius = PoisonGasWarningRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ClientNotifyRestrictingPlayArea
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)

void ATslPlayerController::ClientNotifyRestrictingPlayArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ClientNotifyRestrictingPlayArea");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ClientNotifySpeedBoost
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// float                                   Boost                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ClientNotifySpeedBoost(float Boost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ClientNotifySpeedBoost");

	Params::TslPlayerController_ClientNotifySpeedBoost Parms{};

	Parms.Boost = Boost;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ClientNotifyStartBuff
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// FName                             BuffName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStart                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ClientNotifyStartBuff(FName BuffName, bool bStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ClientNotifyStartBuff");

	Params::TslPlayerController_ClientNotifyStartBuff Parms{};

	Parms.BuffName = BuffName;
	Parms.bStart = bStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ClientOnCharacterDeath
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    bIsTeamMatch                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHasAliveTeamMember                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTslReportedInfo                 InKillerInfo                                           (Parm, NativeAccessSpecifierPublic)
// bool                                    InbCanReport                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ClientOnCharacterDeath(bool bIsTeamMatch, bool bHasAliveTeamMember, const struct FTslReportedInfo& InKillerInfo, bool InbCanReport)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ClientOnCharacterDeath");

	Params::TslPlayerController_ClientOnCharacterDeath Parms{};

	Parms.bIsTeamMatch = bIsTeamMatch;
	Parms.bHasAliveTeamMember = bHasAliveTeamMember;
	Parms.InKillerInfo = std::move(InKillerInfo);
	Parms.InbCanReport = InbCanReport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ClientOnCharacterRestart
// (Net, NetReliable, Native, Event, Public, NetClient)

void ATslPlayerController::ClientOnCharacterRestart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ClientOnCharacterRestart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ClientSendPacketReliable
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// TArray<uint8>                           Packet                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ATslPlayerController::ClientSendPacketReliable(const TArray<uint8>& Packet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ClientSendPacketReliable");

	Params::TslPlayerController_ClientSendPacketReliable Parms{};

	Parms.Packet = std::move(Packet);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ClientSendPacketUnreliable
// (Net, Native, Event, Public, NetClient)
// Parameters:
// TArray<uint8>                           Packet                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ATslPlayerController::ClientSendPacketUnreliable(const TArray<uint8>& Packet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ClientSendPacketUnreliable");

	Params::TslPlayerController_ClientSendPacketUnreliable Parms{};

	Parms.Packet = std::move(Packet);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ClientSendRoundEndEvent
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    bIsWinner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ExpendedTimeInSeconds                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ClientSendRoundEndEvent(bool bIsWinner, int32 ExpendedTimeInSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ClientSendRoundEndEvent");

	Params::TslPlayerController_ClientSendRoundEndEvent Parms{};

	Parms.bIsWinner = bIsWinner;
	Parms.ExpendedTimeInSeconds = ExpendedTimeInSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ClientSetCanAllSpectate
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    InbCanSpectate                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ClientSetCanAllSpectate(bool InbCanSpectate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ClientSetCanAllSpectate");

	Params::TslPlayerController_ClientSetCanAllSpectate Parms{};

	Parms.InbCanSpectate = InbCanSpectate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ClientSetSpectatorCamera
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// struct FVector                          CameraLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         CameraRotation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ATslPlayerController::ClientSetSpectatorCamera(const struct FVector& CameraLocation, const struct FRotator& CameraRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ClientSetSpectatorCamera");

	Params::TslPlayerController_ClientSetSpectatorCamera Parms{};

	Parms.CameraLocation = std::move(CameraLocation);
	Parms.CameraRotation = std::move(CameraRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ClientSetTslPlayerMatchResultInfos
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// TArray<struct FTslPlayerMatchResultInfo>InTslPlayerMatchResultInfos                            (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ATslPlayerController::ClientSetTslPlayerMatchResultInfos(const TArray<struct FTslPlayerMatchResultInfo>& InTslPlayerMatchResultInfos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ClientSetTslPlayerMatchResultInfos");

	Params::TslPlayerController_ClientSetTslPlayerMatchResultInfos Parms{};

	Parms.InTslPlayerMatchResultInfos = std::move(InTslPlayerMatchResultInfos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ClientShowCastingBar
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// float                                   CastTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             CastName                                               (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    OnOff                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ClientShowCastingBar(float CastTime, const class FText& CastName, bool OnOff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ClientShowCastingBar");

	Params::TslPlayerController_ClientShowCastingBar Parms{};

	Parms.CastTime = CastTime;
	Parms.CastName = std::move(CastName);
	Parms.OnOff = OnOff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ClientShowMatchResult
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)

void ATslPlayerController::ClientShowMatchResult()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ClientShowMatchResult");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ClientStartOnlineGame
// (Net, NetReliable, Native, Event, Public, NetClient)

void ATslPlayerController::ClientStartOnlineGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ClientStartOnlineGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ClientUpdateSpectatorCameraMode
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// FName                             InCameraName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InbFirstPerson                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InbIsInVehicle                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InbIsScoping                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ClientUpdateSpectatorCameraMode(FName InCameraName, bool InbFirstPerson, bool InbIsInVehicle, bool InbIsScoping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ClientUpdateSpectatorCameraMode");

	Params::TslPlayerController_ClientUpdateSpectatorCameraMode Parms{};

	Parms.InCameraName = InCameraName;
	Parms.InbFirstPerson = InbFirstPerson;
	Parms.InbIsInVehicle = InbIsInVehicle;
	Parms.InbIsScoping = InbIsScoping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.DropItem
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           ItemTypeName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::DropItem(const class FString& ItemTypeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "DropItem");

	Params::TslPlayerController_DropItem Parms{};

	Parms.ItemTypeName = std::move(ItemTypeName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.DumpActorDetailByRaycast
// (Final, Exec, Native, Public)

void ATslPlayerController::DumpActorDetailByRaycast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "DumpActorDetailByRaycast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.GetGearProfile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ProfileIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class UItem>>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class UItem>> ATslPlayerController::GetGearProfile(int32 ProfileIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "GetGearProfile");

	Params::TslPlayerController_GetGearProfile Parms{};

	Parms.ProfileIndex = ProfileIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.GetHudDebugText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ATslPlayerController::GetHudDebugText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "GetHudDebugText");

	Params::TslPlayerController_GetHudDebugText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.HideMatchResult
// (Final, Native, Private)

void ATslPlayerController::HideMatchResult()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "HideMatchResult");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.HideTslDebugInfomation
// (Final, Exec, Native, Public)

void ATslPlayerController::HideTslDebugInfomation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "HideTslDebugInfomation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.KickCharacter
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ATslCharacter*                    TslCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Reason                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ATslPlayerController::KickCharacter(class ATslCharacter* TslCharacter, const class FText& Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "KickCharacter");

	Params::TslPlayerController_KickCharacter Parms{};

	Parms.TslCharacter = TslCharacter;
	Parms.Reason = std::move(Reason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.NextSetViewTarget
// (Final, Native, Public, BlueprintCallable)

void ATslPlayerController::NextSetViewTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "NextSetViewTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ObserverTeleportTo
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ATslPlayerController::ObserverTeleportTo(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ObserverTeleportTo");

	Params::TslPlayerController_ObserverTeleportTo Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.OffItemStackCountHandlingMode
// (Final, Native, Public, BlueprintCallable)

void ATslPlayerController::OffItemStackCountHandlingMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "OffItemStackCountHandlingMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.OnCancelInteractionCast
// (Final, Native, Private)
// Parameters:
// class UObject*                          CastObject                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::OnCancelInteractionCast(class UObject* CastObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "OnCancelInteractionCast");

	Params::TslPlayerController_OnCancelInteractionCast Parms{};

	Parms.CastObject = CastObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.OnClickedReportButton
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EReportCause                            ReportCause                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESubjectToReport                        SubjectToReport                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::OnClickedReportButton(EReportCause ReportCause, ESubjectToReport SubjectToReport)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "OnClickedReportButton");

	Params::TslPlayerController_OnClickedReportButton Parms{};

	Parms.ReportCause = ReportCause;
	Parms.SubjectToReport = SubjectToReport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.OnExecuteExitCommand
// (Final, Native, Private)

void ATslPlayerController::OnExecuteExitCommand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "OnExecuteExitCommand");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.OnFinishInteractionCast
// (Final, Native, Private)
// Parameters:
// class UObject*                          CastObject                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::OnFinishInteractionCast(class UObject* CastObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "OnFinishInteractionCast");

	Params::TslPlayerController_OnFinishInteractionCast Parms{};

	Parms.CastObject = CastObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.OnItemStackCountHandlingMode
// (Final, Native, Public, BlueprintCallable)

void ATslPlayerController::OnItemStackCountHandlingMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "OnItemStackCountHandlingMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.OnMoveToVehicleSeat
// (Final, Native, Public)
// Parameters:
// uint8                                   idx                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::OnMoveToVehicleSeat(uint8 idx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "OnMoveToVehicleSeat");

	Params::TslPlayerController_OnMoveToVehicleSeat Parms{};

	Parms.idx = idx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.OnRep_CameraViewBehaviour
// (Final, Native, Private)

void ATslPlayerController::OnRep_CameraViewBehaviour()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "OnRep_CameraViewBehaviour");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.OnRep_Team
// (Final, Native, Private)

void ATslPlayerController::OnRep_Team()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "OnRep_Team");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.OnShowCastingBarWidget
// (Final, Native, Protected)
// Parameters:
// float                                   CastTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             CastName                                               (Parm, NativeAccessSpecifierPublic)
// bool                                    OnOff                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::OnShowCastingBarWidget(float CastTime, const class FText& CastName, bool OnOff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "OnShowCastingBarWidget");

	Params::TslPlayerController_OnShowCastingBarWidget Parms{};

	Parms.CastTime = CastTime;
	Parms.CastName = std::move(CastName);
	Parms.OnOff = OnOff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.OnUpdateSpectatorCameraMode
// (Final, Native, Protected)
// Parameters:
// class ATslCharacter*                    TslCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FName                             InCameraName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InbFirstPerson                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InbIsInVehicle                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InbIsScoping                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::OnUpdateSpectatorCameraMode(class ATslCharacter* TslCharacter, FName InCameraName, bool InbFirstPerson, bool InbIsInVehicle, bool InbIsScoping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "OnUpdateSpectatorCameraMode");

	Params::TslPlayerController_OnUpdateSpectatorCameraMode Parms{};

	Parms.TslCharacter = TslCharacter;
	Parms.InCameraName = InCameraName;
	Parms.InbFirstPerson = InbFirstPerson;
	Parms.InbIsInVehicle = InbIsInVehicle;
	Parms.InbIsScoping = InbIsScoping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ReliablePing
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// int32                                   SeqID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   DateTimeTick                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ReliablePing(int32 SeqID, int64 DateTimeTick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ReliablePing");

	Params::TslPlayerController_ReliablePing Parms{};

	Parms.SeqID = SeqID;
	Parms.DateTimeTick = DateTimeTick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ReliablePong
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// int32                                   SeqID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   DateTimeTickFromServer                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ReliablePong(int32 SeqID, int64 DateTimeTickFromServer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ReliablePong");

	Params::TslPlayerController_ReliablePong Parms{};

	Parms.SeqID = SeqID;
	Parms.DateTimeTickFromServer = DateTimeTickFromServer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.SaveGearProfile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ProfileIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class UItem>>        inArray                                                (Parm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

void ATslPlayerController::SaveGearProfile(int32 ProfileIndex, const TArray<TSubclassOf<class UItem>>& inArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "SaveGearProfile");

	Params::TslPlayerController_SaveGearProfile Parms{};

	Parms.ProfileIndex = ProfileIndex;
	Parms.inArray = std::move(inArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.Say
// (Exec, Native, Public)
// Parameters:
// class FString                           Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::Say(const class FString& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "Say");

	Params::TslPlayerController_Say Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.SendSystemMessage
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// ESystemMessageType                      MessageType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Message                                                (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   MessageDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::SendSystemMessage(ESystemMessageType MessageType, const class FText& Message, float MessageDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "SendSystemMessage");

	Params::TslPlayerController_SendSystemMessage Parms{};

	Parms.MessageType = MessageType;
	Parms.Message = std::move(Message);
	Parms.MessageDuration = MessageDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerAdmin
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// class FString                           AdminCommand                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ServerAdmin(const class FString& AdminCommand)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerAdmin");

	Params::TslPlayerController_ServerAdmin Parms{};

	Parms.AdminCommand = std::move(AdminCommand);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerApplyReport
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// EReportCause                            ReportCause                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTslReportedInfo                 InReportedInfo                                         (Parm, NativeAccessSpecifierPublic)

void ATslPlayerController::ServerApplyReport(EReportCause ReportCause, const struct FTslReportedInfo& InReportedInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerApplyReport");

	Params::TslPlayerController_ServerApplyReport Parms{};

	Parms.ReportCause = ReportCause;
	Parms.InReportedInfo = std::move(InReportedInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerBEServerCommand
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// class FString                           Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Arg0                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Arg1                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Arg2                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ServerBEServerCommand(const class FString& Command, const class FString& Arg0, const class FString& Arg1, const class FString& Arg2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerBEServerCommand");

	Params::TslPlayerController_ServerBEServerCommand Parms{};

	Parms.Command = std::move(Command);
	Parms.Arg0 = std::move(Arg0);
	Parms.Arg1 = std::move(Arg1);
	Parms.Arg2 = std::move(Arg2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerBroadCastCastingBar
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                                   CastTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             CastName                                               (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    OnOff                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ServerBroadCastCastingBar(float CastTime, const class FText& CastName, bool OnOff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerBroadCastCastingBar");

	Params::TslPlayerController_ServerBroadCastCastingBar Parms{};

	Parms.CastTime = CastTime;
	Parms.CastName = std::move(CastName);
	Parms.OnOff = OnOff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerBroadCastUsedUpdateCameraMode
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// FName                             InCameraName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InbFirstPerson                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InbIsInVehicle                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InbIsScoping                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ServerBroadCastUsedUpdateCameraMode(FName InCameraName, bool InbFirstPerson, bool InbIsInVehicle, bool InbIsScoping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerBroadCastUsedUpdateCameraMode");

	Params::TslPlayerController_ServerBroadCastUsedUpdateCameraMode Parms{};

	Parms.InCameraName = InCameraName;
	Parms.InbFirstPerson = InbFirstPerson;
	Parms.InbIsInVehicle = InbIsInVehicle;
	Parms.InbIsScoping = InbIsScoping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerCancelInteraction
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class UActorComponent*                  InteractionComponent                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ServerCancelInteraction(class UActorComponent* InteractionComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerCancelInteraction");

	Params::TslPlayerController_ServerCancelInteraction Parms{};

	Parms.InteractionComponent = InteractionComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerCheat
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FString                           Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ServerCheat(const class FString& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerCheat");

	Params::TslPlayerController_ServerCheat Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerKickCharacter
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class ATslCharacter*                    TslCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Reason                                                 (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ATslPlayerController::ServerKickCharacter(class ATslCharacter* TslCharacter, const class FText& Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerKickCharacter");

	Params::TslPlayerController_ServerKickCharacter Parms{};

	Parms.TslCharacter = TslCharacter;
	Parms.Reason = std::move(Reason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerLeaveMatchIntentionally
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ATslPlayerController::ServerLeaveMatchIntentionally()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerLeaveMatchIntentionally");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerMapLoadFinishedOnClient
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ATslPlayerController::ServerMapLoadFinishedOnClient()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerMapLoadFinishedOnClient");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerMoveToVehicleSeat
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// int32                                   SeatIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ServerMoveToVehicleSeat(int32 SeatIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerMoveToVehicleSeat");

	Params::TslPlayerController_ServerMoveToVehicleSeat Parms{};

	Parms.SeatIndex = SeatIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerNextSetViewTarget
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    bIsPrev                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ServerNextSetViewTarget(bool bIsPrev)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerNextSetViewTarget");

	Params::TslPlayerController_ServerNextSetViewTarget Parms{};

	Parms.bIsPrev = bIsPrev;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerNotifyHitToGlassWindow
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class UTslGlassWindowComponent*         GlassWindowComponent                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ATslPlayerController::ServerNotifyHitToGlassWindow(class UTslGlassWindowComponent* GlassWindowComponent, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerNotifyHitToGlassWindow");

	Params::TslPlayerController_ServerNotifyHitToGlassWindow Parms{};

	Parms.GlassWindowComponent = GlassWindowComponent;
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerNotifyHitToGlassWindowInst
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class UTslInstancedGlassWindowComponent*GlassWindowInstComponent                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ATslPlayerController::ServerNotifyHitToGlassWindowInst(class UTslInstancedGlassWindowComponent* GlassWindowInstComponent, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerNotifyHitToGlassWindowInst");

	Params::TslPlayerController_ServerNotifyHitToGlassWindowInst Parms{};

	Parms.GlassWindowInstComponent = GlassWindowInstComponent;
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerPickUpDroppedItem
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// class UObject*                          DroppedItemObject                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FName                             TargetContainer                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Options                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ServerPickUpDroppedItem(class UObject* DroppedItemObject, FName TargetContainer, const class FString& Options)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerPickUpDroppedItem");

	Params::TslPlayerController_ServerPickUpDroppedItem Parms{};

	Parms.DroppedItemObject = DroppedItemObject;
	Parms.TargetContainer = TargetContainer;
	Parms.Options = std::move(Options);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerPickUpItemFromPackage
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// class UItem*                            Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AItemPackage*                     Package                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FName                             TargetContainer                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Options                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ServerPickUpItemFromPackage(class UItem* Item, class AItemPackage* Package, FName TargetContainer, const class FString& Options)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerPickUpItemFromPackage");

	Params::TslPlayerController_ServerPickUpItemFromPackage Parms{};

	Parms.Item = Item;
	Parms.Package = Package;
	Parms.TargetContainer = TargetContainer;
	Parms.Options = std::move(Options);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerSay
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FString                           Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ServerSay(const class FString& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerSay");

	Params::TslPlayerController_ServerSay Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerSendPacketReliable
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// TArray<uint8>                           Packet                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ATslPlayerController::ServerSendPacketReliable(const TArray<uint8>& Packet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerSendPacketReliable");

	Params::TslPlayerController_ServerSendPacketReliable Parms{};

	Parms.Packet = std::move(Packet);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerSendPacketUnreliable
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// TArray<uint8>                           Packet                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ATslPlayerController::ServerSendPacketUnreliable(const TArray<uint8>& Packet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerSendPacketUnreliable");

	Params::TslPlayerController_ServerSendPacketUnreliable Parms{};

	Parms.Packet = std::move(Packet);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerSetAccumViewRotation
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FVector_NetQuantizeNormal        InAccumViewRotation                                    (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ATslPlayerController::ServerSetAccumViewRotation(const struct FVector_NetQuantizeNormal& InAccumViewRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerSetAccumViewRotation");

	Params::TslPlayerController_ServerSetAccumViewRotation Parms{};

	Parms.InAccumViewRotation = std::move(InAccumViewRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerSetClientFps
// (Final, Net, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// float                                   Fps                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ServerSetClientFps(float Fps)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerSetClientFps");

	Params::TslPlayerController_ServerSetClientFps Parms{};

	Parms.Fps = Fps;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerSetIsReviving
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    InbIsReviving                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ServerSetIsReviving(bool InbIsReviving)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerSetIsReviving");

	Params::TslPlayerController_ServerSetIsReviving Parms{};

	Parms.InbIsReviving = InbIsReviving;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerSetThirdPerson
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    bNewThirdPerson                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ServerSetThirdPerson(bool bNewThirdPerson)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerSetThirdPerson");

	Params::TslPlayerController_ServerSetThirdPerson Parms{};

	Parms.bNewThirdPerson = bNewThirdPerson;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerSetViewTarget
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// class AActor*                           NewViewTarget                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ServerSetViewTarget(class AActor* NewViewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerSetViewTarget");

	Params::TslPlayerController_ServerSetViewTarget Parms{};

	Parms.NewViewTarget = NewViewTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerSpawnVehicle
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)

void ATslPlayerController::ServerSpawnVehicle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerSpawnVehicle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerStartHoldRotation
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FRotator                         Current                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ATslPlayerController::ServerStartHoldRotation(const struct FRotator& Current)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerStartHoldRotation");

	Params::TslPlayerController_ServerStartHoldRotation Parms{};

	Parms.Current = std::move(Current);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerStartInteraction
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class UInteractionComponent*            InteractionComponent                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ServerStartInteraction(class UInteractionComponent* InteractionComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerStartInteraction");

	Params::TslPlayerController_ServerStartInteraction Parms{};

	Parms.InteractionComponent = InteractionComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerStartInteractionByComponent
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class UActorComponent*                  InteractionComponent                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ServerStartInteractionByComponent(class UActorComponent* InteractionComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerStartInteractionByComponent");

	Params::TslPlayerController_ServerStartInteractionByComponent Parms{};

	Parms.InteractionComponent = InteractionComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerStopHoldRotation
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FRotator                         DeltaRotation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bUseInterp                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ServerStopHoldRotation(const struct FRotator& DeltaRotation, bool bUseInterp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerStopHoldRotation");

	Params::TslPlayerController_ServerStopHoldRotation Parms{};

	Parms.DeltaRotation = std::move(DeltaRotation);
	Parms.bUseInterp = bUseInterp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerSuicide
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ATslPlayerController::ServerSuicide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerSuicide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerTryInteract
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class AActor*                           TargetObject                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ServerTryInteract(class AActor* TargetObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerTryInteract");

	Params::TslPlayerController_ServerTryInteract Parms{};

	Parms.TargetObject = TargetObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerTryInteractByComponent
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class UActorComponent*                  TargetComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ServerTryInteractByComponent(class UActorComponent* TargetComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerTryInteractByComponent");

	Params::TslPlayerController_ServerTryInteractByComponent Parms{};

	Parms.TargetComponent = TargetComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ServerViewTargetReplicateUpdate
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ATslPlayerController::ServerViewTargetReplicateUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ServerViewTargetReplicateUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.SetCanSeeTerrainThroughFogInTheAir
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCanSee                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::SetCanSeeTerrainThroughFogInTheAir(bool bCanSee)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "SetCanSeeTerrainThroughFogInTheAir");

	Params::TslPlayerController_SetCanSeeTerrainThroughFogInTheAir Parms{};

	Parms.bCanSee = bCanSee;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.SetCustomDepth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bOn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::SetCustomDepth(bool bOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "SetCustomDepth");

	Params::TslPlayerController_SetCustomDepth Parms{};

	Parms.bOn = bOn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.SetDefaultFOV
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewFOV                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::SetDefaultFOV(float NewFOV)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "SetDefaultFOV");

	Params::TslPlayerController_SetDefaultFOV Parms{};

	Parms.NewFOV = NewFOV;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ShowGotoLobbyPopUp
// (Final, Native, Public)
// Parameters:
// EPopupButtonID                          ButtonID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::ShowGotoLobbyPopUp(EPopupButtonID ButtonID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ShowGotoLobbyPopUp");

	Params::TslPlayerController_ShowGotoLobbyPopUp Parms{};

	Parms.ButtonID = ButtonID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ShowInGameMenu
// (Final, Native, Private, BlueprintCallable)

void ATslPlayerController::ShowInGameMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ShowInGameMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ShowMatchResult
// (Final, Native, Private)

void ATslPlayerController::ShowMatchResult()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ShowMatchResult");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ShowPlayerControllerBindActions_Admin
// (Final, Exec, Native, Public)

void ATslPlayerController::ShowPlayerControllerBindActions_Admin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ShowPlayerControllerBindActions_Admin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ShowTeamDeathPopup
// (Final, Native, Private)

void ATslPlayerController::ShowTeamDeathPopup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ShowTeamDeathPopup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ShowTslDebugInfomation
// (Final, Exec, Native, Public)

void ATslPlayerController::ShowTslDebugInfomation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ShowTslDebugInfomation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.SimulateInputKey
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FKey                             Key                                                    (Parm, NativeAccessSpecifierPublic)
// bool                                    bPressed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::SimulateInputKey(const struct FKey& Key, bool bPressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "SimulateInputKey");

	Params::TslPlayerController_SimulateInputKey Parms{};

	Parms.Key = std::move(Key);
	Parms.bPressed = bPressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.Suicide
// (Exec, Native, Public)

void ATslPlayerController::Suicide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "Suicide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.ToggleInventory
// (Final, Native, Private, BlueprintCallable)

void ATslPlayerController::ToggleInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "ToggleInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.UnreliablePing
// (Final, Net, Native, Event, Private, NetClient)
// Parameters:
// int32                                   SeqID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   DateTimeTick                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::UnreliablePing(int32 SeqID, int64 DateTimeTick)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "UnreliablePing");

	Params::TslPlayerController_UnreliablePing Parms{};

	Parms.SeqID = SeqID;
	Parms.DateTimeTick = DateTimeTick;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.UnreliablePong
// (Final, Net, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// int32                                   SeqID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   DateTimeTickFromServer                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerController::UnreliablePong(int32 SeqID, int64 DateTimeTickFromServer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "UnreliablePong");

	Params::TslPlayerController_UnreliablePong Parms{};

	Parms.SeqID = SeqID;
	Parms.DateTimeTickFromServer = DateTimeTickFromServer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerController.CanReport
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslPlayerController::CanReport() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "CanReport");

	Params::TslPlayerController_CanReport Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.CanSeeTerrainThroughFogInTheAir
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslPlayerController::CanSeeTerrainThroughFogInTheAir() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "CanSeeTerrainThroughFogInTheAir");

	Params::TslPlayerController_CanSeeTerrainThroughFogInTheAir Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.CompleteReportKiller
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslPlayerController::CompleteReportKiller() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "CompleteReportKiller");

	Params::TslPlayerController_CompleteReportKiller Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.GetAliveTeamMemberCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ATslPlayerController::GetAliveTeamMemberCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "GetAliveTeamMemberCount");

	Params::TslPlayerController_GetAliveTeamMemberCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.GetCanAllSpectate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslPlayerController::GetCanAllSpectate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "GetCanAllSpectate");

	Params::TslPlayerController_GetCanAllSpectate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.GetClientTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    IncludeSelf                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ATeam*>                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ATeam*> ATslPlayerController::GetClientTeam(bool IncludeSelf) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "GetClientTeam");

	Params::TslPlayerController_GetClientTeam Parms{};

	Parms.IncludeSelf = IncludeSelf;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.GetKillerName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ATslPlayerController::GetKillerName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "GetKillerName");

	Params::TslPlayerController_GetKillerName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.GetObserverAuthorityType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EObserverAuthorityType                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EObserverAuthorityType ATslPlayerController::GetObserverAuthorityType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "GetObserverAuthorityType");

	Params::TslPlayerController_GetObserverAuthorityType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.GetObserverCameraMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EObserverCameraMode                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EObserverCameraMode ATslPlayerController::GetObserverCameraMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "GetObserverCameraMode");

	Params::TslPlayerController_GetObserverCameraMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.GetOtherCastingName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ATslPlayerController::GetOtherCastingName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "GetOtherCastingName");

	Params::TslPlayerController_GetOtherCastingName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.GetOtherCastTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslPlayerController::GetOtherCastTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "GetOtherCastTime");

	Params::TslPlayerController_GetOtherCastTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.GetOtherElapsedCastTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslPlayerController::GetOtherElapsedCastTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "GetOtherElapsedCastTime");

	Params::TslPlayerController_GetOtherElapsedCastTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.GetReplicateCarePackageItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ACarePackageItem*>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ACarePackageItem*> ATslPlayerController::GetReplicateCarePackageItems() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "GetReplicateCarePackageItems");

	Params::TslPlayerController_GetReplicateCarePackageItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.GetReplicateCharacters
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ATslCharacter*>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ATslCharacter*> ATslPlayerController::GetReplicateCharacters() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "GetReplicateCharacters");

	Params::TslPlayerController_GetReplicateCharacters Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.GetReplicateTeamMembers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ATslCharacter*>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ATslCharacter*> ATslPlayerController::GetReplicateTeamMembers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "GetReplicateTeamMembers");

	Params::TslPlayerController_GetReplicateTeamMembers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.GetSpectatingPlayerName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ATslPlayerController::GetSpectatingPlayerName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "GetSpectatingPlayerName");

	Params::TslPlayerController_GetSpectatingPlayerName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.GetTargetViewRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ATslPlayerController::GetTargetViewRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "GetTargetViewRotation");

	Params::TslPlayerController_GetTargetViewRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.GetTeamMemberCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ATslPlayerController::GetTeamMemberCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "GetTeamMemberCount");

	Params::TslPlayerController_GetTeamMemberCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.GetTslCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslCharacter* ATslPlayerController::GetTslCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "GetTslCharacter");

	Params::TslPlayerController_GetTslCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.GetTslPlayerMatchResultInfos
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FTslPlayerMatchResultInfo>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FTslPlayerMatchResultInfo> ATslPlayerController::GetTslPlayerMatchResultInfos() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "GetTslPlayerMatchResultInfos");

	Params::TslPlayerController_GetTslPlayerMatchResultInfos Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.GetViewTargetTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATeam*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATeam* ATslPlayerController::GetViewTargetTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "GetViewTargetTeam");

	Params::TslPlayerController_GetViewTargetTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.GetViewTargetTslCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslCharacter* ATslPlayerController::GetViewTargetTslCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "GetViewTargetTslCharacter");

	Params::TslPlayerController_GetViewTargetTslCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.GetVivoxComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UVivoxComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVivoxComponent* ATslPlayerController::GetVivoxComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "GetVivoxComponent");

	Params::TslPlayerController_GetVivoxComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.IsGameInputAllowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslPlayerController::IsGameInputAllowed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "IsGameInputAllowed");

	Params::TslPlayerController_IsGameInputAllowed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.IsGroggying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslPlayerController::IsGroggying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "IsGroggying");

	Params::TslPlayerController_IsGroggying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.IsHighPing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslPlayerController::IsHighPing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "IsHighPing");

	Params::TslPlayerController_IsHighPing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.IsItemStackCountHandlingMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslPlayerController::IsItemStackCountHandlingMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "IsItemStackCountHandlingMode");

	Params::TslPlayerController_IsItemStackCountHandlingMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.IsObserving
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslPlayerController::IsObserving() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "IsObserving");

	Params::TslPlayerController_IsObserving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.IsReplaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslPlayerController::IsReplaying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "IsReplaying");

	Params::TslPlayerController_IsReplaying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.IsSameObservingCameraMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EObserverCameraMode                     CameraType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslPlayerController::IsSameObservingCameraMode(EObserverCameraMode CameraType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "IsSameObservingCameraMode");

	Params::TslPlayerController_IsSameObservingCameraMode Parms{};

	Parms.CameraType = CameraType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.IsSpectating
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslPlayerController::IsSpectating() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "IsSpectating");

	Params::TslPlayerController_IsSpectating Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerController.IsSpectatorState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslPlayerController::IsSpectatorState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerController", "IsSpectatorState");

	Params::TslPlayerController_IsSpectatorState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.SlotInterface.GetIconTexture
// (Native, Public, BlueprintCallable)
// Parameters:
// class UTexture*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture* ISlotInterface::GetIconTexture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotInterface", "GetIconTexture");

	Params::SlotInterface_GetIconTexture Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.SlotInterface.GetDropSound
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAkAudioEvent*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAkAudioEvent* ISlotInterface::GetDropSound() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotInterface", "GetDropSound");

	Params::SlotInterface_GetDropSound Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.SlotInterface.GetIconSizeRatio
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ISlotInterface::GetIconSizeRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotInterface", "GetIconSizeRatio");

	Params::SlotInterface_GetIconSizeRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.SlotInterface.GetSlotCategory
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ISlotInterface::GetSlotCategory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotInterface", "GetSlotCategory");

	Params::SlotInterface_GetSlotCategory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.SlotInterface.GetSlotDescription
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ISlotInterface::GetSlotDescription() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotInterface", "GetSlotDescription");

	Params::SlotInterface_GetSlotDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.SlotInterface.GetSlotDetailedName
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ISlotInterface::GetSlotDetailedName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotInterface", "GetSlotDetailedName");

	Params::SlotInterface_GetSlotDetailedName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.SlotInterface.GetSlotName
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ISlotInterface::GetSlotName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotInterface", "GetSlotName");

	Params::SlotInterface_GetSlotName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.SlotInterface.GetSortPriority
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ISlotInterface::GetSortPriority() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotInterface", "GetSortPriority");

	Params::SlotInterface_GetSortPriority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.SlotInterface.GetSpace
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ISlotInterface::GetSpace() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotInterface", "GetSpace");

	Params::SlotInterface_GetSpace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.SlotInterface.GetStackCount
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ISlotInterface::GetStackCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotInterface", "GetStackCount");

	Params::SlotInterface_GetStackCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.SlotInterface.GetStackCountMax
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ISlotInterface::GetStackCountMax() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotInterface", "GetStackCountMax");

	Params::SlotInterface_GetStackCountMax Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.SlotInterface.GetToolTipIconSizeRatio
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ISlotInterface::GetToolTipIconSizeRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotInterface", "GetToolTipIconSizeRatio");

	Params::SlotInterface_GetToolTipIconSizeRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.SlotInterface.GetToolTipIconTexture
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTexture*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture* ISlotInterface::GetToolTipIconTexture() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotInterface", "GetToolTipIconTexture");

	Params::SlotInterface_GetToolTipIconTexture Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.SlotInterface.GetUnitSpace
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ISlotInterface::GetUnitSpace() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotInterface", "GetUnitSpace");

	Params::SlotInterface_GetUnitSpace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.SlotInterface.IsAttachment
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ISlotInterface::IsAttachment() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotInterface", "IsAttachment");

	Params::SlotInterface_IsAttachment Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.SlotInterface.IsCastableItem
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ISlotInterface::IsCastableItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotInterface", "IsCastableItem");

	Params::SlotInterface_IsCastableItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.SlotInterface.IsEquipable
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ISlotInterface::IsEquipable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotInterface", "IsEquipable");

	Params::SlotInterface_IsEquipable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.SlotInterface.IsPackageItem
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ISlotInterface::IsPackageItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotInterface", "IsPackageItem");

	Params::SlotInterface_IsPackageItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.SlotInterface.IsStackable
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ISlotInterface::IsStackable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotInterface", "IsStackable");

	Params::SlotInterface_IsStackable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.SlotInterface.IsWeapon
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ISlotInterface::IsWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotInterface", "IsWeapon");

	Params::SlotInterface_IsWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.SlotContainerInterface.DoActionWithSlot
// (Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class ISlotInterface>  Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Options                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ISlotContainerInterface::DoActionWithSlot(TScriptInterface<class ISlotInterface> Slot, FName ActionName, const class FString& Options)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotContainerInterface", "DoActionWithSlot");

	Params::SlotContainerInterface_DoActionWithSlot Parms{};

	Parms.Slot = Slot;
	Parms.ActionName = ActionName;
	Parms.Options = std::move(Options);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.SlotContainerInterface.DoSlotAction
// (Native, Public, BlueprintCallable)
// Parameters:
// FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Options                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ISlotContainerInterface::DoSlotAction(FName ActionName, const class FString& Options)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotContainerInterface", "DoSlotAction");

	Params::SlotContainerInterface_DoSlotAction Parms{};

	Parms.ActionName = ActionName;
	Parms.Options = std::move(Options);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.SlotContainerInterface.DoSlotActionDefault
// (Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class ISlotInterface>  Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

void ISlotContainerInterface::DoSlotActionDefault(TScriptInterface<class ISlotInterface> Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotContainerInterface", "DoSlotActionDefault");

	Params::SlotContainerInterface_DoSlotActionDefault Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.SlotContainerInterface.DropSlotOnOtherContainer
// (Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class ISlotInterface>  Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// TScriptInterface<class ISlotContainerInterface>OtherContainer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// class FString                           Options                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ISlotContainerInterface::DropSlotOnOtherContainer(TScriptInterface<class ISlotInterface> Slot, TScriptInterface<class ISlotContainerInterface> OtherContainer, const class FString& Options)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotContainerInterface", "DropSlotOnOtherContainer");

	Params::SlotContainerInterface_DropSlotOnOtherContainer Parms{};

	Parms.Slot = Slot;
	Parms.OtherContainer = OtherContainer;
	Parms.Options = std::move(Options);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.SlotContainerInterface.GetAvailableSlotActions
// (Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class ISlotInterface>  Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// TArray<FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<FName> ISlotContainerInterface::GetAvailableSlotActions(TScriptInterface<class ISlotInterface> Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotContainerInterface", "GetAvailableSlotActions");

	Params::SlotContainerInterface_GetAvailableSlotActions Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.SlotContainerInterface.GetSlotContext
// (Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class ISlotInterface>  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

TScriptInterface<class ISlotInterface> ISlotContainerInterface::GetSlotContext()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotContainerInterface", "GetSlotContext");

	Params::SlotContainerInterface_GetSlotContext Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.SlotContainerInterface.HideSlotContextMenu
// (Native, Public, BlueprintCallable)

void ISlotContainerInterface::HideSlotContextMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotContainerInterface", "HideSlotContextMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.SlotContainerInterface.ShowSlotContextMenu
// (Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class ISlotInterface>  Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

void ISlotContainerInterface::ShowSlotContextMenu(TScriptInterface<class ISlotInterface> Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotContainerInterface", "ShowSlotContextMenu");

	Params::SlotContainerInterface_ShowSlotContextMenu Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.SlotContainerInterface.GetActionName
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TScriptInterface<class ISlotInterface>  Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// TScriptInterface<class ISlotContainerInterface>OtherContainer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// class FString                           Options                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

FName ISlotContainerInterface::GetActionName(TScriptInterface<class ISlotInterface> Slot, TScriptInterface<class ISlotContainerInterface> OtherContainer, const class FString& Options) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotContainerInterface", "GetActionName");

	Params::SlotContainerInterface_GetActionName Parms{};

	Parms.Slot = Slot;
	Parms.OtherContainer = OtherContainer;
	Parms.Options = std::move(Options);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.SlotContainerInterface.GetAllSlots
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<TScriptInterface<class ISlotInterface>>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TScriptInterface<class ISlotInterface>> ISlotContainerInterface::GetAllSlots() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotContainerInterface", "GetAllSlots");

	Params::SlotContainerInterface_GetAllSlots Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.SlotContainerInterface.GetDefaultActionName
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TScriptInterface<class ISlotInterface>  Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

FName ISlotContainerInterface::GetDefaultActionName(TScriptInterface<class ISlotInterface> Slot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotContainerInterface", "GetDefaultActionName");

	Params::SlotContainerInterface_GetDefaultActionName Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.SlotContainerInterface.GetSlotContainerName
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

FName ISlotContainerInterface::GetSlotContainerName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotContainerInterface", "GetSlotContainerName");

	Params::SlotContainerInterface_GetSlotContainerName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.SlotContainerInterface.GetSlotContainerOwner
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ISlotContainerInterface::GetSlotContainerOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotContainerInterface", "GetSlotContainerOwner");

	Params::SlotContainerInterface_GetSlotContainerOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.SlotContainerInterface.IsEnableAction
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TScriptInterface<class ISlotInterface>  Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// TScriptInterface<class ISlotContainerInterface>OtherContainer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// class FString                           Options                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ISlotContainerInterface::IsEnableAction(TScriptInterface<class ISlotInterface> Slot, TScriptInterface<class ISlotContainerInterface> OtherContainer, const class FString& Options) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SlotContainerInterface", "IsEnableAction");

	Params::SlotContainerInterface_IsEnableAction Parms{};

	Parms.Slot = Slot;
	Parms.OtherContainer = OtherContainer;
	Parms.Options = std::move(Options);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.ItemExplorerInterface.UpdateItemList
// (Native, Public, BlueprintCallable)

void IItemExplorerInterface::UpdateItemList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemExplorerInterface", "UpdateItemList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.ItemExplorerInterface.GetExplorableItemSlotList
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<TScriptInterface<class ISlotInterface>>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TScriptInterface<class ISlotInterface>> IItemExplorerInterface::GetExplorableItemSlotList() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemExplorerInterface", "GetExplorableItemSlotList");

	Params::ItemExplorerInterface_GetExplorableItemSlotList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.ExplorableItemInterface.GetExplorationDistance
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IExplorableItemInterface::GetExplorationDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExplorableItemInterface", "GetExplorationDistance");

	Params::ExplorableItemInterface_GetExplorationDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.ExplorableItemInterface.GetInteractiveActionName
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

FName IExplorableItemInterface::GetInteractiveActionName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExplorableItemInterface", "GetInteractiveActionName");

	Params::ExplorableItemInterface_GetInteractiveActionName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.ExplorableItemInterface.IsValidExplorableItem
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IExplorableItemInterface::IsValidExplorableItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExplorableItemInterface", "IsValidExplorableItem");

	Params::ExplorableItemInterface_IsValidExplorableItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.ItemPackage.AllowInteract
// (Final, Native, Protected)
// Parameters:
// class ATslCharacter*                    OtherCharacter                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AItemPackage::AllowInteract(const class ATslCharacter* OtherCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPackage", "AllowInteract");

	Params::ItemPackage_AllowInteract Parms{};

	Parms.OtherCharacter = OtherCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.ItemPackage.ClientOnInteractBy
// (Native, Protected)
// Parameters:
// class ATslCharacter*                    OtherCharacter                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItemPackage::ClientOnInteractBy(class ATslCharacter* OtherCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPackage", "ClientOnInteractBy");

	Params::ItemPackage_ClientOnInteractBy Parms{};

	Parms.OtherCharacter = OtherCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.ItemPackage.Items_RepNotify
// (Final, Native, Private)

void AItemPackage::Items_RepNotify()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPackage", "Items_RepNotify");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.ItemPackage.IsOpenedBy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AItemPackage::IsOpenedBy(class ATslCharacter* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPackage", "IsOpenedBy");

	Params::ItemPackage_IsOpenedBy Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.DrawDottedLine
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPaintContext                    Context                                                (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector2D                        PositionA                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector2D                        PositionB                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   DottedLength                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DottedInterval                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Tint                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bAntiAlias                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUiHelperFunctions::DrawDottedLine(struct FPaintContext& Context, const struct FVector2D& PositionA, const struct FVector2D& PositionB, float DottedLength, float DottedInterval, const struct FLinearColor& Tint, bool bAntiAlias)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "DrawDottedLine");

	Params::UiHelperFunctions_DrawDottedLine Parms{};

	Parms.Context = std::move(Context);
	Parms.PositionA = std::move(PositionA);
	Parms.PositionB = std::move(PositionB);
	Parms.DottedLength = DottedLength;
	Parms.DottedInterval = DottedInterval;
	Parms.Tint = std::move(Tint);
	Parms.bAntiAlias = bAntiAlias;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Context = std::move(Parms.Context);
}


// Function TslGame.UiHelperFunctions.GetBluezoneGpsState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUiHelperFunctions::GetBluezoneGpsState(class UUserWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetBluezoneGpsState");

	Params::UiHelperFunctions_GetBluezoneGpsState Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetBluezoneReleaseTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UUiHelperFunctions::GetBluezoneReleaseTime(class UUserWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetBluezoneReleaseTime");

	Params::UiHelperFunctions_GetBluezoneReleaseTime Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetBluezoneWarningTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UUiHelperFunctions::GetBluezoneWarningTime(class UUserWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetBluezoneWarningTime");

	Params::UiHelperFunctions_GetBluezoneWarningTime Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetCharacterStateByTeam
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ATeam*                            Team                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUiHelperFunctions::GetCharacterStateByTeam(class ATeam* Team)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetCharacterStateByTeam");

	Params::UiHelperFunctions_GetCharacterStateByTeam Parms{};

	Parms.Team = Team;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetCurrentPlayzonePosition_BluezoneGPS
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector UUiHelperFunctions::GetCurrentPlayzonePosition_BluezoneGPS(class UUserWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetCurrentPlayzonePosition_BluezoneGPS");

	Params::UiHelperFunctions_GetCurrentPlayzonePosition_BluezoneGPS Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetCurrentPlayzoneRadius_BluezoneGPS
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UUiHelperFunctions::GetCurrentPlayzoneRadius_BluezoneGPS(class UUserWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetCurrentPlayzoneRadius_BluezoneGPS");

	Params::UiHelperFunctions_GetCurrentPlayzoneRadius_BluezoneGPS Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetDownWidgetByTslFocusableWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UUiHelperFunctions::GetDownWidgetByTslFocusableWidget(class UWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetDownWidgetByTslFocusableWidget");

	Params::UiHelperFunctions_GetDownWidgetByTslFocusableWidget Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetDurabilityRatio
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TScriptInterface<class ISlotInterface>  ItemSlot                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UUiHelperFunctions::GetDurabilityRatio(TScriptInterface<class ISlotInterface> ItemSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetDurabilityRatio");

	Params::UiHelperFunctions_GetDurabilityRatio Parms{};

	Parms.ItemSlot = ItemSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetGroggyHealthRatioByTeam
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ATeam*                            Team                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UUiHelperFunctions::GetGroggyHealthRatioByTeam(class ATeam* Team)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetGroggyHealthRatioByTeam");

	Params::UiHelperFunctions_GetGroggyHealthRatioByTeam Parms{};

	Parms.Team = Team;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetHealthRatioByTeam
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ATeam*                            Team                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UUiHelperFunctions::GetHealthRatioByTeam(class ATeam* Team)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetHealthRatioByTeam");

	Params::UiHelperFunctions_GetHealthRatioByTeam Parms{};

	Parms.Team = Team;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetLastSpectatedCharacter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATslCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslCharacter* UUiHelperFunctions::GetLastSpectatedCharacter(class UUserWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetLastSpectatedCharacter");

	Params::UiHelperFunctions_GetLastSpectatedCharacter Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetLeftWidgetByTslFocusableWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UUiHelperFunctions::GetLeftWidgetByTslFocusableWidget(class UWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetLeftWidgetByTslFocusableWidget");

	Params::UiHelperFunctions_GetLeftWidgetByTslFocusableWidget Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetMarkerColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   MarkerNum                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FLinearColor UUiHelperFunctions::GetMarkerColor(int32 MarkerNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetMarkerColor");

	Params::UiHelperFunctions_GetMarkerColor Parms{};

	Parms.MarkerNum = MarkerNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetNextPlayzonePosition_BluezoneGPS
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector UUiHelperFunctions::GetNextPlayzonePosition_BluezoneGPS(class UUserWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetNextPlayzonePosition_BluezoneGPS");

	Params::UiHelperFunctions_GetNextPlayzonePosition_BluezoneGPS Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetNextPlayzoneRadius_BluezoneGPS
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UUiHelperFunctions::GetNextPlayzoneRadius_BluezoneGPS(class UUserWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetNextPlayzoneRadius_BluezoneGPS");

	Params::UiHelperFunctions_GetNextPlayzoneRadius_BluezoneGPS Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetOwningTslCharacter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATslCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslCharacter* UUiHelperFunctions::GetOwningTslCharacter(class UUserWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetOwningTslCharacter");

	Params::UiHelperFunctions_GetOwningTslCharacter Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetOwningTslPlayerController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATslPlayerController*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslPlayerController* UUiHelperFunctions::GetOwningTslPlayerController(class UUserWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetOwningTslPlayerController");

	Params::UiHelperFunctions_GetOwningTslPlayerController Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetPlayerName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ATslCharacter*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UUiHelperFunctions::GetPlayerName(class ATslCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetPlayerName");

	Params::UiHelperFunctions_GetPlayerName Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetReportCauses
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FReportCauseData>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FReportCauseData> UUiHelperFunctions::GetReportCauses()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetReportCauses");

	Params::UiHelperFunctions_GetReportCauses Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetRightWidgetByTslFocusableWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UUiHelperFunctions::GetRightWidgetByTslFocusableWidget(class UWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetRightWidgetByTslFocusableWidget");

	Params::UiHelperFunctions_GetRightWidgetByTslFocusableWidget Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetSortedReplicateCharactersByLastHitTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ATslCharacter*>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ATslCharacter*> UUiHelperFunctions::GetSortedReplicateCharactersByLastHitTime(class UUserWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetSortedReplicateCharactersByLastHitTime");

	Params::UiHelperFunctions_GetSortedReplicateCharactersByLastHitTime Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetSortedReplicateCharactersBySpectatorPawnDistance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ATslCharacter*>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ATslCharacter*> UUiHelperFunctions::GetSortedReplicateCharactersBySpectatorPawnDistance(class UUserWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetSortedReplicateCharactersBySpectatorPawnDistance");

	Params::UiHelperFunctions_GetSortedReplicateCharactersBySpectatorPawnDistance Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetSubjectToReport
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FSubjectToReport>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FSubjectToReport> UUiHelperFunctions::GetSubjectToReport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetSubjectToReport");

	Params::UiHelperFunctions_GetSubjectToReport Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetSubjectToReportType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESubjectToReport                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESubjectToReport UUiHelperFunctions::GetSubjectToReportType(class UUserWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetSubjectToReportType");

	Params::UiHelperFunctions_GetSubjectToReportType Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetTeamColors
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   TeamCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FLinearColor>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FLinearColor> UUiHelperFunctions::GetTeamColors(int32 TeamCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetTeamColors");

	Params::UiHelperFunctions_GetTeamColors Parms{};

	Parms.TeamCount = TeamCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetTeamId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ATslCharacter*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUiHelperFunctions::GetTeamId(class ATslCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetTeamId");

	Params::UiHelperFunctions_GetTeamId Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetTslHUD
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATslHUD*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslHUD* UUiHelperFunctions::GetTslHUD(class UUserWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetTslHUD");

	Params::UiHelperFunctions_GetTslHUD Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetTslSpectatorPawn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATslSpectatorPawn*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslSpectatorPawn* UUiHelperFunctions::GetTslSpectatorPawn(class UUserWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetTslSpectatorPawn");

	Params::UiHelperFunctions_GetTslSpectatorPawn Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetUpWidgetByTslFocusableWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UUiHelperFunctions::GetUpWidgetByTslFocusableWidget(class UWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetUpWidgetByTslFocusableWidget");

	Params::UiHelperFunctions_GetUpWidgetByTslFocusableWidget Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetVehicleUI
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            VehiclePawn                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UUserWidget>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UUserWidget> UUiHelperFunctions::GetVehicleUI(class APawn* VehiclePawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetVehicleUI");

	Params::UiHelperFunctions_GetVehicleUI Parms{};

	Parms.VehiclePawn = VehiclePawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.GetViewTargetTslCharacter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATslCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslCharacter* UUiHelperFunctions::GetViewTargetTslCharacter(class UUserWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "GetViewTargetTslCharacter");

	Params::UiHelperFunctions_GetViewTargetTslCharacter Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.HaveDurability
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TScriptInterface<class ISlotInterface>  ItemSlot                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUiHelperFunctions::HaveDurability(TScriptInterface<class ISlotInterface> ItemSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "HaveDurability");

	Params::UiHelperFunctions_HaveDurability Parms{};

	Parms.ItemSlot = ItemSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsAttacked
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUiHelperFunctions::IsAttacked(int32 State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "IsAttacked");

	Params::UiHelperFunctions_IsAttacked Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsBluezoneGpsReset
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUiHelperFunctions::IsBluezoneGpsReset(class UUserWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "IsBluezoneGpsReset");

	Params::UiHelperFunctions_IsBluezoneGpsReset Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsGroggyByTeam
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ATeam*                            Team                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUiHelperFunctions::IsGroggyByTeam(class ATeam* Team)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "IsGroggyByTeam");

	Params::UiHelperFunctions_IsGroggyByTeam Parms{};

	Parms.Team = Team;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsHitted
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUiHelperFunctions::IsHitted(int32 State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "IsHitted");

	Params::UiHelperFunctions_IsHitted Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsInNextPlayzone
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUiHelperFunctions::IsInNextPlayzone(class UUserWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "IsInNextPlayzone");

	Params::UiHelperFunctions_IsInNextPlayzone Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsKickEnableCharacter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ATslCharacter*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUiHelperFunctions::IsKickEnableCharacter(class ATslCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "IsKickEnableCharacter");

	Params::UiHelperFunctions_IsKickEnableCharacter Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsLastSpectatedCharacter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATslCharacter*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUiHelperFunctions::IsLastSpectatedCharacter(class UUserWidget* Widget, class ATslCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "IsLastSpectatedCharacter");

	Params::UiHelperFunctions_IsLastSpectatedCharacter Parms{};

	Parms.Widget = Widget;
	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsLastSpectatorTeam
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATslCharacter*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUiHelperFunctions::IsLastSpectatorTeam(class UUserWidget* Widget, class ATslCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "IsLastSpectatorTeam");

	Params::UiHelperFunctions_IsLastSpectatorTeam Parms{};

	Parms.Widget = Widget;
	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsThereAnyPlayingAnimation
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UWidgetAnimation*>         AnimationArray                                         (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUiHelperFunctions::IsThereAnyPlayingAnimation(class UUserWidget* Widget, const TArray<class UWidgetAnimation*>& AnimationArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "IsThereAnyPlayingAnimation");

	Params::UiHelperFunctions_IsThereAnyPlayingAnimation Parms{};

	Parms.Widget = Widget;
	Parms.AnimationArray = std::move(AnimationArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.IsWarning
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUiHelperFunctions::IsWarning(class UUserWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "IsWarning");

	Params::UiHelperFunctions_IsWarning Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.SortItem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<TScriptInterface<class ISlotInterface>>InItemList                                             (Parm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
// TArray<TScriptInterface<class ISlotInterface>>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TScriptInterface<class ISlotInterface>> UUiHelperFunctions::SortItem(const TArray<TScriptInterface<class ISlotInterface>>& InItemList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "SortItem");

	Params::UiHelperFunctions_SortItem Parms{};

	Parms.InItemList = std::move(InItemList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.SortPlayerMatchResultInfosByRanking
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FTslPlayerMatchResultInfo>PlayerMatchResultInfos                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FTslPlayerMatchResultInfo>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FTslPlayerMatchResultInfo> UUiHelperFunctions::SortPlayerMatchResultInfosByRanking(const TArray<struct FTslPlayerMatchResultInfo>& PlayerMatchResultInfos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "SortPlayerMatchResultInfosByRanking");

	Params::UiHelperFunctions_SortPlayerMatchResultInfosByRanking Parms{};

	Parms.PlayerMatchResultInfos = std::move(PlayerMatchResultInfos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.SortWidgetFormPositionX
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UWidget*>                  Widgets                                                (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bDescendingOrder                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UWidget*>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UWidget*> UUiHelperFunctions::SortWidgetFormPositionX(const TArray<class UWidget*>& Widgets, bool bDescendingOrder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "SortWidgetFormPositionX");

	Params::UiHelperFunctions_SortWidgetFormPositionX Parms{};

	Parms.Widgets = std::move(Widgets);
	Parms.bDescendingOrder = bDescendingOrder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UiHelperFunctions.SortWidgetFormPositionY
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UWidget*>                  Widgets                                                (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bDescendingOrder                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UWidget*>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UWidget*> UUiHelperFunctions::SortWidgetFormPositionY(const TArray<class UWidget*>& Widgets, bool bDescendingOrder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UiHelperFunctions", "SortWidgetFormPositionY");

	Params::UiHelperFunctions_SortWidgetFormPositionY Parms{};

	Parms.Widgets = std::move(Widgets);
	Parms.bDescendingOrder = bDescendingOrder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.DoorFrameComponent.GetDoorStaticMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UStaticMesh*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMesh* UDoorFrameComponent::GetDoorStaticMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DoorFrameComponent", "GetDoorStaticMesh");

	Params::DoorFrameComponent_GetDoorStaticMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.DroppedItem.Item_RepNotify
// (Final, Native, Protected)

void ADroppedItem::Item_RepNotify()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DroppedItem", "Item_RepNotify");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslMotoSeatActor.HandleFlipAndKickstand
// (Final, Native, Public, BlueprintCallable)

void ATslMotoSeatActor::HandleFlipAndKickstand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslMotoSeatActor", "HandleFlipAndKickstand");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslMotoSeatActor.IsEntryAllowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslMotoSeatActor::IsEntryAllowed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslMotoSeatActor", "IsEntryAllowed");

	Params::TslMotoSeatActor_IsEntryAllowed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.DroppedItemGroup.AddItem
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UItem*                            NewItem                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NewWorldLocation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADroppedItemGroup::AddItem(class UItem* NewItem, const struct FVector& NewWorldLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DroppedItemGroup", "AddItem");

	Params::DroppedItemGroup_AddItem Parms{};

	Parms.NewItem = NewItem;
	Parms.NewWorldLocation = std::move(NewWorldLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.DroppedItemGroup.OnItemBeginPlay
// (Final, Native, Private)

void ADroppedItemGroup::OnItemBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DroppedItemGroup", "OnItemBeginPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.DroppedItemGroup.OnItemEndPlay
// (Final, Native, Private)

void ADroppedItemGroup::OnItemEndPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DroppedItemGroup", "OnItemEndPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.DroppedItemInterface.GetDroppedItem
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UItem*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UItem* IDroppedItemInterface::GetDroppedItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DroppedItemInterface", "GetDroppedItem");

	Params::DroppedItemInterface_GetDroppedItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.GeneralItemSpawner.CreateItemInitiators
// (Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FItemInitiator>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FItemInitiator> UGeneralItemSpawner::CreateItemInitiators()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneralItemSpawner", "CreateItemInitiators");

	Params::GeneralItemSpawner_CreateItemInitiators Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.GeneralItemSpawner.CreateItems
// (Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UItem*>                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UItem*> UGeneralItemSpawner::CreateItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneralItemSpawner", "CreateItems");

	Params::GeneralItemSpawner_CreateItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.InteractionInterface.AllowInteractBy
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*                    Character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IInteractionInterface::AllowInteractBy(const class ATslCharacter* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInterface", "AllowInteractBy");

	Params::InteractionInterface_AllowInteractBy Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.InteractionInterface.GetInteractionVerb
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText IInteractionInterface::GetInteractionVerb() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInterface", "GetInteractionVerb");

	Params::InteractionInterface_GetInteractionVerb Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.InteractionInterface.GetInteractiveObjectName
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText IInteractionInterface::GetInteractiveObjectName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionInterface", "GetInteractiveObjectName");

	Params::InteractionInterface_GetInteractiveObjectName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.AttachableItem.GetAttachmentData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// FName                             WeaponTag                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FWeaponAttachmentData            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FWeaponAttachmentData UAttachableItem::GetAttachmentData(FName WeaponTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttachableItem", "GetAttachmentData");

	Params::AttachableItem_GetAttachmentData Parms{};

	Parms.WeaponTag = WeaponTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.AttachableItem.GetAttachmentSlotID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// FName                             WeaponTag                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWeaponAttachmentSlotID                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWeaponAttachmentSlotID UAttachableItem::GetAttachmentSlotID(FName WeaponTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttachableItem", "GetAttachmentSlotID");

	Params::AttachableItem_GetAttachmentSlotID Parms{};

	Parms.WeaponTag = WeaponTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CustomEquipableItem.GetItemLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCustomEquipableItem::GetItemLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomEquipableItem", "GetItemLevel");

	Params::CustomEquipableItem_GetItemLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CustomEquipableItem.GetOffset_Melee
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UCustomEquipableItem::GetOffset_Melee() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomEquipableItem", "GetOffset_Melee");

	Params::CustomEquipableItem_GetOffset_Melee Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CustomEquipableItem.GetOffset_Primary
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UCustomEquipableItem::GetOffset_Primary() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomEquipableItem", "GetOffset_Primary");

	Params::CustomEquipableItem_GetOffset_Primary Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CustomEquipableItem.GetOffset_Secondary
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UCustomEquipableItem::GetOffset_Secondary() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomEquipableItem", "GetOffset_Secondary");

	Params::CustomEquipableItem_GetOffset_Secondary Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CustomEquipableItem.GetOffset_SideArm
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UCustomEquipableItem::GetOffset_SideArm() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomEquipableItem", "GetOffset_SideArm");

	Params::CustomEquipableItem_GetOffset_SideArm Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CustomEquipableItem.GetOffset_Thrown
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UCustomEquipableItem::GetOffset_Thrown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomEquipableItem", "GetOffset_Thrown");

	Params::CustomEquipableItem_GetOffset_Thrown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.ThrowableItem.GetDefaultWeaponObject
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslWeapon* UThrowableItem::GetDefaultWeaponObject() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThrowableItem", "GetDefaultWeaponObject");

	Params::ThrowableItem_GetDefaultWeaponObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.ThrowableItem.GetEquippedWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslWeapon* UThrowableItem::GetEquippedWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThrowableItem", "GetEquippedWeapon");

	Params::ThrowableItem_GetEquippedWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon.AttachWeaponToMesh
// (Final, Native, Public, BlueprintCallable)

void ATslWeapon::AttachWeaponToMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "AttachWeaponToMesh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon.AttachWeaponToSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWeapon::AttachWeaponToSlot(int32 SlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "AttachWeaponToSlot");

	Params::TslWeapon_AttachWeaponToSlot Parms{};

	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon.ClientInitByReconnection
// (Final, Net, NetReliable, Native, Event, Private, NetClient, NetValidate)
// Parameters:
// bool                                    bIsArmed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWeapon::ClientInitByReconnection(bool bIsArmed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "ClientInitByReconnection");

	Params::TslWeapon_ClientInitByReconnection Parms{};

	Parms.bIsArmed = bIsArmed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon.OnAnimationNotify
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// FName                             NotifyName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWeapon::OnAnimationNotify(const FName& NotifyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "OnAnimationNotify");

	Params::TslWeapon_OnAnimationNotify Parms{};

	Parms.NotifyName = NotifyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon.OnRep_AttachedItemClasses
// (Native, Protected)

void ATslWeapon::OnRep_AttachedItemClasses()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "OnRep_AttachedItemClasses");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon.OnRep_MyPawn
// (Final, Native, Protected)

void ATslWeapon::OnRep_MyPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "OnRep_MyPawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon.ServerLogFireWeapon
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// struct FAttackId                        AttackId                                               (Parm, NativeAccessSpecifierPublic)

void ATslWeapon::ServerLogFireWeapon(const struct FAttackId& AttackId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "ServerLogFireWeapon");

	Params::TslWeapon_ServerLogFireWeapon Parms{};

	Parms.AttackId = std::move(AttackId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon.SetCurrentWeaponZero
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   newZero                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWeapon::SetCurrentWeaponZero(float newZero)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "SetCurrentWeaponZero");

	Params::TslWeapon_SetCurrentWeaponZero Parms{};

	Parms.newZero = newZero;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon.SimulatePhysicalBodyHit
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// struct FHitResult                       Impact                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ShotDirection                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ATslWeapon::SimulatePhysicalBodyHit(const struct FHitResult& Impact, const struct FVector& ShotDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "SimulatePhysicalBodyHit");

	Params::TslWeapon_SimulatePhysicalBodyHit Parms{};

	Parms.Impact = std::move(Impact);
	Parms.ShotDirection = std::move(ShotDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon.Weapon_AttachHand
// (Final, Native, Public, BlueprintCallable)

void ATslWeapon::Weapon_AttachHand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "Weapon_AttachHand");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon.Weapon_AttachShoulder
// (Final, Native, Public, BlueprintCallable)

void ATslWeapon::Weapon_AttachShoulder()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "Weapon_AttachShoulder");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon.GetAllWeaponAttachmentAssets
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FWeaponAttachmentAssetData>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FWeaponAttachmentAssetData> ATslWeapon::GetAllWeaponAttachmentAssets() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "GetAllWeaponAttachmentAssets");

	Params::TslWeapon_GetAllWeaponAttachmentAssets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon.GetAllWeaponAttachmentData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FWeaponAttachmentData>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FWeaponAttachmentData> ATslWeapon::GetAllWeaponAttachmentData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "GetAllWeaponAttachmentData");

	Params::TslWeapon_GetAllWeaponAttachmentData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon.GetAnimWeaponType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAnimWeaponType                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAnimWeaponType ATslWeapon::GetAnimWeaponType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "GetAnimWeaponType");

	Params::TslWeapon_GetAnimWeaponType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon.GetAttachedMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UAsyncStaticMeshComponent*>ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UAsyncStaticMeshComponent*> ATslWeapon::GetAttachedMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "GetAttachedMesh");

	Params::TslWeapon_GetAttachedMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon.GetCurrentWeaponZero
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslWeapon::GetCurrentWeaponZero() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "GetCurrentWeaponZero");

	Params::TslWeapon_GetCurrentWeaponZero Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon.GetDoGripPose
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslWeapon::GetDoGripPose() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "GetDoGripPose");

	Params::TslWeapon_GetDoGripPose Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon.GetHandIK_Left
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* ATslWeapon::GetHandIK_Left() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "GetHandIK_Left");

	Params::TslWeapon_GetHandIK_Left Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon.GetHandIK_Right
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* ATslWeapon::GetHandIK_Right() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "GetHandIK_Right");

	Params::TslWeapon_GetHandIK_Right Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon.GetItemName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ATslWeapon::GetItemName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "GetItemName");

	Params::TslWeapon_GetItemName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon.GetLowerRailOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector ATslWeapon::GetLowerRailOffset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "GetLowerRailOffset");

	Params::TslWeapon_GetLowerRailOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon.GetPawnOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslCharacter* ATslWeapon::GetPawnOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "GetPawnOwner");

	Params::TslWeapon_GetPawnOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon.GetRecoilMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ATslWeapon::GetRecoilMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "GetRecoilMontage");

	Params::TslWeapon_GetRecoilMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon.GetStanceSwayModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAnimStance                             Stance                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslWeapon::GetStanceSwayModifier(EAnimStance Stance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "GetStanceSwayModifier");

	Params::TslWeapon_GetStanceSwayModifier Parms{};

	Parms.Stance = Stance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon.GetSwayModifier
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector ATslWeapon::GetSwayModifier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "GetSwayModifier");

	Params::TslWeapon_GetSwayModifier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon.GetThrownType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EThrownWeaponType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EThrownWeaponType ATslWeapon::GetThrownType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "GetThrownType");

	Params::TslWeapon_GetThrownType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon.GetWeaponAnimationKick
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslWeapon::GetWeaponAnimationKick() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "GetWeaponAnimationKick");

	Params::TslWeapon_GetWeaponAnimationKick Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon.GetWeaponAttachmentAsset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponAttachmentSlotID                 SlotID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FWeaponAttachmentAssetData ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FWeaponAttachmentAssetData ATslWeapon::GetWeaponAttachmentAsset(EWeaponAttachmentSlotID SlotID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "GetWeaponAttachmentAsset");

	Params::TslWeapon_GetWeaponAttachmentAsset Parms{};

	Parms.SlotID = SlotID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon.GetWeaponAttachmentAssetDatas
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FWeaponAttachmentAssetData>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FWeaponAttachmentAssetData> ATslWeapon::GetWeaponAttachmentAssetDatas() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "GetWeaponAttachmentAssetDatas");

	Params::TslWeapon_GetWeaponAttachmentAssetDatas Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon.GetWeaponAttachmentData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponAttachmentSlotID                 SlotID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FWeaponAttachmentData      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FWeaponAttachmentData ATslWeapon::GetWeaponAttachmentData(EWeaponAttachmentSlotID SlotID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "GetWeaponAttachmentData");

	Params::TslWeapon_GetWeaponAttachmentData Parms{};

	Parms.SlotID = SlotID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon.GetWeaponAttachmentPoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponAttachmentSlotID                 SlotID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FName                             Tag                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

FName ATslWeapon::GetWeaponAttachmentPoint(EWeaponAttachmentSlotID SlotID, FName Tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "GetWeaponAttachmentPoint");

	Params::TslWeapon_GetWeaponAttachmentPoint Parms{};

	Parms.SlotID = SlotID;
	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon.GetWeaponClassEnum
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponClass                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWeaponClass ATslWeapon::GetWeaponClassEnum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "GetWeaponClassEnum");

	Params::TslWeapon_GetWeaponClassEnum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon.GetWeaponConfig
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FWeaponData                ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FWeaponData ATslWeapon::GetWeaponConfig() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "GetWeaponConfig");

	Params::TslWeapon_GetWeaponConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon.GetWeaponDamage
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslWeapon::GetWeaponDamage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "GetWeaponDamage");

	Params::TslWeapon_GetWeaponDamage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon.GetWeaponEquipDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslWeapon::GetWeaponEquipDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "GetWeaponEquipDuration");

	Params::TslWeapon_GetWeaponEquipDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon.GetWeaponGripTypeLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponGripLeftHand                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWeaponGripLeftHand ATslWeapon::GetWeaponGripTypeLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "GetWeaponGripTypeLeft");

	Params::TslWeapon_GetWeaponGripTypeLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon.GetWeaponMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ATslWeapon::GetWeaponMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "GetWeaponMesh");

	Params::TslWeapon_GetWeaponMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon.GetWeaponReadyDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslWeapon::GetWeaponReadyDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "GetWeaponReadyDuration");

	Params::TslWeapon_GetWeaponReadyDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon.IsCustomSightAttached
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponAttachmentSlotID                 SlotID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslWeapon::IsCustomSightAttached(EWeaponAttachmentSlotID SlotID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "IsCustomSightAttached");

	Params::TslWeapon_IsCustomSightAttached Parms{};

	Parms.SlotID = SlotID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon.IsWeaponAttachedToShoulder
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslWeapon::IsWeaponAttachedToShoulder() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon", "IsWeaponAttachedToShoulder");

	Params::TslWeapon_IsWeaponAttachedToShoulder Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.WeaponItem.AttachItem
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UAttachableItem*                  Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponItem::AttachItem(class UAttachableItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponItem", "AttachItem");

	Params::WeaponItem_AttachItem Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.WeaponItem.DetachItem
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// EWeaponAttachmentSlotID                 SlotID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAttachableItem*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAttachableItem* UWeaponItem::DetachItem(EWeaponAttachmentSlotID SlotID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponItem", "DetachItem");

	Params::WeaponItem_DetachItem Parms{};

	Parms.SlotID = SlotID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.WeaponItem.SetFiringMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFiringMode                             fMode                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponItem::SetFiringMode(EFiringMode fMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponItem", "SetFiringMode");

	Params::WeaponItem_SetFiringMode Parms{};

	Parms.fMode = fMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.WeaponItem.GetAllAttachedItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UAttachableItem*>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UAttachableItem*> UWeaponItem::GetAllAttachedItems() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponItem", "GetAllAttachedItems");

	Params::WeaponItem_GetAllAttachedItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.WeaponItem.GetAttachableItemCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UWeaponItem::GetAttachableItemCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponItem", "GetAttachableItemCount");

	Params::WeaponItem_GetAttachableItemCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.WeaponItem.GetAttachedItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponAttachmentSlotID                 SlotID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAttachableItem*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAttachableItem* UWeaponItem::GetAttachedItem(EWeaponAttachmentSlotID SlotID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponItem", "GetAttachedItem");

	Params::WeaponItem_GetAttachedItem Parms{};

	Parms.SlotID = SlotID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.WeaponItem.GetDefaultWeaponObject
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslWeapon* UWeaponItem::GetDefaultWeaponObject() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponItem", "GetDefaultWeaponObject");

	Params::WeaponItem_GetDefaultWeaponObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.WeaponItem.GetEquippedWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslWeapon* UWeaponItem::GetEquippedWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponItem", "GetEquippedWeapon");

	Params::WeaponItem_GetEquippedWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.WeaponItem.GetFiringMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EFiringMode                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFiringMode UWeaponItem::GetFiringMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponItem", "GetFiringMode");

	Params::WeaponItem_GetFiringMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.WeaponItem.HasAttachmentSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponAttachmentSlotID                 SlotID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponItem::HasAttachmentSlot(EWeaponAttachmentSlotID SlotID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponItem", "HasAttachmentSlot");

	Params::WeaponItem_HasAttachmentSlot Parms{};

	Parms.SlotID = SlotID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.WeaponItem.IsAttachable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAttachableItem*                  Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponItem::IsAttachable(class UAttachableItem* Item) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponItem", "IsAttachable");

	Params::WeaponItem_IsAttachable Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.ItemSpawnProcessor.ProcessGroup
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class UItemSpotGroupComponent*          SpotGroup                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UItemSpotComponent*>       Spots                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UItemSpawnProcessor::ProcessGroup(class UItemSpotGroupComponent* SpotGroup, const TArray<class UItemSpotComponent*>& Spots)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSpawnProcessor", "ProcessGroup");

	Params::ItemSpawnProcessor_ProcessGroup Parms{};

	Parms.SpotGroup = SpotGroup;
	Parms.Spots = std::move(Spots);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.ItemSpawnProcessor.ProcessSpawnItem
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UItemSpotGroupComponent*          Spawner                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemSpawnProcessor::ProcessSpawnItem(class UItemSpotGroupComponent* Spawner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSpawnProcessor", "ProcessSpawnItem");

	Params::ItemSpawnProcessor_ProcessSpawnItem Parms{};

	Parms.Spawner = Spawner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.ItemSpawnProcessor.CheckItemGroup
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// class UItemSpotGroupComponent*          SpotGroup                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemSpawnProcessor::CheckItemGroup(class UItemSpotGroupComponent* SpotGroup) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemSpawnProcessor", "CheckItemGroup");

	Params::ItemSpawnProcessor_CheckItemGroup Parms{};

	Parms.SpotGroup = SpotGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.ItemStudio.AddYaw
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItemStudio::AddYaw(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemStudio", "AddYaw");

	Params::ItemStudio_AddYaw Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.ItemStudio.SetItem
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UItem*                            Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItemStudio::SetItem(class UItem* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemStudio", "SetItem");

	Params::ItemStudio_SetItem Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.ItemStudio.SetTextureRenderTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTextureRenderTarget2D*           NewTextureTarget                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItemStudio::SetTextureRenderTarget(class UTextureRenderTarget2D* NewTextureTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemStudio", "SetTextureRenderTarget");

	Params::ItemStudio_SetTextureRenderTarget Parms{};

	Parms.NewTextureTarget = NewTextureTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.ItemStudio.UpdateComponentToWorld
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   Mesh                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AItemStudio::UpdateComponentToWorld(class UMeshComponent* Mesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemStudio", "UpdateComponentToWorld");

	Params::ItemStudio_UpdateComponentToWorld Parms{};

	Parms.Mesh = Mesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.ItemToolTipWidget.UpdateEquipmentSlotItemToolTip
// (Event, Public, BlueprintEvent)
// Parameters:
// class UEquipableItem*                   EquipableItem                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemToolTipWidget::UpdateEquipmentSlotItemToolTip(class UEquipableItem* EquipableItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemToolTipWidget", "UpdateEquipmentSlotItemToolTip");

	Params::ItemToolTipWidget_UpdateEquipmentSlotItemToolTip Parms{};

	Parms.EquipableItem = EquipableItem;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TslGame.ItemToolTipWidget.UpdateSlotInfo
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TScriptInterface<class ISlotInterface>  SlotInterface                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

void UItemToolTipWidget::UpdateSlotInfo(const TScriptInterface<class ISlotInterface>& SlotInterface)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemToolTipWidget", "UpdateSlotInfo");

	Params::ItemToolTipWidget_UpdateSlotInfo Parms{};

	Parms.SlotInterface = SlotInterface;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TslGame.ItemToolTipWidget.UpdateToolTipBySlotInterface
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class ISlotInterface>  SlotInterface                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// TScriptInterface<class ISlotContainerInterface>Container                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

void UItemToolTipWidget::UpdateToolTipBySlotInterface(TScriptInterface<class ISlotInterface> SlotInterface, TScriptInterface<class ISlotContainerInterface> Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemToolTipWidget", "UpdateToolTipBySlotInterface");

	Params::ItemToolTipWidget_UpdateToolTipBySlotInterface Parms{};

	Parms.SlotInterface = SlotInterface;
	Parms.Container = Container;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.ItemToolTipWidget.UpdateVicinityOrInventorySlotItemToolTip
// (Event, Public, BlueprintEvent)
// Parameters:
// class UEquipableItem*                   EquipableItem                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEquipableItem*                   EquipmentSlotItem                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemToolTipWidget::UpdateVicinityOrInventorySlotItemToolTip(class UEquipableItem* EquipableItem, class UEquipableItem* EquipmentSlotItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemToolTipWidget", "UpdateVicinityOrInventorySlotItemToolTip");

	Params::ItemToolTipWidget_UpdateVicinityOrInventorySlotItemToolTip Parms{};

	Parms.EquipableItem = EquipableItem;
	Parms.EquipmentSlotItem = EquipmentSlotItem;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TslGame.LobbyWidget.GameStateChanging
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// FName                             NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FName                             OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyWidget::GameStateChanging(FName NewState, FName OldState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyWidget", "GameStateChanging");

	Params::LobbyWidget_GameStateChanging Parms{};

	Parms.NewState = NewState;
	Parms.OldState = OldState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TslGame.MatchPreparer.TimerGameStartCountDown
// (Native, Protected)

void UMatchPreparer::TimerGameStartCountDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchPreparer", "TimerGameStartCountDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.AirborneMatchPreparer.AllowDealDamage
// (Final, Native, Private)

void UAirborneMatchPreparer::AllowDealDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirborneMatchPreparer", "AllowDealDamage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.ModeController.HandleServerAdminBlueprint
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FString                           AdminCommand                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AModeController::HandleServerAdminBlueprint(const class FString& AdminCommand)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ModeController", "HandleServerAdminBlueprint");

	Params::ModeController_HandleServerAdminBlueprint Parms{};

	Parms.AdminCommand = std::move(AdminCommand);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function TslGame.ModeController.SendSystemMessageToAll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESystemMessageType                      MessageType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Message                                                (Parm, NativeAccessSpecifierPublic)
// float                                   MessageDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AModeController::SendSystemMessageToAll(ESystemMessageType MessageType, const class FText& Message, float MessageDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ModeController", "SendSystemMessageToAll");

	Params::ModeController_SendSystemMessageToAll Parms{};

	Parms.MessageType = MessageType;
	Parms.Message = std::move(Message);
	Parms.MessageDuration = MessageDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.ModeController.CanDealDamage
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class ATslPlayerState*                  DamageInstigator                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATslPlayerState*                  DamagedPlayer                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AModeController::CanDealDamage(const class ATslPlayerState* DamageInstigator, const class ATslPlayerState* DamagedPlayer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ModeController", "CanDealDamage");

	Params::ModeController_CanDealDamage Parms{};

	Parms.DamageInstigator = DamageInstigator;
	Parms.DamagedPlayer = DamagedPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.ModeController.GetGameMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslGameMode*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslGameMode* AModeController::GetGameMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ModeController", "GetGameMode");

	Params::ModeController_GetGameMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.ModeController.GetGameState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslGameState*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslGameState* AModeController::GetGameState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ModeController", "GetGameState");

	Params::ModeController_GetGameState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.ModeController.IsPlayInEditor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AModeController::IsPlayInEditor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ModeController", "IsPlayInEditor");

	Params::ModeController_IsPlayInEditor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.BattleRoyaleModeController.InitRadius
// (Final, Native, Public, BlueprintCallable)

void ABattleRoyaleModeController::InitRadius()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleRoyaleModeController", "InitRadius");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.BattleRoyaleModeController.SetNextGasInBlackboard
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ABattleRoyaleModeController::SetNextGasInBlackboard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleRoyaleModeController", "SetNextGasInBlackboard");

	Params::BattleRoyaleModeController_SetNextGasInBlackboard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.BattleRoyaleModeController.GetMaxPhaseCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ABattleRoyaleModeController::GetMaxPhaseCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleRoyaleModeController", "GetMaxPhaseCount");

	Params::BattleRoyaleModeController_GetMaxPhaseCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.BattleRoyaleModeController.GetPoisonGasDamagePerSecond
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ABattleRoyaleModeController::GetPoisonGasDamagePerSecond() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleRoyaleModeController", "GetPoisonGasDamagePerSecond");

	Params::BattleRoyaleModeController_GetPoisonGasDamagePerSecond Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CarePackageController.InitCarePackageSetting
// (Final, Native, Public, BlueprintCallable)

void ACarePackageController::InitCarePackageSetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarePackageController", "InitCarePackageSetting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.CarePackageController.SetNextCarePackageInBlackboard
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACarePackageController::SetNextCarePackageInBlackboard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarePackageController", "SetNextCarePackageInBlackboard");

	Params::CarePackageController_SetNextCarePackageInBlackboard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CarePackageController.SpawnAircraftCarePackage
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// bool                                    CopyIntersectionInfo                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector ACarePackageController::SpawnAircraftCarePackage(bool CopyIntersectionInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarePackageController", "SpawnAircraftCarePackage");

	Params::CarePackageController_SpawnAircraftCarePackage Parms{};

	Parms.CopyIntersectionInfo = CopyIntersectionInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CarePackageController.GetSpawnInterval
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACarePackageController::GetSpawnInterval() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarePackageController", "GetSpawnInterval");

	Params::CarePackageController_GetSpawnInterval Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.RedZoneController.InitRedZoneSetting
// (Final, Native, Public, BlueprintCallable)

void ARedZoneController::InitRedZoneSetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RedZoneController", "InitRedZoneSetting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.RedZoneController.SetNextRedZoneInBlackboard
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARedZoneController::SetNextRedZoneInBlackboard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RedZoneController", "SetNextRedZoneInBlackboard");

	Params::RedZoneController_SetNextRedZoneInBlackboard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.RedZoneController.SpawnBombProjectile
// (Final, Native, Public, BlueprintCallable)

void ARedZoneController::SpawnBombProjectile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RedZoneController", "SpawnBombProjectile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.RedZoneController.GetRandomBombingInterval
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARedZoneController::GetRandomBombingInterval() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RedZoneController", "GetRandomBombingInterval");

	Params::RedZoneController_GetRandomBombingInterval Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.MutableCharacter.OnRep_InstanceDescriptor
// (Final, Native, Protected)

void AMutableCharacter::OnRep_InstanceDescriptor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MutableCharacter", "OnRep_InstanceDescriptor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.MutableCharacter.UpdateAppearence
// (Final, Native, Public, BlueprintCallable)

void AMutableCharacter::UpdateAppearence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MutableCharacter", "UpdateAppearence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.MutableCharacter.GetGender
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EGender                                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGender AMutableCharacter::GetGender() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MutableCharacter", "GetGender");

	Params::MutableCharacter_GetGender Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.LobbyCharacter.GetNetId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ALobbyCharacter::GetNetId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyCharacter", "GetNetId");

	Params::LobbyCharacter_GetNetId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.LobbyCharacter.GetNickName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ALobbyCharacter::GetNickName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyCharacter", "GetNickName");

	Params::LobbyCharacter_GetNickName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslVaultingHelper.GetActorAttachScene
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector ATslVaultingHelper::GetActorAttachScene() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVaultingHelper", "GetActorAttachScene");

	Params::TslVaultingHelper_GetActorAttachScene Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.AnimCall_FireWeapon
// (Final, Native, Public, BlueprintCallable)

void ATslWeapon_Gun::AnimCall_FireWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "AnimCall_FireWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.AnimCall_FireWeaponCycle
// (Final, Native, Public, BlueprintCallable)

void ATslWeapon_Gun::AnimCall_FireWeaponCycle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "AnimCall_FireWeaponCycle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.AnimCall_ReloadChargeWeapon
// (Final, Native, Public, BlueprintCallable)

void ATslWeapon_Gun::AnimCall_ReloadChargeWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "AnimCall_ReloadChargeWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.AnimCall_ReloadTacticalWeapon
// (Final, Native, Public, BlueprintCallable)

void ATslWeapon_Gun::AnimCall_ReloadTacticalWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "AnimCall_ReloadTacticalWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.AnimCall_ToggleFireMode
// (Final, Native, Public, BlueprintCallable)

void ATslWeapon_Gun::AnimCall_ToggleFireMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "AnimCall_ToggleFireMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.CancelReloadImpl
// (Final, Native, Public)

void ATslWeapon_Gun::CancelReloadImpl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "CancelReloadImpl");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.CheckMiddlePointCollision
// (Final, Native, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslWeapon_Gun::CheckMiddlePointCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "CheckMiddlePointCollision");

	Params::TslWeapon_Gun_CheckMiddlePointCollision Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.Client_StartManualFireCycle
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void ATslWeapon_Gun::Client_StartManualFireCycle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "Client_StartManualFireCycle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.ClientCancelReload
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ATslWeapon_Gun::ClientCancelReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "ClientCancelReload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.ClientNotifyAmmo
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// int32                                   InCurrentAmmoInClip                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWeapon_Gun::ClientNotifyAmmo(int32 InCurrentAmmoInClip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "ClientNotifyAmmo");

	Params::TslWeapon_Gun_ClientNotifyAmmo Parms{};

	Parms.InCurrentAmmoInClip = InCurrentAmmoInClip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.ClientNotifyStopReloadByOne
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void ATslWeapon_Gun::ClientNotifyStopReloadByOne()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "ClientNotifyStopReloadByOne");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.ClientSimulateWeaponFire
// (Net, Native, Event, NetMulticast, Protected)
// Parameters:
// struct FHitResult                       ExceptTrajectoryHitResult                              (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ATslWeapon_Gun::ClientSimulateWeaponFire(const struct FHitResult& ExceptTrajectoryHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "ClientSimulateWeaponFire");

	Params::TslWeapon_Gun_ClientSimulateWeaponFire Parms{};

	Parms.ExceptTrajectoryHitResult = std::move(ExceptTrajectoryHitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.ClientStopSimulatingWeaponFire
// (Net, Native, Event, NetMulticast, Protected)

void ATslWeapon_Gun::ClientStopSimulatingWeaponFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "ClientStopSimulatingWeaponFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.ManualFireCycleFinished
// (Final, Native, Protected)

void ATslWeapon_Gun::ManualFireCycleFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "ManualFireCycleFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.OnAnimationNotify
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// FName                             NotifyName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWeapon_Gun::OnAnimationNotify(const FName& NotifyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "OnAnimationNotify");

	Params::TslWeapon_Gun_OnAnimationNotify Parms{};

	Parms.NotifyName = NotifyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.OnAttachmentScopeLoaded
// (Final, Native, Protected)

void ATslWeapon_Gun::OnAttachmentScopeLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "OnAttachmentScopeLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.OnRep_AmmoCount
// (Final, Native, Protected)
// Parameters:
// int32                                   LastCurrentAmmoInClip                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWeapon_Gun::OnRep_AmmoCount(int32 LastCurrentAmmoInClip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "OnRep_AmmoCount");

	Params::TslWeapon_Gun_OnRep_AmmoCount Parms{};

	Parms.LastCurrentAmmoInClip = LastCurrentAmmoInClip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.OnRep_AttachedItemClasses
// (Native, Protected)

void ATslWeapon_Gun::OnRep_AttachedItemClasses()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "OnRep_AttachedItemClasses");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.OnRep_TimeBetweenShots
// (Final, Native, Protected)
// Parameters:
// float                                   LastTimeBetweenShots                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWeapon_Gun::OnRep_TimeBetweenShots(float LastTimeBetweenShots)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "OnRep_TimeBetweenShots");

	Params::TslWeapon_Gun_OnRep_TimeBetweenShots Parms{};

	Parms.LastTimeBetweenShots = LastTimeBetweenShots;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.PlayLongTailSound
// (Final, Native, Protected)

void ATslWeapon_Gun::PlayLongTailSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "PlayLongTailSound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.PlayWeaponCycleCameraAnim
// (Final, Native, Protected)

void ATslWeapon_Gun::PlayWeaponCycleCameraAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "PlayWeaponCycleCameraAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.ProcessBoltAction
// (Final, Native, Protected)

void ATslWeapon_Gun::ProcessBoltAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "ProcessBoltAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.Server_StartManualFireCycle
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void ATslWeapon_Gun::Server_StartManualFireCycle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "Server_StartManualFireCycle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.ServerCancelReload
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ATslWeapon_Gun::ServerCancelReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "ServerCancelReload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.ServerHandleFiring
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// struct FHitResult                       ExceptTrajectoryHitResult                              (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ATslWeapon_Gun::ServerHandleFiring(const struct FHitResult& ExceptTrajectoryHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "ServerHandleFiring");

	Params::TslWeapon_Gun_ServerHandleFiring Parms{};

	Parms.ExceptTrajectoryHitResult = std::move(ExceptTrajectoryHitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.ServerSetHip
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// bool                                    bNewIsHipped                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWeapon_Gun::ServerSetHip(bool bNewIsHipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "ServerSetHip");

	Params::TslWeapon_Gun_ServerSetHip Parms{};

	Parms.bNewIsHipped = bNewIsHipped;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.ServerStartFire
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void ATslWeapon_Gun::ServerStartFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "ServerStartFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.ServerStartReload
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void ATslWeapon_Gun::ServerStartReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "ServerStartReload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.ServerStopFire
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void ATslWeapon_Gun::ServerStopFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "ServerStopFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.ServerStopReload
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void ATslWeapon_Gun::ServerStopReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "ServerStopReload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.SetFiringMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFiringMode                             FiringMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWeapon_Gun::SetFiringMode(EFiringMode FiringMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "SetFiringMode");

	Params::TslWeapon_Gun_SetFiringMode Parms{};

	Parms.FiringMode = FiringMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.SetSpawnBulletFromBarrel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    DoSpawnBulletFromBarrel                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWeapon_Gun::SetSpawnBulletFromBarrel(bool DoSpawnBulletFromBarrel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "SetSpawnBulletFromBarrel");

	Params::TslWeapon_Gun_SetSpawnBulletFromBarrel Parms{};

	Parms.DoSpawnBulletFromBarrel = DoSpawnBulletFromBarrel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.SetWeaponReloadInterrupted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsInterrupted                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWeapon_Gun::SetWeaponReloadInterrupted(bool bIsInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "SetWeaponReloadInterrupted");

	Params::TslWeapon_Gun_SetWeaponReloadInterrupted Parms{};

	Parms.bIsInterrupted = bIsInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.SimulateWeaponReload
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// EWeaponReloadAnimExec                   ReloadAnimExec                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWeapon_Gun::SimulateWeaponReload(const EWeaponReloadAnimExec& ReloadAnimExec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "SimulateWeaponReload");

	Params::TslWeapon_Gun_SimulateWeaponReload Parms{};

	Parms.ReloadAnimExec = ReloadAnimExec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.StartManualFireCycle
// (Final, Native, Protected)

void ATslWeapon_Gun::StartManualFireCycle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "StartManualFireCycle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.StopReloadAnimByOne
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void ATslWeapon_Gun::StopReloadAnimByOne()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "StopReloadAnimByOne");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Gun.GetADSRecoilKick
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslWeapon_Gun::GetADSRecoilKick() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetADSRecoilKick");

	Params::TslWeapon_Gun_GetADSRecoilKick Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetAmmoItemClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UAmmoItem>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UAmmoItem> ATslWeapon_Gun::GetAmmoItemClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetAmmoItemClass");

	Params::TslWeapon_Gun_GetAmmoItemClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetAmmoPerClip
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ATslWeapon_Gun::GetAmmoPerClip() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetAmmoPerClip");

	Params::TslWeapon_Gun_GetAmmoPerClip Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCharacterChargeReloadFromAttach
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ATslWeapon_Gun::GetCharacterChargeReloadFromAttach() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetCharacterChargeReloadFromAttach");

	Params::TslWeapon_Gun_GetCharacterChargeReloadFromAttach Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCharacterFireCycle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ATslWeapon_Gun::GetCharacterFireCycle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetCharacterFireCycle");

	Params::TslWeapon_Gun_GetCharacterFireCycle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCharacterFireMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ATslWeapon_Gun::GetCharacterFireMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetCharacterFireMontage");

	Params::TslWeapon_Gun_GetCharacterFireMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCharacterFireSelectorMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ATslWeapon_Gun::GetCharacterFireSelectorMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetCharacterFireSelectorMontage");

	Params::TslWeapon_Gun_GetCharacterFireSelectorMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCharacterGripBlendspace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBlendSpace1D*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBlendSpace1D* ATslWeapon_Gun::GetCharacterGripBlendspace() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetCharacterGripBlendspace");

	Params::TslWeapon_Gun_GetCharacterGripBlendspace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCharacterLHGripBlendspace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBlendSpaceBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBlendSpaceBase* ATslWeapon_Gun::GetCharacterLHGripBlendspace() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetCharacterLHGripBlendspace");

	Params::TslWeapon_Gun_GetCharacterLHGripBlendspace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCharacterReloadByOneSingleMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ATslWeapon_Gun::GetCharacterReloadByOneSingleMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetCharacterReloadByOneSingleMontage");

	Params::TslWeapon_Gun_GetCharacterReloadByOneSingleMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCharacterReloadByOneStartMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ATslWeapon_Gun::GetCharacterReloadByOneStartMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetCharacterReloadByOneStartMontage");

	Params::TslWeapon_Gun_GetCharacterReloadByOneStartMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCharacterReloadByOneStopMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ATslWeapon_Gun::GetCharacterReloadByOneStopMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetCharacterReloadByOneStopMontage");

	Params::TslWeapon_Gun_GetCharacterReloadByOneStopMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCharacterReloadChargeMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ATslWeapon_Gun::GetCharacterReloadChargeMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetCharacterReloadChargeMontage");

	Params::TslWeapon_Gun_GetCharacterReloadChargeMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCharacterReloadTacticalMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ATslWeapon_Gun::GetCharacterReloadTacticalMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetCharacterReloadTacticalMontage");

	Params::TslWeapon_Gun_GetCharacterReloadTacticalMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCharacterTacticalReloadFromAttach
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ATslWeapon_Gun::GetCharacterTacticalReloadFromAttach() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetCharacterTacticalReloadFromAttach");

	Params::TslWeapon_Gun_GetCharacterTacticalReloadFromAttach Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCurrentAmmo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ATslWeapon_Gun::GetCurrentAmmo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetCurrentAmmo");

	Params::TslWeapon_Gun_GetCurrentAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCurrentAmmoInClip
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ATslWeapon_Gun::GetCurrentAmmoInClip() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetCurrentAmmoInClip");

	Params::TslWeapon_Gun_GetCurrentAmmoInClip Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCurrentAmmoInInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ATslWeapon_Gun::GetCurrentAmmoInInventory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetCurrentAmmoInInventory");

	Params::TslWeapon_Gun_GetCurrentAmmoInInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetCurrentDeviation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslWeapon_Gun::GetCurrentDeviation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetCurrentDeviation");

	Params::TslWeapon_Gun_GetCurrentDeviation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetDefaultAmmoObject
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAmmoItem*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAmmoItem* ATslWeapon_Gun::GetDefaultAmmoObject() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetDefaultAmmoObject");

	Params::TslWeapon_Gun_GetDefaultAmmoObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetFiringMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EFiringMode                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFiringMode ATslWeapon_Gun::GetFiringMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetFiringMode");

	Params::TslWeapon_Gun_GetFiringMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetGripTypeIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ATslWeapon_Gun::GetGripTypeIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetGripTypeIndex");

	Params::TslWeapon_Gun_GetGripTypeIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetMagDropAngularVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector ATslWeapon_Gun::GetMagDropAngularVelocity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetMagDropAngularVelocity");

	Params::TslWeapon_Gun_GetMagDropAngularVelocity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetMagDropLinearVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector ATslWeapon_Gun::GetMagDropLinearVelocity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetMagDropLinearVelocity");

	Params::TslWeapon_Gun_GetMagDropLinearVelocity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetMagOutDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslWeapon_Gun::GetMagOutDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetMagOutDuration");

	Params::TslWeapon_Gun_GetMagOutDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetMaxAmmo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ATslWeapon_Gun::GetMaxAmmo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetMaxAmmo");

	Params::TslWeapon_Gun_GetMaxAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetMovementModifierAim
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslWeapon_Gun::GetMovementModifierAim() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetMovementModifierAim");

	Params::TslWeapon_Gun_GetMovementModifierAim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetMovementModifierScope
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslWeapon_Gun::GetMovementModifierScope() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetMovementModifierScope");

	Params::TslWeapon_Gun_GetMovementModifierScope Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetNumOfFiringMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ATslWeapon_Gun::GetNumOfFiringMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetNumOfFiringMode");

	Params::TslWeapon_Gun_GetNumOfFiringMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetRecoilADSSocketOffsetScale
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector ATslWeapon_Gun::GetRecoilADSSocketOffsetScale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetRecoilADSSocketOffsetScale");

	Params::TslWeapon_Gun_GetRecoilADSSocketOffsetScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetReloadAnimationPlayRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslWeapon_Gun::GetReloadAnimationPlayRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetReloadAnimationPlayRate");

	Params::TslWeapon_Gun_GetReloadAnimationPlayRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetWeaponChargeReload
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ATslWeapon_Gun::GetWeaponChargeReload() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetWeaponChargeReload");

	Params::TslWeapon_Gun_GetWeaponChargeReload Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetWeaponCurrentDeviationValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslWeapon_Gun::GetWeaponCurrentDeviationValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetWeaponCurrentDeviationValue");

	Params::TslWeapon_Gun_GetWeaponCurrentDeviationValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetWeaponCurrentRecoilValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslWeapon_Gun::GetWeaponCurrentRecoilValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetWeaponCurrentRecoilValue");

	Params::TslWeapon_Gun_GetWeaponCurrentRecoilValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetWeaponFullRealoadTimeWithAttachments
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslWeapon_Gun::GetWeaponFullRealoadTimeWithAttachments() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetWeaponFullRealoadTimeWithAttachments");

	Params::TslWeapon_Gun_GetWeaponFullRealoadTimeWithAttachments Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetWeaponFullReloadTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslWeapon_Gun::GetWeaponFullReloadTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetWeaponFullReloadTime");

	Params::TslWeapon_Gun_GetWeaponFullReloadTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetWeaponGunAnimConfig
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FWeaponGunAnim                   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FWeaponGunAnim ATslWeapon_Gun::GetWeaponGunAnimConfig() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetWeaponGunAnimConfig");

	Params::TslWeapon_Gun_GetWeaponGunAnimConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetWeaponGunConfig
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FWeaponGunData                   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FWeaponGunData ATslWeapon_Gun::GetWeaponGunConfig() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetWeaponGunConfig");

	Params::TslWeapon_Gun_GetWeaponGunConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetWeaponHandOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector ATslWeapon_Gun::GetWeaponHandOffset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetWeaponHandOffset");

	Params::TslWeapon_Gun_GetWeaponHandOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetWeaponHandOffsetFPP
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector ATslWeapon_Gun::GetWeaponHandOffsetFPP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetWeaponHandOffsetFPP");

	Params::TslWeapon_Gun_GetWeaponHandOffsetFPP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.GetWeaponTacticalReload
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* ATslWeapon_Gun::GetWeaponTacticalReload() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "GetWeaponTacticalReload");

	Params::TslWeapon_Gun_GetWeaponTacticalReload Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.IsReloading
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslWeapon_Gun::IsReloading() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "IsReloading");

	Params::TslWeapon_Gun_IsReloading Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.IsReloadInterrupted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslWeapon_Gun::IsReloadInterrupted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "IsReloadInterrupted");

	Params::TslWeapon_Gun_IsReloadInterrupted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.IsWeaponCycleInProgress
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslWeapon_Gun::IsWeaponCycleInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "IsWeaponCycleInProgress");

	Params::TslWeapon_Gun_IsWeaponCycleInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Gun.WeaponCycleDone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslWeapon_Gun::WeaponCycleDone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Gun", "WeaponCycleDone");

	Params::TslWeapon_Gun_WeaponCycleDone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.WeaponProcessor.ClientForceRemoveWeapon
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// int32                                   WeaponIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeaponProcessor::ClientForceRemoveWeapon(int32 WeaponIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponProcessor", "ClientForceRemoveWeapon");

	Params::WeaponProcessor_ClientForceRemoveWeapon Parms{};

	Parms.WeaponIndex = WeaponIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.WeaponProcessor.ClientInitByReconnection
// (Net, NetReliable, Native, Event, Protected, NetClient, NetValidate)
// Parameters:
// int32                                   InitWeaponIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeaponProcessor::ClientInitByReconnection(int32 InitWeaponIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponProcessor", "ClientInitByReconnection");

	Params::WeaponProcessor_ClientInitByReconnection Parms{};

	Parms.InitWeaponIndex = InitWeaponIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.WeaponProcessor.ClientSetWeaponIndex
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// int32                                   WeaponIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeaponProcessor::ClientSetWeaponIndex(int32 WeaponIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponProcessor", "ClientSetWeaponIndex");

	Params::WeaponProcessor_ClientSetWeaponIndex Parms{};

	Parms.WeaponIndex = WeaponIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.WeaponProcessor.FindWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class ATslWeapon>           WeaponClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATslWeapon*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslWeapon* AWeaponProcessor::FindWeapon(TSubclassOf<class ATslWeapon> WeaponClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponProcessor", "FindWeapon");

	Params::WeaponProcessor_FindWeapon Parms{};

	Parms.WeaponClass = WeaponClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.WeaponProcessor.NotifyWeaponUpdate
// (Final, Native, Private)

void AWeaponProcessor::NotifyWeaponUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponProcessor", "NotifyWeaponUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.WeaponProcessor.OnRep_CurrentWeaponIndex
// (Final, Native, Protected)
// Parameters:
// int32                                   LastWeaponIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeaponProcessor::OnRep_CurrentWeaponIndex(int32 LastWeaponIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponProcessor", "OnRep_CurrentWeaponIndex");

	Params::WeaponProcessor_OnRep_CurrentWeaponIndex Parms{};

	Parms.LastWeaponIndex = LastWeaponIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.WeaponProcessor.OnRep_EquippedWeapons
// (Final, Native, Protected)
// Parameters:
// TArray<class ATslWeapon*>               LastEquippedWeapons                                    (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void AWeaponProcessor::OnRep_EquippedWeapons(const TArray<class ATslWeapon*>& LastEquippedWeapons)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponProcessor", "OnRep_EquippedWeapons");

	Params::WeaponProcessor_OnRep_EquippedWeapons Parms{};

	Parms.LastEquippedWeapons = std::move(LastEquippedWeapons);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.WeaponProcessor.ServerArmWeapon
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// int32                                   WeaponIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNeedAnimation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeaponProcessor::ServerArmWeapon(int32 WeaponIndex, bool bNeedAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponProcessor", "ServerArmWeapon");

	Params::WeaponProcessor_ServerArmWeapon Parms{};

	Parms.WeaponIndex = WeaponIndex;
	Parms.bNeedAnimation = bNeedAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.WeaponProcessor.ServerUnarmCurrentWeapon
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void AWeaponProcessor::ServerUnarmCurrentWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponProcessor", "ServerUnarmCurrentWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.WeaponProcessor.SimulateArmWeapon
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// int32                                   WeaponIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNeedAnimation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeaponProcessor::SimulateArmWeapon(int32 WeaponIndex, bool bNeedAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponProcessor", "SimulateArmWeapon");

	Params::WeaponProcessor_SimulateArmWeapon Parms{};

	Parms.WeaponIndex = WeaponIndex;
	Parms.bNeedAnimation = bNeedAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.WeaponProcessor.SimulateUnArmWeapon
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// int32                                   WeaponIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AWeaponProcessor::SimulateUnArmWeapon(int32 WeaponIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponProcessor", "SimulateUnArmWeapon");

	Params::WeaponProcessor_SimulateUnArmWeapon Parms{};

	Parms.WeaponIndex = WeaponIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.WeaponProcessor.GetCurrentWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslWeapon* AWeaponProcessor::GetCurrentWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponProcessor", "GetCurrentWeapon");

	Params::WeaponProcessor_GetCurrentWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.WeaponProcessor.GetUnarmedWeaponIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AWeaponProcessor::GetUnarmedWeaponIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponProcessor", "GetUnarmedWeaponIndex");

	Params::WeaponProcessor_GetUnarmedWeaponIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.WeaponProcessor.GetWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslWeapon* AWeaponProcessor::GetWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponProcessor", "GetWeapon");

	Params::WeaponProcessor_GetWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.WeaponProcessor.GetWeaponByIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATslWeapon*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslWeapon* AWeaponProcessor::GetWeaponByIndex(int32 Index_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponProcessor", "GetWeaponByIndex");

	Params::WeaponProcessor_GetWeaponByIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.WeaponProcessor.GetWeaponGun
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon_Gun*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslWeapon_Gun* AWeaponProcessor::GetWeaponGun() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponProcessor", "GetWeaponGun");

	Params::WeaponProcessor_GetWeaponGun Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.WeaponProcessor.GetWeaponIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AWeaponProcessor::GetWeaponIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponProcessor", "GetWeaponIndex");

	Params::WeaponProcessor_GetWeaponIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.WeaponProcessor.GetWeaponThrowable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon_Throwable*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslWeapon_Throwable* AWeaponProcessor::GetWeaponThrowable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponProcessor", "GetWeaponThrowable");

	Params::WeaponProcessor_GetWeaponThrowable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.WeaponProcessor.IsUnarmed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWeaponProcessor::IsUnarmed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponProcessor", "IsUnarmed");

	Params::WeaponProcessor_IsUnarmed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.WeaponProcessor.IsUnarmedWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   WeaponIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AWeaponProcessor::IsUnarmedWeapon(int32 WeaponIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponProcessor", "IsUnarmedWeapon");

	Params::WeaponProcessor_IsUnarmedWeapon Parms{};

	Parms.WeaponIndex = WeaponIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VaultingData.GetAnimationCurve
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCurveFloat*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCurveFloat* UVaultingData::GetAnimationCurve() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VaultingData", "GetAnimationCurve");

	Params::VaultingData_GetAnimationCurve Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VaultingData.GetAnimationLength
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UVaultingData::GetAnimationLength() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VaultingData", "GetAnimationLength");

	Params::VaultingData_GetAnimationLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VaultingData.GetBlendSpeedByDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InDistance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UVaultingData::GetBlendSpeedByDistance(float InDistance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VaultingData", "GetBlendSpeedByDistance");

	Params::VaultingData_GetBlendSpeedByDistance Parms{};

	Parms.InDistance = InDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VaultingData.GetVaultAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimSequenceBase*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequenceBase* UVaultingData::GetVaultAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VaultingData", "GetVaultAnimation");

	Params::VaultingData_GetVaultAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.AddBuffMoveSpeedFactor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   MoveSpeedFactor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::AddBuffMoveSpeedFactor(float MoveSpeedFactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "AddBuffMoveSpeedFactor");

	Params::TslCharacter_AddBuffMoveSpeedFactor Parms{};

	Parms.MoveSpeedFactor = MoveSpeedFactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.AdminFreeMoveMode
// (Event, Public, BlueprintEvent)

void ATslCharacter::AdminFreeMoveMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "AdminFreeMoveMode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TslGame.TslCharacter.AdminInvulnerable
// (Event, Public, BlueprintEvent)

void ATslCharacter::AdminInvulnerable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "AdminInvulnerable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TslGame.TslCharacter.AdminSetUpWeapon
// (Event, Public, BlueprintEvent)

void ATslCharacter::AdminSetUpWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "AdminSetUpWeapon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TslGame.TslCharacter.AllowInteract
// (Final, Native, Protected)
// Parameters:
// class ATslCharacter*                    OtherCharacter                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::AllowInteract(const class ATslCharacter* OtherCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "AllowInteract");

	Params::TslCharacter_AllowInteract Parms{};

	Parms.OtherCharacter = OtherCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.Anim_MagazineHandAttach
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bAttach                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::Anim_MagazineHandAttach(bool bAttach)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "Anim_MagazineHandAttach");

	Params::TslCharacter_Anim_MagazineHandAttach Parms{};

	Parms.bAttach = bAttach;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.Anim_MagazineShow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::Anim_MagazineShow(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "Anim_MagazineShow");

	Params::TslCharacter_Anim_MagazineShow Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.ApplyRagdollPhysicsForce
// (Final, Native, Public)

void ATslCharacter::ApplyRagdollPhysicsForce()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "ApplyRagdollPhysicsForce");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.BindCallbackToHUD
// (Final, Native, Public)
// Parameters:
// class ATslPlayerController*             InController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::BindCallbackToHUD(class ATslPlayerController* InController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "BindCallbackToHUD");

	Params::TslCharacter_BindCallbackToHUD Parms{};

	Parms.InController = InController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.Camera_AimoffsetFix_FppToTpp
// (Native, Event, Public, BlueprintEvent)

void ATslCharacter::Camera_AimoffsetFix_FppToTpp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "Camera_AimoffsetFix_FppToTpp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.Camera_AimoffsetFix_TppToFpp
// (Native, Event, Public, BlueprintEvent)

void ATslCharacter::Camera_AimoffsetFix_TppToFpp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "Camera_AimoffsetFix_TppToFpp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.CheckEquipmentSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FEquipPosition                   InSlotData                                             (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::CheckEquipmentSlot(const struct FEquipPosition& InSlotData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "CheckEquipmentSlot");

	Params::TslCharacter_CheckEquipmentSlot Parms{};

	Parms.InSlotData = std::move(InSlotData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.CheckForCoat
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::CheckForCoat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "CheckForCoat");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.CheckJumpAndVault
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// bool                                    bForceVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InForcedVelocity                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ATslCharacter::CheckJumpAndVault(bool bForceVelocity, const struct FVector& InForcedVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "CheckJumpAndVault");

	Params::TslCharacter_CheckJumpAndVault Parms{};

	Parms.bForceVelocity = bForceVelocity;
	Parms.InForcedVelocity = std::move(InForcedVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.CheckMuzzleBulletSpawn
// (Final, Native, Public)

void ATslCharacter::CheckMuzzleBulletSpawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "CheckMuzzleBulletSpawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.CheckMuzzleCollision
// (Final, Native, Public)

void ATslCharacter::CheckMuzzleCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "CheckMuzzleCollision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.Client_CastCancelNotify
// (Net, NetReliable, Native, Event, NetMulticast, Public, NetValidate)

void ATslCharacter::Client_CastCancelNotify()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "Client_CastCancelNotify");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.Client_CastFinishNotify
// (Net, NetReliable, Native, Event, NetMulticast, Public, NetValidate)

void ATslCharacter::Client_CastFinishNotify()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "Client_CastFinishNotify");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.Client_PlayUnarmedAttack
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// int32                                   AnimationIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::Client_PlayUnarmedAttack(int32 AnimationIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "Client_PlayUnarmedAttack");

	Params::TslCharacter_Client_PlayUnarmedAttack Parms{};

	Parms.AnimationIndex = AnimationIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.ClientForceInitStance
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// EStanceMode                             ToStance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::ClientForceInitStance(EStanceMode ToStance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "ClientForceInitStance");

	Params::TslCharacter_ClientForceInitStance Parms{};

	Parms.ToStance = ToStance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.ClientMyCharacterPlayPickUpAnimation
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// struct FVector_NetQuantize              InteractionObject                                      (ConstParm, Parm, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::ClientMyCharacterPlayPickUpAnimation(const struct FVector_NetQuantize& InteractionObject, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "ClientMyCharacterPlayPickUpAnimation");

	Params::TslCharacter_ClientMyCharacterPlayPickUpAnimation Parms{};

	Parms.InteractionObject = std::move(InteractionObject);
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.ClientNotifyCrack
// (Net, Native, Event, Public, NetClient)
// Parameters:
// struct FVector_NetQuantize              LocationRelative                                       (Parm, NativeAccessSpecifierPublic)
// float                                   BulletVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::ClientNotifyCrack(const struct FVector_NetQuantize& LocationRelative, float BulletVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "ClientNotifyCrack");

	Params::TslCharacter_ClientNotifyCrack Parms{};

	Parms.LocationRelative = std::move(LocationRelative);
	Parms.BulletVelocity = BulletVelocity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.ClientPlayPickUpAnimation
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// struct FVector_NetQuantize              InteractionObject                                      (ConstParm, Parm, NativeAccessSpecifierPublic)

void ATslCharacter::ClientPlayPickUpAnimation(const struct FVector_NetQuantize& InteractionObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "ClientPlayPickUpAnimation");

	Params::TslCharacter_ClientPlayPickUpAnimation Parms{};

	Parms.InteractionObject = std::move(InteractionObject);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.ClientProcessRevive
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// float                                   RemainGroggyHealth                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::ClientProcessRevive(float RemainGroggyHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "ClientProcessRevive");

	Params::TslCharacter_ClientProcessRevive Parms{};

	Parms.RemainGroggyHealth = RemainGroggyHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.ClientRevivedCastingWidgetShow
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::ClientRevivedCastingWidgetShow(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "ClientRevivedCastingWidgetShow");

	Params::TslCharacter_ClientRevivedCastingWidgetShow Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.ClientSendGroggyMessage
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ATslPlayerState*                  GroggyCauserPlayerState                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATslPlayerState*                  VictimPlayerState                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      GroggyCauserDamageType                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDamageReason                           DamageReason                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             DamageCauserName                                       (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ATslCharacter::ClientSendGroggyMessage(class ATslPlayerState* GroggyCauserPlayerState, class ATslPlayerState* VictimPlayerState, const class UDamageType* GroggyCauserDamageType, EDamageReason DamageReason, const class FText& DamageCauserName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "ClientSendGroggyMessage");

	Params::TslCharacter_ClientSendGroggyMessage Parms{};

	Parms.GroggyCauserPlayerState = GroggyCauserPlayerState;
	Parms.VictimPlayerState = VictimPlayerState;
	Parms.GroggyCauserDamageType = GroggyCauserDamageType;
	Parms.DamageReason = DamageReason;
	Parms.DamageCauserName = std::move(DamageCauserName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.ClientSetTargeting
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// ETargetingType                          NewTargetingType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::ClientSetTargeting(ETargetingType NewTargetingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "ClientSetTargeting");

	Params::TslCharacter_ClientSetTargeting Parms{};

	Parms.NewTargetingType = NewTargetingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.ClientSimulationArmorDestruction
// (Net, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// EEquipSlotID                            SlotID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Impact                                                 (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ATslCharacter::ClientSimulationArmorDestruction(EEquipSlotID SlotID, const struct FTransform& Impact)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "ClientSimulationArmorDestruction");

	Params::TslCharacter_ClientSimulationArmorDestruction Parms{};

	Parms.SlotID = SlotID;
	Parms.Impact = std::move(Impact);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.ClientSoundPlay
// (Net, Native, Event, Public, NetClient)
// Parameters:
// class UAkAudioEvent*                    SoundAk                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::ClientSoundPlay(class UAkAudioEvent* SoundAk)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "ClientSoundPlay");

	Params::TslCharacter_ClientSoundPlay Parms{};

	Parms.SoundAk = SoundAk;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.DelayedFire
// (Final, Native, Protected)

void ATslCharacter::DelayedFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "DelayedFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.DisableCollision
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::DisableCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "DisableCollision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.EnableAudioTest
// (Final, Exec, Native, Public)

void ATslCharacter::EnableAudioTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "EnableAudioTest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.FindWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class ATslWeapon>           WeaponClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATslWeapon*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslWeapon* ATslCharacter::FindWeapon(TSubclassOf<class ATslWeapon> WeaponClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "FindWeapon");

	Params::TslCharacter_FindWeapon Parms{};

	Parms.WeaponClass = WeaponClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.FixupCamera
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::FixupCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "FixupCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.GetADSSocketOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector ATslCharacter::GetADSSocketOffset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetADSSocketOffset");

	Params::TslCharacter_GetADSSocketOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetBuffComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UBuffComponet*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBuffComponet* ATslCharacter::GetBuffComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetBuffComponent");

	Params::TslCharacter_GetBuffComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetCurrentSway
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ATslCharacter::GetCurrentSway()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetCurrentSway");

	Params::TslCharacter_GetCurrentSway Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetInventoryFacade
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AInventoryFacade*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AInventoryFacade* ATslCharacter::GetInventoryFacade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetInventoryFacade");

	Params::TslCharacter_GetInventoryFacade Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetReactionBone
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

FName ATslCharacter::GetReactionBone(FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetReactionBone");

	Params::TslCharacter_GetReactionBone Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetSpeedKmPerHour2D
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetSpeedKmPerHour2D()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetSpeedKmPerHour2D");

	Params::TslCharacter_GetSpeedKmPerHour2D Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetWeaponProcessor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AWeaponProcessor*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AWeaponProcessor* ATslCharacter::GetWeaponProcessor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetWeaponProcessor");

	Params::TslCharacter_GetWeaponProcessor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GiveWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class ATslWeapon>           WeaponClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::GiveWeapon(TSubclassOf<class ATslWeapon> WeaponClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GiveWeapon");

	Params::TslCharacter_GiveWeapon Parms{};

	Parms.WeaponClass = WeaponClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.HandleCapsuleCollision
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::HandleCapsuleCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "HandleCapsuleCollision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.HandleTargeting_HoldADS
// (Final, Native, Public)

void ATslCharacter::HandleTargeting_HoldADS()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "HandleTargeting_HoldADS");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.HandleVaultEnd_CP
// (Native, Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          InVaultEndVelocity                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ATslCharacter::HandleVaultEnd_CP(const struct FVector& InVaultEndVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "HandleVaultEnd_CP");

	Params::TslCharacter_HandleVaultEnd_CP Parms{};

	Parms.InVaultEndVelocity = std::move(InVaultEndVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.HasWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class ATslWeapon>           WeaponClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::HasWeapon(TSubclassOf<class ATslWeapon> WeaponClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "HasWeapon");

	Params::TslCharacter_HasWeapon Parms{};

	Parms.WeaponClass = WeaponClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.HaveNotAnyHealItemNotifyMessage
// (Event, Public, BlueprintEvent)

void ATslCharacter::HaveNotAnyHealItemNotifyMessage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "HaveNotAnyHealItemNotifyMessage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TslGame.TslCharacter.HiddenCrosshair
// (Event, Public, BlueprintEvent)

void ATslCharacter::HiddenCrosshair()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "HiddenCrosshair");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TslGame.TslCharacter.IsOutSidePlayerArea
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsOutSidePlayerArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsOutSidePlayerArea");

	Params::TslCharacter_IsOutSidePlayerArea Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.LocalMagazineDrop
// (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          InitialVelocity                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ATslCharacter::LocalMagazineDrop(const struct FVector& InitialVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "LocalMagazineDrop");

	Params::TslCharacter_LocalMagazineDrop Parms{};

	Parms.InitialVelocity = std::move(InitialVelocity);

	UObject::ProcessEvent(Func, &Parms);
}


// Function TslGame.TslCharacter.NotHaveBoostItemNotifyMessage
// (Event, Public, BlueprintEvent)

void ATslCharacter::NotHaveBoostItemNotifyMessage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "NotHaveBoostItemNotifyMessage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TslGame.TslCharacter.NotHaveHealItemNotifyMessage
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             ItemName                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ATslCharacter::NotHaveHealItemNotifyMessage(const class FText& ItemName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "NotHaveHealItemNotifyMessage");

	Params::TslCharacter_NotHaveHealItemNotifyMessage Parms{};

	Parms.ItemName = std::move(ItemName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function TslGame.TslCharacter.NotHaveThrowItemNotifyMessage
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             ItemName                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ATslCharacter::NotHaveThrowItemNotifyMessage(const class FText& ItemName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "NotHaveThrowItemNotifyMessage");

	Params::TslCharacter_NotHaveThrowItemNotifyMessage Parms{};

	Parms.ItemName = std::move(ItemName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function TslGame.TslCharacter.OnBlockingWidgetOpened
// (Final, Native, Public)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::OnBlockingWidgetOpened(class UWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnBlockingWidgetOpened");

	Params::TslCharacter_OnBlockingWidgetOpened Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.OnCancelInteractBy
// (Final, Native, Protected)
// Parameters:
// class ATslCharacter*                    OtherCharacter                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::OnCancelInteractBy(class ATslCharacter* OtherCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnCancelInteractBy");

	Params::TslCharacter_OnCancelInteractBy Parms{};

	Parms.OtherCharacter = OtherCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.OnChangeBreath
// (Final, Native, Private)
// Parameters:
// float                                   Breath                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LastBreath                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BreathMax                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::OnChangeBreath(float Breath, float LastBreath, float BreathMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnChangeBreath");

	Params::TslCharacter_OnChangeBreath Parms{};

	Parms.Breath = Breath;
	Parms.LastBreath = LastBreath;
	Parms.BreathMax = BreathMax;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.OnDecreaseMaxFlyAccerleration
// (Event, Public, BlueprintEvent)

void ATslCharacter::OnDecreaseMaxFlyAccerleration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnDecreaseMaxFlyAccerleration");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TslGame.TslCharacter.OnFreeMoveMode
// (Event, Public, BlueprintEvent)

void ATslCharacter::OnFreeMoveMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnFreeMoveMode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TslGame.TslCharacter.OnIncreaseMaxFlyAccerleration
// (Event, Public, BlueprintEvent)

void ATslCharacter::OnIncreaseMaxFlyAccerleration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnIncreaseMaxFlyAccerleration");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TslGame.TslCharacter.OnInteractBy
// (Final, Native, Protected)
// Parameters:
// class ATslCharacter*                    OtherCharacter                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::OnInteractBy(class ATslCharacter* OtherCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnInteractBy");

	Params::TslCharacter_OnInteractBy Parms{};

	Parms.OtherCharacter = OtherCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.OnInvulnerable
// (Event, Public, BlueprintEvent)

void ATslCharacter::OnInvulnerable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnInvulnerable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TslGame.TslCharacter.OnRep_AimOffsets
// (Final, Native, Protected)
// Parameters:
// struct FVector_NetQuantizeNormal        PrevAimOffsets                                         (Parm, NativeAccessSpecifierPublic)

void ATslCharacter::OnRep_AimOffsets(const struct FVector_NetQuantizeNormal& PrevAimOffsets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnRep_AimOffsets");

	Params::TslCharacter_OnRep_AimOffsets Parms{};

	Parms.PrevAimOffsets = std::move(PrevAimOffsets);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.OnRep_BoostGauge
// (Final, Native, Protected)
// Parameters:
// float                                   LastBoostGauge                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::OnRep_BoostGauge(float LastBoostGauge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnRep_BoostGauge");

	Params::TslCharacter_OnRep_BoostGauge Parms{};

	Parms.LastBoostGauge = LastBoostGauge;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.OnRep_CharacterState
// (Final, Native, Protected)

void ATslCharacter::OnRep_CharacterState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnRep_CharacterState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.OnRep_GroggyHealth
// (Final, Native, Protected)
// Parameters:
// float                                   LastGroggyHealth                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::OnRep_GroggyHealth(float LastGroggyHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnRep_GroggyHealth");

	Params::TslCharacter_OnRep_GroggyHealth Parms{};

	Parms.LastGroggyHealth = LastGroggyHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.OnRep_Health
// (Final, Native, Protected)
// Parameters:
// float                                   LastHealth                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::OnRep_Health(float LastHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnRep_Health");

	Params::TslCharacter_OnRep_Health Parms{};

	Parms.LastHealth = LastHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.OnRep_IsCrouched
// (Native, Public)

void ATslCharacter::OnRep_IsCrouched()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnRep_IsCrouched");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.OnRep_IsGroggying
// (Final, Native, Protected)

void ATslCharacter::OnRep_IsGroggying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnRep_IsGroggying");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.OnRep_LastTakeHitInfo
// (Final, Native, Protected)

void ATslCharacter::OnRep_LastTakeHitInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnRep_LastTakeHitInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.OnRep_OutSidePlayerArea
// (Final, Native, Protected)
// Parameters:
// bool                                    bLastOutSidePlayerArea                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::OnRep_OutSidePlayerArea(bool bLastOutSidePlayerArea)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnRep_OutSidePlayerArea");

	Params::TslCharacter_OnRep_OutSidePlayerArea Parms{};

	Parms.bLastOutSidePlayerArea = bLastOutSidePlayerArea;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.OnRep_ReviveCastingTime
// (Final, Native, Protected)

void ATslCharacter::OnRep_ReviveCastingTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnRep_ReviveCastingTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.OnRep_ShoesSoundType
// (Final, Native, Protected)

void ATslCharacter::OnRep_ShoesSoundType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnRep_ShoesSoundType");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.OnRep_TargetingType
// (Final, Native, Protected)

void ATslCharacter::OnRep_TargetingType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnRep_TargetingType");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.OnRep_WeaponProcessor
// (Final, Native, Protected)

void ATslCharacter::OnRep_WeaponProcessor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnRep_WeaponProcessor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.OnStartInteractBy
// (Final, Native, Protected)
// Parameters:
// class ATslCharacter*                    OtherCharacter                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::OnStartInteractBy(class ATslCharacter* OtherCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnStartInteractBy");

	Params::TslCharacter_OnStartInteractBy Parms{};

	Parms.OtherCharacter = OtherCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.OnStartTargeting_HoldADS
// (Final, Native, Public)

void ATslCharacter::OnStartTargeting_HoldADS()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnStartTargeting_HoldADS");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.OnStopFire
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::OnStopFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnStopFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.OnStopTargeting
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::OnStopTargeting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnStopTargeting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.OnStopTargeting_HoldADS
// (Final, Native, Public)

void ATslCharacter::OnStopTargeting_HoldADS()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnStopTargeting_HoldADS");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.OnTest_InspectObject
// (Event, Public, BlueprintEvent)

void ATslCharacter::OnTest_InspectObject()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnTest_InspectObject");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TslGame.TslCharacter.OnTest_SetupWeapon
// (Event, Public, BlueprintEvent)

void ATslCharacter::OnTest_SetupWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnTest_SetupWeapon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TslGame.TslCharacter.OnUnarm
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::OnUnarm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnUnarm");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.OnUnarmPad
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::OnUnarmPad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnUnarmPad");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.OnWeapon_1
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::OnWeapon_1()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnWeapon_1");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.OnWeapon_2
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::OnWeapon_2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnWeapon_2");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.OnWeapon_3
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::OnWeapon_3()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnWeapon_3");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.OnWeapon_4
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::OnWeapon_4()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnWeapon_4");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.OnWeapon_5
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::OnWeapon_5()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "OnWeapon_5");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.PickUpItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UItem*                            Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FName                             TargetContainer                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Options                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::PickUpItem(class UItem* Item, FName TargetContainer, const class FString& Options)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "PickUpItem");

	Params::TslCharacter_PickUpItem Parms{};

	Parms.Item = Item;
	Parms.TargetContainer = TargetContainer;
	Parms.Options = std::move(Options);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.PlayCameraAnim
// (Final, Native, Public)
// Parameters:
// class UCameraAnim*                      CameraAnim                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::PlayCameraAnim(class UCameraAnim* CameraAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "PlayCameraAnim");

	Params::TslCharacter_PlayCameraAnim Parms{};

	Parms.CameraAnim = CameraAnim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.PrepareParachute
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                           ParachuteType_0                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::PrepareParachute(class UClass* ParachuteType_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "PrepareParachute");

	Params::TslCharacter_PrepareParachute Parms{};

	Parms.ParachuteType_0 = ParachuteType_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.ProcessDBNO
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   GroggyHealthPercent                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::ProcessDBNO(float GroggyHealthPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "ProcessDBNO");

	Params::TslCharacter_ProcessDBNO Parms{};

	Parms.GroggyHealthPercent = GroggyHealthPercent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TslGame.TslCharacter.ProcessRevive
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   RemainGroggyHealthPercent                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::ProcessRevive(float RemainGroggyHealthPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "ProcessRevive");

	Params::TslCharacter_ProcessRevive Parms{};

	Parms.RemainGroggyHealthPercent = RemainGroggyHealthPercent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TslGame.TslCharacter.PunchStart
// (Final, Native, Public, HasOutParams)
// Parameters:
// EPunchDamageType                        PunchDamageType                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PunchDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PunchRadius                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::PunchStart(const EPunchDamageType& PunchDamageType, float PunchDistance, float PunchRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "PunchStart");

	Params::TslCharacter_PunchStart Parms{};

	Parms.PunchDamageType = PunchDamageType;
	Parms.PunchDistance = PunchDistance;
	Parms.PunchRadius = PunchRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.ReevaluaeTargetingState
// (Final, Native, Public)

void ATslCharacter::ReevaluaeTargetingState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "ReevaluaeTargetingState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.ResetParachute
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::ResetParachute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "ResetParachute");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.ResetUnarmedAttack
// (Final, Native, Public)

void ATslCharacter::ResetUnarmedAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "ResetUnarmedAttack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.RunVaultCheck_BP
// (Native, Event, Public, BlueprintEvent)

void ATslCharacter::RunVaultCheck_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "RunVaultCheck_BP");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SendSystemMessage
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ESystemMessageType                      MessageType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Message                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ATslCharacter::SendSystemMessage(ESystemMessageType MessageType, const class FText& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SendSystemMessage");

	Params::TslCharacter_SendSystemMessage Parms{};

	Parms.MessageType = MessageType;
	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.Server_CastCancelNotify
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ATslCharacter::Server_CastCancelNotify()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "Server_CastCancelNotify");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.Server_CastFinishNotify
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ATslCharacter::Server_CastFinishNotify()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "Server_CastFinishNotify");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.Server_PlayUnarmedAttack
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   AnimationIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::Server_PlayUnarmedAttack(int32 AnimationIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "Server_PlayUnarmedAttack");

	Params::TslCharacter_Server_PlayUnarmedAttack Parms{};

	Parms.AnimationIndex = AnimationIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.Server_SetAimState
// (Net, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// bool                                    IsActive                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::Server_SetAimState(bool IsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "Server_SetAimState");

	Params::TslCharacter_Server_SetAimState Parms{};

	Parms.IsActive = IsActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.Server_SetCanGroggyDamage
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    bInCanGroggyDamage                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::Server_SetCanGroggyDamage(bool bInCanGroggyDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "Server_SetCanGroggyDamage");

	Params::TslCharacter_Server_SetCanGroggyDamage Parms{};

	Parms.bInCanGroggyDamage = bInCanGroggyDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.Server_SetCastAnim
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// ECastAnim                               InCastAnim                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::Server_SetCastAnim(ECastAnim InCastAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "Server_SetCastAnim");

	Params::TslCharacter_Server_SetCastAnim Parms{};

	Parms.InCastAnim = InCastAnim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.Server_SetCoatEquipped
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    IsEquipped                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::Server_SetCoatEquipped(bool IsEquipped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "Server_SetCoatEquipped");

	Params::TslCharacter_Server_SetCoatEquipped Parms{};

	Parms.IsEquipped = IsEquipped;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.Server_SetFiringMode
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// EFiringMode                             fMode                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::Server_SetFiringMode(EFiringMode fMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "Server_SetFiringMode");

	Params::TslCharacter_Server_SetFiringMode Parms{};

	Parms.fMode = fMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.Server_SetParachuteLandingAssist
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// bool                                    bAssistActive                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::Server_SetParachuteLandingAssist(bool bAssistActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "Server_SetParachuteLandingAssist");

	Params::TslCharacter_Server_SetParachuteLandingAssist Parms{};

	Parms.bAssistActive = bAssistActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.Server_SetThrowMode
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    bNewVal                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::Server_SetThrowMode(bool bNewVal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "Server_SetThrowMode");

	Params::TslCharacter_Server_SetThrowMode Parms{};

	Parms.bNewVal = bNewVal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.Server_SetVaultCancel
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    InCancel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::Server_SetVaultCancel(bool InCancel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "Server_SetVaultCancel");

	Params::TslCharacter_Server_SetVaultCancel Parms{};

	Parms.InCancel = InCancel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.Server_SetWeaponObstruction
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// bool                                    bNewObstruction                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::Server_SetWeaponObstruction(bool bNewObstruction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "Server_SetWeaponObstruction");

	Params::TslCharacter_Server_SetWeaponObstruction Parms{};

	Parms.bNewObstruction = bNewObstruction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.Server_UnarmedHitNotify
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FHitResult                       Hit                                                    (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// EPunchDamageType                        PunchDamageType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint32                                  HitSeq                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::Server_UnarmedHitNotify(const struct FHitResult& Hit, EPunchDamageType PunchDamageType, uint32 HitSeq)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "Server_UnarmedHitNotify");

	Params::TslCharacter_Server_UnarmedHitNotify Parms{};

	Parms.Hit = std::move(Hit);
	Parms.PunchDamageType = PunchDamageType;
	Parms.HitSeq = HitSeq;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.ServerSetAimOffsets
// (Net, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// struct FVector_NetQuantizeNormal        NewAimOffsets                                          (Parm, NativeAccessSpecifierPublic)

void ATslCharacter::ServerSetAimOffsets(const struct FVector_NetQuantizeNormal& NewAimOffsets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "ServerSetAimOffsets");

	Params::TslCharacter_ServerSetAimOffsets Parms{};

	Parms.NewAimOffsets = std::move(NewAimOffsets);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.ServerSetGunDirectionSway
// (Net, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FRotator                         InGunDirectionSway                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ATslCharacter::ServerSetGunDirectionSway(const struct FRotator& InGunDirectionSway)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "ServerSetGunDirectionSway");

	Params::TslCharacter_ServerSetGunDirectionSway Parms{};

	Parms.InGunDirectionSway = std::move(InGunDirectionSway);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.ServerSetHoldingBreath
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// bool                                    bNewHoldingBreath                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::ServerSetHoldingBreath(bool bNewHoldingBreath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "ServerSetHoldingBreath");

	Params::TslCharacter_ServerSetHoldingBreath Parms{};

	Parms.bNewHoldingBreath = bNewHoldingBreath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.ServerSetPeekLeft
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// bool                                    bNewPeekLeft                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InbUseRightShoulderAiming                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::ServerSetPeekLeft(bool bNewPeekLeft, bool InbUseRightShoulderAiming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "ServerSetPeekLeft");

	Params::TslCharacter_ServerSetPeekLeft Parms{};

	Parms.bNewPeekLeft = bNewPeekLeft;
	Parms.InbUseRightShoulderAiming = InbUseRightShoulderAiming;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.ServerSetPeekRight
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// bool                                    bNewPeekRight                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InbUseRightShoulderAiming                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::ServerSetPeekRight(bool bNewPeekRight, bool InbUseRightShoulderAiming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "ServerSetPeekRight");

	Params::TslCharacter_ServerSetPeekRight Parms{};

	Parms.bNewPeekRight = bNewPeekRight;
	Parms.InbUseRightShoulderAiming = InbUseRightShoulderAiming;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.ServerSetRolling
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// bool                                    bNewRolling                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsLeft                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::ServerSetRolling(bool bNewRolling, bool bIsLeft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "ServerSetRolling");

	Params::TslCharacter_ServerSetRolling Parms{};

	Parms.bNewRolling = bNewRolling;
	Parms.bIsLeft = bIsLeft;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.ServerSetRunning
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// bool                                    bNewRunning                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::ServerSetRunning(bool bNewRunning)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "ServerSetRunning");

	Params::TslCharacter_ServerSetRunning Parms{};

	Parms.bNewRunning = bNewRunning;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.ServerSetSprinting
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// bool                                    bNewSprinting                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::ServerSetSprinting(bool bNewSprinting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "ServerSetSprinting");

	Params::TslCharacter_ServerSetSprinting Parms{};

	Parms.bNewSprinting = bNewSprinting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.ServerSetSprintingAuto
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// bool                                    bNewSprintingAuto                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::ServerSetSprintingAuto(bool bNewSprintingAuto)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "ServerSetSprintingAuto");

	Params::TslCharacter_ServerSetSprintingAuto Parms{};

	Parms.bNewSprintingAuto = bNewSprintingAuto;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.ServerSetTargeting
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// ETargetingType                          NewTargetingType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::ServerSetTargeting(ETargetingType NewTargetingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "ServerSetTargeting");

	Params::TslCharacter_ServerSetTargeting Parms{};

	Parms.NewTargetingType = NewTargetingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SetAccessorySlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTslAccessoryComponent*           AccessoryComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAccessorySlot                          Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::SetAccessorySlot(class UTslAccessoryComponent* AccessoryComponent, EAccessorySlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetAccessorySlot");

	Params::TslCharacter_SetAccessorySlot Parms{};

	Parms.AccessoryComponent = AccessoryComponent;
	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SetAccessorySlot_Melee
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTslAccessoryComponent*           AccessoryComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::SetAccessorySlot_Melee(class UTslAccessoryComponent* AccessoryComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetAccessorySlot_Melee");

	Params::TslCharacter_SetAccessorySlot_Melee Parms{};

	Parms.AccessoryComponent = AccessoryComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SetAccessorySlot_Primary
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTslAccessoryComponent*           AccessoryComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::SetAccessorySlot_Primary(class UTslAccessoryComponent* AccessoryComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetAccessorySlot_Primary");

	Params::TslCharacter_SetAccessorySlot_Primary Parms{};

	Parms.AccessoryComponent = AccessoryComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SetAccessorySlot_Secondary
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTslAccessoryComponent*           AccessoryComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::SetAccessorySlot_Secondary(class UTslAccessoryComponent* AccessoryComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetAccessorySlot_Secondary");

	Params::TslCharacter_SetAccessorySlot_Secondary Parms{};

	Parms.AccessoryComponent = AccessoryComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SetAccessorySlot_SideArm
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTslAccessoryComponent*           AccessoryComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::SetAccessorySlot_SideArm(class UTslAccessoryComponent* AccessoryComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetAccessorySlot_SideArm");

	Params::TslCharacter_SetAccessorySlot_SideArm Parms{};

	Parms.AccessoryComponent = AccessoryComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SetAccessorySlot_Thrown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTslAccessoryComponent*           AccessoryComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::SetAccessorySlot_Thrown(class UTslAccessoryComponent* AccessoryComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetAccessorySlot_Thrown");

	Params::TslCharacter_SetAccessorySlot_Thrown Parms{};

	Parms.AccessoryComponent = AccessoryComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SetActiveRagdoll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsActive                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::SetActiveRagdoll(bool bIsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetActiveRagdoll");

	Params::TslCharacter_SetActiveRagdoll Parms{};

	Parms.bIsActive = bIsActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SetADSSocketOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewOffset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ATslCharacter::SetADSSocketOffset(const struct FVector& NewOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetADSSocketOffset");

	Params::TslCharacter_SetADSSocketOffset Parms{};

	Parms.NewOffset = std::move(NewOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SetAimStateActive
// (Final, Native, Protected)
// Parameters:
// bool                                    IsActive                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::SetAimStateActive(bool IsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetAimStateActive");

	Params::TslCharacter_SetAimStateActive Parms{};

	Parms.IsActive = IsActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SetAnimationAkRTPC
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           RTPCName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RTPCValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::SetAnimationAkRTPC(const class FString& RTPCName, float RTPCValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetAnimationAkRTPC");

	Params::TslCharacter_SetAnimationAkRTPC Parms{};

	Parms.RTPCName = std::move(RTPCName);
	Parms.RTPCValue = RTPCValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SetAnimationAkSwitch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           SwitchGroup                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SwitchState                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::SetAnimationAkSwitch(const class FString& SwitchGroup, const class FString& SwitchState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetAnimationAkSwitch");

	Params::TslCharacter_SetAnimationAkSwitch Parms{};

	Parms.SwitchGroup = std::move(SwitchGroup);
	Parms.SwitchState = std::move(SwitchState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SetBoostGauge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewBoostGauge                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::SetBoostGauge(float NewBoostGauge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetBoostGauge");

	Params::TslCharacter_SetBoostGauge Parms{};

	Parms.NewBoostGauge = NewBoostGauge;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SetBuffFinalSpreadFactor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FinalSpreadFactor                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::SetBuffFinalSpreadFactor(float FinalSpreadFactor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetBuffFinalSpreadFactor");

	Params::TslCharacter_SetBuffFinalSpreadFactor Parms{};

	Parms.FinalSpreadFactor = FinalSpreadFactor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SetBulletSpawnOverride
// (Final, Native, Public)
// Parameters:
// bool                                    InOverride                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::SetBulletSpawnOverride(bool InOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetBulletSpawnOverride");

	Params::TslCharacter_SetBulletSpawnOverride Parms{};

	Parms.InOverride = InOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SetCanGroggyDamage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInCanGroggyDamage                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::SetCanGroggyDamage(bool bInCanGroggyDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetCanGroggyDamage");

	Params::TslCharacter_SetCanGroggyDamage Parms{};

	Parms.bInCanGroggyDamage = bInCanGroggyDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SetCharacterVaultingData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InVaultTimer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InIsVaulting                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InIsClimbing                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InEndVaultToFall                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDirection                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::SetCharacterVaultingData(float InVaultTimer, bool InIsVaulting, bool InIsClimbing, bool InEndVaultToFall, float InDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetCharacterVaultingData");

	Params::TslCharacter_SetCharacterVaultingData Parms{};

	Parms.InVaultTimer = InVaultTimer;
	Parms.InIsVaulting = InIsVaulting;
	Parms.InIsClimbing = InIsClimbing;
	Parms.InEndVaultToFall = InEndVaultToFall;
	Parms.InDirection = InDirection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SetCustomDepth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bOn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::SetCustomDepth(bool bOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetCustomDepth");

	Params::TslCharacter_SetCustomDepth Parms{};

	Parms.bOn = bOn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SetJumpStartLocationAndFallheight
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          JumpStartLoc                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   FallHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::SetJumpStartLocationAndFallheight(const struct FVector& JumpStartLoc, float FallHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetJumpStartLocationAndFallheight");

	Params::TslCharacter_SetJumpStartLocationAndFallheight Parms{};

	Parms.JumpStartLoc = std::move(JumpStartLoc);
	Parms.FallHeight = FallHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SetLaunchEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FAttackId                        AttackId                                               (Parm, NativeAccessSpecifierPublic)
// class ATslPlayerState*                  InPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Causer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::SetLaunchEvent(const struct FAttackId& AttackId, class ATslPlayerState* InPlayerState, class AActor* Causer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetLaunchEvent");

	Params::TslCharacter_SetLaunchEvent Parms{};

	Parms.AttackId = std::move(AttackId);
	Parms.InPlayerState = InPlayerState;
	Parms.Causer = Causer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SetMovementEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsEnabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::SetMovementEnabled(bool IsEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetMovementEnabled");

	Params::TslCharacter_SetMovementEnabled Parms{};

	Parms.IsEnabled = IsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SetOutSidePlayerArea
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewOutSidePlayerArea                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::SetOutSidePlayerArea(bool bNewOutSidePlayerArea)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetOutSidePlayerArea");

	Params::TslCharacter_SetOutSidePlayerArea Parms{};

	Parms.bNewOutSidePlayerArea = bNewOutSidePlayerArea;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SetParachuteLandingAssist
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bAssistActive                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::SetParachuteLandingAssist(bool bAssistActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetParachuteLandingAssist");

	Params::TslCharacter_SetParachuteLandingAssist Parms{};

	Parms.bAssistActive = bAssistActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SetServerVaultFinished
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InFinished                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::SetServerVaultFinished(bool InFinished)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetServerVaultFinished");

	Params::TslCharacter_SetServerVaultFinished Parms{};

	Parms.InFinished = InFinished;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SetSwayDebuffParameters
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   SwaySpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SwayVerticalMultiplier                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SwayHorizontalMultiplier                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::SetSwayDebuffParameters(float SwaySpeed, float SwayVerticalMultiplier, float SwayHorizontalMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetSwayDebuffParameters");

	Params::TslCharacter_SetSwayDebuffParameters Parms{};

	Parms.SwaySpeed = SwaySpeed;
	Parms.SwayVerticalMultiplier = SwayVerticalMultiplier;
	Parms.SwayHorizontalMultiplier = SwayHorizontalMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SetTickOptimization_Actor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bActivate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::SetTickOptimization_Actor(bool bActivate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetTickOptimization_Actor");

	Params::TslCharacter_SetTickOptimization_Actor Parms{};

	Parms.bActivate = bActivate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SetTickOptimization_Anim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bActivate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::SetTickOptimization_Anim(bool bActivate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetTickOptimization_Anim");

	Params::TslCharacter_SetTickOptimization_Anim Parms{};

	Parms.bActivate = bActivate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SetTickOptimization_Movement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bActivate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::SetTickOptimization_Movement(bool bActivate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetTickOptimization_Movement");

	Params::TslCharacter_SetTickOptimization_Movement Parms{};

	Parms.bActivate = bActivate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SetTPPSpringarmOffset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   VerticalOffset                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::SetTPPSpringarmOffset(float VerticalOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetTPPSpringarmOffset");

	Params::TslCharacter_SetTPPSpringarmOffset Parms{};

	Parms.VerticalOffset = VerticalOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SetupWeaponBlueprint
// (Event, Public, BlueprintEvent)

void ATslCharacter::SetupWeaponBlueprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetupWeaponBlueprint");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TslGame.TslCharacter.SetWeaponInertia
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         InInertia                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ATslCharacter::SetWeaponInertia(const struct FRotator& InInertia)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetWeaponInertia");

	Params::TslCharacter_SetWeaponInertia Parms{};

	Parms.InInertia = std::move(InInertia);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SetWorldTransformIdentity
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::SetWorldTransformIdentity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SetWorldTransformIdentity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.ShowDynamicCrosshair
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::ShowDynamicCrosshair(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "ShowDynamicCrosshair");

	Params::TslCharacter_ShowDynamicCrosshair Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SimulateHeadShot
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FTransform                       SpawnTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       ImpactTransform                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ATslCharacter::SimulateHeadShot(const struct FTransform& SpawnTransform, const struct FTransform& ImpactTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SimulateHeadShot");

	Params::TslCharacter_SimulateHeadShot Parms{};

	Parms.SpawnTransform = std::move(SpawnTransform);
	Parms.ImpactTransform = std::move(ImpactTransform);

	UObject::ProcessEvent(Func, &Parms);
}


// Function TslGame.TslCharacter.SimulatePhysicalHitRecovery
// (Final, Native, Protected)

void ATslCharacter::SimulatePhysicalHitRecovery()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SimulatePhysicalHitRecovery");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SpawnBulletPassByEffect
// (Native, Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   BulletVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::SpawnBulletPassByEffect(const struct FVector& Location, float BulletVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SpawnBulletPassByEffect");

	Params::TslCharacter_SpawnBulletPassByEffect Parms{};

	Parms.Location = std::move(Location);
	Parms.BulletVelocity = BulletVelocity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SpawnPunchImpact
// (Final, Native, Public, HasDefaults)
// Parameters:
// struct FVector                          InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         InRotation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ATslCharacter::SpawnPunchImpact(const struct FVector& InLocation, const struct FRotator& InRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SpawnPunchImpact");

	Params::TslCharacter_SpawnPunchImpact Parms{};

	Parms.InLocation = std::move(InLocation);
	Parms.InRotation = std::move(InRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.SpawnPunchImpact_Reliable
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// struct FVector                          InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         InRotation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ATslCharacter::SpawnPunchImpact_Reliable(const struct FVector& InLocation, const struct FRotator& InRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "SpawnPunchImpact_Reliable");

	Params::TslCharacter_SpawnPunchImpact_Reliable Parms{};

	Parms.InLocation = std::move(InLocation);
	Parms.InRotation = std::move(InRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.STAT_TickBegin
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::STAT_TickBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "STAT_TickBegin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.STAT_TickEnd
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::STAT_TickEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "STAT_TickEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.StopAllAnimMontages
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::StopAllAnimMontages()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "StopAllAnimMontages");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.TickOptimization_Eval
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::TickOptimization_Eval()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "TickOptimization_Eval");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.ToggleAnimDynamics
// (Final, Exec, Native, Public)

void ATslCharacter::ToggleAnimDynamics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "ToggleAnimDynamics");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.UnBindCallbackToHUD
// (Final, Native, Public)
// Parameters:
// class ATslPlayerController*             InController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacter::UnBindCallbackToHUD(class ATslPlayerController* InController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "UnBindCallbackToHUD");

	Params::TslCharacter_UnBindCallbackToHUD Parms{};

	Parms.InController = InController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.UpdateWeaponAttachPoint
// (Final, Native, Public, BlueprintCallable)

void ATslCharacter::UpdateWeaponAttachPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "UpdateWeaponAttachPoint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacter.Anim_IsMagazineVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::Anim_IsMagazineVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "Anim_IsMagazineVisible");

	Params::TslCharacter_Anim_IsMagazineVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.CanSwim
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::CanSwim() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "CanSwim");

	Params::TslCharacter_CanSwim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetAccessorySlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAccessorySlot                          Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTslAccessoryComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTslAccessoryComponent* ATslCharacter::GetAccessorySlot(EAccessorySlot Slot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetAccessorySlot");

	Params::TslCharacter_GetAccessorySlot Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetActiveCamera
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCameraComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraComponent* ATslCharacter::GetActiveCamera() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetActiveCamera");

	Params::TslCharacter_GetActiveCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetActorCanInteract
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ATslCharacter::GetActorCanInteract() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetActorCanInteract");

	Params::TslCharacter_GetActorCanInteract Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetAimOffsets
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ATslCharacter::GetAimOffsets() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetAimOffsets");

	Params::TslCharacter_GetAimOffsets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetAimStateAlpha
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetAimStateAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetAimStateAlpha");

	Params::TslCharacter_GetAimStateAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetAimStateTimer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetAimStateTimer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetAimStateTimer");

	Params::TslCharacter_GetAimStateTimer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetAnimStance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAnimStance                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAnimStance ATslCharacter::GetAnimStance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetAnimStance");

	Params::TslCharacter_GetAnimStance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetAnimWeaponType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAnimWeaponType                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAnimWeaponType ATslCharacter::GetAnimWeaponType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetAnimWeaponType");

	Params::TslCharacter_GetAnimWeaponType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetBreathComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCharacterBreathComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCharacterBreathComponent* ATslCharacter::GetBreathComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetBreathComponent");

	Params::TslCharacter_GetBreathComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetBulletSpawnOverride
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::GetBulletSpawnOverride() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetBulletSpawnOverride");

	Params::TslCharacter_GetBulletSpawnOverride Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetCameraAnimOverrideAlpha
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetCameraAnimOverrideAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetCameraAnimOverrideAlpha");

	Params::TslCharacter_GetCameraAnimOverrideAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetCameraDOF
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector ATslCharacter::GetCameraDOF() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetCameraDOF");

	Params::TslCharacter_GetCameraDOF Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetCastObject
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* ATslCharacter::GetCastObject() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetCastObject");

	Params::TslCharacter_GetCastObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetComponentCanInteract
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TScriptInterface<class IInteractionInterface>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

TScriptInterface<class IInteractionInterface> ATslCharacter::GetComponentCanInteract() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetComponentCanInteract");

	Params::TslCharacter_GetComponentCanInteract Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetCtrlShortCutOnOff
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::GetCtrlShortCutOnOff() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetCtrlShortCutOnOff");

	Params::TslCharacter_GetCtrlShortCutOnOff Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetCurrentHeightFromWaterFloor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetCurrentHeightFromWaterFloor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetCurrentHeightFromWaterFloor");

	Params::TslCharacter_GetCurrentHeightFromWaterFloor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetCurrentMagazineLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform ATslCharacter::GetCurrentMagazineLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetCurrentMagazineLocation");

	Params::TslCharacter_GetCurrentMagazineLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetCurrentMagazineMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UStaticMesh*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMesh* ATslCharacter::GetCurrentMagazineMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetCurrentMagazineMesh");

	Params::TslCharacter_GetCurrentMagazineMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetCurrentWaterDepth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetCurrentWaterDepth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetCurrentWaterDepth");

	Params::TslCharacter_GetCurrentWaterDepth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetCurrentWaterSurfaceBaseZ
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetCurrentWaterSurfaceBaseZ() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetCurrentWaterSurfaceBaseZ");

	Params::TslCharacter_GetCurrentWaterSurfaceBaseZ Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetCurrentWaterSurfaceZ
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetCurrentWaterSurfaceZ() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetCurrentWaterSurfaceZ");

	Params::TslCharacter_GetCurrentWaterSurfaceZ Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetCurrentWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslWeapon* ATslCharacter::GetCurrentWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetCurrentWeapon");

	Params::TslCharacter_GetCurrentWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetDesiredRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ATslCharacter::GetDesiredRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetDesiredRotation");

	Params::TslCharacter_GetDesiredRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetDirectionalSpeedModifier
// (Final, Native, Public, Const)
// Parameters:
// EMovementType                           StanceType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetDirectionalSpeedModifier(EMovementType StanceType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetDirectionalSpeedModifier");

	Params::TslCharacter_GetDirectionalSpeedModifier Parms{};

	Parms.StanceType = StanceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetDirectionString
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ATslCharacter::GetDirectionString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetDirectionString");

	Params::TslCharacter_GetDirectionString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetDropPackageType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class AItemPackage>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AItemPackage> ATslCharacter::GetDropPackageType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetDropPackageType");

	Params::TslCharacter_GetDropPackageType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetDynamicCrosshairHidden
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::GetDynamicCrosshairHidden() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetDynamicCrosshairHidden");

	Params::TslCharacter_GetDynamicCrosshairHidden Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetFreelookDeltaRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ATslCharacter::GetFreelookDeltaRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetFreelookDeltaRotation");

	Params::TslCharacter_GetFreelookDeltaRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetFreelookSavedRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ATslCharacter::GetFreelookSavedRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetFreelookSavedRotation");

	Params::TslCharacter_GetFreelookSavedRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetIndoorFactor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetIndoorFactor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetIndoorFactor");

	Params::TslCharacter_GetIndoorFactor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetInteractionString
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ATslCharacter::GetInteractionString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetInteractionString");

	Params::TslCharacter_GetInteractionString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetInteractObjectLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector ATslCharacter::GetInteractObjectLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetInteractObjectLocation");

	Params::TslCharacter_GetInteractObjectLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetLastMoveRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ATslCharacter::GetLastMoveRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetLastMoveRotation");

	Params::TslCharacter_GetLastMoveRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetLeanLeftAlpha
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetLeanLeftAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetLeanLeftAlpha");

	Params::TslCharacter_GetLeanLeftAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetLeanRightAlpha
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetLeanRightAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetLeanRightAlpha");

	Params::TslCharacter_GetLeanRightAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetLocationString
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ATslCharacter::GetLocationString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetLocationString");

	Params::TslCharacter_GetLocationString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetMaxGroundSpeedOnSlope
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetMaxGroundSpeedOnSlope() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetMaxGroundSpeedOnSlope");

	Params::TslCharacter_GetMaxGroundSpeedOnSlope Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetMaxSprintSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetMaxSprintSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetMaxSprintSpeed");

	Params::TslCharacter_GetMaxSprintSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetObjectCanInteract
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TScriptInterface<class IInteractionInterface>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

TScriptInterface<class IInteractionInterface> ATslCharacter::GetObjectCanInteract() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetObjectCanInteract");

	Params::TslCharacter_GetObjectCanInteract Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetParachute
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AParachuteVehicle*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AParachuteVehicle* ATslCharacter::GetParachute() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetParachute");

	Params::TslCharacter_GetParachute Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetParachuteLandingAssist
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::GetParachuteLandingAssist() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetParachuteLandingAssist");

	Params::TslCharacter_GetParachuteLandingAssist Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetPlayerName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ATslCharacter::GetPlayerName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetPlayerName");

	Params::TslCharacter_GetPlayerName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetRunningSpeedModifier_Crouch
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetRunningSpeedModifier_Crouch() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetRunningSpeedModifier_Crouch");

	Params::TslCharacter_GetRunningSpeedModifier_Crouch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetRunningSpeedModifier_Prone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetRunningSpeedModifier_Prone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetRunningSpeedModifier_Prone");

	Params::TslCharacter_GetRunningSpeedModifier_Prone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetRunningSpeedModifier_Stand
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetRunningSpeedModifier_Stand() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetRunningSpeedModifier_Stand");

	Params::TslCharacter_GetRunningSpeedModifier_Stand Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetServerVaultFinished
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::GetServerVaultFinished() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetServerVaultFinished");

	Params::TslCharacter_GetServerVaultFinished Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetShortPlayerName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ATslCharacter::GetShortPlayerName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetShortPlayerName");

	Params::TslCharacter_GetShortPlayerName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetSpeedModifierByWeaponClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetSpeedModifierByWeaponClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetSpeedModifierByWeaponClass");

	Params::TslCharacter_GetSpeedModifierByWeaponClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetSprintCurrentValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetSprintCurrentValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetSprintCurrentValue");

	Params::TslCharacter_GetSprintCurrentValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetSprintingSpeedModifier_Crouch
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetSprintingSpeedModifier_Crouch() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetSprintingSpeedModifier_Crouch");

	Params::TslCharacter_GetSprintingSpeedModifier_Crouch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetSprintingSpeedModifier_Prone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetSprintingSpeedModifier_Prone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetSprintingSpeedModifier_Prone");

	Params::TslCharacter_GetSprintingSpeedModifier_Prone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetSprintingSpeedModifier_Stand
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetSprintingSpeedModifier_Stand() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetSprintingSpeedModifier_Stand");

	Params::TslCharacter_GetSprintingSpeedModifier_Stand Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetStance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EStanceMode                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EStanceMode ATslCharacter::GetStance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetStance");

	Params::TslCharacter_GetStance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetTargetingSpeedModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetTargetingSpeedModifier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetTargetingSpeedModifier");

	Params::TslCharacter_GetTargetingSpeedModifier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATeam*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATeam* ATslCharacter::GetTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetTeam");

	Params::TslCharacter_GetTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetTPPCameraCurve
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCurveFloat*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCurveFloat* ATslCharacter::GetTPPCameraCurve() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetTPPCameraCurve");

	Params::TslCharacter_GetTPPCameraCurve Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetTPPSpringarmOffset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetTPPSpringarmOffset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetTPPSpringarmOffset");

	Params::TslCharacter_GetTPPSpringarmOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetTslCharacterMovement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTslCharacterMovement*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTslCharacterMovement* ATslCharacter::GetTslCharacterMovement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetTslCharacterMovement");

	Params::TslCharacter_GetTslCharacterMovement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetTslPlayerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslPlayerController*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslPlayerController* ATslCharacter::GetTslPlayerController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetTslPlayerController");

	Params::TslCharacter_GetTslPlayerController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetTslPlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslPlayerState*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslPlayerState* ATslCharacter::GetTslPlayerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetTslPlayerState");

	Params::TslCharacter_GetTslPlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetVaultingDataByEnum
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EVaultAnimType                          InVaultType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVaultingData*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVaultingData* ATslCharacter::GetVaultingDataByEnum(EVaultAnimType InVaultType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetVaultingDataByEnum");

	Params::TslCharacter_GetVaultingDataByEnum Parms{};

	Parms.InVaultType = InVaultType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetVaultingDirection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetVaultingDirection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetVaultingDirection");

	Params::TslCharacter_GetVaultingDirection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetVaultTimer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetVaultTimer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetVaultTimer");

	Params::TslCharacter_GetVaultTimer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetVehicleInterface
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TScriptInterface<class ITslVehicleInterface>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

TScriptInterface<class ITslVehicleInterface> ATslCharacter::GetVehicleInterface() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetVehicleInterface");

	Params::TslCharacter_GetVehicleInterface Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetVehiclePawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* ATslCharacter::GetVehiclePawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetVehiclePawn");

	Params::TslCharacter_GetVehiclePawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetVehicleRiderComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UVehicleRiderComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVehicleRiderComponent* ATslCharacter::GetVehicleRiderComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetVehicleRiderComponent");

	Params::TslCharacter_GetVehicleRiderComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetVehicleSeat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UVehicleSeatInteractionComponent* ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVehicleSeatInteractionComponent* ATslCharacter::GetVehicleSeat() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetVehicleSeat");

	Params::TslCharacter_GetVehicleSeat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetVehicleSeatComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTslVehicleSeatComponent*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTslVehicleSeatComponent* ATslCharacter::GetVehicleSeatComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetVehicleSeatComponent");

	Params::TslCharacter_GetVehicleSeatComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetWantsToJump
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::GetWantsToJump() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetWantsToJump");

	Params::TslCharacter_GetWantsToJump Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslWeapon* ATslCharacter::GetWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetWeapon");

	Params::TslCharacter_GetWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetWeaponADSTimeModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetWeaponADSTimeModifier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetWeaponADSTimeModifier");

	Params::TslCharacter_GetWeaponADSTimeModifier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetWeaponGun
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon_Gun*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslWeapon_Gun* ATslCharacter::GetWeaponGun() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetWeaponGun");

	Params::TslCharacter_GetWeaponGun Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetWeaponGunCollisionAlpha
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetWeaponGunCollisionAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetWeaponGunCollisionAlpha");

	Params::TslCharacter_GetWeaponGunCollisionAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetWeaponHandIK_Left
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform ATslCharacter::GetWeaponHandIK_Left() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetWeaponHandIK_Left");

	Params::TslCharacter_GetWeaponHandIK_Left Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetWeaponHandIK_Right
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform ATslCharacter::GetWeaponHandIK_Right() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetWeaponHandIK_Right");

	Params::TslCharacter_GetWeaponHandIK_Right Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetWeaponInertia
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ATslCharacter::GetWeaponInertia() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetWeaponInertia");

	Params::TslCharacter_GetWeaponInertia Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetWeaponLeftHandIKTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform ATslCharacter::GetWeaponLeftHandIKTransform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetWeaponLeftHandIKTransform");

	Params::TslCharacter_GetWeaponLeftHandIKTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetWeaponMovementModifierAim
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetWeaponMovementModifierAim() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetWeaponMovementModifierAim");

	Params::TslCharacter_GetWeaponMovementModifierAim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetWeaponMovementModifierScope
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetWeaponMovementModifierScope() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetWeaponMovementModifierScope");

	Params::TslCharacter_GetWeaponMovementModifierScope Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetWeaponObstructionRemote
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::GetWeaponObstructionRemote() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetWeaponObstructionRemote");

	Params::TslCharacter_GetWeaponObstructionRemote Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetWeaponReloadPlayRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslCharacter::GetWeaponReloadPlayRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetWeaponReloadPlayRate");

	Params::TslCharacter_GetWeaponReloadPlayRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.GetWeaponThrowable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon_Throwable*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslWeapon_Throwable* ATslCharacter::GetWeaponThrowable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "GetWeaponThrowable");

	Params::TslCharacter_GetWeaponThrowable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.HasWeaponLeftHandIKSocket
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::HasWeaponLeftHandIKSocket() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "HasWeaponLeftHandIKSocket");

	Params::TslCharacter_HasWeaponLeftHandIKSocket Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsActiveRagdoll
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsActiveRagdoll() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsActiveRagdoll");

	Params::TslCharacter_IsActiveRagdoll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsAlive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsAlive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsAlive");

	Params::TslCharacter_IsAlive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsAnimDynamicsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsAnimDynamicsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsAnimDynamicsEnabled");

	Params::TslCharacter_IsAnimDynamicsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsAttacked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsAttacked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsAttacked");

	Params::TslCharacter_IsAttacked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsAudioTestEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsAudioTestEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsAudioTestEnabled");

	Params::TslCharacter_IsAudioTestEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsCameraUnderwater
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsCameraUnderwater() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsCameraUnderwater");

	Params::TslCharacter_IsCameraUnderwater Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsCasting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsCasting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsCasting");

	Params::TslCharacter_IsCasting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsCoatEquipped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsCoatEquipped() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsCoatEquipped");

	Params::TslCharacter_IsCoatEquipped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsCycleInProgress
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsCycleInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsCycleInProgress");

	Params::TslCharacter_IsCycleInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsDying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsDying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsDying");

	Params::TslCharacter_IsDying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsFallingFromHighAltitude
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsFallingFromHighAltitude() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsFallingFromHighAltitude");

	Params::TslCharacter_IsFallingFromHighAltitude Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsFallingWithParachute
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsFallingWithParachute() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsFallingWithParachute");

	Params::TslCharacter_IsFallingWithParachute Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsFiring
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsFiring() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsFiring");

	Params::TslCharacter_IsFiring Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsFirstPerson
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsFirstPerson() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsFirstPerson");

	Params::TslCharacter_IsFirstPerson Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsFloating
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsFloating() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsFloating");

	Params::TslCharacter_IsFloating Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsForcedProneAfterFall
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsForcedProneAfterFall() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsForcedProneAfterFall");

	Params::TslCharacter_IsForcedProneAfterFall Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsForceRotation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsForceRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsForceRotation");

	Params::TslCharacter_IsForceRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsForcingFall
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsForcingFall() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsForcingFall");

	Params::TslCharacter_IsForcingFall Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsFreelooking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsFreelooking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsFreelooking");

	Params::TslCharacter_IsFreelooking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsGroggying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsGroggying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsGroggying");

	Params::TslCharacter_IsGroggying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsHipped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsHipped() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsHipped");

	Params::TslCharacter_IsHipped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsHitted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsHitted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsHitted");

	Params::TslCharacter_IsHitted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsHoldingBreath
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsHoldingBreath() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsHoldingBreath");

	Params::TslCharacter_IsHoldingBreath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsInAircraft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsInAircraft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsInAircraft");

	Params::TslCharacter_IsInAircraft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsIndoor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsIndoor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsIndoor");

	Params::TslCharacter_IsIndoor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsInteracting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsInteracting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsInteracting");

	Params::TslCharacter_IsInteracting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsInVehicle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsInVehicle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsInVehicle");

	Params::TslCharacter_IsInVehicle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsInWaterVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsInWaterVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsInWaterVolume");

	Params::TslCharacter_IsInWaterVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsLocalOrSpectating
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsLocalOrSpectating() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsLocalOrSpectating");

	Params::TslCharacter_IsLocalOrSpectating Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsMagazineGunAttached
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsMagazineGunAttached() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsMagazineGunAttached");

	Params::TslCharacter_IsMagazineGunAttached Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsMagazineHandAttached
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsMagazineHandAttached() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsMagazineHandAttached");

	Params::TslCharacter_IsMagazineHandAttached Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsMeleeAttacking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsMeleeAttacking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsMeleeAttacking");

	Params::TslCharacter_IsMeleeAttacking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsMouseUse
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsMouseUse() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsMouseUse");

	Params::TslCharacter_IsMouseUse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsMoving
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsMoving() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsMoving");

	Params::TslCharacter_IsMoving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsParachuting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsParachuting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsParachuting");

	Params::TslCharacter_IsParachuting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsPeekLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsPeekLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsPeekLeft");

	Params::TslCharacter_IsPeekLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsPeekRight
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsPeekRight() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsPeekRight");

	Params::TslCharacter_IsPeekRight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsPlayingPickUpAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsPlayingPickUpAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsPlayingPickUpAnimation");

	Params::TslCharacter_IsPlayingPickUpAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsQuickThrowHigh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsQuickThrowHigh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsQuickThrowHigh");

	Params::TslCharacter_IsQuickThrowHigh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsQuitter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsQuitter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsQuitter");

	Params::TslCharacter_IsQuitter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsReviving
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsReviving() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsReviving");

	Params::TslCharacter_IsReviving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsRolling
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsRolling() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsRolling");

	Params::TslCharacter_IsRolling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsRunning
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsRunning() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsRunning");

	Params::TslCharacter_IsRunning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsScoping
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsScoping() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsScoping");

	Params::TslCharacter_IsScoping Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsSitting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsSitting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsSitting");

	Params::TslCharacter_IsSitting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsSpectatingCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsSpectatingCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsSpectatingCharacter");

	Params::TslCharacter_IsSpectatingCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsSprinting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsSprinting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsSprinting");

	Params::TslCharacter_IsSprinting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsSwimming
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsSwimming() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsSwimming");

	Params::TslCharacter_IsSwimming Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsTargeting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsTargeting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsTargeting");

	Params::TslCharacter_IsTargeting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsTeamMatch
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsTeamMatch() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsTeamMatch");

	Params::TslCharacter_IsTeamMatch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsUnderRoof
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsUnderRoof() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsUnderRoof");

	Params::TslCharacter_IsUnderRoof Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsUnderwater
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsUnderwater() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsUnderwater");

	Params::TslCharacter_IsUnderwater Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsUpperCollision
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsUpperCollision() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsUpperCollision");

	Params::TslCharacter_IsUpperCollision Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsUsingRightShoulderAiming
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsUsingRightShoulderAiming() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsUsingRightShoulderAiming");

	Params::TslCharacter_IsUsingRightShoulderAiming Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsVaultCancelled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsVaultCancelled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsVaultCancelled");

	Params::TslCharacter_IsVaultCancelled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsVaulting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsVaulting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsVaulting");

	Params::TslCharacter_IsVaulting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsVaultingDebugEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsVaultingDebugEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsVaultingDebugEnabled");

	Params::TslCharacter_IsVaultingDebugEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsVaultingEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsVaultingEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsVaultingEnabled");

	Params::TslCharacter_IsVaultingEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsVehicleDriver
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsVehicleDriver() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsVehicleDriver");

	Params::TslCharacter_IsVehicleDriver Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsVehiclePassenger
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsVehiclePassenger() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsVehiclePassenger");

	Params::TslCharacter_IsVehiclePassenger Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsWeaponArmed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsWeaponArmed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsWeaponArmed");

	Params::TslCharacter_IsWeaponArmed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsWeaponUsingHighMagnificationScope
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsWeaponUsingHighMagnificationScope() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsWeaponUsingHighMagnificationScope");

	Params::TslCharacter_IsWeaponUsingHighMagnificationScope Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsZombie
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsZombie() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsZombie");

	Params::TslCharacter_IsZombie Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.IsZooming
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::IsZooming() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "IsZooming");

	Params::TslCharacter_IsZooming Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.TickOptimization_IsOverMinimumDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::TickOptimization_IsOverMinimumDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "TickOptimization_IsOverMinimumDistance");

	Params::TslCharacter_TickOptimization_IsOverMinimumDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.TickOptimization_ShouldRunAnimUpdate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::TickOptimization_ShouldRunAnimUpdate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "TickOptimization_ShouldRunAnimUpdate");

	Params::TslCharacter_TickOptimization_ShouldRunAnimUpdate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacter.TickOptimization_ShouldRunMovementUpdate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslCharacter::TickOptimization_ShouldRunMovementUpdate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacter", "TickOptimization_ShouldRunMovementUpdate");

	Params::TslCharacter_TickOptimization_ShouldRunMovementUpdate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.ObserverTagWidget.SetCharacterIconPosition_UC
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector2D                        Pos_UC                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    IsHidden                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObserverTagWidget::SetCharacterIconPosition_UC(const struct FVector2D& Pos_UC, bool IsHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObserverTagWidget", "SetCharacterIconPosition_UC");

	Params::ObserverTagWidget_SetCharacterIconPosition_UC Parms{};

	Parms.Pos_UC = std::move(Pos_UC);
	Parms.IsHidden = IsHidden;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TslGame.ObserverTagWidget.IsLastSpectatedCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UObserverTagWidget::IsLastSpectatedCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObserverTagWidget", "IsLastSpectatedCharacter");

	Params::ObserverTagWidget_IsLastSpectatedCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.ObserverTagWidget.IsTeamMember
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UObserverTagWidget::IsTeamMember() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObserverTagWidget", "IsTeamMember");

	Params::ObserverTagWidget_IsTeamMember Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslVehicleInterface.GetTslPlayerController
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslPlayerController*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslPlayerController* ITslVehicleInterface::GetTslPlayerController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleInterface", "GetTslPlayerController");

	Params::TslVehicleInterface_GetTslPlayerController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslVehicleInterface.GetVehicleMeshComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ITslVehicleInterface::GetVehicleMeshComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleInterface", "GetVehicleMeshComponent");

	Params::TslVehicleInterface_GetVehicleMeshComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.ParachuteVehicle.AllowInteractBy
// (Final, Native, Private)
// Parameters:
// class ATslCharacter*                    Character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AParachuteVehicle::AllowInteractBy(const class ATslCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParachuteVehicle", "AllowInteractBy");

	Params::ParachuteVehicle_AllowInteractBy Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.ParachuteVehicle.AllowSecondInteractBy
// (Final, Native, Private)
// Parameters:
// class ATslCharacter*                    Character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AParachuteVehicle::AllowSecondInteractBy(const class ATslCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParachuteVehicle", "AllowSecondInteractBy");

	Params::ParachuteVehicle_AllowSecondInteractBy Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.ParachuteVehicle.Land
// (Final, Net, Native, Event, NetMulticast, Private)

void AParachuteVehicle::Land()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParachuteVehicle", "Land");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.ParachuteVehicle.OnDriverLeave
// (Final, Native, Private)

void AParachuteVehicle::OnDriverLeave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParachuteVehicle", "OnDriverLeave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.ParachuteVehicle.OnDriverRide
// (Final, Native, Private)

void AParachuteVehicle::OnDriverRide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParachuteVehicle", "OnDriverRide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.ParachuteVehicle.OnInteractBy
// (Final, Native, Private)
// Parameters:
// class ATslCharacter*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AParachuteVehicle::OnInteractBy(class ATslCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParachuteVehicle", "OnInteractBy");

	Params::ParachuteVehicle_OnInteractBy Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.ParachuteVehicle.OnPostDriverLeave
// (Final, Native, Private)

void AParachuteVehicle::OnPostDriverLeave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParachuteVehicle", "OnPostDriverLeave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.ParachuteVehicle.OnRep_IsDriven
// (Final, Native, Private)

void AParachuteVehicle::OnRep_IsDriven()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParachuteVehicle", "OnRep_IsDriven");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.ParachuteVehicle.OnRep_IsReleased
// (Final, Native, Private)

void AParachuteVehicle::OnRep_IsReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParachuteVehicle", "OnRep_IsReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.ParachuteVehicle.OnRide
// (Final, Native, Private)
// Parameters:
// class ATslCharacter*                    Rider                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVehicleSeatInteractionComponent* Seat                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AParachuteVehicle::OnRide(class ATslCharacter* Rider, class UVehicleSeatInteractionComponent* Seat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParachuteVehicle", "OnRide");

	Params::ParachuteVehicle_OnRide Parms{};

	Parms.Rider = Rider;
	Parms.Seat = Seat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.ParachuteVehicle.OnSecondInteractBy
// (Final, Native, Private)
// Parameters:
// class ATslCharacter*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AParachuteVehicle::OnSecondInteractBy(class ATslCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParachuteVehicle", "OnSecondInteractBy");

	Params::ParachuteVehicle_OnSecondInteractBy Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.ParachuteVehicle.PhysicsVolumeChanged
// (Final, Native, Private)
// Parameters:
// class APhysicsVolume*                   NewVolume                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AParachuteVehicle::PhysicsVolumeChanged(class APhysicsVolume* NewVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParachuteVehicle", "PhysicsVolumeChanged");

	Params::ParachuteVehicle_PhysicsVolumeChanged Parms{};

	Parms.NewVolume = NewVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.ParachuteVehicle.ServerRelease
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void AParachuteVehicle::ServerRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParachuteVehicle", "ServerRelease");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.ParachuteVehicle.CanRelease
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AParachuteVehicle::CanRelease() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParachuteVehicle", "CanRelease");

	Params::ParachuteVehicle_CanRelease Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.ParachuteVehicle.CanReleaseByInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AParachuteVehicle::CanReleaseByInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParachuteVehicle", "CanReleaseByInput");

	Params::ParachuteVehicle_CanReleaseByInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.ParachuteVehicle.GetAltitudeFromFloor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AParachuteVehicle::GetAltitudeFromFloor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParachuteVehicle", "GetAltitudeFromFloor");

	Params::ParachuteVehicle_GetAltitudeFromFloor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.ParachuteVehicle.IsDriven
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AParachuteVehicle::IsDriven() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParachuteVehicle", "IsDriven");

	Params::ParachuteVehicle_IsDriven Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.ParachuteVehicle.IsReleased
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AParachuteVehicle::IsReleased() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParachuteVehicle", "IsReleased");

	Params::ParachuteVehicle_IsReleased Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.ParachuteVehicle.IsStuck
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AParachuteVehicle::IsStuck() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParachuteVehicle", "IsStuck");

	Params::ParachuteVehicle_IsStuck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.ReplicationTrigger.EnableReplicationGroup
// (Final, Native, Private)

void AReplicationTrigger::EnableReplicationGroup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ReplicationTrigger", "EnableReplicationGroup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.SceneInteractionComponent.AllowInteractBy
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*                    Character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USceneInteractionComponent::AllowInteractBy(const class ATslCharacter* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SceneInteractionComponent", "AllowInteractBy");

	Params::SceneInteractionComponent_AllowInteractBy Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.SceneInteractionComponent.GetInteractionVerb
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText USceneInteractionComponent::GetInteractionVerb() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SceneInteractionComponent", "GetInteractionVerb");

	Params::SceneInteractionComponent_GetInteractionVerb Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.SceneInteractionComponent.GetInteractiveObjectName
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText USceneInteractionComponent::GetInteractiveObjectName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SceneInteractionComponent", "GetInteractiveObjectName");

	Params::SceneInteractionComponent_GetInteractiveObjectName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.DoorInteractionComponent.AllowInteract
// (Final, Native, Protected)
// Parameters:
// class ATslCharacter*                    OtherCharacter                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDoorInteractionComponent::AllowInteract(const class ATslCharacter* OtherCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DoorInteractionComponent", "AllowInteract");

	Params::DoorInteractionComponent_AllowInteract Parms{};

	Parms.OtherCharacter = OtherCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.DoorInteractionComponent.OnRep_DoorState
// (Final, Native, Protected)
// Parameters:
// EDoorState                              PrevDoorState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDoorInteractionComponent::OnRep_DoorState(EDoorState PrevDoorState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DoorInteractionComponent", "OnRep_DoorState");

	Params::DoorInteractionComponent_OnRep_DoorState Parms{};

	Parms.PrevDoorState = PrevDoorState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.ApplyAutoQualitySetting
// (Final, Native, Static, Public, BlueprintCallable)

void UTslGameOption::ApplyAutoQualitySetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "ApplyAutoQualitySetting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.ApplyGameUserSettings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bCheckForCommandLineOverrides                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::ApplyGameUserSettings(bool bCheckForCommandLineOverrides)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "ApplyGameUserSettings");

	Params::TslGameOption_ApplyGameUserSettings Parms{};

	Parms.bCheckForCommandLineOverrides = bCheckForCommandLineOverrides;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.ApplyMouseSensitivity
// (Final, Native, Static, Public, BlueprintCallable)

void UTslGameOption::ApplyMouseSensitivity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "ApplyMouseSensitivity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.CastTslInputModeFromName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// FName                             InputModeName                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETslInputModes                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETslInputModes UTslGameOption::CastTslInputModeFromName(const FName& InputModeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "CastTslInputModeFromName");

	Params::TslGameOption_CastTslInputModeFromName Parms{};

	Parms.InputModeName = InputModeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.CultureNames
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UTslGameOption::CultureNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "CultureNames");

	Params::TslGameOption_CultureNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.CustomizableActionNames
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FCustomizableActionName>  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FCustomizableActionName> UTslGameOption::CustomizableActionNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "CustomizableActionNames");

	Params::TslGameOption_CustomizableActionNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.CustomizableAxisName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FCustomizableAxisName>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FCustomizableAxisName> UTslGameOption::CustomizableAxisName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "CustomizableAxisName");

	Params::TslGameOption_CustomizableAxisName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.CustomizableCategoryData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FCustomizableCategoryData>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FCustomizableCategoryData> UTslGameOption::CustomizableCategoryData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "CustomizableCategoryData");

	Params::TslGameOption_CustomizableCategoryData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.CustomizableMouseSensitiveNames
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FCustomizableMouseSensitiveName>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FCustomizableMouseSensitiveName> UTslGameOption::CustomizableMouseSensitiveNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "CustomizableMouseSensitiveNames");

	Params::TslGameOption_CustomizableMouseSensitiveNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetActionKey
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGamepad                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDefault                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWantAnyKey                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EKeyBindingSlot                         eKeySlot                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTslInputKey                     ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTslInputKey UTslGameOption::GetActionKey(FName ActionName, bool bGamepad, bool bDefault, bool bWantAnyKey, EKeyBindingSlot eKeySlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetActionKey");

	Params::TslGameOption_GetActionKey Parms{};

	Parms.ActionName = ActionName;
	Parms.bGamepad = bGamepad;
	Parms.bDefault = bDefault;
	Parms.bWantAnyKey = bWantAnyKey;
	Parms.eKeySlot = eKeySlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetActionKeys
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDefault                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTslInputKey>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FTslInputKey> UTslGameOption::GetActionKeys(FName ActionName, bool bDefault)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetActionKeys");

	Params::TslGameOption_GetActionKeys Parms{};

	Parms.ActionName = ActionName;
	Parms.bDefault = bDefault;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetAutoQualityLevels
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   WorkScale                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CPUMultiplier                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   GPUMultiplier                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FQualityLevelInfo>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FQualityLevelInfo> UTslGameOption::GetAutoQualityLevels(int32 WorkScale, float CPUMultiplier, float GPUMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetAutoQualityLevels");

	Params::TslGameOption_GetAutoQualityLevels Parms{};

	Parms.WorkScale = WorkScale;
	Parms.CPUMultiplier = CPUMultiplier;
	Parms.GPUMultiplier = GPUMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetAvailableProviderDisplayNames
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FText>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FText> UTslGameOption::GetAvailableProviderDisplayNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetAvailableProviderDisplayNames");

	Params::TslGameOption_GetAvailableProviderDisplayNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetAvailableProviderNames
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UTslGameOption::GetAvailableProviderNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetAvailableProviderNames");

	Params::TslGameOption_GetAvailableProviderNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetAxisKey
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// FName                             AxisName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGamepad                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDefault                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWantAnyKey                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EKeyBindingSlot                         eKeySlot                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTslInputKey                     ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTslInputKey UTslGameOption::GetAxisKey(FName AxisName, float Scale, bool bGamepad, bool bDefault, bool bWantAnyKey, EKeyBindingSlot eKeySlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetAxisKey");

	Params::TslGameOption_GetAxisKey Parms{};

	Parms.AxisName = AxisName;
	Parms.Scale = Scale;
	Parms.bGamepad = bGamepad;
	Parms.bDefault = bDefault;
	Parms.bWantAnyKey = bWantAnyKey;
	Parms.eKeySlot = eKeySlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetAxisKeys
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// FName                             AxisName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDefault                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTslInputKey>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FTslInputKey> UTslGameOption::GetAxisKeys(FName AxisName, float Scale, bool bDefault)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetAxisKeys");

	Params::TslGameOption_GetAxisKeys Parms{};

	Parms.AxisName = AxisName;
	Parms.Scale = Scale;
	Parms.bDefault = bDefault;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetBGMSoundVolume
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslGameOption::GetBGMSoundVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetBGMSoundVolume");

	Params::TslGameOption_GetBGMSoundVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetColorBlindTypes
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FColorBlindType>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FColorBlindType> UTslGameOption::GetColorBlindTypes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetColorBlindTypes");

	Params::TslGameOption_GetColorBlindTypes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetConvertedMouseSensitivity
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// FName                             InMouseSensitiveName                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslGameOption::GetConvertedMouseSensitivity(FName InMouseSensitiveName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetConvertedMouseSensitivity");

	Params::TslGameOption_GetConvertedMouseSensitivity Parms{};

	Parms.InMouseSensitiveName = InMouseSensitiveName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetCrosshairColors
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FPresetColor>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FPresetColor> UTslGameOption::GetCrosshairColors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetCrosshairColors");

	Params::TslGameOption_GetCrosshairColors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetCurrentColorBlindKey
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EColorBlindType                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EColorBlindType UTslGameOption::GetCurrentColorBlindKey()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetCurrentColorBlindKey");

	Params::TslGameOption_GetCurrentColorBlindKey Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetCurrentCrosshairColorStr
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTslGameOption::GetCurrentCrosshairColorStr()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetCurrentCrosshairColorStr");

	Params::TslGameOption_GetCurrentCrosshairColorStr Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetCurrentCultureName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTslGameOption::GetCurrentCultureName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetCurrentCultureName");

	Params::TslGameOption_GetCurrentCultureName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetCurrentProvider
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTslGameOption::GetCurrentProvider()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetCurrentProvider");

	Params::TslGameOption_GetCurrentProvider Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetDefaultCultureName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTslGameOption::GetDefaultCultureName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetDefaultCultureName");

	Params::TslGameOption_GetDefaultCultureName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetDefaultInputModeSetting
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EInputModeSettingActions                eAction                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETslInputModes                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETslInputModes UTslGameOption::GetDefaultInputModeSetting(EInputModeSettingActions eAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetDefaultInputModeSetting");

	Params::TslGameOption_GetDefaultInputModeSetting Parms{};

	Parms.eAction = eAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetEffectSoundVolume
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslGameOption::GetEffectSoundVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetEffectSoundVolume");

	Params::TslGameOption_GetEffectSoundVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetFppEquipableItemIconShowType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EUiShowType                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EUiShowType UTslGameOption::GetFppEquipableItemIconShowType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetFppEquipableItemIconShowType");

	Params::TslGameOption_GetFppEquipableItemIconShowType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetFppWeaponIconShowType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EUiShowType                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EUiShowType UTslGameOption::GetFppWeaponIconShowType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetFppWeaponIconShowType");

	Params::TslGameOption_GetFppWeaponIconShowType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetFpsCameraFov
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslGameOption::GetFpsCameraFov()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetFpsCameraFov");

	Params::TslGameOption_GetFpsCameraFov Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetFullScreenMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EWindowMode                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWindowMode UTslGameOption::GetFullScreenMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetFullScreenMode");

	Params::TslGameOption_GetFullScreenMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetGamma
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslGameOption::GetGamma()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetGamma");

	Params::TslGameOption_GetGamma Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetKeyInputModeNames
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FKeyInputModeName>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FKeyInputModeName> UTslGameOption::GetKeyInputModeNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetKeyInputModeNames");

	Params::TslGameOption_GetKeyInputModeNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetKeyName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTslInputKey                     Key                                                    (Parm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UTslGameOption::GetKeyName(const struct FTslInputKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetKeyName");

	Params::TslGameOption_GetKeyName Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetMasterSoundVolume
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslGameOption::GetMasterSoundVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetMasterSoundVolume");

	Params::TslGameOption_GetMasterSoundVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetMiniMapTypes
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FUiType>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FUiType> UTslGameOption::GetMiniMapTypes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetMiniMapTypes");

	Params::TslGameOption_GetMiniMapTypes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetMouseSensitivity
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// FName                             InMouseSensitiveName                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslGameOption::GetMouseSensitivity(FName InMouseSensitiveName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetMouseSensitivity");

	Params::TslGameOption_GetMouseSensitivity Parms{};

	Parms.InMouseSensitiveName = InMouseSensitiveName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetNativeLanguage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           InCultureName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTslGameOption::GetNativeLanguage(const class FString& InCultureName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetNativeLanguage");

	Params::TslGameOption_GetNativeLanguage Parms{};

	Parms.InCultureName = std::move(InCultureName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetOverallScalabilityLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTslGameOption::GetOverallScalabilityLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetOverallScalabilityLevel");

	Params::TslGameOption_GetOverallScalabilityLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetQualityLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EQualityType                            Quality                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTslGameOption::GetQualityLevel(EQualityType Quality)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetQualityLevel");

	Params::TslGameOption_GetQualityLevel Parms{};

	Parms.Quality = Quality;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetScreenResolution
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FScreenResolution                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FScreenResolution UTslGameOption::GetScreenResolution()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetScreenResolution");

	Params::TslGameOption_GetScreenResolution Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetScreenScale
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslGameOption::GetScreenScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetScreenScale");

	Params::TslGameOption_GetScreenScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetSelectMiniMapTypeIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTslGameOption::GetSelectMiniMapTypeIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetSelectMiniMapTypeIndex");

	Params::TslGameOption_GetSelectMiniMapTypeIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetSupportedQualityLevels
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FSurportQualityLevel>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FSurportQualityLevel> UTslGameOption::GetSupportedQualityLevels()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetSupportedQualityLevels");

	Params::TslGameOption_GetSupportedQualityLevels Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetSupportedScreenResolutions
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FScreenResolution>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FScreenResolution> UTslGameOption::GetSupportedScreenResolutions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetSupportedScreenResolutions");

	Params::TslGameOption_GetSupportedScreenResolutions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetTpsWeaponIconShowType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EUiShowType                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EUiShowType UTslGameOption::GetTpsWeaponIconShowType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetTpsWeaponIconShowType");

	Params::TslGameOption_GetTpsWeaponIconShowType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetTslInputMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EInputModeSettingActions                eAction                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETslInputModes                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETslInputModes UTslGameOption::GetTslInputMode(EInputModeSettingActions eAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetTslInputMode");

	Params::TslGameOption_GetTslInputMode Parms{};

	Parms.eAction = eAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetUISoundVolume
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslGameOption::GetUISoundVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetUISoundVolume");

	Params::TslGameOption_GetUISoundVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetUseCharacterCapture
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslGameOption::GetUseCharacterCapture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetUseCharacterCapture");

	Params::TslGameOption_GetUseCharacterCapture Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetUseGlobalVoice
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslGameOption::GetUseGlobalVoice()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetUseGlobalVoice");

	Params::TslGameOption_GetUseGlobalVoice Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetUsePushToTalk
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslGameOption::GetUsePushToTalk()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetUsePushToTalk");

	Params::TslGameOption_GetUsePushToTalk Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetUseTeamVoice
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslGameOption::GetUseTeamVoice()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetUseTeamVoice");

	Params::TslGameOption_GetUseTeamVoice Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetVoiceInputVolume
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTslGameOption::GetVoiceInputVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetVoiceInputVolume");

	Params::TslGameOption_GetVoiceInputVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetVoiceOutputVolume
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTslGameOption::GetVoiceOutputVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetVoiceOutputVolume");

	Params::TslGameOption_GetVoiceOutputVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.GetWorldMapZoomSpeedLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTslGameOption::GetWorldMapZoomSpeedLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "GetWorldMapZoomSpeedLevel");

	Params::TslGameOption_GetWorldMapZoomSpeedLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.IsBGMSoundMute
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslGameOption::IsBGMSoundMute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "IsBGMSoundMute");

	Params::TslGameOption_IsBGMSoundMute Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.IsDefaultFunctionalityEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EGameplayFunctionalities                eAction                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslGameOption::IsDefaultFunctionalityEnabled(EGameplayFunctionalities eAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "IsDefaultFunctionalityEnabled");

	Params::TslGameOption_IsDefaultFunctionalityEnabled Parms{};

	Parms.eAction = eAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.IsDoubleTapSupported
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EInputModeSettingActions                eAction                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslGameOption::IsDoubleTapSupported(EInputModeSettingActions eAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "IsDoubleTapSupported");

	Params::TslGameOption_IsDoubleTapSupported Parms{};

	Parms.eAction = eAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.IsEffectSoundMute
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslGameOption::IsEffectSoundMute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "IsEffectSoundMute");

	Params::TslGameOption_IsEffectSoundMute Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.IsEnabledMotionBlur
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslGameOption::IsEnabledMotionBlur()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "IsEnabledMotionBlur");

	Params::TslGameOption_IsEnabledMotionBlur Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.IsFunctionalityEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EGameplayFunctionalities                eAction                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslGameOption::IsFunctionalityEnabled(EGameplayFunctionalities eAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "IsFunctionalityEnabled");

	Params::TslGameOption_IsFunctionalityEnabled Parms{};

	Parms.eAction = eAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.IsGamepadKey
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTslInputKey                     Key                                                    (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslGameOption::IsGamepadKey(const struct FTslInputKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "IsGamepadKey");

	Params::TslGameOption_IsGamepadKey Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.IsInvertMouse
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslGameOption::IsInvertMouse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "IsInvertMouse");

	Params::TslGameOption_IsInvertMouse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.IsKeyUsed
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTslInputKey                     Key                                                    (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslGameOption::IsKeyUsed(const struct FTslInputKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "IsKeyUsed");

	Params::TslGameOption_IsKeyUsed Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.IsKeyValid
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTslInputKey                     Key                                                    (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslGameOption::IsKeyValid(const struct FTslInputKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "IsKeyValid");

	Params::TslGameOption_IsKeyValid Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.IsMasterSoundMute
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslGameOption::IsMasterSoundMute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "IsMasterSoundMute");

	Params::TslGameOption_IsMasterSoundMute Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.IsModifierKey
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTslInputKey                     Key                                                    (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslGameOption::IsModifierKey(const struct FTslInputKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "IsModifierKey");

	Params::TslGameOption_IsModifierKey Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.IsMouseWheelInput
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTslInputKey                     InInputedKey                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslGameOption::IsMouseWheelInput(const struct FTslInputKey& InInputedKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "IsMouseWheelInput");

	Params::TslGameOption_IsMouseWheelInput Parms{};

	Parms.InInputedKey = std::move(InInputedKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.IsUISoundMute
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslGameOption::IsUISoundMute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "IsUISoundMute");

	Params::TslGameOption_IsUISoundMute Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.IsVoiceInputMute
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslGameOption::IsVoiceInputMute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "IsVoiceInputMute");

	Params::TslGameOption_IsVoiceInputMute Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.IsVoiceOutputMute
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslGameOption::IsVoiceOutputMute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "IsVoiceOutputMute");

	Params::TslGameOption_IsVoiceOutputMute Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.IsVSyncEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslGameOption::IsVSyncEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "IsVSyncEnabled");

	Params::TslGameOption_IsVSyncEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.NotDuplicateCategoryNames
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// FName                             CatecoryName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<FName> UTslGameOption::NotDuplicateCategoryNames(FName CatecoryName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "NotDuplicateCategoryNames");

	Params::TslGameOption_NotDuplicateCategoryNames Parms{};

	Parms.CatecoryName = CatecoryName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameOption.SetActionKey
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// FName                             ActionName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTslInputKey                     NewKey                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EKeyBindingSlot                         InKeyBindingSlot                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGamepad                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetActionKey(const FName& ActionName, const struct FTslInputKey& NewKey, EKeyBindingSlot InKeyBindingSlot, bool bGamepad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetActionKey");

	Params::TslGameOption_SetActionKey Parms{};

	Parms.ActionName = ActionName;
	Parms.NewKey = std::move(NewKey);
	Parms.InKeyBindingSlot = InKeyBindingSlot;
	Parms.bGamepad = bGamepad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetActionKeys
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// FName                             ActionName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTslInputKey>             NewKeys                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UTslGameOption::SetActionKeys(const FName& ActionName, const TArray<struct FTslInputKey>& NewKeys)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetActionKeys");

	Params::TslGameOption_SetActionKeys Parms{};

	Parms.ActionName = ActionName;
	Parms.NewKeys = std::move(NewKeys);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetActionKeysToDefault
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// FName                             ActionName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetActionKeysToDefault(const FName& ActionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetActionKeysToDefault");

	Params::TslGameOption_SetActionKeysToDefault Parms{};

	Parms.ActionName = ActionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetAxisKey
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// FName                             AxisName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTslInputKey                     NewKey                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EKeyBindingSlot                         InKeyBindingSlot                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGamepad                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetAxisKey(const FName& AxisName, float Scale, const struct FTslInputKey& NewKey, EKeyBindingSlot InKeyBindingSlot, bool bGamepad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetAxisKey");

	Params::TslGameOption_SetAxisKey Parms{};

	Parms.AxisName = AxisName;
	Parms.Scale = Scale;
	Parms.NewKey = std::move(NewKey);
	Parms.InKeyBindingSlot = InKeyBindingSlot;
	Parms.bGamepad = bGamepad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetAxisKeys
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// FName                             AxisName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTslInputKey>             NewKeys                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UTslGameOption::SetAxisKeys(const FName& AxisName, float Scale, const TArray<struct FTslInputKey>& NewKeys)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetAxisKeys");

	Params::TslGameOption_SetAxisKeys Parms{};

	Parms.AxisName = AxisName;
	Parms.Scale = Scale;
	Parms.NewKeys = std::move(NewKeys);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetAxisKeysToDefault
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// FName                             AxisName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetAxisKeysToDefault(const FName& AxisName, float Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetAxisKeysToDefault");

	Params::TslGameOption_SetAxisKeysToDefault Parms{};

	Parms.AxisName = AxisName;
	Parms.Scale = Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetBGMSoundMute
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsMute                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetBGMSoundMute(bool bIsMute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetBGMSoundMute");

	Params::TslGameOption_SetBGMSoundMute Parms{};

	Parms.bIsMute = bIsMute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetBGMSoundVolume
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetBGMSoundVolume(float Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetBGMSoundVolume");

	Params::TslGameOption_SetBGMSoundVolume Parms{};

	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetCurrentColorBlindKey
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EColorBlindType                         ColorBlindKey                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetCurrentColorBlindKey(EColorBlindType ColorBlindKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetCurrentColorBlindKey");

	Params::TslGameOption_SetCurrentColorBlindKey Parms{};

	Parms.ColorBlindKey = ColorBlindKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetCurrentColorBlindKeyByInt
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ColorBlindKey                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetCurrentColorBlindKeyByInt(int32 ColorBlindKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetCurrentColorBlindKeyByInt");

	Params::TslGameOption_SetCurrentColorBlindKeyByInt Parms{};

	Parms.ColorBlindKey = ColorBlindKey;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetCurrentCrosshairColorString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           CrosshairColorStr                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetCurrentCrosshairColorString(const class FString& CrosshairColorStr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetCurrentCrosshairColorString");

	Params::TslGameOption_SetCurrentCrosshairColorString Parms{};

	Parms.CrosshairColorStr = std::move(CrosshairColorStr);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetCurrentCultureName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           InCultureName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetCurrentCultureName(const class FString& InCultureName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetCurrentCultureName");

	Params::TslGameOption_SetCurrentCultureName Parms{};

	Parms.InCultureName = std::move(InCultureName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetCurrentProvider
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ProviderName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetCurrentProvider(const class FString& ProviderName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetCurrentProvider");

	Params::TslGameOption_SetCurrentProvider Parms{};

	Parms.ProviderName = std::move(ProviderName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetEffectSoundMute
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsMute                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetEffectSoundMute(bool bIsMute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetEffectSoundMute");

	Params::TslGameOption_SetEffectSoundMute Parms{};

	Parms.bIsMute = bIsMute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetEffectSoundVolume
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetEffectSoundVolume(float Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetEffectSoundVolume");

	Params::TslGameOption_SetEffectSoundVolume Parms{};

	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetEnableFunctionality
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EGameplayFunctionalities                eAction                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetEnableFunctionality(EGameplayFunctionalities eAction, bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetEnableFunctionality");

	Params::TslGameOption_SetEnableFunctionality Parms{};

	Parms.eAction = eAction;
	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetEquipableIteIconShow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewShow                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetEquipableIteIconShow(bool bNewShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetEquipableIteIconShow");

	Params::TslGameOption_SetEquipableIteIconShow Parms{};

	Parms.bNewShow = bNewShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetFppEquipableItemIconShowType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EUiShowType                             NewShowType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetFppEquipableItemIconShowType(EUiShowType NewShowType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetFppEquipableItemIconShowType");

	Params::TslGameOption_SetFppEquipableItemIconShowType Parms{};

	Parms.NewShowType = NewShowType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetFppWeaponIconShowType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EUiShowType                             NewShowType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetFppWeaponIconShowType(EUiShowType NewShowType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetFppWeaponIconShowType");

	Params::TslGameOption_SetFppWeaponIconShowType Parms{};

	Parms.NewShowType = NewShowType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetFpsCameraFov
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   NewFovValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetFpsCameraFov(float NewFovValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetFpsCameraFov");

	Params::TslGameOption_SetFpsCameraFov Parms{};

	Parms.NewFovValue = NewFovValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetFpsWeaponSlotShow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewShow                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetFpsWeaponSlotShow(bool bNewShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetFpsWeaponSlotShow");

	Params::TslGameOption_SetFpsWeaponSlotShow Parms{};

	Parms.bNewShow = bNewShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetFullScreen
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EWindowMode                             InFullscreenMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetFullScreen(EWindowMode InFullscreenMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetFullScreen");

	Params::TslGameOption_SetFullScreen Parms{};

	Parms.InFullscreenMode = InFullscreenMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetGamma
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Gamma                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetGamma(float Gamma)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetGamma");

	Params::TslGameOption_SetGamma Parms{};

	Parms.Gamma = Gamma;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetInputKey_Internal
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// TArray<struct FTslInputKey>             OutKeyList                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FTslInputKey                     NewKey                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EKeyBindingSlot                         InKeyBindingSlot                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGamepad                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetInputKey_Internal(TArray<struct FTslInputKey>* OutKeyList, const struct FTslInputKey& NewKey, EKeyBindingSlot InKeyBindingSlot, bool bGamepad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetInputKey_Internal");

	Params::TslGameOption_SetInputKey_Internal Parms{};

	Parms.NewKey = std::move(NewKey);
	Parms.InKeyBindingSlot = InKeyBindingSlot;
	Parms.bGamepad = bGamepad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutKeyList != nullptr)
		*OutKeyList = std::move(Parms.OutKeyList);
}


// Function TslGame.TslGameOption.SetInvertMouse
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bInvert                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetInvertMouse(bool bInvert)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetInvertMouse");

	Params::TslGameOption_SetInvertMouse Parms{};

	Parms.bInvert = bInvert;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetMasterSoundMute
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsMute                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetMasterSoundMute(bool bIsMute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetMasterSoundMute");

	Params::TslGameOption_SetMasterSoundMute Parms{};

	Parms.bIsMute = bIsMute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetMasterSoundVolume
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetMasterSoundVolume(float Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetMasterSoundVolume");

	Params::TslGameOption_SetMasterSoundVolume Parms{};

	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetMotionBlur
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetMotionBlur(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetMotionBlur");

	Params::TslGameOption_SetMotionBlur Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetMouseSensitivity
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// FName                             InMouseSensitiveName                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMouseSensitivity                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetMouseSensitivity(FName InMouseSensitiveName, float InMouseSensitivity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetMouseSensitivity");

	Params::TslGameOption_SetMouseSensitivity Parms{};

	Parms.InMouseSensitiveName = InMouseSensitiveName;
	Parms.InMouseSensitivity = InMouseSensitivity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetOverallScalabilityLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetOverallScalabilityLevel(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetOverallScalabilityLevel");

	Params::TslGameOption_SetOverallScalabilityLevel Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetQualityLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EQualityType                            Quality                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   QualityLevel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetQualityLevel(EQualityType Quality, int32 QualityLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetQualityLevel");

	Params::TslGameOption_SetQualityLevel Parms{};

	Parms.Quality = Quality;
	Parms.QualityLevel = QualityLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetScreenResoultion
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FScreenResolution                ScreenResolution                                       (Parm, NativeAccessSpecifierPublic)

void UTslGameOption::SetScreenResoultion(const struct FScreenResolution& ScreenResolution)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetScreenResoultion");

	Params::TslGameOption_SetScreenResoultion Parms{};

	Parms.ScreenResolution = std::move(ScreenResolution);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetScreenScale
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetScreenScale(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetScreenScale");

	Params::TslGameOption_SetScreenScale Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetSelectMinimapTypeIndex
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetSelectMinimapTypeIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetSelectMinimapTypeIndex");

	Params::TslGameOption_SetSelectMinimapTypeIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetTpsWeaponIconShowType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EUiShowType                             NewShowType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetTpsWeaponIconShowType(EUiShowType NewShowType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetTpsWeaponIconShowType");

	Params::TslGameOption_SetTpsWeaponIconShowType Parms{};

	Parms.NewShowType = NewShowType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetTslInputMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EInputModeSettingActions                eAction                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETslInputModes                          eTslInputMode                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetTslInputMode(EInputModeSettingActions eAction, ETslInputModes eTslInputMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetTslInputMode");

	Params::TslGameOption_SetTslInputMode Parms{};

	Parms.eAction = eAction;
	Parms.eTslInputMode = eTslInputMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetUISoundMute
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsMute                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetUISoundMute(bool bIsMute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetUISoundMute");

	Params::TslGameOption_SetUISoundMute Parms{};

	Parms.bIsMute = bIsMute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetUISoundVolume
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetUISoundVolume(float Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetUISoundVolume");

	Params::TslGameOption_SetUISoundVolume Parms{};

	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetUseCharacterCapture
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bUseCharacterCapture                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetUseCharacterCapture(bool bUseCharacterCapture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetUseCharacterCapture");

	Params::TslGameOption_SetUseCharacterCapture Parms{};

	Parms.bUseCharacterCapture = bUseCharacterCapture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetUseGlobalVoice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bUse                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetUseGlobalVoice(bool bUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetUseGlobalVoice");

	Params::TslGameOption_SetUseGlobalVoice Parms{};

	Parms.bUse = bUse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetUsePushToTalk
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bUse                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetUsePushToTalk(bool bUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetUsePushToTalk");

	Params::TslGameOption_SetUsePushToTalk Parms{};

	Parms.bUse = bUse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetUseTeamVoice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bUse                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetUseTeamVoice(bool bUse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetUseTeamVoice");

	Params::TslGameOption_SetUseTeamVoice Parms{};

	Parms.bUse = bUse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetVoiceInputMute
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsMute                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetVoiceInputMute(bool bIsMute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetVoiceInputMute");

	Params::TslGameOption_SetVoiceInputMute Parms{};

	Parms.bIsMute = bIsMute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetVoiceInputVolume
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetVoiceInputVolume(int32 Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetVoiceInputVolume");

	Params::TslGameOption_SetVoiceInputVolume Parms{};

	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetVoiceOutputMute
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsMute                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetVoiceOutputMute(bool bIsMute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetVoiceOutputMute");

	Params::TslGameOption_SetVoiceOutputMute Parms{};

	Parms.bIsMute = bIsMute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetVoiceOutputVolume
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetVoiceOutputVolume(int32 Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetVoiceOutputVolume");

	Params::TslGameOption_SetVoiceOutputVolume Parms{};

	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetVSyncEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetVSyncEnabled(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetVSyncEnabled");

	Params::TslGameOption_SetVSyncEnabled Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.SetWorldMapZoomLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   NewZoomLevel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameOption::SetWorldMapZoomLevel(int32 NewZoomLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "SetWorldMapZoomLevel");

	Params::TslGameOption_SetWorldMapZoomLevel Parms{};

	Parms.NewZoomLevel = NewZoomLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameOption.WheelAxisNameToWheelActionName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTslInputKey                     Key                                                    (Parm, NativeAccessSpecifierPublic)
// float                                   InAxisScale                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UTslGameOption::WheelAxisNameToWheelActionName(const struct FTslInputKey& Key, float InAxisScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslGameOption", "WheelAxisNameToWheelActionName");

	Params::TslGameOption_WheelAxisNameToWheelActionName Parms{};

	Parms.Key = std::move(Key);
	Parms.InAxisScale = InAxisScale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.DroppedItemInteractionComponent.OnRep_Item
// (Final, Native, Private)

void UDroppedItemInteractionComponent::OnRep_Item()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DroppedItemInteractionComponent", "OnRep_Item");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.DroppedItemInteractionComponent.AllowInteractBy
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*                    Character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDroppedItemInteractionComponent::AllowInteractBy(const class ATslCharacter* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DroppedItemInteractionComponent", "AllowInteractBy");

	Params::DroppedItemInteractionComponent_AllowInteractBy Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.AllowInteractDelegate
// (Native, Protected)
// Parameters:
// class ATslCharacter*                    OtherCharacter                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVehicleSeatInteractionComponent::AllowInteractDelegate(const class ATslCharacter* OtherCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatInteractionComponent", "AllowInteractDelegate");

	Params::VehicleSeatInteractionComponent_AllowInteractDelegate Parms{};

	Parms.OtherCharacter = OtherCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetMaxPitchByYaw
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   CurrentYaw                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UVehicleSeatInteractionComponent::GetMaxPitchByYaw(float CurrentYaw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatInteractionComponent", "GetMaxPitchByYaw");

	Params::VehicleSeatInteractionComponent_GetMaxPitchByYaw Parms{};

	Parms.CurrentYaw = CurrentYaw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetMinPitchByYaw
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   CurrentYaw                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UVehicleSeatInteractionComponent::GetMinPitchByYaw(float CurrentYaw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatInteractionComponent", "GetMinPitchByYaw");

	Params::VehicleSeatInteractionComponent_GetMinPitchByYaw Parms{};

	Parms.CurrentYaw = CurrentYaw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.OnInteractDelegate
// (Native, Protected)
// Parameters:
// class ATslCharacter*                    OtherCharacter                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVehicleSeatInteractionComponent::OnInteractDelegate(class ATslCharacter* OtherCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatInteractionComponent", "OnInteractDelegate");

	Params::VehicleSeatInteractionComponent_OnInteractDelegate Parms{};

	Parms.OtherCharacter = OtherCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VehicleSeatInteractionComponent.OnRep_Rider
// (Final, Native, Private)

void UVehicleSeatInteractionComponent::OnRep_Rider()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatInteractionComponent", "OnRep_Rider");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VehicleSeatInteractionComponent.GetAdditionalMessage
// (Native, Public, Const)
// Parameters:
// class ATslCharacter*                    Character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UVehicleSeatInteractionComponent::GetAdditionalMessage(const class ATslCharacter* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatInteractionComponent", "GetAdditionalMessage");

	Params::VehicleSeatInteractionComponent_GetAdditionalMessage Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetCanFireOnlyWhileAimed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVehicleSeatInteractionComponent::GetCanFireOnlyWhileAimed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatInteractionComponent", "GetCanFireOnlyWhileAimed");

	Params::VehicleSeatInteractionComponent_GetCanFireOnlyWhileAimed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetRider
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslCharacter* UVehicleSeatInteractionComponent::GetRider() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatInteractionComponent", "GetRider");

	Params::VehicleSeatInteractionComponent_GetRider Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetSeatAimingBlendspace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBlendSpaceBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBlendSpaceBase* UVehicleSeatInteractionComponent::GetSeatAimingBlendspace() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatInteractionComponent", "GetSeatAimingBlendspace");

	Params::VehicleSeatInteractionComponent_GetSeatAimingBlendspace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetSeatAimingFPPBlendspace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBlendSpaceBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBlendSpaceBase* UVehicleSeatInteractionComponent::GetSeatAimingFPPBlendspace() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatInteractionComponent", "GetSeatAimingFPPBlendspace");

	Params::VehicleSeatInteractionComponent_GetSeatAimingFPPBlendspace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetSeatIdleAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimSequenceBase*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimSequenceBase* UVehicleSeatInteractionComponent::GetSeatIdleAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatInteractionComponent", "GetSeatIdleAnimation");

	Params::VehicleSeatInteractionComponent_GetSeatIdleAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetSeatIdleAO
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAimOffsetBlendSpace*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAimOffsetBlendSpace* UVehicleSeatInteractionComponent::GetSeatIdleAO() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatInteractionComponent", "GetSeatIdleAO");

	Params::VehicleSeatInteractionComponent_GetSeatIdleAO Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetTransitionInBlendspace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBlendSpaceBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBlendSpaceBase* UVehicleSeatInteractionComponent::GetTransitionInBlendspace() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatInteractionComponent", "GetTransitionInBlendspace");

	Params::VehicleSeatInteractionComponent_GetTransitionInBlendspace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetTransitionOutBlendspace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBlendSpaceBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBlendSpaceBase* UVehicleSeatInteractionComponent::GetTransitionOutBlendspace() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatInteractionComponent", "GetTransitionOutBlendspace");

	Params::VehicleSeatInteractionComponent_GetTransitionOutBlendspace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetVehicleAnimType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EVehicleAnimType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EVehicleAnimType UVehicleSeatInteractionComponent::GetVehicleAnimType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatInteractionComponent", "GetVehicleAnimType");

	Params::VehicleSeatInteractionComponent_GetVehicleAnimType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetVehicleInterface
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TScriptInterface<class ITslVehicleInterface>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

TScriptInterface<class ITslVehicleInterface> UVehicleSeatInteractionComponent::GetVehicleInterface() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatInteractionComponent", "GetVehicleInterface");

	Params::VehicleSeatInteractionComponent_GetVehicleInterface Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetVehiclePawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UVehicleSeatInteractionComponent::GetVehiclePawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatInteractionComponent", "GetVehiclePawn");

	Params::VehicleSeatInteractionComponent_GetVehiclePawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.GetVehicleSeatComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTslVehicleSeatComponent*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTslVehicleSeatComponent* UVehicleSeatInteractionComponent::GetVehicleSeatComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatInteractionComponent", "GetVehicleSeatComponent");

	Params::VehicleSeatInteractionComponent_GetVehicleSeatComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.IsEntryAllowedByVelocity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVehicleSeatInteractionComponent::IsEntryAllowedByVelocity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatInteractionComponent", "IsEntryAllowedByVelocity");

	Params::VehicleSeatInteractionComponent_IsEntryAllowedByVelocity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VehicleSeatInteractionComponent.IsWeaponClassAllowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWeaponClass                            InClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UVehicleSeatInteractionComponent::IsWeaponClassAllowed(EWeaponClass InClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VehicleSeatInteractionComponent", "IsWeaponClassAllowed");

	Params::VehicleSeatInteractionComponent_IsWeaponClassAllowed Parms{};

	Parms.InClass = InClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGunAnimInstance.HandleFiremodeMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     FireModeMontage                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGunAnimInstance::HandleFiremodeMontage(class UAnimMontage* FireModeMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGunAnimInstance", "HandleFiremodeMontage");

	Params::TslGunAnimInstance_HandleFiremodeMontage Parms{};

	Parms.FireModeMontage = FireModeMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.MotorbikeVehicleSeatInteraction.HandleFlipAndKickstand
// (Final, Native, Public, BlueprintCallable)

void UMotorbikeVehicleSeatInteraction::HandleFlipAndKickstand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotorbikeVehicleSeatInteraction", "HandleFlipAndKickstand");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.MotorbikeVehicleSeatInteraction.IsEntryAllowed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMotorbikeVehicleSeatInteraction::IsEntryAllowed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MotorbikeVehicleSeatInteraction", "IsEntryAllowed");

	Params::MotorbikeVehicleSeatInteraction_IsEntryAllowed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.FreeFallMovement.ServerUpdateInput
// (Final, Net, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// float                                   InForwardInput                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRightInput                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDesiredPitchRotation                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDesiredYawRotation                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFreeFallMovement::ServerUpdateInput(const float InForwardInput, const float InRightInput, const float InDesiredPitchRotation, const float InDesiredYawRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FreeFallMovement", "ServerUpdateInput");

	Params::FreeFallMovement_ServerUpdateInput Parms{};

	Parms.InForwardInput = InForwardInput;
	Parms.InRightInput = InRightInput;
	Parms.InDesiredPitchRotation = InDesiredPitchRotation;
	Parms.InDesiredYawRotation = InDesiredYawRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.FreeFallMovement.GetForwardInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFreeFallMovement::GetForwardInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FreeFallMovement", "GetForwardInput");

	Params::FreeFallMovement_GetForwardInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.FreeFallMovement.GetRightInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFreeFallMovement::GetRightInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FreeFallMovement", "GetRightInput");

	Params::FreeFallMovement_GetRightInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.ParachuteVehicleMovement.ServerUpdateInput
// (Final, Net, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// float                                   InForwardInput                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRotationInput                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParachuteVehicleMovement::ServerUpdateInput(float InForwardInput, float InRotationInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParachuteVehicleMovement", "ServerUpdateInput");

	Params::ParachuteVehicleMovement_ServerUpdateInput Parms{};

	Parms.InForwardInput = InForwardInput;
	Parms.InRotationInput = InRotationInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.ParachuteVehicleMovement.GetClientRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UParachuteVehicleMovement::GetClientRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParachuteVehicleMovement", "GetClientRotation");

	Params::ParachuteVehicleMovement_GetClientRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.ParachuteVehicleMovement.GetForwardInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UParachuteVehicleMovement::GetForwardInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParachuteVehicleMovement", "GetForwardInput");

	Params::ParachuteVehicleMovement_GetForwardInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.ParachuteVehicleMovement.GetRotationInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UParachuteVehicleMovement::GetRotationInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParachuteVehicleMovement", "GetRotationInput");

	Params::ParachuteVehicleMovement_GetRotationInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.ParachuteVehicleMovement.GetRotationYawRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UParachuteVehicleMovement::GetRotationYawRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParachuteVehicleMovement", "GetRotationYawRate");

	Params::ParachuteVehicleMovement_GetRotationYawRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.StanceComponent.ClientInitByReconnection
// (Final, Net, NetReliable, Native, Event, Private, NetClient, NetValidate)
// Parameters:
// EStanceMode                             InitStance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStanceComponent::ClientInitByReconnection(EStanceMode InitStance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StanceComponent", "ClientInitByReconnection");

	Params::StanceComponent_ClientInitByReconnection Parms{};

	Parms.InitStance = InitStance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.StanceComponent.OnRep_CurrentStance
// (Native, Public)

void UStanceComponent::OnRep_CurrentStance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StanceComponent", "OnRep_CurrentStance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.StanceComponent.ServerChangeStance
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// EStanceMode                             ToStance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UStanceComponent::ServerChangeStance(EStanceMode ToStance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StanceComponent", "ServerChangeStance");

	Params::StanceComponent_ServerChangeStance Parms{};

	Parms.ToStance = ToStance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.StanceComponent.ServerForceInitStance
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)

void UStanceComponent::ServerForceInitStance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StanceComponent", "ServerForceInitStance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslInstancedGlassWindowComponent.ClientNotifyHit
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    bBlockingHit                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              Location                                               (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal        ImpactNormal                                           (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   InstanceIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslInstancedGlassWindowComponent::ClientNotifyHit(bool bBlockingHit, const struct FVector_NetQuantize& Location, const struct FVector_NetQuantizeNormal& ImpactNormal, int32 InstanceIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslInstancedGlassWindowComponent", "ClientNotifyHit");

	Params::TslInstancedGlassWindowComponent_ClientNotifyHit Parms{};

	Parms.bBlockingHit = bBlockingHit;
	Parms.Location = std::move(Location);
	Parms.ImpactNormal = std::move(ImpactNormal);
	Parms.InstanceIndex = InstanceIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslInstancedGlassWindowComponent.OnRep_Destroyed
// (Final, Native, Protected)

void UTslInstancedGlassWindowComponent::OnRep_Destroyed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslInstancedGlassWindowComponent", "OnRep_Destroyed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslInstancedGlassWindowComponent.OnRep_PendingDestroy
// (Final, Native, Protected)

void UTslInstancedGlassWindowComponent::OnRep_PendingDestroy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslInstancedGlassWindowComponent", "OnRep_PendingDestroy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslInstancedGlassWindowComponent.OnRep_ReplicatedOnClient
// (Final, Native, Protected)
// Parameters:
// bool                                    bLastReplicatedOnClient                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslInstancedGlassWindowComponent::OnRep_ReplicatedOnClient(bool bLastReplicatedOnClient)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslInstancedGlassWindowComponent", "OnRep_ReplicatedOnClient");

	Params::TslInstancedGlassWindowComponent_OnRep_ReplicatedOnClient Parms{};

	Parms.bLastReplicatedOnClient = bLastReplicatedOnClient;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerStart.GetRandomStartLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector ATslPlayerStart::GetRandomStartLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerStart", "GetRandomStartLocation");

	Params::TslPlayerStart_GetRandomStartLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerStart.GetRandomStartYawRotation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslPlayerStart::GetRandomStartYawRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerStart", "GetRandomStartYawRotation");

	Params::TslPlayerStart_GetRandomStartYawRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.InventoryFacade.GetEquipment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AEquipment*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEquipment* AInventoryFacade::GetEquipment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryFacade", "GetEquipment");

	Params::InventoryFacade_GetEquipment Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.InventoryFacade.GetInventory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AInventory*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AInventory* AInventoryFacade::GetInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryFacade", "GetInventory");

	Params::InventoryFacade_GetInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.InventoryFacade.GiveItem_Admin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UItem>                ItemClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInventoryFacade::GiveItem_Admin(TSubclassOf<class UItem> ItemClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryFacade", "GiveItem_Admin");

	Params::InventoryFacade_GiveItem_Admin Parms{};

	Parms.ItemClass = ItemClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.InventoryFacade.GetOwnerCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslCharacter* AInventoryFacade::GetOwnerCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryFacade", "GetOwnerCharacter");

	Params::InventoryFacade_GetOwnerCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.InventoryFacade.HasItemByClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UItem>                ItemClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInventoryFacade::HasItemByClass(TSubclassOf<class UItem> ItemClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryFacade", "HasItemByClass");

	Params::InventoryFacade_HasItemByClass Parms{};

	Parms.ItemClass = ItemClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.InventoryFacade.IsAutoSwappable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEquipSlotID                            SlotID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInventoryFacade::IsAutoSwappable(EEquipSlotID SlotID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryFacade", "IsAutoSwappable");

	Params::InventoryFacade_IsAutoSwappable Parms{};

	Parms.SlotID = SlotID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Equipment.DetachItem
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FEquipPosition                   EquipPosition                                          (Parm, NativeAccessSpecifierPublic)
// FName                             ItemClassForVerify                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWeaponAttachmentSlotID                 SlotID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSoundPlay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEquipment::DetachItem(const struct FEquipPosition& EquipPosition, FName ItemClassForVerify, EWeaponAttachmentSlotID SlotID, bool bSoundPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Equipment", "DetachItem");

	Params::Equipment_DetachItem Parms{};

	Parms.EquipPosition = std::move(EquipPosition);
	Parms.ItemClassForVerify = ItemClassForVerify;
	Parms.SlotID = SlotID;
	Parms.bSoundPlay = bSoundPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.Equipment.DropAttachedItem
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FEquipPosition                   EquipPosition                                          (Parm, NativeAccessSpecifierPublic)
// FName                             ItemClassForVerify                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWeaponAttachmentSlotID                 SlotID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSoundPlay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEquipment::DropAttachedItem(const struct FEquipPosition& EquipPosition, FName ItemClassForVerify, EWeaponAttachmentSlotID SlotID, bool bSoundPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Equipment", "DropAttachedItem");

	Params::Equipment_DropAttachedItem Parms{};

	Parms.EquipPosition = std::move(EquipPosition);
	Parms.ItemClassForVerify = ItemClassForVerify;
	Parms.SlotID = SlotID;
	Parms.bSoundPlay = bSoundPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.Equipment.DropItem
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FEquipPosition                   Position                                               (Parm, NativeAccessSpecifierPublic)
// FName                             ItemClassForVerify                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsForce                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSoundPlay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEquipment::DropItem(const struct FEquipPosition& Position, FName ItemClassForVerify, bool bIsForce, bool bSoundPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Equipment", "DropItem");

	Params::Equipment_DropItem Parms{};

	Parms.Position = std::move(Position);
	Parms.ItemClassForVerify = ItemClassForVerify;
	Parms.bIsForce = bIsForce;
	Parms.bSoundPlay = bSoundPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.Equipment.EquipItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FEquipPosition                   Position                                               (Parm, NativeAccessSpecifierPublic)
// class UEquipableItem*                   Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCheckViaCanEquipTo                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSoundPlay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEquipment::EquipItem(const struct FEquipPosition& Position, class UEquipableItem* Item, bool bCheckViaCanEquipTo, bool bSoundPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Equipment", "EquipItem");

	Params::Equipment_EquipItem Parms{};

	Parms.Position = std::move(Position);
	Parms.Item = Item;
	Parms.bCheckViaCanEquipTo = bCheckViaCanEquipTo;
	Parms.bSoundPlay = bSoundPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Equipment.Items_RepNotify
// (Final, Native, Protected)

void AEquipment::Items_RepNotify()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Equipment", "Items_RepNotify");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.Equipment.PrimaryWeaponSwap
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FEquipPosition                   EquipPosition                                          (Parm, NativeAccessSpecifierPublic)
// class FString                           Options                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEquipment::PrimaryWeaponSwap(const struct FEquipPosition& EquipPosition, const class FString& Options)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Equipment", "PrimaryWeaponSwap");

	Params::Equipment_PrimaryWeaponSwap Parms{};

	Parms.EquipPosition = std::move(EquipPosition);
	Parms.Options = std::move(Options);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.Equipment.TryEquipItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UItem*                            Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSoundPlay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEquipment::TryEquipItem(class UItem* Item, bool bSoundPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Equipment", "TryEquipItem");

	Params::Equipment_TryEquipItem Parms{};

	Parms.Item = Item;
	Parms.bSoundPlay = bSoundPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Equipment.UnequipItem
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FEquipPosition                   Position                                               (Parm, NativeAccessSpecifierPublic)
// FName                             ItemClassForVerify                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSoundPlay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEquipment::UnequipItem(const struct FEquipPosition& Position, FName ItemClassForVerify, bool bSoundPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Equipment", "UnequipItem");

	Params::Equipment_UnequipItem Parms{};

	Parms.Position = std::move(Position);
	Parms.ItemClassForVerify = ItemClassForVerify;
	Parms.bSoundPlay = bSoundPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.Equipment.WeaponAttachmentSwap
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FEquipPosition                   SourceWeapon                                           (Parm, NativeAccessSpecifierPublic)
// struct FEquipPosition                   TargetWeapon                                           (Parm, NativeAccessSpecifierPublic)
// FName                             ItemClassForVerify                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWeaponAttachmentSlotID                 AttachmentSlotID                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSoundPlay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEquipment::WeaponAttachmentSwap(const struct FEquipPosition& SourceWeapon, const struct FEquipPosition& TargetWeapon, FName ItemClassForVerify, EWeaponAttachmentSlotID AttachmentSlotID, bool bSoundPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Equipment", "WeaponAttachmentSwap");

	Params::Equipment_WeaponAttachmentSwap Parms{};

	Parms.SourceWeapon = std::move(SourceWeapon);
	Parms.TargetWeapon = std::move(TargetWeapon);
	Parms.ItemClassForVerify = ItemClassForVerify;
	Parms.AttachmentSlotID = AttachmentSlotID;
	Parms.bSoundPlay = bSoundPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.Equipment.EquipPositionToWeaponIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FEquipPosition                   Position                                               (Parm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AEquipment::EquipPositionToWeaponIndex(const struct FEquipPosition& Position) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Equipment", "EquipPositionToWeaponIndex");

	Params::Equipment_EquipPositionToWeaponIndex Parms{};

	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Equipment.FindAttachableWeaponIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAttachableItem*                  AttachableItem                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Options                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AEquipment::FindAttachableWeaponIndex(class UAttachableItem* AttachableItem, const class FString& Options) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Equipment", "FindAttachableWeaponIndex");

	Params::Equipment_FindAttachableWeaponIndex Parms{};

	Parms.AttachableItem = AttachableItem;
	Parms.Options = std::move(Options);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Equipment.FindEquipableWeaponPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEquipableItem*                   EquipableItem                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Options                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEquipPosition                   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEquipPosition AEquipment::FindEquipableWeaponPosition(class UEquipableItem* EquipableItem, const class FString& Options) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Equipment", "FindEquipableWeaponPosition");

	Params::Equipment_FindEquipableWeaponPosition Parms{};

	Parms.EquipableItem = EquipableItem;
	Parms.Options = std::move(Options);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Equipment.FindEquipPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEquipSlotID                            SlotID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnlyFree                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEquipPosition                   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEquipPosition AEquipment::FindEquipPosition(EEquipSlotID SlotID, bool bOnlyFree) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Equipment", "FindEquipPosition");

	Params::Equipment_FindEquipPosition Parms{};

	Parms.SlotID = SlotID;
	Parms.bOnlyFree = bOnlyFree;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Equipment.FindPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UItem*                            Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEquipPosition                   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEquipPosition AEquipment::FindPosition(class UItem* Item) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Equipment", "FindPosition");

	Params::Equipment_FindPosition Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Equipment.GetInventoryFacade
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AInventoryFacade*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AInventoryFacade* AEquipment::GetInventoryFacade() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Equipment", "GetInventoryFacade");

	Params::Equipment_GetInventoryFacade Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Equipment.GetItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FEquipPosition                   Position                                               (Parm, NativeAccessSpecifierPublic)
// class UEquipableItem*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEquipableItem* AEquipment::GetItem(const struct FEquipPosition& Position) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Equipment", "GetItem");

	Params::Equipment_GetItem Parms{};

	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Equipment.GetItemCountByClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UItem>                ItemClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AEquipment::GetItemCountByClass(TSubclassOf<class UItem> ItemClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Equipment", "GetItemCountByClass");

	Params::Equipment_GetItemCountByClass Parms{};

	Parms.ItemClass = ItemClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Equipment.GetOwnerCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslCharacter* AEquipment::GetOwnerCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Equipment", "GetOwnerCharacter");

	Params::Equipment_GetOwnerCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Equipment.IsAttachableToWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   WeaponIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAttachableItem*                  AttachableItem                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnlyFree                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEquipment::IsAttachableToWeapon(int32 WeaponIndex, class UAttachableItem* AttachableItem, bool bOnlyFree) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Equipment", "IsAttachableToWeapon");

	Params::Equipment_IsAttachableToWeapon Parms{};

	Parms.WeaponIndex = WeaponIndex;
	Parms.AttachableItem = AttachableItem;
	Parms.bOnlyFree = bOnlyFree;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Equipment.IsSwapablePrimaryWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FEquipPosition                   EquipPosition                                          (Parm, NativeAccessSpecifierPublic)
// class FString                           Options                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEquipment::IsSwapablePrimaryWeapon(const struct FEquipPosition& EquipPosition, const class FString& Options) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Equipment", "IsSwapablePrimaryWeapon");

	Params::Equipment_IsSwapablePrimaryWeapon Parms{};

	Parms.EquipPosition = std::move(EquipPosition);
	Parms.Options = std::move(Options);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Equipment.WeaponIndexToEquipPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   WeaponIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEquipPosition                   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEquipPosition AEquipment::WeaponIndexToEquipPosition(int32 WeaponIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Equipment", "WeaponIndexToEquipPosition");

	Params::Equipment_WeaponIndexToEquipPosition Parms{};

	Parms.WeaponIndex = WeaponIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Inventory.AttachItem
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FName                             ItemClassForVerify                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEquipPosition                   EquipPosition                                          (Parm, NativeAccessSpecifierPublic)
// bool                                    bSoundPlay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInventory::AttachItem(int32 Index_0, FName ItemClassForVerify, const struct FEquipPosition& EquipPosition, bool bSoundPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "AttachItem");

	Params::Inventory_AttachItem Parms{};

	Parms.Index_0 = Index_0;
	Parms.ItemClassForVerify = ItemClassForVerify;
	Parms.EquipPosition = std::move(EquipPosition);
	Parms.bSoundPlay = bSoundPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.Inventory.AttachOrDropItem
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FName                             ItemClassForVerify                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSoundPlay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInventory::AttachOrDropItem(int32 Index_0, FName ItemClassForVerify, bool bSoundPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "AttachOrDropItem");

	Params::Inventory_AttachOrDropItem Parms{};

	Parms.Index_0 = Index_0;
	Parms.ItemClassForVerify = ItemClassForVerify;
	Parms.bSoundPlay = bSoundPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.Inventory.ClientBroadcastNoBagSpaceEvent
// (Net, Native, Event, Public, NetClient)

void AInventory::ClientBroadcastNoBagSpaceEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "ClientBroadcastNoBagSpaceEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.Inventory.ConsumeItemByClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UItem>                ItemClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInventory::ConsumeItemByClass(TSubclassOf<class UItem> ItemClass, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "ConsumeItemByClass");

	Params::Inventory_ConsumeItemByClass Parms{};

	Parms.ItemClass = ItemClass;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Inventory.DropItem
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FName                             ItemClassForVerify                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Options                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSoundPlay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInventory::DropItem(int32 Index_0, FName ItemClassForVerify, const class FString& Options, bool bSoundPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "DropItem");

	Params::Inventory_DropItem Parms{};

	Parms.Index_0 = Index_0;
	Parms.ItemClassForVerify = ItemClassForVerify;
	Parms.Options = std::move(Options);
	Parms.bSoundPlay = bSoundPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.Inventory.EquipItem
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FName                             ItemClassForVerify                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSoundPlay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInventory::EquipItem(int32 Index_0, FName ItemClassForVerify, bool bSoundPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "EquipItem");

	Params::Inventory_EquipItem Parms{};

	Parms.Index_0 = Index_0;
	Parms.ItemClassForVerify = ItemClassForVerify;
	Parms.bSoundPlay = bSoundPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.Inventory.EquipOrDropItem
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FName                             ItemClassForVerify                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSoundPlay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInventory::EquipOrDropItem(int32 Index_0, FName ItemClassForVerify, bool bSoundPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "EquipOrDropItem");

	Params::Inventory_EquipOrDropItem Parms{};

	Parms.Index_0 = Index_0;
	Parms.ItemClassForVerify = ItemClassForVerify;
	Parms.bSoundPlay = bSoundPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.Inventory.FindItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UItem>                ItemClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItem*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UItem* AInventory::FindItem(TSubclassOf<class UItem> ItemClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "FindItem");

	Params::Inventory_FindItem Parms{};

	Parms.ItemClass = ItemClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Inventory.FindItemHasMinStack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UItem>                ItemClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItem*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UItem* AInventory::FindItemHasMinStack(TSubclassOf<class UItem> ItemClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "FindItemHasMinStack");

	Params::Inventory_FindItemHasMinStack Parms{};

	Parms.ItemClass = ItemClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Inventory.Items_RepNotify
// (Final, Native, Protected)

void AInventory::Items_RepNotify()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "Items_RepNotify");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.Inventory.OnFinishUseCast
// (Final, Native, Private)
// Parameters:
// class UObject*                          CastObject                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInventory::OnFinishUseCast(class UObject* CastObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "OnFinishUseCast");

	Params::Inventory_OnFinishUseCast Parms{};

	Parms.CastObject = CastObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.Inventory.UseItem
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FName                             ItemClassForVerify                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInventory::UseItem(int32 Index_0, FName ItemClassForVerify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "UseItem");

	Params::Inventory_UseItem Parms{};

	Parms.Index_0 = Index_0;
	Parms.ItemClassForVerify = ItemClassForVerify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.Inventory.FindItemIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UItem*                            Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AInventory::FindItemIndex(class UItem* Item) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "FindItemIndex");

	Params::Inventory_FindItemIndex Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Inventory.GetAdditionalMaxCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UItem*                            Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AInventory::GetAdditionalMaxCount(class UItem* Item) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "GetAdditionalMaxCount");

	Params::Inventory_GetAdditionalMaxCount Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Inventory.GetAllItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FInventoryItem>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FInventoryItem> AInventory::GetAllItems() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "GetAllItems");

	Params::Inventory_GetAllItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Inventory.GetAllItemsByType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UItem>                ItemSuperClass                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FInventoryItem>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FInventoryItem> AInventory::GetAllItemsByType(TSubclassOf<class UItem> ItemSuperClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "GetAllItemsByType");

	Params::Inventory_GetAllItemsByType Parms{};

	Parms.ItemSuperClass = ItemSuperClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Inventory.GetCurrentSpace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AInventory::GetCurrentSpace() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "GetCurrentSpace");

	Params::Inventory_GetCurrentSpace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Inventory.GetInventoryFacade
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AInventoryFacade*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AInventoryFacade* AInventory::GetInventoryFacade() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "GetInventoryFacade");

	Params::Inventory_GetInventoryFacade Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Inventory.GetItemCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AInventory::GetItemCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "GetItemCount");

	Params::Inventory_GetItemCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Inventory.GetItemCountByClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UItem>                ItemClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AInventory::GetItemCountByClass(TSubclassOf<class UItem> ItemClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "GetItemCountByClass");

	Params::Inventory_GetItemCountByClass Parms{};

	Parms.ItemClass = ItemClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Inventory.GetMaxSpace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AInventory::GetMaxSpace() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "GetMaxSpace");

	Params::Inventory_GetMaxSpace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Inventory.GetOwnerCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslCharacter* AInventory::GetOwnerCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "GetOwnerCharacter");

	Params::Inventory_GetOwnerCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.ItemExplorerProxy.Pop
// (Final, Native, Public, BlueprintCallable)

void AItemExplorerProxy::Pop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemExplorerProxy", "Pop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.ItemExplorerProxy.PropagateCreateAndShowContextMenuWidget
// (Final, Native, Private)
// Parameters:
// TScriptInterface<class ISlotContainerInterface>Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

void AItemExplorerProxy::PropagateCreateAndShowContextMenuWidget(TScriptInterface<class ISlotContainerInterface> Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemExplorerProxy", "PropagateCreateAndShowContextMenuWidget");

	Params::ItemExplorerProxy_PropagateCreateAndShowContextMenuWidget Parms{};

	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.ItemExplorerProxy.PropagateDestroyContextMenuWidget
// (Final, Native, Private)

void AItemExplorerProxy::PropagateDestroyContextMenuWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemExplorerProxy", "PropagateDestroyContextMenuWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.ItemExplorerProxy.PropagateUpdateItemList
// (Final, Native, Private)

void AItemExplorerProxy::PropagateUpdateItemList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemExplorerProxy", "PropagateUpdateItemList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.ItemExplorerProxy.IsBaseExplorer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AItemExplorerProxy::IsBaseExplorer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemExplorerProxy", "IsBaseExplorer");

	Params::ItemExplorerProxy_IsBaseExplorer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CarePackageItem.IsFalling
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACarePackageItem::IsFalling() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarePackageItem", "IsFalling");

	Params::CarePackageItem_IsFalling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CarePackageItem.IsPickupedItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACarePackageItem::IsPickupedItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarePackageItem", "IsPickupedItem");

	Params::CarePackageItem_IsPickupedItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPawnInputBindingComponent.NotifyOwnerPossessed
// (Final, Native, Public)
// Parameters:
// class ATslPlayerController*             InController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslPawnInputBindingComponent::NotifyOwnerPossessed(class ATslPlayerController* InController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPawnInputBindingComponent", "NotifyOwnerPossessed");

	Params::TslPawnInputBindingComponent_NotifyOwnerPossessed Parms{};

	Parms.InController = InController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPawnInputBindingComponent.NotifyOwnerUnPossessed
// (Final, Native, Public)
// Parameters:
// class ATslPlayerController*             InController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslPawnInputBindingComponent::NotifyOwnerUnPossessed(class ATslPlayerController* InController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPawnInputBindingComponent", "NotifyOwnerUnPossessed");

	Params::TslPawnInputBindingComponent_NotifyOwnerUnPossessed Parms{};

	Parms.InController = InController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.Team.OnRep_Dying
// (Final, Native, Public)
// Parameters:
// bool                                    bLastDying                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATeam::OnRep_Dying(bool bLastDying)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Team", "OnRep_Dying");

	Params::Team_OnRep_Dying Parms{};

	Parms.bLastDying = bLastDying;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.Team.ServerSetMapMarkerPosition
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, BlueprintCallable, NetValidate)
// Parameters:
// struct FVector2D                        NewMapMarkerPosition                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ATeam::ServerSetMapMarkerPosition(const struct FVector2D& NewMapMarkerPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Team", "ServerSetMapMarkerPosition");

	Params::Team_ServerSetMapMarkerPosition Parms{};

	Parms.NewMapMarkerPosition = std::move(NewMapMarkerPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.Team.ServerSetShowMapMarker
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
// bool                                    bNewShowMapMarker                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATeam::ServerSetShowMapMarker(bool bNewShowMapMarker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Team", "ServerSetShowMapMarker");

	Params::Team_ServerSetShowMapMarker Parms{};

	Parms.bNewShowMapMarker = bNewShowMapMarker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.Team.GetGroggyHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATeam::GetGroggyHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Team", "GetGroggyHealth");

	Params::Team_GetGroggyHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Team.GetGroggyHealthMax
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATeam::GetGroggyHealthMax() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Team", "GetGroggyHealthMax");

	Params::Team_GetGroggyHealthMax Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Team.GetHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATeam::GetHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Team", "GetHealth");

	Params::Team_GetHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Team.GetHealthMax
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATeam::GetHealthMax() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Team", "GetHealthMax");

	Params::Team_GetHealthMax Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Team.GetMapMarkerPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector2D ATeam::GetMapMarkerPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Team", "GetMapMarkerPosition");

	Params::Team_GetMapMarkerPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Team.GetMemberNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ATeam::GetMemberNumber() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Team", "GetMemberNumber");

	Params::Team_GetMemberNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Team.GetPlayerLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector ATeam::GetPlayerLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Team", "GetPlayerLocation");

	Params::Team_GetPlayerLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Team.GetPlayerName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ATeam::GetPlayerName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Team", "GetPlayerName");

	Params::Team_GetPlayerName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Team.GetPlayerRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ATeam::GetPlayerRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Team", "GetPlayerRotation");

	Params::Team_GetPlayerRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Team.GetPlayerUniqueId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ATeam::GetPlayerUniqueId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Team", "GetPlayerUniqueId");

	Params::Team_GetPlayerUniqueId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Team.GetRideVehicle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETeamVehicleType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETeamVehicleType ATeam::GetRideVehicle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Team", "GetRideVehicle");

	Params::Team_GetRideVehicle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Team.GetTslCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslCharacter* ATeam::GetTslCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Team", "GetTslCharacter");

	Params::Team_GetTslCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Team.IsDying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATeam::IsDying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Team", "IsDying");

	Params::Team_IsDying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Team.IsGroggying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATeam::IsGroggying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Team", "IsGroggying");

	Params::Team_IsGroggying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Team.IsQuitter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATeam::IsQuitter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Team", "IsQuitter");

	Params::Team_IsQuitter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.Team.IsShowMapMarker
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATeam::IsShowMapMarker() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Team", "IsShowMapMarker");

	Params::Team_IsShowMapMarker Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslProjectile.CheckVelocityForStart
// (Final, Native, Protected)

void ATslProjectile::CheckVelocityForStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslProjectile", "CheckVelocityForStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslProjectile.ExplodeBP
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FHitResult                       Impact                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslProjectile::ExplodeBP(const struct FVector& Location, const struct FRotator& Rotation, const struct FHitResult& Impact, float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslProjectile", "ExplodeBP");

	Params::TslProjectile_ExplodeBP Parms{};

	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.Impact = std::move(Impact);
	Parms.Radius = Radius;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TslGame.TslProjectile.OnHit
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ATslProjectile::OnHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslProjectile", "OnHit");

	Params::TslProjectile_OnHit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslProjectile.OnImpact
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// struct FHitResult                       ImpactResult                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ImpactVelocity                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ATslProjectile::OnImpact(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslProjectile", "OnImpact");

	Params::TslProjectile_OnImpact Parms{};

	Parms.ImpactResult = std::move(ImpactResult);
	Parms.ImpactVelocity = std::move(ImpactVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslProjectile.OnRep_ActiveParticle
// (Final, Native, Protected)

void ATslProjectile::OnRep_ActiveParticle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslProjectile", "OnRep_ActiveParticle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslProjectile.OnRep_ClientActivate
// (Final, Native, Protected)

void ATslProjectile::OnRep_ClientActivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslProjectile", "OnRep_ClientActivate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslProjectile.OnRep_Exploded
// (Final, Native, Protected)

void ATslProjectile::OnRep_Exploded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslProjectile", "OnRep_Exploded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslProjectile.SetMeshRotationFromServer
// (Final, Native, Protected)

void ATslProjectile::SetMeshRotationFromServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslProjectile", "SetMeshRotationFromServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAccessoryComponent.InitSetupComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSimulatePhysics                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslAccessoryComponent::InitSetupComponent(bool bSimulatePhysics)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAccessoryComponent", "InitSetupComponent");

	Params::TslAccessoryComponent_InitSetupComponent Parms{};

	Parms.bSimulatePhysics = bSimulatePhysics;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAccessoryComponent.SetPhysicsSimulation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSimulatePhysics                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslAccessoryComponent::SetPhysicsSimulation(bool bSimulatePhysics)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAccessoryComponent", "SetPhysicsSimulation");

	Params::TslAccessoryComponent_SetPhysicsSimulation Parms{};

	Parms.bSimulatePhysics = bSimulatePhysics;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslParticle.GetEmitterGlobalSpawnRateScale
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslParticle::GetEmitterGlobalSpawnRateScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslParticle", "GetEmitterGlobalSpawnRateScale");

	Params::TslParticle_GetEmitterGlobalSpawnRateScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslParticle.AttachToParent
// (Final, Native, Protected)

void ATslParticle::AttachToParent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslParticle", "AttachToParent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslParticle.ForceSpawn
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   emitterIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InLocation                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ATslParticle::ForceSpawn(int32 emitterIndex, const struct FVector& InLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslParticle", "ForceSpawn");

	Params::TslParticle_ForceSpawn Parms{};

	Parms.emitterIndex = emitterIndex;
	Parms.InLocation = std::move(InLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslParticle.OnParameterUpdated
// (Event, Protected, BlueprintEvent)

void ATslParticle::OnParameterUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslParticle", "OnParameterUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TslGame.TslParticle.OnParticleCollide
// (Final, Native, Public, HasDefaults)
// Parameters:
// FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EmitterTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ParticleTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Velocity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Normal                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPhysicalMaterial*                PhysMat                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslParticle::OnParticleCollide(FName EventName, float EmitterTime, int32 ParticleTime, const struct FVector& Location, const struct FVector& Velocity, const struct FVector& Direction, const struct FVector& Normal, FName BoneName, class UPhysicalMaterial* PhysMat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslParticle", "OnParticleCollide");

	Params::TslParticle_OnParticleCollide Parms{};

	Parms.EventName = EventName;
	Parms.EmitterTime = EmitterTime;
	Parms.ParticleTime = ParticleTime;
	Parms.Location = std::move(Location);
	Parms.Velocity = std::move(Velocity);
	Parms.Direction = std::move(Direction);
	Parms.Normal = std::move(Normal);
	Parms.BoneName = BoneName;
	Parms.PhysMat = PhysMat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslParticle.OnParticleFinish
// (Final, Native, Protected)
// Parameters:
// class UParticleSystemComponent*         PSystem                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslParticle::OnParticleFinish(class UParticleSystemComponent* PSystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslParticle", "OnParticleFinish");

	Params::TslParticle_OnParticleFinish Parms{};

	Parms.PSystem = PSystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslParticle.SetParticleParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableRTPC                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslParticle::SetParticleParameter(const class FString& Name_0, float Value, bool bEnableRTPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslParticle", "SetParticleParameter");

	Params::TslParticle_SetParticleParameter Parms{};

	Parms.Name_0 = std::move(Name_0);
	Parms.Value = Value;
	Parms.bEnableRTPC = bEnableRTPC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslParticle.GetParticleParamter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DefaultValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslParticle::GetParticleParamter(const class FString& Name_0, float DefaultValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslParticle", "GetParticleParamter");

	Params::TslParticle_GetParticleParamter Parms{};

	Parms.Name_0 = std::move(Name_0);
	Parms.DefaultValue = DefaultValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslAIController.FindClosestEnemy
// (Final, Native, Public, BlueprintCallable)

void ATslAIController::FindClosestEnemy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAIController", "FindClosestEnemy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAIController.FindClosestEnemyWithLOS
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ATslCharacter*                    ExcludeEnemy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslAIController::FindClosestEnemyWithLOS(class ATslCharacter* ExcludeEnemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAIController", "FindClosestEnemyWithLOS");

	Params::TslAIController_FindClosestEnemyWithLOS Parms{};

	Parms.ExcludeEnemy = ExcludeEnemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslAIController.ShootEnemy
// (Final, Native, Public, BlueprintCallable)

void ATslAIController::ShootEnemy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAIController", "ShootEnemy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Projectile.ServerFireProjectile
// (Net, NetReliable, Native, Event, Protected, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FVector                          Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal        ShootDir                                               (Parm, NativeAccessSpecifierPublic)

void ATslWeapon_Projectile::ServerFireProjectile(const struct FVector& Origin, const struct FVector_NetQuantizeNormal& ShootDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Projectile", "ServerFireProjectile");

	Params::TslWeapon_Projectile_ServerFireProjectile Parms{};

	Parms.Origin = std::move(Origin);
	Parms.ShootDir = std::move(ShootDir);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.AircraftCarePackage.IsPlayInEditor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAircraftCarePackage::IsPlayInEditor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AircraftCarePackage", "IsPlayInEditor");

	Params::AircraftCarePackage_IsPlayInEditor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TransportAircraftVehicle.AllowInteractBy
// (Final, Native, Private)
// Parameters:
// class ATslCharacter*                    Character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATransportAircraftVehicle::AllowInteractBy(const class ATslCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransportAircraftVehicle", "AllowInteractBy");

	Params::TransportAircraftVehicle_AllowInteractBy Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TransportAircraftVehicle.EjectAll
// (Final, Native, Public)

void ATransportAircraftVehicle::EjectAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransportAircraftVehicle", "EjectAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TransportAircraftVehicle.EnterAtEjectionArea
// (Final, Native, Public)

void ATransportAircraftVehicle::EnterAtEjectionArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransportAircraftVehicle", "EnterAtEjectionArea");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TransportAircraftVehicle.OnInteractBy
// (Final, Native, Private)
// Parameters:
// class ATslCharacter*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransportAircraftVehicle::OnInteractBy(class ATslCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransportAircraftVehicle", "OnInteractBy");

	Params::TransportAircraftVehicle_OnInteractBy Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TransportAircraftVehicle.OnLeave
// (Final, Native, Private)
// Parameters:
// class ATslCharacter*                    Rider                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVehicleSeatInteractionComponent* Seat                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransportAircraftVehicle::OnLeave(class ATslCharacter* Rider, class UVehicleSeatInteractionComponent* Seat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransportAircraftVehicle", "OnLeave");

	Params::TransportAircraftVehicle_OnLeave Parms{};

	Parms.Rider = Rider;
	Parms.Seat = Seat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TransportAircraftVehicle.OnLocalPlayerLeave
// (Event, Public, BlueprintEvent)

void ATransportAircraftVehicle::OnLocalPlayerLeave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransportAircraftVehicle", "OnLocalPlayerLeave");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TslGame.TransportAircraftVehicle.OnLocalPlayerRide
// (Event, Public, BlueprintEvent)

void ATransportAircraftVehicle::OnLocalPlayerRide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransportAircraftVehicle", "OnLocalPlayerRide");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TslGame.TransportAircraftVehicle.OnRide
// (Final, Native, Private)
// Parameters:
// class ATslCharacter*                    Rider                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVehicleSeatInteractionComponent* Seat                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATransportAircraftVehicle::OnRide(class ATslCharacter* Rider, class UVehicleSeatInteractionComponent* Seat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransportAircraftVehicle", "OnRide");

	Params::TransportAircraftVehicle_OnRide Parms{};

	Parms.Rider = Rider;
	Parms.Seat = Seat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TransportAircraftVehicle.IsInEjectionArea
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATransportAircraftVehicle::IsInEjectionArea() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TransportAircraftVehicle", "IsInEjectionArea");

	Params::TransportAircraftVehicle_IsInEjectionArea Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWheeledVehicle.ActivationTriggerBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OverlapInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ATslWheeledVehicle::ActivationTriggerBeginOverlap(class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& OverlapInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "ActivationTriggerBeginOverlap");

	Params::TslWheeledVehicle_ActivationTriggerBeginOverlap Parms{};

	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.OverlapInfo = std::move(OverlapInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicle.ActivationTriggerEndOverlap
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWheeledVehicle::ActivationTriggerEndOverlap(class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "ActivationTriggerEndOverlap");

	Params::TslWheeledVehicle_ActivationTriggerEndOverlap Parms{};

	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicle.BindCallbackToHUD
// (Final, Native, Protected)
// Parameters:
// class ATslPlayerController*             InController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWheeledVehicle::BindCallbackToHUD(class ATslPlayerController* InController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "BindCallbackToHUD");

	Params::TslWheeledVehicle_BindCallbackToHUD Parms{};

	Parms.InController = InController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicle.MulticastCharacterHitEffects
// (Net, Native, Event, NetMulticast, Protected)
// Parameters:
// class ATslCharacter*                    CharacterHit                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HitDamage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWheeledVehicle::MulticastCharacterHitEffects(class ATslCharacter* CharacterHit, float HitDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "MulticastCharacterHitEffects");

	Params::TslWheeledVehicle_MulticastCharacterHitEffects Parms{};

	Parms.CharacterHit = CharacterHit;
	Parms.HitDamage = HitDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicle.MulticastSetInstantHorn
// (Net, NetReliable, Native, Event, NetMulticast, Protected, NetValidate)
// Parameters:
// struct FHornPlayInfo                    InHornPlayInfo                                         (Parm, NativeAccessSpecifierPublic)

void ATslWheeledVehicle::MulticastSetInstantHorn(const struct FHornPlayInfo& InHornPlayInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "MulticastSetInstantHorn");

	Params::TslWheeledVehicle_MulticastSetInstantHorn Parms{};

	Parms.InHornPlayInfo = std::move(InHornPlayInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicle.OnBlockingWidgetOpened
// (Final, Native, Protected)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWheeledVehicle::OnBlockingWidgetOpened(class UWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "OnBlockingWidgetOpened");

	Params::TslWheeledVehicle_OnBlockingWidgetOpened Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicle.OnBreak
// (Final, Native, Private)

void ATslWheeledVehicle::OnBreak()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "OnBreak");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicle.OnCharacterHit
// (Final, Native, Private)
// Parameters:
// class ATslCharacter*                    HitCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HitDamage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWheeledVehicle::OnCharacterHit(class ATslCharacter* HitCharacter, float HitDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "OnCharacterHit");

	Params::TslWheeledVehicle_OnCharacterHit Parms{};

	Parms.HitCharacter = HitCharacter;
	Parms.HitDamage = HitDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicle.OnHornEnd
// (Final, Native, Protected)

void ATslWheeledVehicle::OnHornEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "OnHornEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicle.OnHornKeyDown
// (Final, Native, Protected)

void ATslWheeledVehicle::OnHornKeyDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "OnHornKeyDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicle.OnHornKeyUp
// (Final, Native, Protected)

void ATslWheeledVehicle::OnHornKeyUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "OnHornKeyUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicle.OnPostDriverLeave
// (Native, Public)

void ATslWheeledVehicle::OnPostDriverLeave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "OnPostDriverLeave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicle.OnPostDriverRide
// (Native, Public)

void ATslWheeledVehicle::OnPostDriverRide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "OnPostDriverRide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicle.OnRep_SetHornPlayInfo
// (Final, Native, Protected)

void ATslWheeledVehicle::OnRep_SetHornPlayInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "OnRep_SetHornPlayInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicle.OnRide
// (Final, Native, Private)
// Parameters:
// class ATslCharacter*                    Rider                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVehicleSeatInteractionComponent* Seat                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWheeledVehicle::OnRide(class ATslCharacter* Rider, class UVehicleSeatInteractionComponent* Seat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "OnRide");

	Params::TslWheeledVehicle_OnRide Parms{};

	Parms.Rider = Rider;
	Parms.Seat = Seat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicle.OnVehicleEjected
// (Native, Public)

void ATslWheeledVehicle::OnVehicleEjected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "OnVehicleEjected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicle.PlayHorn
// (Final, Native, Protected)
// Parameters:
// bool                                    bIsLocalPlay                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHornSoundType                          InHornSoundType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWheeledVehicle::PlayHorn(bool bIsLocalPlay, EHornSoundType InHornSoundType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "PlayHorn");

	Params::TslWheeledVehicle_PlayHorn Parms{};

	Parms.bIsLocalPlay = bIsLocalPlay;
	Parms.InHornSoundType = InHornSoundType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicle.PlayInstantHorn
// (Final, Native, Protected)

void ATslWheeledVehicle::PlayInstantHorn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "PlayInstantHorn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicle.ServerSetBoosting
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                                    bNewBoosting                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWheeledVehicle::ServerSetBoosting(bool bNewBoosting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "ServerSetBoosting");

	Params::TslWheeledVehicle_ServerSetBoosting Parms{};

	Parms.bNewBoosting = bNewBoosting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicle.ServerSetHorn
// (Net, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// struct FHornPlayInfo                    InHornPlayInfo                                         (Parm, NativeAccessSpecifierPublic)

void ATslWheeledVehicle::ServerSetHorn(const struct FHornPlayInfo& InHornPlayInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "ServerSetHorn");

	Params::TslWheeledVehicle_ServerSetHorn Parms{};

	Parms.InHornPlayInfo = std::move(InHornPlayInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicle.SetAirControlPitchInput
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InInput                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWheeledVehicle::SetAirControlPitchInput(float InInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "SetAirControlPitchInput");

	Params::TslWheeledVehicle_SetAirControlPitchInput Parms{};

	Parms.InInput = InInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicle.TickHorn
// (Final, Native, Protected)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWheeledVehicle::TickHorn(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "TickHorn");

	Params::TslWheeledVehicle_TickHorn Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicle.UnBindCallbackToHUD
// (Final, Native, Protected)
// Parameters:
// class ATslPlayerController*             InController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWheeledVehicle::UnBindCallbackToHUD(class ATslPlayerController* InController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "UnBindCallbackToHUD");

	Params::TslWheeledVehicle_UnBindCallbackToHUD Parms{};

	Parms.InController = InController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicle.UpdateBasicInfoCaching
// (Native, Public, BlueprintCallable)

void ATslWheeledVehicle::UpdateBasicInfoCaching()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "UpdateBasicInfoCaching");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicle.UpdateWheelCaching
// (Native, Public, BlueprintCallable)

void ATslWheeledVehicle::UpdateWheelCaching()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "UpdateWheelCaching");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicle.UpdateWheelSound
// (Native, Public, BlueprintCallable)

void ATslWheeledVehicle::UpdateWheelSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "UpdateWheelSound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicle.GetAirControlPitchInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslWheeledVehicle::GetAirControlPitchInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "GetAirControlPitchInput");

	Params::TslWheeledVehicle_GetAirControlPitchInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWheeledVehicle.GetBuffComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBuffComponet*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBuffComponet* ATslWheeledVehicle::GetBuffComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "GetBuffComponent");

	Params::TslWheeledVehicle_GetBuffComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWheeledVehicle.GetCurrentWaterSurfaceZ
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslWheeledVehicle::GetCurrentWaterSurfaceZ() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "GetCurrentWaterSurfaceZ");

	Params::TslWheeledVehicle_GetCurrentWaterSurfaceZ Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWheeledVehicle.GetSteeringInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslWheeledVehicle::GetSteeringInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "GetSteeringInput");

	Params::TslWheeledVehicle_GetSteeringInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWheeledVehicle.GetTslVehicleMovement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTslWheeledVehicleMovement*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTslWheeledVehicleMovement* ATslWheeledVehicle::GetTslVehicleMovement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "GetTslVehicleMovement");

	Params::TslWheeledVehicle_GetTslVehicleMovement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWheeledVehicle.IsBoosting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslWheeledVehicle::IsBoosting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "IsBoosting");

	Params::TslWheeledVehicle_IsBoosting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWheeledVehicle.IsEnabledOptimizeTick
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslWheeledVehicle::IsEnabledOptimizeTick() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "IsEnabledOptimizeTick");

	Params::TslWheeledVehicle_IsEnabledOptimizeTick Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWheeledVehicle.IsInWaterVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslWheeledVehicle::IsInWaterVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "IsInWaterVolume");

	Params::TslWheeledVehicle_IsInWaterVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWheeledVehicle.IsStabilizeOverrideEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslWheeledVehicle::IsStabilizeOverrideEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "IsStabilizeOverrideEnabled");

	Params::TslWheeledVehicle_IsStabilizeOverrideEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWheeledVehicle.IsStablizeOverrideActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslWheeledVehicle::IsStablizeOverrideActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "IsStablizeOverrideActive");

	Params::TslWheeledVehicle_IsStablizeOverrideActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWheeledVehicle.IsSunken
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslWheeledVehicle::IsSunken() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicle", "IsSunken");

	Params::TslWheeledVehicle_IsSunken Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslFloatingVehicle.GetSteerYawAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslFloatingVehicle::GetSteerYawAngle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFloatingVehicle", "GetSteerYawAngle");

	Params::TslFloatingVehicle_GetSteerYawAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslFloatingVehicle.GetVehicleAcceleration
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector ATslFloatingVehicle::GetVehicleAcceleration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFloatingVehicle", "GetVehicleAcceleration");

	Params::TslFloatingVehicle_GetVehicleAcceleration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslFloatingVehicle.GetVehicleEngineImmersionDepth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslFloatingVehicle::GetVehicleEngineImmersionDepth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFloatingVehicle", "GetVehicleEngineImmersionDepth");

	Params::TslFloatingVehicle_GetVehicleEngineImmersionDepth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslFloatingVehicle.IsBoosting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslFloatingVehicle::IsBoosting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFloatingVehicle", "IsBoosting");

	Params::TslFloatingVehicle_IsBoosting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWheeledVehicleMovement.ClientPunctureTire
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// int32                                   WheelIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslWheeledVehicleMovement::ClientPunctureTire(int32 WheelIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicleMovement", "ClientPunctureTire");

	Params::TslWheeledVehicleMovement_ClientPunctureTire Parms{};

	Parms.WheelIndex = WheelIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicleMovement.OnBreak
// (Final, Native, Public)

void UTslWheeledVehicleMovement::OnBreak()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicleMovement", "OnBreak");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicleMovement.OnDriverLeave
// (Final, Native, Public)

void UTslWheeledVehicleMovement::OnDriverLeave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicleMovement", "OnDriverLeave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicleMovement.OnDriverRide
// (Final, Native, Public)

void UTslWheeledVehicleMovement::OnDriverRide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicleMovement", "OnDriverRide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicleMovement.ServerUpdateAdditionalState
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   TargetGear                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslWheeledVehicleMovement::ServerUpdateAdditionalState(int32 TargetGear)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicleMovement", "ServerUpdateAdditionalState");

	Params::TslWheeledVehicleMovement_ServerUpdateAdditionalState Parms{};

	Parms.TargetGear = TargetGear;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicleMovement.SetSimulateVehicle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSimulate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslWheeledVehicleMovement::SetSimulateVehicle(bool bSimulate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicleMovement", "SetSimulateVehicle");

	Params::TslWheeledVehicleMovement_SetSimulateVehicle Parms{};

	Parms.bSimulate = bSimulate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWheeledVehicleMovement.GetBrakeInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslWheeledVehicleMovement::GetBrakeInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicleMovement", "GetBrakeInput");

	Params::TslWheeledVehicleMovement_GetBrakeInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWheeledVehicleMovement.GetHandbrakeInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslWheeledVehicleMovement::GetHandbrakeInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicleMovement", "GetHandbrakeInput");

	Params::TslWheeledVehicleMovement_GetHandbrakeInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWheeledVehicleMovement.GetSteeringInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslWheeledVehicleMovement::GetSteeringInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicleMovement", "GetSteeringInput");

	Params::TslWheeledVehicleMovement_GetSteeringInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWheeledVehicleMovement.GetSteeringInputClamped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslWheeledVehicleMovement::GetSteeringInputClamped() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicleMovement", "GetSteeringInputClamped");

	Params::TslWheeledVehicleMovement_GetSteeringInputClamped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWheeledVehicleMovement.GetThrottleInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslWheeledVehicleMovement::GetThrottleInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicleMovement", "GetThrottleInput");

	Params::TslWheeledVehicleMovement_GetThrottleInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWheeledVehicleMovement.GetWheelContactData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinVelocity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinSkid                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinSpin                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SuspOffsetForContact                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FWheelContactData                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FWheelContactData UTslWheeledVehicleMovement::GetWheelContactData(int32 Index_0, float MinVelocity, float MinSkid, float MinSpin, float SuspOffsetForContact) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicleMovement", "GetWheelContactData");

	Params::TslWheeledVehicleMovement_GetWheelContactData Parms{};

	Parms.Index_0 = Index_0;
	Parms.MinVelocity = MinVelocity;
	Parms.MinSkid = MinSkid;
	Parms.MinSpin = MinSpin;
	Parms.SuspOffsetForContact = SuspOffsetForContact;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWheeledVehicleMovement.GetWheelContactSurfaceMaterial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPhysicalMaterial*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPhysicalMaterial* UTslWheeledVehicleMovement::GetWheelContactSurfaceMaterial(int32 Index_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicleMovement", "GetWheelContactSurfaceMaterial");

	Params::TslWheeledVehicleMovement_GetWheelContactSurfaceMaterial Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWheeledVehicleMovement.GetWheelContactType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinVelocity                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinSkid                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinSpin                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SuspOffsetForContact                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWheelContactType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWheelContactType UTslWheeledVehicleMovement::GetWheelContactType(int32 Index_0, float MinVelocity, float MinSkid, float MinSpin, float SuspOffsetForContact) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicleMovement", "GetWheelContactType");

	Params::TslWheeledVehicleMovement_GetWheelContactType Parms{};

	Parms.Index_0 = Index_0;
	Parms.MinVelocity = MinVelocity;
	Parms.MinSkid = MinSkid;
	Parms.MinSpin = MinSpin;
	Parms.SuspOffsetForContact = SuspOffsetForContact;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWheeledVehicleMovement.GetWheelHealthPercentages
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<float>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<float> UTslWheeledVehicleMovement::GetWheelHealthPercentages() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicleMovement", "GetWheelHealthPercentages");

	Params::TslWheeledVehicleMovement_GetWheelHealthPercentages Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWheeledVehicleMovement.GetWheelRotationSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslWheeledVehicleMovement::GetWheelRotationSpeed(int32 Index_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicleMovement", "GetWheelRotationSpeed");

	Params::TslWheeledVehicleMovement_GetWheelRotationSpeed Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWheeledVehicleMovement.GetWheelSuspensionMaxDrop
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslWheeledVehicleMovement::GetWheelSuspensionMaxDrop(int32 Index_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicleMovement", "GetWheelSuspensionMaxDrop");

	Params::TslWheeledVehicleMovement_GetWheelSuspensionMaxDrop Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWheeledVehicleMovement.GetWheelSuspensionMaxRaise
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslWheeledVehicleMovement::GetWheelSuspensionMaxRaise(int32 Index_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicleMovement", "GetWheelSuspensionMaxRaise");

	Params::TslWheeledVehicleMovement_GetWheelSuspensionMaxRaise Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWheeledVehicleMovement.GetWheelWaterDepth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslWheeledVehicleMovement::GetWheelWaterDepth(int32 Index_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicleMovement", "GetWheelWaterDepth");

	Params::TslWheeledVehicleMovement_GetWheelWaterDepth Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWheeledVehicleMovement.IsSimulatingVehicle
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslWheeledVehicleMovement::IsSimulatingVehicle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWheeledVehicleMovement", "IsSimulatingVehicle");

	Params::TslWheeledVehicleMovement_IsSimulatingVehicle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslFloatingVehicleMovement.OnDriverLeave
// (Final, Native, Private)

void UTslFloatingVehicleMovement::OnDriverLeave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFloatingVehicleMovement", "OnDriverLeave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslFloatingVehicleMovement.ServerUpdateInput
// (Final, Net, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// float                                   InForwardInput                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRotationInput                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInIsBoosting                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslFloatingVehicleMovement::ServerUpdateInput(float InForwardInput, float InRotationInput, bool bInIsBoosting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFloatingVehicleMovement", "ServerUpdateInput");

	Params::TslFloatingVehicleMovement_ServerUpdateInput Parms{};

	Parms.InForwardInput = InForwardInput;
	Parms.InRotationInput = InRotationInput;
	Parms.bInIsBoosting = bInIsBoosting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslFloatingVehicleMovement.GetAcceleration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslFloatingVehicleMovement::GetAcceleration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFloatingVehicleMovement", "GetAcceleration");

	Params::TslFloatingVehicleMovement_GetAcceleration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslFloatingVehicleMovement.GetCalculatedAcceleration
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector UTslFloatingVehicleMovement::GetCalculatedAcceleration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFloatingVehicleMovement", "GetCalculatedAcceleration");

	Params::TslFloatingVehicleMovement_GetCalculatedAcceleration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslFloatingVehicleMovement.GetMaxAcceleration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslFloatingVehicleMovement::GetMaxAcceleration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFloatingVehicleMovement", "GetMaxAcceleration");

	Params::TslFloatingVehicleMovement_GetMaxAcceleration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslFloatingVehicleMovement.GetMaxRotationYawAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslFloatingVehicleMovement::GetMaxRotationYawAngle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFloatingVehicleMovement", "GetMaxRotationYawAngle");

	Params::TslFloatingVehicleMovement_GetMaxRotationYawAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslFloatingVehicleMovement.GetRotationYawAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslFloatingVehicleMovement::GetRotationYawAngle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFloatingVehicleMovement", "GetRotationYawAngle");

	Params::TslFloatingVehicleMovement_GetRotationYawAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslFloatingVehicleMovement.IsBoosting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslFloatingVehicleMovement::IsBoosting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFloatingVehicleMovement", "IsBoosting");

	Params::TslFloatingVehicleMovement_IsBoosting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacterMovement.StartVaultingTask
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FVaultingTask                    InVaultTask                                            (Parm, NativeAccessSpecifierPublic)

void UTslCharacterMovement::StartVaultingTask(const struct FVaultingTask& InVaultTask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacterMovement", "StartVaultingTask");

	Params::TslCharacterMovement_StartVaultingTask Parms{};

	Parms.InVaultTask = std::move(InVaultTask);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacterMovement.EndCurrentTaskToFall
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslCharacterMovement::EndCurrentTaskToFall() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacterMovement", "EndCurrentTaskToFall");

	Params::TslCharacterMovement_EndCurrentTaskToFall Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacterMovement.EvaluateVaultAnimType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   FirstRow                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ApexAdditiveStepCounter                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AverageCellCount                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceVault                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceClimb                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CharVelocity                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVaultAnimType                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EVaultAnimType UTslCharacterMovement::EvaluateVaultAnimType(int32 FirstRow, int32 ApexAdditiveStepCounter, float AverageCellCount, bool bForceVault, bool bForceClimb, float CharVelocity) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacterMovement", "EvaluateVaultAnimType");

	Params::TslCharacterMovement_EvaluateVaultAnimType Parms{};

	Parms.FirstRow = FirstRow;
	Parms.ApexAdditiveStepCounter = ApexAdditiveStepCounter;
	Parms.AverageCellCount = AverageCellCount;
	Parms.bForceVault = bForceVault;
	Parms.bForceClimb = bForceClimb;
	Parms.CharVelocity = CharVelocity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacterMovement.GetCurrentVaultType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EVaultAnimType                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EVaultAnimType UTslCharacterMovement::GetCurrentVaultType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacterMovement", "GetCurrentVaultType");

	Params::TslCharacterMovement_GetCurrentVaultType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacterMovement.GetGlobalVaultingSpeedMultiplier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslCharacterMovement::GetGlobalVaultingSpeedMultiplier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacterMovement", "GetGlobalVaultingSpeedMultiplier");

	Params::TslCharacterMovement_GetGlobalVaultingSpeedMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacterMovement.GetVaultingDataFromAnim
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EVaultAnimType                          InVaultType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVaultingData*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVaultingData* UTslCharacterMovement::GetVaultingDataFromAnim(EVaultAnimType InVaultType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacterMovement", "GetVaultingDataFromAnim");

	Params::TslCharacterMovement_GetVaultingDataFromAnim Parms{};

	Parms.InVaultType = InVaultType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslCharacterMovement.GetVTimer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslCharacterMovement::GetVTimer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacterMovement", "GetVTimer");

	Params::TslCharacterMovement_GetVTimer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslAnimInstance.CacheCharacterReference
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ATslCharacter*                    InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslAnimInstance::CacheCharacterReference(class ATslCharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "CacheCharacterReference");

	Params::TslAnimInstance_CacheCharacterReference Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.EvaluateAimOffsets
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateAimOffsets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "EvaluateAimOffsets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.EvaluateAimStates
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateAimStates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "EvaluateAimStates");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.EvaluateAnimDynamics
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateAnimDynamics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "EvaluateAnimDynamics");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.EvaluateCasting
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateCasting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "EvaluateCasting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.EvaluateCharacterStates
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateCharacterStates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "EvaluateCharacterStates");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.EvaluateCoatExternalForce
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateCoatExternalForce()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "EvaluateCoatExternalForce");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.EvaluateFallingAndLanding
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateFallingAndLanding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "EvaluateFallingAndLanding");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.EvaluateFreefallAndParachute
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateFreefallAndParachute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "EvaluateFreefallAndParachute");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.EvaluateFreelook
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateFreelook()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "EvaluateFreelook");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.EvaluateIdle
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateIdle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "EvaluateIdle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.EvaluateItemOffsets
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateItemOffsets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "EvaluateItemOffsets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.EvaluateJumpCamera
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateJumpCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "EvaluateJumpCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.EvaluateJumping
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateJumping()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "EvaluateJumping");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.EvaluateLeaning
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateLeaning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "EvaluateLeaning");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.EvaluateLocalPawnStates
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateLocalPawnStates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "EvaluateLocalPawnStates");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.EvaluateMeleeAttack
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateMeleeAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "EvaluateMeleeAttack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.EvaluatePawnStates
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluatePawnStates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "EvaluatePawnStates");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.EvaluateRecoilRoll
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateRecoilRoll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "EvaluateRecoilRoll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.EvaluateRotations
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateRotations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "EvaluateRotations");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.EvaluateSwimming
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateSwimming()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "EvaluateSwimming");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.EvaluateVaulting
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateVaulting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "EvaluateVaulting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.EvaluateVehicle
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateVehicle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "EvaluateVehicle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.EvaluateWeaponCollision
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateWeaponCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "EvaluateWeaponCollision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.EvaluateWeaponInertia
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateWeaponInertia()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "EvaluateWeaponInertia");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.EvaluateWeaponStability
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateWeaponStability()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "EvaluateWeaponStability");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.EvaluateWeaponStates
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::EvaluateWeaponStates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "EvaluateWeaponStates");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.HandleADSSocketOffset
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::HandleADSSocketOffset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "HandleADSSocketOffset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.HandleAnimCurves
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::HandleAnimCurves()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "HandleAnimCurves");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.HandleSpeedAndDirection_CP
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::HandleSpeedAndDirection_CP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "HandleSpeedAndDirection_CP");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.OnHitReaction
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// EAnimWeaponType                         WeaponType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UTslAnimInstance::OnHitReaction(EAnimWeaponType WeaponType, FName BoneName, const struct FVector& Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "OnHitReaction");

	Params::TslAnimInstance_OnHitReaction Parms{};

	Parms.WeaponType = WeaponType;
	Parms.BoneName = BoneName;
	Parms.Direction = std::move(Direction);

	UObject::ProcessEvent(Func, &Parms);
}


// Function TslGame.TslAnimInstance.PreEvaluatePawnState
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::PreEvaluatePawnState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "PreEvaluatePawnState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.ProcessCodePaths
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::ProcessCodePaths()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "ProcessCodePaths");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.RandomizeIdleIndex_CP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ExludeLastIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslAnimInstance::RandomizeIdleIndex_CP(bool ExludeLastIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "RandomizeIdleIndex_CP");

	Params::TslAnimInstance_RandomizeIdleIndex_CP Parms{};

	Parms.ExludeLastIndex = ExludeLastIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.ResetIdle
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::ResetIdle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "ResetIdle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.ResetRecoilRoll
// (Final, Native, Public, BlueprintCallable)

void UTslAnimInstance::ResetRecoilRoll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "ResetRecoilRoll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.SetJumpStartLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          NewLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   DefaultFallHeight                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslAnimInstance::SetJumpStartLocation(const struct FVector& NewLocation, float DefaultFallHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "SetJumpStartLocation");

	Params::TslAnimInstance_SetJumpStartLocation Parms{};

	Parms.NewLocation = std::move(NewLocation);
	Parms.DefaultFallHeight = DefaultFallHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.SetLandPredictionVector
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          newLandVector                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UTslAnimInstance::SetLandPredictionVector(const struct FVector& newLandVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "SetLandPredictionVector");

	Params::TslAnimInstance_SetLandPredictionVector Parms{};

	Parms.newLandVector = std::move(newLandVector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.SetWeaponStatesEvaluationCooldown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslAnimInstance::SetWeaponStatesEvaluationCooldown(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "SetWeaponStatesEvaluationCooldown");

	Params::TslAnimInstance_SetWeaponStatesEvaluationCooldown Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAnimInstance.FindPositionFromDistanceCurve
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Distance                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                InAnimSequence                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslAnimInstance::FindPositionFromDistanceCurve(const float& Distance, class UAnimSequenceBase* InAnimSequence) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "FindPositionFromDistanceCurve");

	Params::TslAnimInstance_FindPositionFromDistanceCurve Parms{};

	Parms.Distance = Distance;
	Parms.InAnimSequence = InAnimSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslAnimInstance.HandleCardinalDirection90
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InDirection                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UTslAnimInstance::HandleCardinalDirection90(float InDirection) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAnimInstance", "HandleCardinalDirection90");

	Params::TslAnimInstance_HandleCardinalDirection90 Parms{};

	Parms.InDirection = InDirection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslHUD.GoToLobby
// (Final, Native, Public, BlueprintCallable)

void ATslHUD::GoToLobby()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslHUD", "GoToLobby");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslHUD.InitCaptureWorld
// (Final, Native, Public, BlueprintCallable)

void ATslHUD::InitCaptureWorld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslHUD", "InitCaptureWorld");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslHUD.NotifyDropSlotOnOtherContainer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class ISlotContainerInterface>Container                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// TScriptInterface<class ISlotInterface>  Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
// TScriptInterface<class ISlotContainerInterface>OtherContainer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

void ATslHUD::NotifyDropSlotOnOtherContainer(TScriptInterface<class ISlotContainerInterface> Container, TScriptInterface<class ISlotInterface> Slot, TScriptInterface<class ISlotContainerInterface> OtherContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslHUD", "NotifyDropSlotOnOtherContainer");

	Params::TslHUD_NotifyDropSlotOnOtherContainer Parms{};

	Parms.Container = Container;
	Parms.Slot = Slot;
	Parms.OtherContainer = OtherContainer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslHUD.SetHighlightProvider
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Provider                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslHUD::SetHighlightProvider(const class FString& Provider)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslHUD", "SetHighlightProvider");

	Params::TslHUD_SetHighlightProvider Parms{};

	Parms.Provider = std::move(Provider);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslHUD.SpawnActorInSceneCaptureWorld
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       SpawnTransform                                         (ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TDelegate<void(class AActor* SpawnedActor)>DelegateToCall                                         (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void ATslHUD::SpawnActorInSceneCaptureWorld(TSubclassOf<class AActor> ActorClass, const struct FTransform& SpawnTransform, TDelegate<void(class AActor* SpawnedActor)> DelegateToCall)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslHUD", "SpawnActorInSceneCaptureWorld");

	Params::TslHUD_SpawnActorInSceneCaptureWorld Parms{};

	Parms.ActorClass = ActorClass;
	Parms.SpawnTransform = std::move(SpawnTransform);
	Parms.DelegateToCall = DelegateToCall;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslHUD.TestGameEvent_Die
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bGroggy                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslHUD::TestGameEvent_Die(bool bGroggy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslHUD", "TestGameEvent_Die");

	Params::TslHUD_TestGameEvent_Die Parms{};

	Parms.bGroggy = bGroggy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslHUD.TestGameEvent_KillOtherPlayer
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bGroggy                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslHUD::TestGameEvent_KillOtherPlayer(bool bGroggy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslHUD", "TestGameEvent_KillOtherPlayer");

	Params::TslHUD_TestGameEvent_KillOtherPlayer Parms{};

	Parms.bGroggy = bGroggy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslHUD.TestGameEvent_MatchEnded
// (Final, Exec, Native, Public)

void ATslHUD::TestGameEvent_MatchEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslHUD", "TestGameEvent_MatchEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslHUD.TestKillMessage
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           KillerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           VictimName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bKillerIsOwner                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVictimIsOwner                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslHUD::TestKillMessage(const class FString& KillerName, const class FString& VictimName, bool bKillerIsOwner, bool bVictimIsOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslHUD", "TestKillMessage");

	Params::TslHUD_TestKillMessage Parms{};

	Parms.KillerName = std::move(KillerName);
	Parms.VictimName = std::move(VictimName);
	Parms.bKillerIsOwner = bKillerIsOwner;
	Parms.bVictimIsOwner = bVictimIsOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslHUD.TestSendImportantMessage
// (Final, Exec, Native, Public)
// Parameters:
// class FText                             Message                                                (Parm, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslHUD::TestSendImportantMessage(const class FText& Message, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslHUD", "TestSendImportantMessage");

	Params::TslHUD_TestSendImportantMessage Parms{};

	Parms.Message = std::move(Message);
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslHUD.TestSendSystemMessage
// (Final, Exec, Native, Public)
// Parameters:
// class FText                             Message                                                (Parm, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslHUD::TestSendSystemMessage(const class FText& Message, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslHUD", "TestSendSystemMessage");

	Params::TslHUD_TestSendSystemMessage Parms{};

	Parms.Message = std::move(Message);
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslHUD.GetPossessCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslCharacter* ATslHUD::GetPossessCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslHUD", "GetPossessCharacter");

	Params::TslHUD_GetPossessCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslHUD.GetPossessPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* ATslHUD::GetPossessPawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslHUD", "GetPossessPawn");

	Params::TslHUD_GetPossessPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslHUD.IsGameEnded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslHUD::IsGameEnded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslHUD", "IsGameEnded");

	Params::TslHUD_IsGameEnded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.LobbyHUD.ClearAllWidget
// (Final, Native, Public, BlueprintCallable)

void ALobbyHUD::ClearAllWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyHUD", "ClearAllWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.LobbyHUD.SetWidgetForBinding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ViewIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCoherentUIGTWidget*              Widget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALobbyHUD::SetWidgetForBinding(int32 ViewIndex, class UCoherentUIGTWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyHUD", "SetWidgetForBinding");

	Params::LobbyHUD_SetWidgetForBinding Parms{};

	Parms.ViewIndex = ViewIndex;
	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.LobbyHUD.GetLobbyCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALobbyCharacter*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALobbyCharacter* ALobbyHUD::GetLobbyCharacter(int32 SlotIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyHUD", "GetLobbyCharacter");

	Params::LobbyHUD_GetLobbyCharacter Parms{};

	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.LobbyHUD.GetLobbyCharacterNum
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALobbyHUD::GetLobbyCharacterNum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyHUD", "GetLobbyCharacterNum");

	Params::LobbyHUD_GetLobbyCharacterNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.LobbyHUD.GetStartUrl
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ALobbyHUD::GetStartUrl() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyHUD", "GetStartUrl");

	Params::LobbyHUD_GetStartUrl Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslMotorbikeVehicle.OnPostDriverLeave
// (Final, Native, Private)

void ATslMotorbikeVehicle::OnPostDriverLeave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslMotorbikeVehicle", "OnPostDriverLeave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslMotorbikeVehicle.OnPostDriverRide
// (Final, Native, Private)

void ATslMotorbikeVehicle::OnPostDriverRide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslMotorbikeVehicle", "OnPostDriverRide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslMotorbikeVehicle.OnVehicleEjected
// (Final, Native, Private)

void ATslMotorbikeVehicle::OnVehicleEjected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslMotorbikeVehicle", "OnVehicleEjected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslMotorbikeVehicle.ProcessFlipAndStabilize
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)

void ATslMotorbikeVehicle::ProcessFlipAndStabilize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslMotorbikeVehicle", "ProcessFlipAndStabilize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslMotorbikeVehicle.SetAirControlB
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   inFloat                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslMotorbikeVehicle::SetAirControlB(float inFloat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslMotorbikeVehicle", "SetAirControlB");

	Params::TslMotorbikeVehicle_SetAirControlB Parms{};

	Parms.inFloat = inFloat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslMotorbikeVehicle.SetAirControlE
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   inFloat                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslMotorbikeVehicle::SetAirControlE(float inFloat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslMotorbikeVehicle", "SetAirControlE");

	Params::TslMotorbikeVehicle_SetAirControlE Parms{};

	Parms.inFloat = inFloat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslMotorbikeVehicle.SetAirControlF
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   inFloat                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslMotorbikeVehicle::SetAirControlF(float inFloat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslMotorbikeVehicle", "SetAirControlF");

	Params::TslMotorbikeVehicle_SetAirControlF Parms{};

	Parms.inFloat = inFloat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslMotorbikeVehicle.SetAirControlL
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   inFloat                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslMotorbikeVehicle::SetAirControlL(float inFloat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslMotorbikeVehicle", "SetAirControlL");

	Params::TslMotorbikeVehicle_SetAirControlL Parms{};

	Parms.inFloat = inFloat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslMotorbikeVehicle.SetAirControlQ
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   inFloat                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslMotorbikeVehicle::SetAirControlQ(float inFloat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslMotorbikeVehicle", "SetAirControlQ");

	Params::TslMotorbikeVehicle_SetAirControlQ Parms{};

	Parms.inFloat = inFloat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslMotorbikeVehicle.SetAirControlR
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   inFloat                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslMotorbikeVehicle::SetAirControlR(float inFloat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslMotorbikeVehicle", "SetAirControlR");

	Params::TslMotorbikeVehicle_SetAirControlR Parms{};

	Parms.inFloat = inFloat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslMotorbikeVehicle.GetCOMSteerOffset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslMotorbikeVehicle::GetCOMSteerOffset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslMotorbikeVehicle", "GetCOMSteerOffset");

	Params::TslMotorbikeVehicle_GetCOMSteerOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslMotorbikeVehicle.HasContact
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslMotorbikeVehicle::HasContact() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslMotorbikeVehicle", "HasContact");

	Params::TslMotorbikeVehicle_HasContact Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslMotorbikeVehicle.IsFlippingEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslMotorbikeVehicle::IsFlippingEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslMotorbikeVehicle", "IsFlippingEnabled");

	Params::TslMotorbikeVehicle_IsFlippingEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslMotorbikeVehicle.IsKickstandActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslMotorbikeVehicle::IsKickstandActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslMotorbikeVehicle", "IsKickstandActive");

	Params::TslMotorbikeVehicle_IsKickstandActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslMotorbikeVehicle.IsUsingActiveStabilize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslMotorbikeVehicle::IsUsingActiveStabilize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslMotorbikeVehicle", "IsUsingActiveStabilize");

	Params::TslMotorbikeVehicle_IsUsingActiveStabilize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslMotorbikeVehicle.VehicleHasDriver
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslMotorbikeVehicle::VehicleHasDriver() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslMotorbikeVehicle", "VehicleHasDriver");

	Params::TslMotorbikeVehicle_VehicleHasDriver Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.PerfBotPlayerController.ClientQuit
// (Net, NetReliable, Native, Event, Public, NetClient)

void APerfBotPlayerController::ClientQuit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerfBotPlayerController", "ClientQuit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.PerfBotPlayerController.ServerMoveToLocation
// (Net, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void APerfBotPlayerController::ServerMoveToLocation(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerfBotPlayerController", "ServerMoveToLocation");

	Params::PerfBotPlayerController_ServerMoveToLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslViewTargetTempComponent.AddTempComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  TempComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslViewTargetTempComponent::AddTempComponent(class USceneComponent* TempComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslViewTargetTempComponent", "AddTempComponent");

	Params::TslViewTargetTempComponent_AddTempComponent Parms{};

	Parms.TempComponent = TempComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslViewTargetTempComponent.AddTempComponentWithDelegate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  TempComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class USceneComponent* NewComponent)>DelegateToCall                                         (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UTslViewTargetTempComponent::AddTempComponentWithDelegate(class USceneComponent* TempComponent, TDelegate<void(class USceneComponent* NewComponent)> DelegateToCall)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslViewTargetTempComponent", "AddTempComponentWithDelegate");

	Params::TslViewTargetTempComponent_AddTempComponentWithDelegate Parms{};

	Parms.TempComponent = TempComponent;
	Parms.DelegateToCall = DelegateToCall;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslStreamer.OnLevelChangedInternal
// (Final, Native, Private)

void UTslStreamer::OnLevelChangedInternal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslStreamer", "OnLevelChangedInternal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslStreamer.OnOriginShiftedInternal
// (Final, Native, Private)
// Parameters:
// class UWorld*                           InWorld                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       From                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FIntVector                       To                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UTslStreamer::OnOriginShiftedInternal(class UWorld* InWorld, const struct FIntVector& From, const struct FIntVector& To)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslStreamer", "OnOriginShiftedInternal");

	Params::TslStreamer_OnOriginShiftedInternal Parms{};

	Parms.InWorld = InWorld;
	Parms.From = std::move(From);
	Parms.To = std::move(To);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.CharacterBreathBuff.GetBreathComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCharacterBreathComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCharacterBreathComponent* ACharacterBreathBuff::GetBreathComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBreathBuff", "GetBreathComponent");

	Params::CharacterBreathBuff_GetBreathComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.CharacterBreathBuff.GetCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslCharacter* ACharacterBreathBuff::GetCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterBreathBuff", "GetCharacter");

	Params::CharacterBreathBuff_GetCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslThrowableTrajectoryViewComponent.AttachToThrowable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ATslWeapon_Throwable*             ThrowableIn                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslThrowableTrajectoryViewComponent::AttachToThrowable(const class ATslWeapon_Throwable* ThrowableIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslThrowableTrajectoryViewComponent", "AttachToThrowable");

	Params::TslThrowableTrajectoryViewComponent_AttachToThrowable Parms{};

	Parms.ThrowableIn = ThrowableIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacterProxy.SetAccessorySlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTslAccessoryComponent*           AccessoryComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAccessorySlot                          Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslCharacterProxy::SetAccessorySlot(class UTslAccessoryComponent* AccessoryComponent, EAccessorySlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacterProxy", "SetAccessorySlot");

	Params::TslCharacterProxy_SetAccessorySlot Parms{};

	Parms.AccessoryComponent = AccessoryComponent;
	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacterProxy.UpdateArmedWeapons
// (Final, Native, Public)

void ATslCharacterProxy::UpdateArmedWeapons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacterProxy", "UpdateArmedWeapons");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacterProxy.UpdateCharacterAppearance
// (Final, Native, Public)

void ATslCharacterProxy::UpdateCharacterAppearance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacterProxy", "UpdateCharacterAppearance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacterProxy.UpdateEquippedWeapons
// (Final, Native, Public)

void ATslCharacterProxy::UpdateEquippedWeapons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacterProxy", "UpdateEquippedWeapons");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCharacterProxy.GetAccessorySlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAccessorySlot                          Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTslAccessoryComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTslAccessoryComponent* ATslCharacterProxy::GetAccessorySlot(EAccessorySlot Slot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCharacterProxy", "GetAccessorySlot");

	Params::TslCharacterProxy_GetAccessorySlot Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslUserWidget.ListenForInputAxis
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// FName                             AxisName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConsume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(float Scale)>            Callback                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UTslUserWidget::ListenForInputAxis(FName AxisName, float Scale, bool bConsume, TDelegate<void(float Scale)> Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslUserWidget", "ListenForInputAxis");

	Params::TslUserWidget_ListenForInputAxis Parms{};

	Parms.AxisName = AxisName;
	Parms.Scale = Scale;
	Parms.bConsume = bConsume;
	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslUserWidget.StopListeningForAllInputAxises
// (Final, Native, Public, BlueprintCallable)

void UTslUserWidget::StopListeningForAllInputAxises()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslUserWidget", "StopListeningForAllInputAxises");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslUserWidget.GetCachedCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslCharacter* UTslUserWidget::GetCachedCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslUserWidget", "GetCachedCharacter");

	Params::TslUserWidget_GetCachedCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslUserWidget.GetCachedGameState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslGameState*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslGameState* UTslUserWidget::GetCachedGameState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslUserWidget", "GetCachedGameState");

	Params::TslUserWidget_GetCachedGameState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslUserWidget.GetCachedViewTargetTslCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslCharacter* UTslUserWidget::GetCachedViewTargetTslCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslUserWidget", "GetCachedViewTargetTslCharacter");

	Params::TslUserWidget_GetCachedViewTargetTslCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.UmgBaseWidget.HandleMainPrepass
// (Native, Public)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUmgBaseWidget::HandleMainPrepass(class UWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgBaseWidget", "HandleMainPrepass");

	Params::UmgBaseWidget_HandleMainPrepass Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.UmgBaseWidget.IsMouseOn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUmgBaseWidget::IsMouseOn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UmgBaseWidget", "IsMouseOn");

	Params::UmgBaseWidget_IsMouseOn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.BluezoneGpsBaseWidget.OnNotifyNextGasIn
// (Final, Native, Public, HasDefaults)
// Parameters:
// struct FVector                          PoisonGasWarningPosition                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   PoisonGasWarningRadius                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBluezoneGpsBaseWidget::OnNotifyNextGasIn(const struct FVector& PoisonGasWarningPosition, float PoisonGasWarningRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BluezoneGpsBaseWidget", "OnNotifyNextGasIn");

	Params::BluezoneGpsBaseWidget_OnNotifyNextGasIn Parms{};

	Parms.PoisonGasWarningPosition = std::move(PoisonGasWarningPosition);
	Parms.PoisonGasWarningRadius = PoisonGasWarningRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCheatManager.ChangeTeam
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   NewTeamNumber                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslCheatManager::ChangeTeam(int32 NewTeamNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCheatManager", "ChangeTeam");

	Params::TslCheatManager_ChangeTeam Parms{};

	Parms.NewTeamNumber = NewTeamNumber;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCheatManager.Cheat
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslCheatManager::Cheat(const class FString& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCheatManager", "Cheat");

	Params::TslCheatManager_Cheat Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCheatManager.CopyDebugInfo
// (Final, Exec, Native, Public)

void UTslCheatManager::CopyDebugInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCheatManager", "CopyDebugInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCheatManager.CtrlShortCutOnOff
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    OnOff                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslCheatManager::CtrlShortCutOnOff(bool OnOff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCheatManager", "CtrlShortCutOnOff");

	Params::TslCheatManager_CtrlShortCutOnOff Parms{};

	Parms.OnOff = OnOff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCheatManager.DelayCrash
// (Final, Exec, Native, Public)
// Parameters:
// float                                   DelaySeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslCheatManager::DelayCrash(float DelaySeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCheatManager", "DelayCrash");

	Params::TslCheatManager_DelayCrash Parms{};

	Parms.DelaySeconds = DelaySeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCheatManager.DrawVehicleCenterOfMass
// (Final, Exec, Native, Public)

void UTslCheatManager::DrawVehicleCenterOfMass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCheatManager", "DrawVehicleCenterOfMass");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCheatManager.DumpDestructibleComponents
// (Final, Exec, Native, Public)

void UTslCheatManager::DumpDestructibleComponents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCheatManager", "DumpDestructibleComponents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCheatManager.DumpReplicatedItems
// (Final, Exec, Native, Public)

void UTslCheatManager::DumpReplicatedItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCheatManager", "DumpReplicatedItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCheatManager.DumpVoiceDevices
// (Final, Exec, Native, Public)

void UTslCheatManager::DumpVoiceDevices()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCheatManager", "DumpVoiceDevices");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCheatManager.ForceMatchStart
// (Final, Exec, Native, Public)

void UTslCheatManager::ForceMatchStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCheatManager", "ForceMatchStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCheatManager.InsertCrashMeCommand
// (Final, Native, Private)

void UTslCheatManager::InsertCrashMeCommand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCheatManager", "InsertCrashMeCommand");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCheatManager.LookAt
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Pitch                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Yaw                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Roll                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslCheatManager::LookAt(float Pitch, float Yaw, float Roll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCheatManager", "LookAt");

	Params::TslCheatManager_LookAt Parms{};

	Parms.Pitch = Pitch;
	Parms.Yaw = Yaw;
	Parms.Roll = Roll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCheatManager.MoveVehicleOnClient
// (Final, Exec, Native, Public)
// Parameters:
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslCheatManager::MoveVehicleOnClient(float X, float Y, float Z)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCheatManager", "MoveVehicleOnClient");

	Params::TslCheatManager_MoveVehicleOnClient Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCheatManager.ReturnLookAt
// (Final, Exec, Native, Public)

void UTslCheatManager::ReturnLookAt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCheatManager", "ReturnLookAt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCheatManager.SetClientConnectionTimeout
// (Final, Exec, Native, Public)
// Parameters:
// float                                   TimeoutSeconds                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslCheatManager::SetClientConnectionTimeout(float TimeoutSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCheatManager", "SetClientConnectionTimeout");

	Params::TslCheatManager_SetClientConnectionTimeout Parms{};

	Parms.TimeoutSeconds = TimeoutSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCheatManager.SetSpectatorYawAndPitch
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Yaw                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Pitch                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RevertSmoothSpeed                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslCheatManager::SetSpectatorYawAndPitch(float Yaw, float Pitch, float RevertSmoothSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCheatManager", "SetSpectatorYawAndPitch");

	Params::TslCheatManager_SetSpectatorYawAndPitch Parms{};

	Parms.Yaw = Yaw;
	Parms.Pitch = Pitch;
	Parms.RevertSmoothSpeed = RevertSmoothSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCheatManager.SetVehicleRepPosCorrection
// (Final, Exec, Native, Public)
// Parameters:
// float                                   LinearDeltaThresholdSq                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LinearInterpAlpha                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LinearRecipFixTime                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BodySpeedThresholdSq                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslCheatManager::SetVehicleRepPosCorrection(float LinearDeltaThresholdSq, float LinearInterpAlpha, float LinearRecipFixTime, float BodySpeedThresholdSq)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCheatManager", "SetVehicleRepPosCorrection");

	Params::TslCheatManager_SetVehicleRepPosCorrection Parms{};

	Parms.LinearDeltaThresholdSq = LinearDeltaThresholdSq;
	Parms.LinearInterpAlpha = LinearInterpAlpha;
	Parms.LinearRecipFixTime = LinearRecipFixTime;
	Parms.BodySpeedThresholdSq = BodySpeedThresholdSq;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCheatManager.SetVehicleRepRotCorrection
// (Final, Exec, Native, Public)
// Parameters:
// float                                   AngularDeltaThreshold                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AngularInterpAlpha                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AngularRecipFixTime                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslCheatManager::SetVehicleRepRotCorrection(float AngularDeltaThreshold, float AngularInterpAlpha, float AngularRecipFixTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCheatManager", "SetVehicleRepRotCorrection");

	Params::TslCheatManager_SetVehicleRepRotCorrection Parms{};

	Parms.AngularDeltaThreshold = AngularDeltaThreshold;
	Parms.AngularInterpAlpha = AngularInterpAlpha;
	Parms.AngularRecipFixTime = AngularRecipFixTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCheatManager.SpawnBot
// (Final, Exec, Native, Public)

void UTslCheatManager::SpawnBot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCheatManager", "SpawnBot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCheatManager.TestVoiceAccessToken
// (Final, Exec, Native, Public)

void UTslCheatManager::TestVoiceAccessToken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCheatManager", "TestVoiceAccessToken");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCheatManager.ToggleCollisionOfDestructibleComponents
// (Final, Exec, Native, Public)

void UTslCheatManager::ToggleCollisionOfDestructibleComponents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCheatManager", "ToggleCollisionOfDestructibleComponents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCheatManager.ToggleMatchTimer
// (Final, Exec, Native, Public)

void UTslCheatManager::ToggleMatchTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCheatManager", "ToggleMatchTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCheatManager.ToggleVisibilityOfDestructibleComponents
// (Final, Exec, Native, Public)

void UTslCheatManager::ToggleVisibilityOfDestructibleComponents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCheatManager", "ToggleVisibilityOfDestructibleComponents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslCoherentWidget.GoBack
// (Final, Native, Public, BlueprintCallable)

void UTslCoherentWidget::GoBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslCoherentWidget", "GoBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.KillCountBaseWidget.OnUpdateKillCount
// (Final, Native, Public)
// Parameters:
// int32                                   NewKillCount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKillCountBaseWidget::OnUpdateKillCount(int32 NewKillCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillCountBaseWidget", "OnUpdateKillCount");

	Params::KillCountBaseWidget_OnUpdateKillCount Parms{};

	Parms.NewKillCount = NewKillCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.KillCountBaseWidget.GetLastKillCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UKillCountBaseWidget::GetLastKillCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KillCountBaseWidget", "GetLastKillCount");

	Params::KillCountBaseWidget_GetLastKillCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslDestructibleComponent.ClientReceiveComponentDamage
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageEvent                     DamageEvent                                            (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// class AController*                      EventInstigator                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslDestructibleComponent::ClientReceiveComponentDamage(float DamageAmount, const struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslDestructibleComponent", "ClientReceiveComponentDamage");

	Params::TslDestructibleComponent_ClientReceiveComponentDamage Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.DamageEvent = std::move(DamageEvent);
	Parms.EventInstigator = EventInstigator;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslDestructibleContainer.OnRep_Flag
// (Final, Native, Private)

void ATslDestructibleContainer::OnRep_Flag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslDestructibleContainer", "OnRep_Flag");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslDoor.ClientTakeDamage
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              HitLocation                                            (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   DamageRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Impulse                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslDoor::ClientTakeDamage(float Damage, const struct FVector_NetQuantize& HitLocation, float DamageRadius, float Impulse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslDoor", "ClientTakeDamage");

	Params::TslDoor_ClientTakeDamage Parms{};

	Parms.Damage = Damage;
	Parms.HitLocation = std::move(HitLocation);
	Parms.DamageRadius = DamageRadius;
	Parms.Impulse = Impulse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslDoor.OnInteractBy
// (Native, Protected)
// Parameters:
// class ATslCharacter*                    OtherCharacter                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslDoor::OnInteractBy(class ATslCharacter* OtherCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslDoor", "OnInteractBy");

	Params::TslDoor_OnInteractBy Parms{};

	Parms.OtherCharacter = OtherCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslDoor.OnRep_DoorBreakingState
// (Final, Native, Protected)

void ATslDoor::OnRep_DoorBreakingState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslDoor", "OnRep_DoorBreakingState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslDoor.OnRep_DoorOpened
// (Final, Native, Protected)

void ATslDoor::OnRep_DoorOpened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslDoor", "OnRep_DoorOpened");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleReactionInterface.OnImpactedByVehicle
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          Velocity                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ITslVehicleReactionInterface::OnImpactedByVehicle(const struct FHitResult& Hit, const struct FVector& Velocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleReactionInterface", "OnImpactedByVehicle");

	Params::TslVehicleReactionInterface_OnImpactedByVehicle Parms{};

	Parms.Hit = std::move(Hit);
	Parms.Velocity = std::move(Velocity);

	UObject::ProcessEvent(Func, &Parms);
}


// Function TslGame.TslExplosionEffect.OnParticleCollide
// (Final, Native, Private, HasDefaults)
// Parameters:
// FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EmitterTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ParticleTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Velocity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Normal                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslExplosionEffect::OnParticleCollide(FName EventName, float EmitterTime, int32 ParticleTime, const struct FVector& Location, const struct FVector& Velocity, const struct FVector& Direction, const struct FVector& Normal, FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslExplosionEffect", "OnParticleCollide");

	Params::TslExplosionEffect_OnParticleCollide Parms{};

	Parms.EventName = EventName;
	Parms.EmitterTime = EmitterTime;
	Parms.ParticleTime = ParticleTime;
	Parms.Location = std::move(Location);
	Parms.Velocity = std::move(Velocity);
	Parms.Direction = std::move(Direction);
	Parms.Normal = std::move(Normal);
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslExplosionReactionInterface.OnExplode
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DamageAmout                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               ComponentHits                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AController*                      EventInstigator                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ITslExplosionReactionInterface::OnExplode(float DamageAmout, const struct FVector& Origin, const TArray<struct FHitResult>& ComponentHits, class AController* EventInstigator, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslExplosionReactionInterface", "OnExplode");

	Params::TslExplosionReactionInterface_OnExplode Parms{};

	Parms.DamageAmout = DamageAmout;
	Parms.Origin = std::move(Origin);
	Parms.ComponentHits = std::move(ComponentHits);
	Parms.EventInstigator = EventInstigator;
	Parms.DamageCauser = DamageCauser;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TslGame.TslFence.GetSplineComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USplineComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USplineComponent* ATslFence::GetSplineComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFence", "GetSplineComponent");

	Params::TslFence_GetSplineComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslReactionComponent.Client_ReactByPointDamage
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Impact                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ImpulseDir                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UTslReactionComponent::Client_ReactByPointDamage(float DamageAmount, const struct FVector& Impact, const struct FVector& ImpulseDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslReactionComponent", "Client_ReactByPointDamage");

	Params::TslReactionComponent_Client_ReactByPointDamage Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.Impact = std::move(Impact);
	Parms.ImpulseDir = std::move(ImpulseDir);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslReactionComponent.Client_ReactByRadialDamage
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Impact                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ImpulseDir                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   OuterRadius                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslReactionComponent::Client_ReactByRadialDamage(float DamageAmount, const struct FVector& Origin, const struct FVector& Impact, const struct FVector& ImpulseDir, float OuterRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslReactionComponent", "Client_ReactByRadialDamage");

	Params::TslReactionComponent_Client_ReactByRadialDamage Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.Origin = std::move(Origin);
	Parms.Impact = std::move(Impact);
	Parms.ImpulseDir = std::move(ImpulseDir);
	Parms.OuterRadius = OuterRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslReactionComponent.Client_ReactByVehicle
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// struct FVector                          Impact                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ImpulseDir                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Velocity                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UTslReactionComponent::Client_ReactByVehicle(const struct FVector& Impact, const struct FVector& ImpulseDir, const struct FVector& Velocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslReactionComponent", "Client_ReactByVehicle");

	Params::TslReactionComponent_Client_ReactByVehicle Parms{};

	Parms.Impact = std::move(Impact);
	Parms.ImpulseDir = std::move(ImpulseDir);
	Parms.Velocity = std::move(Velocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslReactionComponent.OnRep_PendingDestroy
// (Final, Native, Protected)

void UTslReactionComponent::OnRep_PendingDestroy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslReactionComponent", "OnRep_PendingDestroy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleEffectComponent.ApplyDestoyedMaterialWithDelay
// (Final, Native, Public, BlueprintCallable)

void UTslVehicleEffectComponent::ApplyDestoyedMaterialWithDelay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleEffectComponent", "ApplyDestoyedMaterialWithDelay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleEffectComponent.OnDeath
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   KillingDamage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageEvent                     DamageEvent                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class ATslPlayerState*                  PlayerInstigator                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslVehicleEffectComponent::OnDeath(float KillingDamage, const struct FDamageEvent& DamageEvent, class ATslPlayerState* PlayerInstigator, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleEffectComponent", "OnDeath");

	Params::TslVehicleEffectComponent_OnDeath Parms{};

	Parms.KillingDamage = KillingDamage;
	Parms.DamageEvent = std::move(DamageEvent);
	Parms.PlayerInstigator = PlayerInstigator;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleEffectComponent.OnDestroyedImpactEffect
// (Final, Native, Private)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslVehicleEffectComponent::OnDestroyedImpactEffect(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleEffectComponent", "OnDestroyedImpactEffect");

	Params::TslVehicleEffectComponent_OnDestroyedImpactEffect Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleEffectComponent.OnHealthChange
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// float                                   CurrentHealth                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LastHealth                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HealthMax                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsDying                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslVehicleEffectComponent::OnHealthChange(float CurrentHealth, float LastHealth, float HealthMax, bool bIsDying)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleEffectComponent", "OnHealthChange");

	Params::TslVehicleEffectComponent_OnHealthChange Parms{};

	Parms.CurrentHealth = CurrentHealth;
	Parms.LastHealth = LastHealth;
	Parms.HealthMax = HealthMax;
	Parms.bIsDying = bIsDying;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleEffectComponent.OnHit
// (Native, Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class AActor*                           SelfActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UTslVehicleEffectComponent::OnHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleEffectComponent", "OnHit");

	Params::TslVehicleEffectComponent_OnHit Parms{};

	Parms.SelfActor = SelfActor;
	Parms.OtherActor = OtherActor;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleEffectComponent.SetEngineSoundRTPC
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           RTPC                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslVehicleEffectComponent::SetEngineSoundRTPC(const class FString& RTPC, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleEffectComponent", "SetEngineSoundRTPC");

	Params::TslVehicleEffectComponent_SetEngineSoundRTPC Parms{};

	Parms.RTPC = std::move(RTPC);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleEffectComponent.SetVehicleMaterialsToDestroyed
// (Final, Native, Public, BlueprintCallable)

void UTslVehicleEffectComponent::SetVehicleMaterialsToDestroyed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleEffectComponent", "SetVehicleMaterialsToDestroyed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleEffectComponent.GetEngineSoundComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAkComponent*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAkComponent* UTslVehicleEffectComponent::GetEngineSoundComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleEffectComponent", "GetEngineSoundComponent");

	Params::TslVehicleEffectComponent_GetEngineSoundComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWebPopupInterface.ShowWebPopup
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FWebPopupParam                   Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ITslWebPopupInterface::ShowWebPopup(const struct FWebPopupParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWebPopupInterface", "ShowWebPopup");

	Params::TslWebPopupInterface_ShowWebPopup Parms{};

	Parms.Param = std::move(Param);

	UObject::ProcessEvent(Func, &Parms);
}


// Function TslGame.TslFocusableWidgetInterface.Down
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITslFocusableWidgetInterface::Down()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFocusableWidgetInterface", "Down");

	Params::TslFocusableWidgetInterface_Down Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.InputA
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITslFocusableWidgetInterface::InputA()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFocusableWidgetInterface", "InputA");

	Params::TslFocusableWidgetInterface_InputA Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.InputB
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITslFocusableWidgetInterface::InputB()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFocusableWidgetInterface", "InputB");

	Params::TslFocusableWidgetInterface_InputB Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.InputLB
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITslFocusableWidgetInterface::InputLB()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFocusableWidgetInterface", "InputLB");

	Params::TslFocusableWidgetInterface_InputLB Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.InputLT
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITslFocusableWidgetInterface::InputLT()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFocusableWidgetInterface", "InputLT");

	Params::TslFocusableWidgetInterface_InputLT Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.InputRB
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITslFocusableWidgetInterface::InputRB()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFocusableWidgetInterface", "InputRB");

	Params::TslFocusableWidgetInterface_InputRB Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.InputRT
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITslFocusableWidgetInterface::InputRT()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFocusableWidgetInterface", "InputRT");

	Params::TslFocusableWidgetInterface_InputRT Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.InputX
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITslFocusableWidgetInterface::InputX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFocusableWidgetInterface", "InputX");

	Params::TslFocusableWidgetInterface_InputX Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.InputY
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITslFocusableWidgetInterface::InputY()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFocusableWidgetInterface", "InputY");

	Params::TslFocusableWidgetInterface_InputY Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.Left
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITslFocusableWidgetInterface::Left()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFocusableWidgetInterface", "Left");

	Params::TslFocusableWidgetInterface_Left Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.Right
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITslFocusableWidgetInterface::Right()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFocusableWidgetInterface", "Right");

	Params::TslFocusableWidgetInterface_Right Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.SetFocus
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NewFocus                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITslFocusableWidgetInterface::SetFocus(bool NewFocus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFocusableWidgetInterface", "SetFocus");

	Params::TslFocusableWidgetInterface_SetFocus Parms{};

	Parms.NewFocus = NewFocus;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.Up
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITslFocusableWidgetInterface::Up()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFocusableWidgetInterface", "Up");

	Params::TslFocusableWidgetInterface_Up Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.GetDownWidget
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* ITslFocusableWidgetInterface::GetDownWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFocusableWidgetInterface", "GetDownWidget");

	Params::TslFocusableWidgetInterface_GetDownWidget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.GetFocusingChildWidget
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* ITslFocusableWidgetInterface::GetFocusingChildWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFocusableWidgetInterface", "GetFocusingChildWidget");

	Params::TslFocusableWidgetInterface_GetFocusingChildWidget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.GetLeftWidget
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* ITslFocusableWidgetInterface::GetLeftWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFocusableWidgetInterface", "GetLeftWidget");

	Params::TslFocusableWidgetInterface_GetLeftWidget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.GetRightWidget
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* ITslFocusableWidgetInterface::GetRightWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFocusableWidgetInterface", "GetRightWidget");

	Params::TslFocusableWidgetInterface_GetRightWidget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.GetUpWidget
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* ITslFocusableWidgetInterface::GetUpWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFocusableWidgetInterface", "GetUpWidget");

	Params::TslFocusableWidgetInterface_GetUpWidget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.IsFocus
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITslFocusableWidgetInterface::IsFocus() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFocusableWidgetInterface", "IsFocus");

	Params::TslFocusableWidgetInterface_IsFocus Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function TslGame.TslFocusableWidgetInterface.IsFocusable
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITslFocusableWidgetInterface::IsFocusable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslFocusableWidgetInterface", "IsFocusable");

	Params::TslFocusableWidgetInterface_IsFocusable Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function TslGame.TslVehicleSyncComponent.OnDriverRide
// (Final, Native, Private)

void UTslVehicleSyncComponent::OnDriverRide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleSyncComponent", "OnDriverRide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleSyncComponent.OnHitAtClient
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           SelfActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UTslVehicleSyncComponent::OnHitAtClient(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleSyncComponent", "OnHitAtClient");

	Params::TslVehicleSyncComponent_OnHitAtClient Parms{};

	Parms.SelfActor = SelfActor;
	Parms.OtherActor = OtherActor;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleSyncComponent.OnHitAtServer
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           SelfActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UTslVehicleSyncComponent::OnHitAtServer(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleSyncComponent", "OnHitAtServer");

	Params::TslVehicleSyncComponent_OnHitAtServer Parms{};

	Parms.SelfActor = SelfActor;
	Parms.OtherActor = OtherActor;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleSyncComponent.SendClientHitToServerReliably
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// int32                                   InCorrectionId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100           ClientLocation                                         (Parm, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100           ClientLinearVelocity                                   (Parm, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal        ClientRotator                                          (Parm, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100           ClientAngularVelocity                                  (Parm, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100           NormalImpulse                                          (Parm, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UTslVehicleSyncComponent::SendClientHitToServerReliably(int32 InCorrectionId, const struct FVector_NetQuantize100& ClientLocation, const struct FVector_NetQuantize100& ClientLinearVelocity, const struct FVector_NetQuantizeNormal& ClientRotator, const struct FVector_NetQuantize100& ClientAngularVelocity, const struct FVector_NetQuantize100& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleSyncComponent", "SendClientHitToServerReliably");

	Params::TslVehicleSyncComponent_SendClientHitToServerReliably Parms{};

	Parms.InCorrectionId = InCorrectionId;
	Parms.ClientLocation = std::move(ClientLocation);
	Parms.ClientLinearVelocity = std::move(ClientLinearVelocity);
	Parms.ClientRotator = std::move(ClientRotator);
	Parms.ClientAngularVelocity = std::move(ClientAngularVelocity);
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleSyncComponent.SendClientHitToServerUnreliably
// (Final, Net, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// int32                                   InCorrectionId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100           ClientLocation                                         (Parm, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100           ClientLinearVelocity                                   (Parm, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal        ClientRotator                                          (Parm, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100           ClientAngularVelocity                                  (Parm, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100           NormalImpulse                                          (Parm, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UTslVehicleSyncComponent::SendClientHitToServerUnreliably(int32 InCorrectionId, const struct FVector_NetQuantize100& ClientLocation, const struct FVector_NetQuantize100& ClientLinearVelocity, const struct FVector_NetQuantizeNormal& ClientRotator, const struct FVector_NetQuantize100& ClientAngularVelocity, const struct FVector_NetQuantize100& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleSyncComponent", "SendClientHitToServerUnreliably");

	Params::TslVehicleSyncComponent_SendClientHitToServerUnreliably Parms{};

	Parms.InCorrectionId = InCorrectionId;
	Parms.ClientLocation = std::move(ClientLocation);
	Parms.ClientLinearVelocity = std::move(ClientLinearVelocity);
	Parms.ClientRotator = std::move(ClientRotator);
	Parms.ClientAngularVelocity = std::move(ClientAngularVelocity);
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleSyncComponent.SendClientMoveToServerReliably
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// int32                                   InCorrectionId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100           ClientLocation                                         (Parm, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100           ClientLinearVelocity                                   (Parm, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal        ClientRotator                                          (Parm, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100           ClientAngularVelocity                                  (Parm, NativeAccessSpecifierPublic)

void UTslVehicleSyncComponent::SendClientMoveToServerReliably(int32 InCorrectionId, const struct FVector_NetQuantize100& ClientLocation, const struct FVector_NetQuantize100& ClientLinearVelocity, const struct FVector_NetQuantizeNormal& ClientRotator, const struct FVector_NetQuantize100& ClientAngularVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleSyncComponent", "SendClientMoveToServerReliably");

	Params::TslVehicleSyncComponent_SendClientMoveToServerReliably Parms{};

	Parms.InCorrectionId = InCorrectionId;
	Parms.ClientLocation = std::move(ClientLocation);
	Parms.ClientLinearVelocity = std::move(ClientLinearVelocity);
	Parms.ClientRotator = std::move(ClientRotator);
	Parms.ClientAngularVelocity = std::move(ClientAngularVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleSyncComponent.SendClientMoveToServerUnreliably
// (Final, Net, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// int32                                   InCorrectionId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100           ClientLocation                                         (Parm, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100           ClientLinearVelocity                                   (Parm, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal        ClientRotator                                          (Parm, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100           ClientAngularVelocity                                  (Parm, NativeAccessSpecifierPublic)

void UTslVehicleSyncComponent::SendClientMoveToServerUnreliably(int32 InCorrectionId, const struct FVector_NetQuantize100& ClientLocation, const struct FVector_NetQuantize100& ClientLinearVelocity, const struct FVector_NetQuantizeNormal& ClientRotator, const struct FVector_NetQuantize100& ClientAngularVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleSyncComponent", "SendClientMoveToServerUnreliably");

	Params::TslVehicleSyncComponent_SendClientMoveToServerUnreliably Parms{};

	Parms.InCorrectionId = InCorrectionId;
	Parms.ClientLocation = std::move(ClientLocation);
	Parms.ClientLinearVelocity = std::move(ClientLinearVelocity);
	Parms.ClientRotator = std::move(ClientRotator);
	Parms.ClientAngularVelocity = std::move(ClientAngularVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleSyncComponent.SendServerMoveToClient
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// int32                                   InCorrectionId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100           ServerLocation                                         (Parm, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100           ServerLinearVelocity                                   (Parm, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal        ServerRotator                                          (Parm, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize100           ServerAngularVelocity                                  (Parm, NativeAccessSpecifierPublic)
// bool                                    bIsSnap                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslVehicleSyncComponent::SendServerMoveToClient(int32 InCorrectionId, const struct FVector_NetQuantize100& ServerLocation, const struct FVector_NetQuantize100& ServerLinearVelocity, const struct FVector_NetQuantizeNormal& ServerRotator, const struct FVector_NetQuantize100& ServerAngularVelocity, bool bIsSnap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleSyncComponent", "SendServerMoveToClient");

	Params::TslVehicleSyncComponent_SendServerMoveToClient Parms{};

	Parms.InCorrectionId = InCorrectionId;
	Parms.ServerLocation = std::move(ServerLocation);
	Parms.ServerLinearVelocity = std::move(ServerLinearVelocity);
	Parms.ServerRotator = std::move(ServerRotator);
	Parms.ServerAngularVelocity = std::move(ServerAngularVelocity);
	Parms.bIsSnap = bIsSnap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSettings.GetTslSettings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UTslSettings*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTslSettings* UTslSettings::GetTslSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslSettings", "GetTslSettings");

	Params::TslSettings_GetTslSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslSettings.GetCharacterStudioRenderTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UTextureRenderTarget2D*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTextureRenderTarget2D* UTslSettings::GetCharacterStudioRenderTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSettings", "GetCharacterStudioRenderTarget");

	Params::TslSettings_GetCharacterStudioRenderTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslSettings.SetCharacterStudioRenderTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTextureRenderTarget2D*           rt                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslSettings::SetCharacterStudioRenderTarget(class UTextureRenderTarget2D* rt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSettings", "SetCharacterStudioRenderTarget");

	Params::TslSettings_SetCharacterStudioRenderTarget Parms{};

	Parms.rt = rt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSettings.IsESports
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslSettings::IsESports() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSettings", "IsESports");

	Params::TslSettings_IsESports Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslSettings.IsForChineseLicensing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UTslSettings::IsForChineseLicensing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSettings", "IsForChineseLicensing");

	Params::TslSettings_IsForChineseLicensing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslSettings.IsForKoreanRating
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UTslSettings::IsForKoreanRating() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSettings", "IsForKoreanRating");

	Params::TslSettings_IsForKoreanRating Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslVehicleCommonComponent.AddVehicleFuel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslVehicleCommonComponent::AddVehicleFuel(float Delta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleCommonComponent", "AddVehicleFuel");

	Params::TslVehicleCommonComponent_AddVehicleFuel Parms{};

	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleCommonComponent.Break
// (Final, Native, Public, BlueprintCallable)

void UTslVehicleCommonComponent::Break()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleCommonComponent", "Break");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleCommonComponent.OnRep_Broken
// (Final, Native, Private)

void UTslVehicleCommonComponent::OnRep_Broken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleCommonComponent", "OnRep_Broken");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleCommonComponent.OnRep_Dying
// (Final, Native, Private)

void UTslVehicleCommonComponent::OnRep_Dying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleCommonComponent", "OnRep_Dying");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleCommonComponent.OnRep_Fuel
// (Final, Native, Private)
// Parameters:
// float                                   LastFuel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslVehicleCommonComponent::OnRep_Fuel(float LastFuel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleCommonComponent", "OnRep_Fuel");

	Params::TslVehicleCommonComponent_OnRep_Fuel Parms{};

	Parms.LastFuel = LastFuel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleCommonComponent.OnRep_Health
// (Final, Native, Private)
// Parameters:
// float                                   LastHealth                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslVehicleCommonComponent::OnRep_Health(float LastHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleCommonComponent", "OnRep_Health");

	Params::TslVehicleCommonComponent_OnRep_Health Parms{};

	Parms.LastHealth = LastHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleCommonComponent.Repair
// (Final, Native, Public, BlueprintCallable)

void UTslVehicleCommonComponent::Repair()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleCommonComponent", "Repair");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleCommonComponent.SetVehicleFuel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewFuel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslVehicleCommonComponent::SetVehicleFuel(float NewFuel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleCommonComponent", "SetVehicleFuel");

	Params::TslVehicleCommonComponent_SetVehicleFuel Parms{};

	Parms.NewFuel = NewFuel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleCommonComponent.SetVehicleFuelPercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Percent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslVehicleCommonComponent::SetVehicleFuelPercent(float Percent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleCommonComponent", "SetVehicleFuelPercent");

	Params::TslVehicleCommonComponent_SetVehicleFuelPercent Parms{};

	Parms.Percent = Percent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleCommonComponent.SetVehicleHealth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslVehicleCommonComponent::SetVehicleHealth(float NewHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleCommonComponent", "SetVehicleHealth");

	Params::TslVehicleCommonComponent_SetVehicleHealth Parms{};

	Parms.NewHealth = NewHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleCommonComponent.CanIgnoreCharacterDamage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDamageTypeCategory                     DamageTypeCategory                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslVehicleCommonComponent::CanIgnoreCharacterDamage(EDamageTypeCategory DamageTypeCategory) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleCommonComponent", "CanIgnoreCharacterDamage");

	Params::TslVehicleCommonComponent_CanIgnoreCharacterDamage Parms{};

	Parms.DamageTypeCategory = DamageTypeCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslVehicleCommonComponent.GetVehicleBaseFuel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslVehicleCommonComponent::GetVehicleBaseFuel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleCommonComponent", "GetVehicleBaseFuel");

	Params::TslVehicleCommonComponent_GetVehicleBaseFuel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslVehicleCommonComponent.GetVehicleBaseHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslVehicleCommonComponent::GetVehicleBaseHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleCommonComponent", "GetVehicleBaseHealth");

	Params::TslVehicleCommonComponent_GetVehicleBaseHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslVehicleCommonComponent.GetVehicleFuel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslVehicleCommonComponent::GetVehicleFuel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleCommonComponent", "GetVehicleFuel");

	Params::TslVehicleCommonComponent_GetVehicleFuel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslVehicleCommonComponent.GetVehicleFuelPercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslVehicleCommonComponent::GetVehicleFuelPercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleCommonComponent", "GetVehicleFuelPercent");

	Params::TslVehicleCommonComponent_GetVehicleFuelPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslVehicleCommonComponent.GetVehicleHealth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslVehicleCommonComponent::GetVehicleHealth() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleCommonComponent", "GetVehicleHealth");

	Params::TslVehicleCommonComponent_GetVehicleHealth Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslVehicleCommonComponent.GetVehicleHealthPercent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslVehicleCommonComponent::GetVehicleHealthPercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleCommonComponent", "GetVehicleHealthPercent");

	Params::TslVehicleCommonComponent_GetVehicleHealthPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslVehicleCommonComponent.GetVehicleUI
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UUserWidget>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UUserWidget> UTslVehicleCommonComponent::GetVehicleUI() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleCommonComponent", "GetVehicleUI");

	Params::TslVehicleCommonComponent_GetVehicleUI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslVehicleCommonComponent.IsBroken
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslVehicleCommonComponent::IsBroken() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleCommonComponent", "IsBroken");

	Params::TslVehicleCommonComponent_IsBroken Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslVehicleCommonComponent.IsDying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslVehicleCommonComponent::IsDying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleCommonComponent", "IsDying");

	Params::TslVehicleCommonComponent_IsDying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameInstance.EnumerateReplayKillEvents
// (Final, Native, Public, BlueprintCallable)

void UTslGameInstance::EnumerateReplayKillEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameInstance", "EnumerateReplayKillEvents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameInstance.GetNumTotalReplays
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTslGameInstance::GetNumTotalReplays()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameInstance", "GetNumTotalReplays");

	Params::TslGameInstance_GetNumTotalReplays Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameInstance.GetReplayCurrentTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslGameInstance::GetReplayCurrentTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameInstance", "GetReplayCurrentTime");

	Params::TslGameInstance_GetReplayCurrentTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameInstance.GetReplayList
// (Final, Native, Public, BlueprintCallable)

void UTslGameInstance::GetReplayList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameInstance", "GetReplayList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameInstance.GetReplayListByRegionOrLocal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           RegionOrLocal                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PageIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PageSize                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameInstance::GetReplayListByRegionOrLocal(const class FString& RegionOrLocal, int32 PageIndex, int32 PageSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameInstance", "GetReplayListByRegionOrLocal");

	Params::TslGameInstance_GetReplayListByRegionOrLocal Parms{};

	Parms.RegionOrLocal = std::move(RegionOrLocal);
	Parms.PageIndex = PageIndex;
	Parms.PageSize = PageSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameInstance.GetReplayListLocal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PageIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PageSize                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameInstance::GetReplayListLocal(int32 PageIndex, int32 PageSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameInstance", "GetReplayListLocal");

	Params::TslGameInstance_GetReplayListLocal Parms{};

	Parms.PageIndex = PageIndex;
	Parms.PageSize = PageSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameInstance.GetReplayTotalTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslGameInstance::GetReplayTotalTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameInstance", "GetReplayTotalTime");

	Params::TslGameInstance_GetReplayTotalTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameInstance.IsLive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslGameInstance::IsLive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameInstance", "IsLive");

	Params::TslGameInstance_IsLive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameInstance.IsPaused
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslGameInstance::IsPaused()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameInstance", "IsPaused");

	Params::TslGameInstance_IsPaused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameInstance.IsRecording
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslGameInstance::IsRecording()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameInstance", "IsRecording");

	Params::TslGameInstance_IsRecording Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameInstance.IsReplaying
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslGameInstance::IsReplaying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameInstance", "IsReplaying");

	Params::TslGameInstance_IsReplaying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameInstance.Pause
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslGameInstance::Pause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameInstance", "Pause");

	Params::TslGameInstance_Pause Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameInstance.PlayReplayBP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           SessionOrFriendlyName                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameInstance::PlayReplayBP(const class FString& SessionOrFriendlyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameInstance", "PlayReplayBP");

	Params::TslGameInstance_PlayReplayBP Parms{};

	Parms.SessionOrFriendlyName = std::move(SessionOrFriendlyName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameInstance.PlayReplayBPByRegionOrLocal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           RegionOrLocal                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SessionOrFriendlyName                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameInstance::PlayReplayBPByRegionOrLocal(const class FString& RegionOrLocal, const class FString& SessionOrFriendlyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameInstance", "PlayReplayBPByRegionOrLocal");

	Params::TslGameInstance_PlayReplayBPByRegionOrLocal Parms{};

	Parms.RegionOrLocal = std::move(RegionOrLocal);
	Parms.SessionOrFriendlyName = std::move(SessionOrFriendlyName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameInstance.ReplayJump
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TimelinePercentage                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameInstance::ReplayJump(float TimelinePercentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameInstance", "ReplayJump");

	Params::TslGameInstance_ReplayJump Parms{};

	Parms.TimelinePercentage = TimelinePercentage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameInstance.SetReplayTimeSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TimeSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGameInstance::SetReplayTimeSpeed(float TimeSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameInstance", "SetReplayTimeSpeed");

	Params::TslGameInstance_SetReplayTimeSpeed Parms{};

	Parms.TimeSpeed = TimeSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameInstance.ShowLoadingScreen
// (Final, Native, Public, BlueprintCallable)

void UTslGameInstance::ShowLoadingScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameInstance", "ShowLoadingScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameInstance.UnPause
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslGameInstance::UnPause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameInstance", "UnPause");

	Params::TslGameInstance_UnPause Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameInstance.GetCurrentGameState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

FName UTslGameInstance::GetCurrentGameState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameInstance", "GetCurrentGameState");

	Params::TslGameInstance_GetCurrentGameState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameInstance.GetGameEventObserver
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UGameEventObserver*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameEventObserver* UTslGameInstance::GetGameEventObserver() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameInstance", "GetGameEventObserver");

	Params::TslGameInstance_GetGameEventObserver Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameInstance.GetStartParameter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FTslStartParameter         ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FTslStartParameter UTslGameInstance::GetStartParameter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameInstance", "GetStartParameter");

	Params::TslGameInstance_GetStartParameter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameInstance.GetStartParameterStringValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NotFoundValue                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTslGameInstance::GetStartParameterStringValue(const class FString& Key, const class FString& NotFoundValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameInstance", "GetStartParameterStringValue");

	Params::TslGameInstance_GetStartParameterStringValue Parms{};

	Parms.Key = std::move(Key);
	Parms.NotFoundValue = std::move(NotFoundValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameInstance.UseLobbyWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslGameInstance::UseLobbyWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameInstance", "UseLobbyWidget");

	Params::TslGameInstance_UseLobbyWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameMode.BenchmarkFinished
// (Final, Native, Protected)

void ATslGameMode::BenchmarkFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameMode", "BenchmarkFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameMode.BroadcastGameModeEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Parameter                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslGameMode::BroadcastGameModeEvent(FName EventName, const class FString& Parameter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameMode", "BroadcastGameModeEvent");

	Params::TslGameMode_BroadcastGameModeEvent Parms{};

	Parms.EventName = EventName;
	Parms.Parameter = std::move(Parameter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameMode.FindCharacterByPlayerState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerState*                     State                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATslCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslCharacter* ATslGameMode::FindCharacterByPlayerState(const class APlayerState* State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameMode", "FindCharacterByPlayerState");

	Params::TslGameMode_FindCharacterByPlayerState Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameMode.FinishMatch
// (Final, Exec, Native, Public, BlueprintCallable)

void ATslGameMode::FinishMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameMode", "FinishMatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameMode.GetAllPawns
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class APawn*>                    OutPawns                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ATslGameMode::GetAllPawns(TArray<class APawn*>* OutPawns)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameMode", "GetAllPawns");

	Params::TslGameMode_GetAllPawns Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPawns != nullptr)
		*OutPawns = std::move(Parms.OutPawns);
}


// Function TslGame.TslGameMode.GetItemSpawnProcessor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UItemSpawnProcessor*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UItemSpawnProcessor* ATslGameMode::GetItemSpawnProcessor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameMode", "GetItemSpawnProcessor");

	Params::TslGameMode_GetItemSpawnProcessor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameMode.GetThingSpawnProcessor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UThingSpawnProcessor*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UThingSpawnProcessor* ATslGameMode::GetThingSpawnProcessor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameMode", "GetThingSpawnProcessor");

	Params::TslGameMode_GetThingSpawnProcessor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameMode.NotifyNextGasInToAll
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          PoisonGasWarningPosition                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   PoisonGasWarningRadius                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslGameMode::NotifyNextGasInToAll(const struct FVector& PoisonGasWarningPosition, float PoisonGasWarningRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameMode", "NotifyNextGasInToAll");

	Params::TslGameMode_NotifyNextGasInToAll Parms{};

	Parms.PoisonGasWarningPosition = std::move(PoisonGasWarningPosition);
	Parms.PoisonGasWarningRadius = PoisonGasWarningRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameMode.NotifyRestrictingPlayAreaToAll
// (Final, Native, Public, BlueprintCallable)

void ATslGameMode::NotifyRestrictingPlayAreaToAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameMode", "NotifyRestrictingPlayAreaToAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameMode.SendSystemMessageToAll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESystemMessageType                      MessageType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Message                                                (Parm, NativeAccessSpecifierPublic)
// float                                   MessageDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslGameMode::SendSystemMessageToAll(ESystemMessageType MessageType, const class FText& Message, float MessageDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameMode", "SendSystemMessageToAll");

	Params::TslGameMode_SendSystemMessageToAll Parms{};

	Parms.MessageType = MessageType;
	Parms.Message = std::move(Message);
	Parms.MessageDuration = MessageDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameMode.CanDealDamage
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslPlayerState*                  DamageInstigator                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATslPlayerState*                  DamagedPlayer                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslGameMode::CanDealDamage(const class ATslPlayerState* DamageInstigator, const class ATslPlayerState* DamagedPlayer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameMode", "CanDealDamage");

	Params::TslGameMode_CanDealDamage Parms{};

	Parms.DamageInstigator = DamageInstigator;
	Parms.DamagedPlayer = DamagedPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameMode.GetLobbyLink
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULobbyLink*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULobbyLink* ATslGameMode::GetLobbyLink() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameMode", "GetLobbyLink");

	Params::TslGameMode_GetLobbyLink Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameMode.GetVivoxManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UVivoxManager*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVivoxManager* ATslGameMode::GetVivoxManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameMode", "GetVivoxManager");

	Params::TslGameMode_GetVivoxManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameMode.IsPlayInEditor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslGameMode::IsPlayInEditor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameMode", "IsPlayInEditor");

	Params::TslGameMode_IsPlayInEditor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameMode.IsPreventFinishMatch
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslGameMode::IsPreventFinishMatch() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameMode", "IsPreventFinishMatch");

	Params::TslGameMode_IsPreventFinishMatch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameState.OnRep_GasRelease
// (Final, Native, Public)
// Parameters:
// bool                                    bLastIsGasRelease                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslGameState::OnRep_GasRelease(bool bLastIsGasRelease)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameState", "OnRep_GasRelease");

	Params::TslGameState_OnRep_GasRelease Parms{};

	Parms.bLastIsGasRelease = bLastIsGasRelease;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameState.OnRep_MatchShortGuid
// (Final, Native, Public)

void ATslGameState::OnRep_MatchShortGuid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameState", "OnRep_MatchShortGuid");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameState.OnStartGasRelease
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InbIsGasRelease                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslGameState::OnStartGasRelease(bool InbIsGasRelease)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameState", "OnStartGasRelease");

	Params::TslGameState_OnStartGasRelease Parms{};

	Parms.InbIsGasRelease = InbIsGasRelease;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameState.UpdateWorldTimeSecondsDelta
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslGameState::UpdateWorldTimeSecondsDelta(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameState", "UpdateWorldTimeSecondsDelta");

	Params::TslGameState_UpdateWorldTimeSecondsDelta Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGameState.GetLevelAttribute
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ALevelAttribute*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ALevelAttribute* ATslGameState::GetLevelAttribute() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameState", "GetLevelAttribute");

	Params::TslGameState_GetLevelAttribute Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameState.IsMatchInProgressBP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslGameState::IsMatchInProgressBP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameState", "IsMatchInProgressBP");

	Params::TslGameState_IsMatchInProgressBP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslGameState.ShowPlayerStateList
// (Final, Exec, Native, Public, Const)

void ATslGameState::ShowPlayerStateList() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGameState", "ShowPlayerStateList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGlassWindowComponent.ClientNotifyHit
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    bBlockingHit                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              Location                                               (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal        ImpactNormal                                           (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UTslGlassWindowComponent::ClientNotifyHit(bool bBlockingHit, const struct FVector_NetQuantize& Location, const struct FVector_NetQuantizeNormal& ImpactNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGlassWindowComponent", "ClientNotifyHit");

	Params::TslGlassWindowComponent_ClientNotifyHit Parms{};

	Parms.bBlockingHit = bBlockingHit;
	Parms.Location = std::move(Location);
	Parms.ImpactNormal = std::move(ImpactNormal);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGlassWindowComponent.OnRep_Destroyed
// (Final, Native, Protected)
// Parameters:
// bool                                    bLastDestroyed                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGlassWindowComponent::OnRep_Destroyed(bool bLastDestroyed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGlassWindowComponent", "OnRep_Destroyed");

	Params::TslGlassWindowComponent_OnRep_Destroyed Parms{};

	Parms.bLastDestroyed = bLastDestroyed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslGlassWindowComponent.OnRep_ReplicatedOnClient
// (Final, Native, Protected)
// Parameters:
// bool                                    bLastReplicatedOnClient                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslGlassWindowComponent::OnRep_ReplicatedOnClient(bool bLastReplicatedOnClient)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslGlassWindowComponent", "OnRep_ReplicatedOnClient");

	Params::TslGlassWindowComponent_OnRep_ReplicatedOnClient Parms{};

	Parms.bLastReplicatedOnClient = bLastReplicatedOnClient;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslHealthGaugeData.GetGaugeColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   HealthPercent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FLinearColor UTslHealthGaugeData::GetGaugeColor(float HealthPercent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslHealthGaugeData", "GetGaugeColor");

	Params::TslHealthGaugeData_GetGaugeColor Parms{};

	Parms.HealthPercent = HealthPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslInstancedReactionComponent.Client_ReactByPointDamage
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// int32                                   InstanceIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Impact                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ImpulseDir                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UTslInstancedReactionComponent::Client_ReactByPointDamage(int32 InstanceIndex, float DamageAmount, const struct FVector& Impact, const struct FVector& ImpulseDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslInstancedReactionComponent", "Client_ReactByPointDamage");

	Params::TslInstancedReactionComponent_Client_ReactByPointDamage Parms{};

	Parms.InstanceIndex = InstanceIndex;
	Parms.DamageAmount = DamageAmount;
	Parms.Impact = std::move(Impact);
	Parms.ImpulseDir = std::move(ImpulseDir);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslInstancedReactionComponent.Client_ReactByRadialDamage
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// int32                                   InstanceIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Impact                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ImpulseDir                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   OuterRadius                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslInstancedReactionComponent::Client_ReactByRadialDamage(int32 InstanceIndex, float DamageAmount, const struct FVector& Origin, const struct FVector& Impact, const struct FVector& ImpulseDir, float OuterRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslInstancedReactionComponent", "Client_ReactByRadialDamage");

	Params::TslInstancedReactionComponent_Client_ReactByRadialDamage Parms{};

	Parms.InstanceIndex = InstanceIndex;
	Parms.DamageAmount = DamageAmount;
	Parms.Origin = std::move(Origin);
	Parms.Impact = std::move(Impact);
	Parms.ImpulseDir = std::move(ImpulseDir);
	Parms.OuterRadius = OuterRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslInstancedReactionComponent.Client_ReactByVehicle
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// int32                                   InstanceIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Impact                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ImpulseDir                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Velocity                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UTslInstancedReactionComponent::Client_ReactByVehicle(int32 InstanceIndex, const struct FVector& Impact, const struct FVector& ImpulseDir, const struct FVector& Velocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslInstancedReactionComponent", "Client_ReactByVehicle");

	Params::TslInstancedReactionComponent_Client_ReactByVehicle Parms{};

	Parms.InstanceIndex = InstanceIndex;
	Parms.Impact = std::move(Impact);
	Parms.ImpulseDir = std::move(ImpulseDir);
	Parms.Velocity = std::move(Velocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslInstancedReactionComponent.OnRep_PendingDestroy
// (Final, Native, Protected)

void UTslInstancedReactionComponent::OnRep_PendingDestroy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslInstancedReactionComponent", "OnRep_PendingDestroy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslLevelScriptActor.EnumerateReplayLevelEvents
// (Final, Native, Private, BlueprintCallable)

void ATslLevelScriptActor::EnumerateReplayLevelEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslLevelScriptActor", "EnumerateReplayLevelEvents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslLevelScriptActor.OnRep_SelectedWeatherIndex
// (Final, Native, Private)

void ATslLevelScriptActor::OnRep_SelectedWeatherIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslLevelScriptActor", "OnRep_SelectedWeatherIndex");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslLevelScriptActor.RecordWeatherAsCustomEvent
// (Final, Native, Private)

void ATslLevelScriptActor::RecordWeatherAsCustomEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslLevelScriptActor", "RecordWeatherAsCustomEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslLevelScriptActor.RequestReplayALevelWeatherEvent
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class FString                           EventID                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslLevelScriptActor::RequestReplayALevelWeatherEvent(const class FString& EventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslLevelScriptActor", "RequestReplayALevelWeatherEvent");

	Params::TslLevelScriptActor_RequestReplayALevelWeatherEvent Parms{};

	Parms.EventID = std::move(EventID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslModularBuilding.AddAttachmentToTable
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FString                           Keyword                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMeshComponent*             Attachment                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslModularBuilding::AddAttachmentToTable(const class FString& Keyword, class UStaticMeshComponent* Attachment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslModularBuilding", "AddAttachmentToTable");

	Params::TslModularBuilding_AddAttachmentToTable Parms{};

	Parms.Keyword = std::move(Keyword);
	Parms.Attachment = Attachment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslModularBuilding.AddBuildingModuleToTable
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FString                           Keyword                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMeshComponent*             Building                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslModularBuilding::AddBuildingModuleToTable(const class FString& Keyword, class UStaticMeshComponent* Building)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslModularBuilding", "AddBuildingModuleToTable");

	Params::TslModularBuilding_AddBuildingModuleToTable Parms{};

	Parms.Keyword = std::move(Keyword);
	Parms.Building = Building;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslModularBuilding.ClearAttachmentTable
// (Final, Native, Protected, BlueprintCallable)

void ATslModularBuilding::ClearAttachmentTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslModularBuilding", "ClearAttachmentTable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslModularBuilding.ClearBuildingModuleTable
// (Final, Native, Protected, BlueprintCallable)

void ATslModularBuilding::ClearBuildingModuleTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslModularBuilding", "ClearBuildingModuleTable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslModularBuilding.GetAttachmentsFromTable
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FString                           Keyword                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UStaticMeshComponent*>     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UStaticMeshComponent*> ATslModularBuilding::GetAttachmentsFromTable(const class FString& Keyword)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslModularBuilding", "GetAttachmentsFromTable");

	Params::TslModularBuilding_GetAttachmentsFromTable Parms{};

	Parms.Keyword = std::move(Keyword);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslModularBuilding.GetBuildingModuleFromTable
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FString                           Keyword                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UStaticMeshComponent*>     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UStaticMeshComponent*> ATslModularBuilding::GetBuildingModuleFromTable(const class FString& Keyword)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslModularBuilding", "GetBuildingModuleFromTable");

	Params::TslModularBuilding_GetBuildingModuleFromTable Parms{};

	Parms.Keyword = std::move(Keyword);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslModularBuilding.GetMeshOnSapartedFloor
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   SepartedFloor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Keyword                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UStaticMeshComponent*>     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UStaticMeshComponent*> ATslModularBuilding::GetMeshOnSapartedFloor(int32 SepartedFloor, const class FString& Keyword)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslModularBuilding", "GetMeshOnSapartedFloor");

	Params::TslModularBuilding_GetMeshOnSapartedFloor Parms{};

	Parms.SepartedFloor = SepartedFloor;
	Parms.Keyword = std::move(Keyword);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslModularBuilding.PassSeparatedFloors
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UChildActorComponent*>     Floors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ATslModularBuilding::PassSeparatedFloors(const TArray<class UChildActorComponent*>& Floors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslModularBuilding", "PassSeparatedFloors");

	Params::TslModularBuilding_PassSeparatedFloors Parms{};

	Parms.Floors = std::move(Floors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerState.BroadcastDeath
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ATslPlayerState*                  KillerPlayerState                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATslPlayerState*                  GroggyPlayerInstigator                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      KillerDamageType                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDamageReason                           DamageReason                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             DamageCauserName                                       (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   AlivePlayerNum                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AliveTeamNum                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InbIsStealKilled                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerState::BroadcastDeath(class ATslPlayerState* KillerPlayerState, class ATslPlayerState* GroggyPlayerInstigator, const class UDamageType* KillerDamageType, EDamageReason DamageReason, const class FText& DamageCauserName, int32 AlivePlayerNum, int32 AliveTeamNum, bool InbIsStealKilled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerState", "BroadcastDeath");

	Params::TslPlayerState_BroadcastDeath Parms{};

	Parms.KillerPlayerState = KillerPlayerState;
	Parms.GroggyPlayerInstigator = GroggyPlayerInstigator;
	Parms.KillerDamageType = KillerDamageType;
	Parms.DamageReason = DamageReason;
	Parms.DamageCauserName = std::move(DamageCauserName);
	Parms.AlivePlayerNum = AlivePlayerNum;
	Parms.AliveTeamNum = AliveTeamNum;
	Parms.InbIsStealKilled = InbIsStealKilled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerState.InformAboutKill
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class UDamageType*                      KillerDamageType                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATslPlayerState*                  KilledPlayerState                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslPlayerState::InformAboutKill(const class UDamageType* KillerDamageType, class ATslPlayerState* KilledPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerState", "InformAboutKill");

	Params::TslPlayerState_InformAboutKill Parms{};

	Parms.KillerDamageType = KillerDamageType;
	Parms.KilledPlayerState = KilledPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerState.OnRep_LastHitTime
// (Final, Native, Protected)

void ATslPlayerState::OnRep_LastHitTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerState", "OnRep_LastHitTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerState.OnRep_PlayerStatistics
// (Final, Native, Protected)
// Parameters:
// struct FTslPlayerStatistics             OldPlayerStatistics                                    (Parm, NativeAccessSpecifierPublic)

void ATslPlayerState::OnRep_PlayerStatistics(const struct FTslPlayerStatistics& OldPlayerStatistics)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerState", "OnRep_PlayerStatistics");

	Params::TslPlayerState_OnRep_PlayerStatistics Parms{};

	Parms.OldPlayerStatistics = std::move(OldPlayerStatistics);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslPlayerState.GetKills
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ATslPlayerState::GetKills() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerState", "GetKills");

	Params::TslPlayerState_GetKills Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerState.GetObserverAuthorityType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EObserverAuthorityType                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EObserverAuthorityType ATslPlayerState::GetObserverAuthorityType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerState", "GetObserverAuthorityType");

	Params::TslPlayerState_GetObserverAuthorityType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerState.GetPing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslPlayerState::GetPing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerState", "GetPing");

	Params::TslPlayerState_GetPing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerState.GetPlayerScores
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTslPlayerScores                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTslPlayerScores ATslPlayerState::GetPlayerScores() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerState", "GetPlayerScores");

	Params::TslPlayerState_GetPlayerScores Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerState.GetShortPlayerName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ATslPlayerState::GetShortPlayerName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerState", "GetShortPlayerName");

	Params::TslPlayerState_GetShortPlayerName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerState.GetTeamNum
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ATslPlayerState::GetTeamNum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerState", "GetTeamNum");

	Params::TslPlayerState_GetTeamNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerState.IsObserver
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslPlayerState::IsObserver() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerState", "IsObserver");

	Params::TslPlayerState_IsObserver Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPlayerState.IsQuitter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslPlayerState::IsQuitter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPlayerState", "IsQuitter");

	Params::TslPlayerState_IsQuitter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPostProcessEffect.SetEffectParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ParameterName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslPostProcessEffect::SetEffectParameter(const class FString& ParameterName, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPostProcessEffect", "SetEffectParameter");

	Params::TslPostProcessEffect_SetEffectParameter Parms{};

	Parms.ParameterName = std::move(ParameterName);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPostProcessEffect.SetMaterialBlendWeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   idx                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslPostProcessEffect::SetMaterialBlendWeight(int32 idx, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPostProcessEffect", "SetMaterialBlendWeight");

	Params::TslPostProcessEffect_SetMaterialBlendWeight Parms{};

	Parms.idx = idx;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPostProcessEffect.SetMaterialParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   idx                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslPostProcessEffect::SetMaterialParameter(int32 idx, FName ParameterName, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPostProcessEffect", "SetMaterialParameter");

	Params::TslPostProcessEffect_SetMaterialParameter Parms{};

	Parms.idx = idx;
	Parms.ParameterName = ParameterName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPostProcessEffect.SetMaterialVectorParameter
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   idx                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslPostProcessEffect::SetMaterialVectorParameter(int32 idx, FName ParameterName, const struct FLinearColor& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPostProcessEffect", "SetMaterialVectorParameter");

	Params::TslPostProcessEffect_SetMaterialVectorParameter Parms{};

	Parms.idx = idx;
	Parms.ParameterName = ParameterName;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslPostProcessEffect.GetEffectParameter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ParameterName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DefaultValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslPostProcessEffect::GetEffectParameter(const class FString& ParameterName, float DefaultValue) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslPostProcessEffect", "GetEffectParameter");

	Params::TslPostProcessEffect_GetEffectParameter Parms{};

	Parms.ParameterName = std::move(ParameterName);
	Parms.DefaultValue = DefaultValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslReactionDoorComponent.ClientTakeDamage
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              HitLocation                                            (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   DamageRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Impulse                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslReactionDoorComponent::ClientTakeDamage(float Damage, const struct FVector_NetQuantize& HitLocation, float DamageRadius, float Impulse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslReactionDoorComponent", "ClientTakeDamage");

	Params::TslReactionDoorComponent_ClientTakeDamage Parms{};

	Parms.Damage = Damage;
	Parms.HitLocation = std::move(HitLocation);
	Parms.DamageRadius = DamageRadius;
	Parms.Impulse = Impulse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslReactionDoorComponent.OnRep_DoorBreakingState
// (Final, Native, Protected)

void UTslReactionDoorComponent::OnRep_DoorBreakingState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslReactionDoorComponent", "OnRep_DoorBreakingState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSceneCaptureComponent2D.CaptureScene
// (Final, Native, Public, BlueprintCallable)

void UTslSceneCaptureComponent2D::CaptureScene()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSceneCaptureComponent2D", "CaptureScene");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSceneCaptureWorld.DestroyWorld
// (Final, Native, Public, BlueprintCallable)

void UTslSceneCaptureWorld::DestroyWorld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSceneCaptureWorld", "DestroyWorld");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSceneCaptureWorld.InitWorld
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameInstance*                    GameInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SceneCapturePackageName                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslSceneCaptureWorld::InitWorld(class UGameInstance* GameInstance, const class FString& SceneCapturePackageName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSceneCaptureWorld", "InitWorld");

	Params::TslSceneCaptureWorld_InitWorld Parms{};

	Parms.GameInstance = GameInstance;
	Parms.SceneCapturePackageName = std::move(SceneCapturePackageName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslServerParticle.OnParticleFinish
// (Final, Native, Protected)
// Parameters:
// class UParticleSystemComponent*         PSystem                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslServerParticle::OnParticleFinish(class UParticleSystemComponent* PSystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslServerParticle", "OnParticleFinish");

	Params::TslServerParticle_OnParticleFinish Parms{};

	Parms.PSystem = PSystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslServerParticle.StopParticleMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ATslServerParticle::StopParticleMulticast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslServerParticle", "StopParticleMulticast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSpectatorPawn.BackupTargetCharacterID
// (Final, Native, Public, BlueprintCallable)

void ATslSpectatorPawn::BackupTargetCharacterID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "BackupTargetCharacterID");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSpectatorPawn.OnPlayerInfoDistanceDown
// (Final, Native, Public)

void ATslSpectatorPawn::OnPlayerInfoDistanceDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "OnPlayerInfoDistanceDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSpectatorPawn.OnPlayerInfoDistanceDownHold
// (Final, Native, Public)

void ATslSpectatorPawn::OnPlayerInfoDistanceDownHold()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "OnPlayerInfoDistanceDownHold");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSpectatorPawn.OnPlayerInfoDistanceUp
// (Final, Native, Public)

void ATslSpectatorPawn::OnPlayerInfoDistanceUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "OnPlayerInfoDistanceUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSpectatorPawn.OnPlayerInfoDistanceUpHold
// (Final, Native, Public)

void ATslSpectatorPawn::OnPlayerInfoDistanceUpHold()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "OnPlayerInfoDistanceUpHold");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSpectatorPawn.OnSaveCharacter
// (Final, Native, Public)
// Parameters:
// uint8                                   idx                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslSpectatorPawn::OnSaveCharacter(uint8 idx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "OnSaveCharacter");

	Params::TslSpectatorPawn_OnSaveCharacter Parms{};

	Parms.idx = idx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSpectatorPawn.OnSaveLocation
// (Final, Native, Private)
// Parameters:
// uint8                                   idx                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslSpectatorPawn::OnSaveLocation(uint8 idx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "OnSaveLocation");

	Params::TslSpectatorPawn_OnSaveLocation Parms{};

	Parms.idx = idx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSpectatorPawn.OnSetCharacter
// (Final, Native, Private)
// Parameters:
// uint8                                   idx                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslSpectatorPawn::OnSetCharacter(uint8 idx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "OnSetCharacter");

	Params::TslSpectatorPawn_OnSetCharacter Parms{};

	Parms.idx = idx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSpectatorPawn.OnSetCharacterSpec
// (Final, Native, Private)
// Parameters:
// uint8                                   idx                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslSpectatorPawn::OnSetCharacterSpec(uint8 idx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "OnSetCharacterSpec");

	Params::TslSpectatorPawn_OnSetCharacterSpec Parms{};

	Parms.idx = idx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSpectatorPawn.OnSetFollow
// (Final, Native, Public)

void ATslSpectatorPawn::OnSetFollow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "OnSetFollow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSpectatorPawn.OnSetFree
// (Final, Native, Public)

void ATslSpectatorPawn::OnSetFree()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "OnSetFree");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSpectatorPawn.OnSetLocation
// (Final, Native, Private)
// Parameters:
// uint8                                   idx                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslSpectatorPawn::OnSetLocation(uint8 idx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "OnSetLocation");

	Params::TslSpectatorPawn_OnSetLocation Parms{};

	Parms.idx = idx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSpectatorPawn.OnSetSpectator
// (Final, Native, Public)

void ATslSpectatorPawn::OnSetSpectator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "OnSetSpectator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSpectatorPawn.OnStartFastMove
// (Final, Native, Private)

void ATslSpectatorPawn::OnStartFastMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "OnStartFastMove");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSpectatorPawn.OnStartSlowMove
// (Final, Native, Private)

void ATslSpectatorPawn::OnStartSlowMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "OnStartSlowMove");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSpectatorPawn.OnStopFastMove
// (Final, Native, Private)

void ATslSpectatorPawn::OnStopFastMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "OnStopFastMove");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSpectatorPawn.OnStopSlowMove
// (Final, Native, Private)

void ATslSpectatorPawn::OnStopSlowMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "OnStopSlowMove");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSpectatorPawn.OnSwitchCameraFollow
// (Final, Native, Public)

void ATslSpectatorPawn::OnSwitchCameraFollow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "OnSwitchCameraFollow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSpectatorPawn.OnSwitchCameraSpectator
// (Final, Native, Public)

void ATslSpectatorPawn::OnSwitchCameraSpectator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "OnSwitchCameraSpectator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSpectatorPawn.OnThirdPersonActivated
// (Final, Native, Private)
// Parameters:
// class UActorComponent*                  InThirdPersonCamera                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslSpectatorPawn::OnThirdPersonActivated(class UActorComponent* InThirdPersonCamera, bool bReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "OnThirdPersonActivated");

	Params::TslSpectatorPawn_OnThirdPersonActivated Parms{};

	Parms.InThirdPersonCamera = InThirdPersonCamera;
	Parms.bReset = bReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSpectatorPawn.OnToggleObseverTagWidget
// (Final, Native, Private)

void ATslSpectatorPawn::OnToggleObseverTagWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "OnToggleObseverTagWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSpectatorPawn.OnToggleShowObseverTagWeapon
// (Final, Native, Private)

void ATslSpectatorPawn::OnToggleShowObseverTagWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "OnToggleShowObseverTagWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSpectatorPawn.OnViewTargetUpdate
// (Final, Native, Private)
// Parameters:
// class AActor*                           NewViewTarget                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslSpectatorPawn::OnViewTargetUpdate(class AActor* NewViewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "OnViewTargetUpdate");

	Params::TslSpectatorPawn_OnViewTargetUpdate Parms{};

	Parms.NewViewTarget = NewViewTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSpectatorPawn.RestoreTargetCharacter
// (Final, Native, Public, BlueprintCallable)

void ATslSpectatorPawn::RestoreTargetCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "RestoreTargetCharacter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSpectatorPawn.SetFreeCamBattleLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          HitterLoc                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          AttackedLoc                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ATslSpectatorPawn::SetFreeCamBattleLocation(const struct FVector& HitterLoc, const struct FVector& AttackedLoc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "SetFreeCamBattleLocation");

	Params::TslSpectatorPawn_SetFreeCamBattleLocation Parms{};

	Parms.HitterLoc = std::move(HitterLoc);
	Parms.AttackedLoc = std::move(AttackedLoc);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSpectatorPawn.SetObserverCameraMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EObserverCameraMode                     NewCameraMode                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           NewViewTarget                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsBlend                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslSpectatorPawn::SetObserverCameraMode(EObserverCameraMode NewCameraMode, class AActor* NewViewTarget, bool IsBlend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "SetObserverCameraMode");

	Params::TslSpectatorPawn_SetObserverCameraMode Parms{};

	Parms.NewCameraMode = NewCameraMode;
	Parms.NewViewTarget = NewViewTarget;
	Parms.IsBlend = IsBlend;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSpectatorPawn.SetPlayerCamera
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           NewViewTarget                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslSpectatorPawn::SetPlayerCamera(class AActor* NewViewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "SetPlayerCamera");

	Params::TslSpectatorPawn_SetPlayerCamera Parms{};

	Parms.NewViewTarget = NewViewTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSpectatorPawn.SetShowPlayerInfoDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslSpectatorPawn::SetShowPlayerInfoDistance(float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "SetShowPlayerInfoDistance");

	Params::TslSpectatorPawn_SetShowPlayerInfoDistance Parms{};

	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslSpectatorPawn.GetCameraMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EObserverCameraMode                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EObserverCameraMode ATslSpectatorPawn::GetCameraMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "GetCameraMode");

	Params::TslSpectatorPawn_GetCameraMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslSpectatorPawn.GetLastSpectatedCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslCharacter* ATslSpectatorPawn::GetLastSpectatedCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "GetLastSpectatedCharacter");

	Params::TslSpectatorPawn_GetLastSpectatedCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslSpectatorPawn.GetObserverTagShow
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslSpectatorPawn::GetObserverTagShow() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "GetObserverTagShow");

	Params::TslSpectatorPawn_GetObserverTagShow Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslSpectatorPawn.GetShowPlayerInfoDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslSpectatorPawn::GetShowPlayerInfoDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "GetShowPlayerInfoDistance");

	Params::TslSpectatorPawn_GetShowPlayerInfoDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslSpectatorPawn.GetSpectableCarePackageItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACarePackageItem*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACarePackageItem* ATslSpectatorPawn::GetSpectableCarePackageItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "GetSpectableCarePackageItem");

	Params::TslSpectatorPawn_GetSpectableCarePackageItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslSpectatorPawn.GetSpectatableCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslCharacter* ATslSpectatorPawn::GetSpectatableCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "GetSpectatableCharacter");

	Params::TslSpectatorPawn_GetSpectatableCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslSpectatorPawn.IsObserverTagWeaponShow
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslSpectatorPawn::IsObserverTagWeaponShow() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslSpectatorPawn", "IsObserverTagWeaponShow");

	Params::TslSpectatorPawn_IsObserverTagWeaponShow Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.ApplyDamage
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           DamagedActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseDamage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      EventInstigator                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDamageType>          DamageTypeClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAttackId                        AttackId                                               (Parm, NativeAccessSpecifierPublic)

void UTslStatics::ApplyDamage(class AActor* DamagedActor, float BaseDamage, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UDamageType> DamageTypeClass, const struct FAttackId& AttackId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "ApplyDamage");

	Params::TslStatics_ApplyDamage Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.BaseDamage = BaseDamage;
	Parms.EventInstigator = EventInstigator;
	Parms.DamageCauser = DamageCauser;
	Parms.DamageTypeClass = DamageTypeClass;
	Parms.AttackId = std::move(AttackId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslStatics.ApplyRadialDamage
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseDamage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   DamageRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDamageType>          DamageTypeClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   IgnoreActors                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FAttackId                        AttackId                                               (Parm, NativeAccessSpecifierPublic)
// bool                                    bIsTargetDestructible                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedByController                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDoFullDamage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       DamagePreventionChannel                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExplode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslStatics::ApplyRadialDamage(class UObject* WorldContextObject, float BaseDamage, const struct FVector& Origin, float DamageRadius, TSubclassOf<class UDamageType> DamageTypeClass, const TArray<class AActor*>& IgnoreActors, const struct FAttackId& AttackId, bool bIsTargetDestructible, class AActor* DamageCauser, class AController* InstigatedByController, bool bDoFullDamage, ECollisionChannel DamagePreventionChannel, bool bExplode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "ApplyRadialDamage");

	Params::TslStatics_ApplyRadialDamage Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BaseDamage = BaseDamage;
	Parms.Origin = std::move(Origin);
	Parms.DamageRadius = DamageRadius;
	Parms.DamageTypeClass = DamageTypeClass;
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.AttackId = std::move(AttackId);
	Parms.bIsTargetDestructible = bIsTargetDestructible;
	Parms.DamageCauser = DamageCauser;
	Parms.InstigatedByController = InstigatedByController;
	Parms.bDoFullDamage = bDoFullDamage;
	Parms.DamagePreventionChannel = DamagePreventionChannel;
	Parms.bExplode = bExplode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.ApplyRadialDamageWithCurve
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseDamage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   DamageRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      DamageCurve                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDamageType>          DamageTypeClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   IgnoreActors                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FAttackId                        AttackId                                               (Parm, NativeAccessSpecifierPublic)
// bool                                    bIsTargetDestructible                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedByController                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       DamagePreventionChannel                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExplode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslStatics::ApplyRadialDamageWithCurve(class UObject* WorldContextObject, float BaseDamage, const struct FVector& Origin, float DamageRadius, const class UCurveFloat* DamageCurve, TSubclassOf<class UDamageType> DamageTypeClass, const TArray<class AActor*>& IgnoreActors, const struct FAttackId& AttackId, bool bIsTargetDestructible, class AActor* DamageCauser, class AController* InstigatedByController, ECollisionChannel DamagePreventionChannel, bool bExplode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "ApplyRadialDamageWithCurve");

	Params::TslStatics_ApplyRadialDamageWithCurve Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BaseDamage = BaseDamage;
	Parms.Origin = std::move(Origin);
	Parms.DamageRadius = DamageRadius;
	Parms.DamageCurve = DamageCurve;
	Parms.DamageTypeClass = DamageTypeClass;
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.AttackId = std::move(AttackId);
	Parms.bIsTargetDestructible = bIsTargetDestructible;
	Parms.DamageCauser = DamageCauser;
	Parms.InstigatedByController = InstigatedByController;
	Parms.DamagePreventionChannel = DamagePreventionChannel;
	Parms.bExplode = bExplode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.ApplyRadialDamageWithFalloff
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BaseDamage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinimumDamage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   DamageInnerRadius                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageOuterRadius                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DamageFalloff                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UDamageType>          DamageTypeClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   IgnoreActors                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FAttackId                        AttackId                                               (Parm, NativeAccessSpecifierPublic)
// bool                                    bIsTargetDestructible                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedByController                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       DamagePreventionChannel                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExplode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslStatics::ApplyRadialDamageWithFalloff(class UObject* WorldContextObject, float BaseDamage, float MinimumDamage, const struct FVector& Origin, float DamageInnerRadius, float DamageOuterRadius, float DamageFalloff, TSubclassOf<class UDamageType> DamageTypeClass, const TArray<class AActor*>& IgnoreActors, const struct FAttackId& AttackId, bool bIsTargetDestructible, class AActor* DamageCauser, class AController* InstigatedByController, ECollisionChannel DamagePreventionChannel, bool bExplode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "ApplyRadialDamageWithFalloff");

	Params::TslStatics_ApplyRadialDamageWithFalloff Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BaseDamage = BaseDamage;
	Parms.MinimumDamage = MinimumDamage;
	Parms.Origin = std::move(Origin);
	Parms.DamageInnerRadius = DamageInnerRadius;
	Parms.DamageOuterRadius = DamageOuterRadius;
	Parms.DamageFalloff = DamageFalloff;
	Parms.DamageTypeClass = DamageTypeClass;
	Parms.IgnoreActors = std::move(IgnoreActors);
	Parms.AttackId = std::move(AttackId);
	Parms.bIsTargetDestructible = bIsTargetDestructible;
	Parms.DamageCauser = DamageCauser;
	Parms.InstigatedByController = InstigatedByController;
	Parms.DamagePreventionChannel = DamagePreventionChannel;
	Parms.bExplode = bExplode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.ConeVolumeLineTraceMulti
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  OutHitPoints                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   SamplingNum                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HalfConeAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RayLength                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTslStatics::ConeVolumeLineTraceMulti(const class UObject* WorldContextObject, TArray<struct FVector>* OutHitPoints, const struct FVector& Origin, int32 SamplingNum, float HalfConeAngle, float RayLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "ConeVolumeLineTraceMulti");

	Params::TslStatics_ConeVolumeLineTraceMulti Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Origin = std::move(Origin);
	Parms.SamplingNum = SamplingNum;
	Parms.HalfConeAngle = HalfConeAngle;
	Parms.RayLength = RayLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHitPoints != nullptr)
		*OutHitPoints = std::move(Parms.OutHitPoints);

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.ConeVolumeLineTraceSingle
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OutHitPoint                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   HalfConeAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RayLength                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslStatics::ConeVolumeLineTraceSingle(const class UObject* WorldContextObject, struct FVector* OutHitPoint, const struct FVector& Origin, float HalfConeAngle, float RayLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "ConeVolumeLineTraceSingle");

	Params::TslStatics_ConeVolumeLineTraceSingle Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Origin = std::move(Origin);
	Parms.HalfConeAngle = HalfConeAngle;
	Parms.RayLength = RayLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHitPoint != nullptr)
		*OutHitPoint = std::move(Parms.OutHitPoint);

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.GetBluezonePosition
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector UTslStatics::GetBluezonePosition(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "GetBluezonePosition");

	Params::TslStatics_GetBluezonePosition Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.GetBluezoneRadius
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslStatics::GetBluezoneRadius(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "GetBluezoneRadius");

	Params::TslStatics_GetBluezoneRadius Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.GetConsoleValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ConsloeName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutValueFloat                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutValueInt                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutValueString                                         (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslStatics::GetConsoleValue(const class FString& ConsloeName, float* OutValueFloat, int32* OutValueInt, class FString* OutValueString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "GetConsoleValue");

	Params::TslStatics_GetConsoleValue Parms{};

	Parms.ConsloeName = std::move(ConsloeName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValueFloat != nullptr)
		*OutValueFloat = Parms.OutValueFloat;

	if (OutValueInt != nullptr)
		*OutValueInt = Parms.OutValueInt;

	if (OutValueString != nullptr)
		*OutValueString = std::move(Parms.OutValueString);

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.GetFullGameVersion
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTslStatics::GetFullGameVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "GetFullGameVersion");

	Params::TslStatics_GetFullGameVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.GetGameVersion
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTslStatics::GetGameVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "GetGameVersion");

	Params::TslStatics_GetGameVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.GetNextPlayzonePosition
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector UTslStatics::GetNextPlayzonePosition(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "GetNextPlayzonePosition");

	Params::TslStatics_GetNextPlayzonePosition Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.GetNextPlayzoneRadius
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslStatics::GetNextPlayzoneRadius(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "GetNextPlayzoneRadius");

	Params::TslStatics_GetNextPlayzoneRadius Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.GetServerLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          ActorOrComponent                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector UTslStatics::GetServerLocation(const class UObject* ActorOrComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "GetServerLocation");

	Params::TslStatics_GetServerLocation Parms{};

	Parms.ActorOrComponent = ActorOrComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.GetSimplePhysicalMaterial
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              PrimitiveComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPhysicalMaterial*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPhysicalMaterial* UTslStatics::GetSimplePhysicalMaterial(class UPrimitiveComponent* PrimitiveComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "GetSimplePhysicalMaterial");

	Params::TslStatics_GetSimplePhysicalMaterial Parms{};

	Parms.PrimitiveComponent = PrimitiveComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.GetTslCharacter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATslCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslCharacter* UTslStatics::GetTslCharacter(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "GetTslCharacter");

	Params::TslStatics_GetTslCharacter Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.GetTslGameState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATslGameState*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslGameState* UTslStatics::GetTslGameState(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "GetTslGameState");

	Params::TslStatics_GetTslGameState Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.GetTslPlatformName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTslStatics::GetTslPlatformName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "GetTslPlatformName");

	Params::TslStatics_GetTslPlatformName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.GetTslPlayerController
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APawn*                            Pawn                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATslPlayerController*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslPlayerController* UTslStatics::GetTslPlayerController(const class APawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "GetTslPlayerController");

	Params::TslStatics_GetTslPlayerController Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.GetVehicleCommonComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTslVehicleCommonComponent*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTslVehicleCommonComponent* UTslStatics::GetVehicleCommonComponent(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "GetVehicleCommonComponent");

	Params::TslStatics_GetVehicleCommonComponent Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.GetVehicleSeatComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTslVehicleSeatComponent*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTslVehicleSeatComponent* UTslStatics::GetVehicleSeatComponent(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "GetVehicleSeatComponent");

	Params::TslStatics_GetVehicleSeatComponent Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.GetWaterSurfaceHeight
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class APhysicsVolume*                   PhysicsVolume                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CurLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslStatics::GetWaterSurfaceHeight(const class APhysicsVolume* PhysicsVolume, const struct FVector& CurLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "GetWaterSurfaceHeight");

	Params::TslStatics_GetWaterSurfaceHeight Parms{};

	Parms.PhysicsVolume = PhysicsVolume;
	Parms.CurLocation = std::move(CurLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.IsClientActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslStatics::IsClientActor(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "IsClientActor");

	Params::TslStatics_IsClientActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.IsEditor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslStatics::IsEditor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "IsEditor");

	Params::TslStatics_IsEditor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.IsESports
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslStatics::IsESports()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "IsESports");

	Params::TslStatics_IsESports Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.IsForChineseLicensing
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslStatics::IsForChineseLicensing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "IsForChineseLicensing");

	Params::TslStatics_IsForChineseLicensing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.IsForKoreanRating
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslStatics::IsForKoreanRating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "IsForKoreanRating");

	Params::TslStatics_IsForKoreanRating Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.IsGamepadConnected
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslStatics::IsGamepadConnected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "IsGamepadConnected");

	Params::TslStatics_IsGamepadConnected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.IsLastInputGamepad
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslStatics::IsLastInputGamepad(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "IsLastInputGamepad");

	Params::TslStatics_IsLastInputGamepad Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.IsMapFullyLoaded
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslStatics::IsMapFullyLoaded(class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "IsMapFullyLoaded");

	Params::TslStatics_IsMapFullyLoaded Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.IsServerActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslStatics::IsServerActor(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "IsServerActor");

	Params::TslStatics_IsServerActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.IsShipping
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslStatics::IsShipping()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "IsShipping");

	Params::TslStatics_IsShipping Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.LineSphereIntersection
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Intersection1                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Intersection2                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Center                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Origion                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          Direction                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslStatics::LineSphereIntersection(struct FVector* Intersection1, struct FVector* Intersection2, const struct FVector& Center, const struct FVector& Origion, const struct FVector& Direction, const float& Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "LineSphereIntersection");

	Params::TslStatics_LineSphereIntersection Parms{};

	Parms.Center = std::move(Center);
	Parms.Origion = std::move(Origion);
	Parms.Direction = std::move(Direction);
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Intersection1 != nullptr)
		*Intersection1 = std::move(Parms.Intersection1);

	if (Intersection2 != nullptr)
		*Intersection2 = std::move(Parms.Intersection2);

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.LocalPositionToServer
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Local                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector UTslStatics::LocalPositionToServer(class UObject* WorldContextObject, const struct FVector& Local)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "LocalPositionToServer");

	Params::TslStatics_LocalPositionToServer Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Local = std::move(Local);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.PhysicalSurfaceToName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EPhysicalSurface                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

FName UTslStatics::PhysicalSurfaceToName(EPhysicalSurface Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "PhysicalSurfaceToName");

	Params::TslStatics_PhysicalSurfaceToName Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.PhysicalSurfaceToString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EPhysicalSurface                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UTslStatics::PhysicalSurfaceToString(EPhysicalSurface Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "PhysicalSurfaceToString");

	Params::TslStatics_PhysicalSurfaceToString Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.PredictProjectilePathBox
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  OutPathPositions                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector                          OutLastTraceDestination                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          StartPos                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          LaunchVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bTracePath                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ProjectileBox                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawDebugTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SimFrequency                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxSimTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OverrideGravityZ                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslStatics::PredictProjectilePathBox(const class UObject* WorldContextObject, struct FHitResult* OutHit, TArray<struct FVector>* OutPathPositions, struct FVector* OutLastTraceDestination, const struct FVector& StartPos, const struct FVector& LaunchVelocity, bool bTracePath, const struct FVector& ProjectileBox, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, float DrawDebugTime, float SimFrequency, float MaxSimTime, float OverrideGravityZ)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "PredictProjectilePathBox");

	Params::TslStatics_PredictProjectilePathBox Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.StartPos = std::move(StartPos);
	Parms.LaunchVelocity = std::move(LaunchVelocity);
	Parms.bTracePath = bTracePath;
	Parms.ProjectileBox = std::move(ProjectileBox);
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.DrawDebugTime = DrawDebugTime;
	Parms.SimFrequency = SimFrequency;
	Parms.MaxSimTime = MaxSimTime;
	Parms.OverrideGravityZ = OverrideGravityZ;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	if (OutPathPositions != nullptr)
		*OutPathPositions = std::move(Parms.OutPathPositions);

	if (OutLastTraceDestination != nullptr)
		*OutLastTraceDestination = std::move(Parms.OutLastTraceDestination);

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.PredictProjectilePathCapsule
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  OutPathPositions                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector                          OutLastTraceDestination                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          StartPos                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          LaunchVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bTracePath                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ProjectileBox                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bTraceComplex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EDrawDebugTrace                         DrawDebugType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawDebugTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SimFrequency                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxSimTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OverrideGravityZ                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslStatics::PredictProjectilePathCapsule(const class UObject* WorldContextObject, struct FHitResult* OutHit, TArray<struct FVector>* OutPathPositions, struct FVector* OutLastTraceDestination, const struct FVector& StartPos, const struct FVector& LaunchVelocity, bool bTracePath, const struct FVector& ProjectileBox, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, float DrawDebugTime, float SimFrequency, float MaxSimTime, float OverrideGravityZ)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "PredictProjectilePathCapsule");

	Params::TslStatics_PredictProjectilePathCapsule Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.StartPos = std::move(StartPos);
	Parms.LaunchVelocity = std::move(LaunchVelocity);
	Parms.bTracePath = bTracePath;
	Parms.ProjectileBox = std::move(ProjectileBox);
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.DrawDebugType = DrawDebugType;
	Parms.DrawDebugTime = DrawDebugTime;
	Parms.SimFrequency = SimFrequency;
	Parms.MaxSimTime = MaxSimTime;
	Parms.OverrideGravityZ = OverrideGravityZ;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	if (OutPathPositions != nullptr)
		*OutPathPositions = std::move(Parms.OutPathPositions);

	if (OutLastTraceDestination != nullptr)
		*OutLastTraceDestination = std::move(Parms.OutLastTraceDestination);

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.ProjectPointsToHighFloor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bOutHit                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AroundLength                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RayLength                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector UTslStatics::ProjectPointsToHighFloor(const class UObject* WorldContextObject, const struct FVector& Origin, bool* bOutHit, float AroundLength, float RayLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "ProjectPointsToHighFloor");

	Params::TslStatics_ProjectPointsToHighFloor Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Origin = std::move(Origin);
	Parms.AroundLength = AroundLength;
	Parms.RayLength = RayLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutHit != nullptr)
		*bOutHit = Parms.bOutHit;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.ProjectPointToFloor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bOutHit                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Length                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector UTslStatics::ProjectPointToFloor(const class UObject* WorldContextObject, const struct FVector& Origin, bool* bOutHit, float Length)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "ProjectPointToFloor");

	Params::TslStatics_ProjectPointToFloor Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Origin = std::move(Origin);
	Parms.Length = Length;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutHit != nullptr)
		*bOutHit = Parms.bOutHit;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.ReleaseMouseCaptureFromPlayerController
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslStatics::ReleaseMouseCaptureFromPlayerController(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "ReleaseMouseCaptureFromPlayerController");

	Params::TslStatics_ReleaseMouseCaptureFromPlayerController Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslStatics.SafeDivide_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DivideByZeroValue                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslStatics::SafeDivide_FloatFloat(float A, float B, float DivideByZeroValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "SafeDivide_FloatFloat");

	Params::TslStatics_SafeDivide_FloatFloat Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.DivideByZeroValue = DivideByZeroValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.SafeDivide_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DivideByZeroValue                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTslStatics::SafeDivide_IntInt(int32 A, int32 B, int32 DivideByZeroValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "SafeDivide_IntInt");

	Params::TslStatics_SafeDivide_IntInt Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.DivideByZeroValue = DivideByZeroValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.ServerPositionToLocal
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Server                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector UTslStatics::ServerPositionToLocal(class UObject* WorldContextObject, const struct FVector& Server)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "ServerPositionToLocal");

	Params::TslStatics_ServerPositionToLocal Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Server = std::move(Server);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslStatics.SetAnimationAkRTPC
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           RTPCName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RTPCValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslStatics::SetAnimationAkRTPC(class ACharacter* Character, const class FString& RTPCName, float RTPCValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "SetAnimationAkRTPC");

	Params::TslStatics_SetAnimationAkRTPC Parms{};

	Parms.Character = Character;
	Parms.RTPCName = std::move(RTPCName);
	Parms.RTPCValue = RTPCValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslStatics.SetAnimationAkSwitch
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SwitchGroup                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SwitchState                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslStatics::SetAnimationAkSwitch(class ACharacter* Character, const class FString& SwitchGroup, const class FString& SwitchState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "SetAnimationAkSwitch");

	Params::TslStatics_SetAnimationAkSwitch Parms{};

	Parms.Character = Character;
	Parms.SwitchGroup = std::move(SwitchGroup);
	Parms.SwitchState = std::move(SwitchState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslStatics.SetWorldOrigin
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                Controller                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslStatics::SetWorldOrigin(const class APlayerController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "SetWorldOrigin");

	Params::TslStatics_SetWorldOrigin Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslStatics.SetWorldOriginByDistance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                Controller                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   XYDistanceToShift                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslStatics::SetWorldOriginByDistance(const class APlayerController* Controller, float XYDistanceToShift)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "SetWorldOriginByDistance");

	Params::TslStatics_SetWorldOriginByDistance Parms{};

	Parms.Controller = Controller;
	Parms.XYDistanceToShift = XYDistanceToShift;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslStatics.UseHighPrecisionMouseMovement
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslStatics::UseHighPrecisionMouseMovement(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TslStatics", "UseHighPrecisionMouseMovement");

	Params::TslStatics_UseHighPrecisionMouseMovement Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.EquipableItemIconBaseWidget.OnNoBagSpaceEvent
// (Final, Native, Public)

void UEquipableItemIconBaseWidget::OnNoBagSpaceEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipableItemIconBaseWidget", "OnNoBagSpaceEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.LifeGaugeBaseWidget.OnNotifyHeal
// (Final, Native, Protected)
// Parameters:
// float                                   StartHealth                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   GoalHealth                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULifeGaugeBaseWidget::OnNotifyHeal(float StartHealth, float GoalHealth, float MaxHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LifeGaugeBaseWidget", "OnNotifyHeal");

	Params::LifeGaugeBaseWidget_OnNotifyHeal Parms{};

	Parms.StartHealth = StartHealth;
	Parms.GoalHealth = GoalHealth;
	Parms.MaxHealth = MaxHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.LifeGaugeBaseWidget.OnNotifyHit
// (Final, Native, Protected)
// Parameters:
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDamageTypeCategory                     DamageType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULifeGaugeBaseWidget::OnNotifyHit(float Damage, EDamageTypeCategory DamageType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LifeGaugeBaseWidget", "OnNotifyHit");

	Params::LifeGaugeBaseWidget_OnNotifyHit Parms{};

	Parms.Damage = Damage;
	Parms.DamageType = DamageType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.MapCarePackageItemIconBaseWidget.OnButtonDown
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        Geometry                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    MouseEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UMapCarePackageItemIconBaseWidget::OnButtonDown(const struct FGeometry& Geometry, const struct FPointerEvent& MouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapCarePackageItemIconBaseWidget", "OnButtonDown");

	Params::MapCarePackageItemIconBaseWidget_OnButtonDown Parms{};

	Parms.Geometry = std::move(Geometry);
	Parms.MouseEvent = std::move(MouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.MapCharacterIconBaseWidget.OnButtonDown
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        Geometry                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    MouseEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply UMapCharacterIconBaseWidget::OnButtonDown(const struct FGeometry& Geometry, const struct FPointerEvent& MouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapCharacterIconBaseWidget", "OnButtonDown");

	Params::MapCharacterIconBaseWidget_OnButtonDown Parms{};

	Parms.Geometry = std::move(Geometry);
	Parms.MouseEvent = std::move(MouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.MapGridWidget.AddCenter_UC
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        Offset_UC                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UMapGridWidget::AddCenter_UC(const struct FVector2D& Offset_UC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapGridWidget", "AddCenter_UC");

	Params::MapGridWidget_AddCenter_UC Parms{};

	Parms.Offset_UC = std::move(Offset_UC);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.MapGridWidget.ClampPosition_UC
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        Positon                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector2D UMapGridWidget::ClampPosition_UC(const struct FVector2D& Positon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapGridWidget", "ClampPosition_UC");

	Params::MapGridWidget_ClampPosition_UC Parms{};

	Parms.Positon = std::move(Positon);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.MapGridWidget.ClampPositionByWidgetSize_UC
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        Positon                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector2D                        WidgetSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector2D UMapGridWidget::ClampPositionByWidgetSize_UC(const struct FVector2D& Positon, const struct FVector2D& WidgetSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapGridWidget", "ClampPositionByWidgetSize_UC");

	Params::MapGridWidget_ClampPositionByWidgetSize_UC Parms{};

	Parms.Positon = std::move(Positon);
	Parms.WidgetSize = std::move(WidgetSize);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.MapGridWidget.CursorUCtoCenterMC
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        UC                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector2D                        Offest_MC                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bUpdate                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapGridWidget::CursorUCtoCenterMC(const struct FVector2D& UC, struct FVector2D* Offest_MC, bool* bUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapGridWidget", "CursorUCtoCenterMC");

	Params::MapGridWidget_CursorUCtoCenterMC Parms{};

	Parms.UC = std::move(UC);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Offest_MC != nullptr)
		*Offest_MC = std::move(Parms.Offest_MC);

	if (bUpdate != nullptr)
		*bUpdate = Parms.bUpdate;
}


// Function TslGame.MapGridWidget.GetMapImageWigetSizeAndImageOffset
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector2D                        WidgetSize                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector2D                        ImageOffset                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UMapGridWidget::GetMapImageWigetSizeAndImageOffset(struct FVector2D* WidgetSize, struct FVector2D* ImageOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapGridWidget", "GetMapImageWigetSizeAndImageOffset");

	Params::MapGridWidget_GetMapImageWigetSizeAndImageOffset Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (WidgetSize != nullptr)
		*WidgetSize = std::move(Parms.WidgetSize);

	if (ImageOffset != nullptr)
		*ImageOffset = std::move(Parms.ImageOffset);
}


// Function TslGame.MapGridWidget.OnMapCarePackageItemIconClicked
// (Final, Native, Public)
// Parameters:
// class UMapCarePackageItemIconBaseWidget*MapIconWidget                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapGridWidget::OnMapCarePackageItemIconClicked(class UMapCarePackageItemIconBaseWidget* MapIconWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapGridWidget", "OnMapCarePackageItemIconClicked");

	Params::MapGridWidget_OnMapCarePackageItemIconClicked Parms{};

	Parms.MapIconWidget = MapIconWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.MapGridWidget.OnMapIconClicked
// (Final, Native, Public)
// Parameters:
// class UMapCharacterIconBaseWidget*      MapIconWidget                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapGridWidget::OnMapIconClicked(class UMapCharacterIconBaseWidget* MapIconWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapGridWidget", "OnMapIconClicked");

	Params::MapGridWidget_OnMapIconClicked Parms{};

	Parms.MapIconWidget = MapIconWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.MapGridWidget.SetCenter_MC
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        Center                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UMapGridWidget::SetCenter_MC(const struct FVector2D& Center)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapGridWidget", "SetCenter_MC");

	Params::MapGridWidget_SetCenter_MC Parms{};

	Parms.Center = std::move(Center);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.MapGridWidget.SetCharacterIconPositionAndRotation_UC
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector2D                        Pos_UC                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Angle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapGridWidget::SetCharacterIconPositionAndRotation_UC(const struct FVector2D& Pos_UC, float Angle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapGridWidget", "SetCharacterIconPositionAndRotation_UC");

	Params::MapGridWidget_SetCharacterIconPositionAndRotation_UC Parms{};

	Parms.Pos_UC = std::move(Pos_UC);
	Parms.Angle = Angle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TslGame.MapGridWidget.SetImageBrush
// (Event, Public, BlueprintEvent)
// Parameters:
// class UMaterialInstanceDynamic*         NewMatInst                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapGridWidget::SetImageBrush(class UMaterialInstanceDynamic* NewMatInst)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapGridWidget", "SetImageBrush");

	Params::MapGridWidget_SetImageBrush Parms{};

	Parms.NewMatInst = NewMatInst;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TslGame.MapGridWidget.SetZoomLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewZoomLevel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapGridWidget::SetZoomLevel(float NewZoomLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapGridWidget", "SetZoomLevel");

	Params::MapGridWidget_SetZoomLevel Parms{};

	Parms.NewZoomLevel = NewZoomLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.MapGridWidget.UpdateRectangleView
// (Event, Public, BlueprintEvent)

void UMapGridWidget::UpdateRectangleView()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapGridWidget", "UpdateRectangleView");

	UObject::ProcessEvent(Func, nullptr);
}


// Function TslGame.MapGridWidget.UpdateRectangleViewByWidgetSize
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector2D                        WidgetSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UMapGridWidget::UpdateRectangleViewByWidgetSize(const struct FVector2D& WidgetSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapGridWidget", "UpdateRectangleViewByWidgetSize");

	Params::MapGridWidget_UpdateRectangleViewByWidgetSize Parms{};

	Parms.WidgetSize = std::move(WidgetSize);

	UObject::ProcessEvent(Func, &Parms);
}


// Function TslGame.MapGridWidget.UpdateReplicatedCarePackageItemList
// (Final, Native, Public)

void UMapGridWidget::UpdateReplicatedCarePackageItemList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapGridWidget", "UpdateReplicatedCarePackageItemList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.MapGridWidget.UpdateReplicatedCharacterList
// (Final, Native, Public)

void UMapGridWidget::UpdateReplicatedCharacterList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapGridWidget", "UpdateReplicatedCharacterList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.MapGridWidget.UpdateWidgetSize_UC
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        WidgetSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UMapGridWidget::UpdateWidgetSize_UC(const struct FVector2D& WidgetSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapGridWidget", "UpdateWidgetSize_UC");

	Params::MapGridWidget_UpdateWidgetSize_UC Parms{};

	Parms.WidgetSize = std::move(WidgetSize);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.MapGridWidget.UpdateZoomAndWidgetSize
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   Zoom                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        WidgetSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UMapGridWidget::UpdateZoomAndWidgetSize(float Zoom, const struct FVector2D& WidgetSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapGridWidget", "UpdateZoomAndWidgetSize");

	Params::MapGridWidget_UpdateZoomAndWidgetSize Parms{};

	Parms.Zoom = Zoom;
	Parms.WidgetSize = std::move(WidgetSize);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.MapGridWidget.DrawMarker_UC
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent, Const)
// Parameters:
// struct FVector2D                        MarkerCenter_UC                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UMapGridWidget::DrawMarker_UC(const struct FVector2D& MarkerCenter_UC) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapGridWidget", "DrawMarker_UC");

	Params::MapGridWidget_DrawMarker_UC Parms{};

	Parms.MarkerCenter_UC = std::move(MarkerCenter_UC);

	UObject::ProcessEvent(Func, &Parms);
}


// Function TslGame.MapGridWidget.DrawRedZone_UC
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent, Const)
// Parameters:
// struct FVector2D                        Center_UC                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Radius_UC                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapGridWidget::DrawRedZone_UC(const struct FVector2D& Center_UC, float Radius_UC) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapGridWidget", "DrawRedZone_UC");

	Params::MapGridWidget_DrawRedZone_UC Parms{};

	Parms.Center_UC = std::move(Center_UC);
	Parms.Radius_UC = Radius_UC;

	UObject::ProcessEvent(Func, &Parms);
}


// Function TslGame.MapGridWidget.GetAlignment
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector2D UMapGridWidget::GetAlignment() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapGridWidget", "GetAlignment");

	Params::MapGridWidget_GetAlignment Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.MapGridWidget.GetCharacterGridTextHorizental
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMapGridWidget::GetCharacterGridTextHorizental() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapGridWidget", "GetCharacterGridTextHorizental");

	Params::MapGridWidget_GetCharacterGridTextHorizental Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.MapGridWidget.GetCharacterGridVertical
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMapGridWidget::GetCharacterGridVertical() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapGridWidget", "GetCharacterGridVertical");

	Params::MapGridWidget_GetCharacterGridVertical Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.MapGridWidget.GetLocalMousePosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector2D UMapGridWidget::GetLocalMousePosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapGridWidget", "GetLocalMousePosition");

	Params::MapGridWidget_GetLocalMousePosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.MapGridWidget.GetScreenOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector2D UMapGridWidget::GetScreenOffset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapGridWidget", "GetScreenOffset");

	Params::MapGridWidget_GetScreenOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.MapGridWidget.GetWidgetPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector2D UMapGridWidget::GetWidgetPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapGridWidget", "GetWidgetPosition");

	Params::MapGridWidget_GetWidgetPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.MapGridWidget.GetWidgetSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector2D UMapGridWidget::GetWidgetSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapGridWidget", "GetWidgetSize");

	Params::MapGridWidget_GetWidgetSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.MapGridWidget.GetZoomLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMapGridWidget::GetZoomLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapGridWidget", "GetZoomLevel");

	Params::MapGridWidget_GetZoomLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.MapGridWidget.IsMouseInMarker
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMapGridWidget::IsMouseInMarker() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapGridWidget", "IsMouseInMarker");

	Params::MapGridWidget_IsMouseInMarker Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.MapGridWidget.MCtoUC
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        MapCoord                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector2D UMapGridWidget::MCtoUC(const struct FVector2D& MapCoord) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapGridWidget", "MCtoUC");

	Params::MapGridWidget_MCtoUC Parms{};

	Parms.MapCoord = std::move(MapCoord);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.MapGridWidget.UCtoMC
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        UC                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector2D UMapGridWidget::UCtoMC(const struct FVector2D& UC) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapGridWidget", "UCtoMC");

	Params::MapGridWidget_UCtoMC Parms{};

	Parms.UC = std::move(UC);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TeamMarkWidget.InitializeTeamMarkGrid
// (Final, Native, Public, BlueprintCallable)

void UTeamMarkWidget::InitializeTeamMarkGrid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamMarkWidget", "InitializeTeamMarkGrid");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAdaptiveCrosshairWidget.DecideAdaptiveCrosshairColor
// (Final, Native, Public, BlueprintCallable)

void UTslAdaptiveCrosshairWidget::DecideAdaptiveCrosshairColor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAdaptiveCrosshairWidget", "DecideAdaptiveCrosshairColor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAdaptiveCrosshairWidget.HandleGameUserSettingApplied
// (Final, Native, Public)

void UTslAdaptiveCrosshairWidget::HandleGameUserSettingApplied()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAdaptiveCrosshairWidget", "HandleGameUserSettingApplied");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAdaptiveCrosshairWidget.SetAdaptiveCrosshairPosition
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        ScreenPosition                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslAdaptiveCrosshairWidget::SetAdaptiveCrosshairPosition(const struct FVector2D& ScreenPosition, float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAdaptiveCrosshairWidget", "SetAdaptiveCrosshairPosition");

	Params::TslAdaptiveCrosshairWidget_SetAdaptiveCrosshairPosition Parms{};

	Parms.ScreenPosition = std::move(ScreenPosition);
	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAdaptiveCrosshairWidget.SetAdaptiveCrosshairVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslAdaptiveCrosshairWidget::SetAdaptiveCrosshairVisibility(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAdaptiveCrosshairWidget", "SetAdaptiveCrosshairVisibility");

	Params::TslAdaptiveCrosshairWidget_SetAdaptiveCrosshairVisibility Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAdaptiveCrosshairWidget.SetCenterCrosshairClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EWeaponClass                            InWeaponClass                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHasWeapon                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslAdaptiveCrosshairWidget::SetCenterCrosshairClass(EWeaponClass InWeaponClass, bool bHasWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAdaptiveCrosshairWidget", "SetCenterCrosshairClass");

	Params::TslAdaptiveCrosshairWidget_SetCenterCrosshairClass Parms{};

	Parms.InWeaponClass = InWeaponClass;
	Parms.bHasWeapon = bHasWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAdaptiveCrosshairWidget.SetCenterCrosshairDeviation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InDeviation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslAdaptiveCrosshairWidget::SetCenterCrosshairDeviation(float InDeviation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAdaptiveCrosshairWidget", "SetCenterCrosshairDeviation");

	Params::TslAdaptiveCrosshairWidget_SetCenterCrosshairDeviation Parms{};

	Parms.InDeviation = InDeviation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAdaptiveCrosshairWidget.SetCenterCrosshairVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslAdaptiveCrosshairWidget::SetCenterCrosshairVisibility(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAdaptiveCrosshairWidget", "SetCenterCrosshairVisibility");

	Params::TslAdaptiveCrosshairWidget_SetCenterCrosshairVisibility Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslAdaptiveCrosshairWidget.SetShowCrosshairWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslAdaptiveCrosshairWidget::SetShowCrosshairWidget(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslAdaptiveCrosshairWidget", "SetShowCrosshairWidget");

	Params::TslAdaptiveCrosshairWidget_SetShowCrosshairWidget Parms{};

	Parms.bShow = bShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslBaseOptionWidget.OnApply
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UTslBaseOptionWidget::OnApply()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBaseOptionWidget", "OnApply");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslBaseOptionWidget.OnDefault
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UTslBaseOptionWidget::OnDefault()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBaseOptionWidget", "OnDefault");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslBaseOptionWidget.OnReset
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UTslBaseOptionWidget::OnReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBaseOptionWidget", "OnReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslBaseOptionWidget.IsChanged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslBaseOptionWidget::IsChanged() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBaseOptionWidget", "IsChanged");

	Params::TslBaseOptionWidget_IsChanged Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslBaseOptionWidget.IsEnableApply
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslBaseOptionWidget::IsEnableApply() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBaseOptionWidget", "IsEnableApply");

	Params::TslBaseOptionWidget_IsEnableApply Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslBaseOptionWidget.IsKeyUp
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslBaseOptionWidget::IsKeyUp() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBaseOptionWidget", "IsKeyUp");

	Params::TslBaseOptionWidget_IsKeyUp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslKeyDisplayWidget.ApplyKey
// (Final, Native, Public, BlueprintCallable)

void UTslKeyDisplayWidget::ApplyKey()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslKeyDisplayWidget", "ApplyKey");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslKeyDisplayWidget.InitializeKeyDisplayWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDefault                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslKeyDisplayWidget::InitializeKeyDisplayWidget(bool bDefault)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslKeyDisplayWidget", "InitializeKeyDisplayWidget");

	Params::TslKeyDisplayWidget_InitializeKeyDisplayWidget Parms{};

	Parms.bDefault = bDefault;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslKeyDisplayWidget.SetupKeyDisplayWidget
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// FName                             InInputName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             InDisplayName                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// FName                             InCategoryName                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InbAxisInput                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InAxisScale                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InbGamepad                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslKeyDisplayWidget::SetupKeyDisplayWidget(const FName& InInputName, const class FText& InDisplayName, const FName& InCategoryName, bool InbAxisInput, float InAxisScale, bool InbGamepad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslKeyDisplayWidget", "SetupKeyDisplayWidget");

	Params::TslKeyDisplayWidget_SetupKeyDisplayWidget Parms{};

	Parms.InInputName = InInputName;
	Parms.InDisplayName = std::move(InDisplayName);
	Parms.InCategoryName = InCategoryName;
	Parms.InbAxisInput = InbAxisInput;
	Parms.InAxisScale = InAxisScale;
	Parms.InbGamepad = InbGamepad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslKeyDisplayWidget.TransferInputEvent
// (Final, Native, Public)
// Parameters:
// struct FTslInputKey                     TslInputKey                                            (Parm, NativeAccessSpecifierPublic)

void UTslKeyDisplayWidget::TransferInputEvent(const struct FTslInputKey& TslInputKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslKeyDisplayWidget", "TransferInputEvent");

	Params::TslKeyDisplayWidget_TransferInputEvent Parms{};

	Parms.TslInputKey = std::move(TslInputKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslKeyOptionWidget.InitializeKeyAndMouseSetting
// (Final, Native, Public)

void UTslKeyOptionWidget::InitializeKeyAndMouseSetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslKeyOptionWidget", "InitializeKeyAndMouseSetting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslKeyOptionWidget.OnKeyChanged
// (Final, Native, Private)
// Parameters:
// class UTslKeyDisplayWidget*             InKeyDisplayWidget                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTslInputKey                     InInputedKey                                           (Parm, NativeAccessSpecifierPublic)

void UTslKeyOptionWidget::OnKeyChanged(class UTslKeyDisplayWidget* InKeyDisplayWidget, const struct FTslInputKey& InInputedKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslKeyOptionWidget", "OnKeyChanged");

	Params::TslKeyOptionWidget_OnKeyChanged Parms{};

	Parms.InKeyDisplayWidget = InKeyDisplayWidget;
	Parms.InInputedKey = std::move(InInputedKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslKeySettingWidget.InitializeKeySettingWidget
// (Final, Native, Public, BlueprintCallable)

void UTslKeySettingWidget::InitializeKeySettingWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslKeySettingWidget", "InitializeKeySettingWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslKeySettingWidget.SetToDefault
// (Final, Native, Public, BlueprintCallable)

void UTslKeySettingWidget::SetToDefault()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslKeySettingWidget", "SetToDefault");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslKeySettingWidget.StartupKeySettingWidget
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// FName                             InCategoryName                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             InDisplayText                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTslKeySettingWidget::StartupKeySettingWidget(const FName& InCategoryName, const class FText& InDisplayText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslKeySettingWidget", "StartupKeySettingWidget");

	Params::TslKeySettingWidget_StartupKeySettingWidget Parms{};

	Parms.InCategoryName = InCategoryName;
	Parms.InDisplayText = std::move(InDisplayText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslKeySettingWidget.TransferInputEvent
// (Final, Native, Public)
// Parameters:
// class UTslKeyDisplayWidget*             KeyDisplayWidget                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTslInputKey                     TslInputKey                                            (Parm, NativeAccessSpecifierPublic)

void UTslKeySettingWidget::TransferInputEvent(class UTslKeyDisplayWidget* KeyDisplayWidget, const struct FTslInputKey& TslInputKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslKeySettingWidget", "TransferInputEvent");

	Params::TslKeySettingWidget_TransferInputEvent Parms{};

	Parms.KeyDisplayWidget = KeyDisplayWidget;
	Parms.TslInputKey = std::move(TslInputKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslBuffIconListWidget.OnStartBuff
// (Final, Native, Public)
// Parameters:
// FName                             BuffName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStart                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslBuffIconListWidget::OnStartBuff(FName BuffName, bool bStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBuffIconListWidget", "OnStartBuff");

	Params::TslBuffIconListWidget_OnStartBuff Parms{};

	Parms.BuffName = BuffName;
	Parms.bStart = bStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslBuffIconListWidget.UpdateHealBuffIcon
// (Final, Native, Public)

void UTslBuffIconListWidget::UpdateHealBuffIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBuffIconListWidget", "UpdateHealBuffIcon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslBuffIconListWidget.UpdateHealBuffIconVisibility
// (Final, Native, Public)

void UTslBuffIconListWidget::UpdateHealBuffIconVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBuffIconListWidget", "UpdateHealBuffIconVisibility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslBuffIconListWidget.UpdateRunBuffIcon
// (Final, Native, Public)

void UTslBuffIconListWidget::UpdateRunBuffIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBuffIconListWidget", "UpdateRunBuffIcon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslBuffIconListWidget.UpdateRunBuffIconVisibility
// (Final, Native, Public)

void UTslBuffIconListWidget::UpdateRunBuffIconVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBuffIconListWidget", "UpdateRunBuffIconVisibility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslBuffIconListWidget.GetBoostPercent
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTslBuffIconListWidget::GetBoostPercent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBuffIconListWidget", "GetBoostPercent");

	Params::TslBuffIconListWidget_GetBoostPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslBuffIconListWidget.GetHealBuffIconOpacity
// (Final, Native, Public, HasDefaults, Const)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FLinearColor UTslBuffIconListWidget::GetHealBuffIconOpacity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBuffIconListWidget", "GetHealBuffIconOpacity");

	Params::TslBuffIconListWidget_GetHealBuffIconOpacity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslBuffIconListWidget.GetHealBuffVisibility
// (Final, Native, Public, Const)
// Parameters:
// ESlateVisibility                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESlateVisibility UTslBuffIconListWidget::GetHealBuffVisibility() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBuffIconListWidget", "GetHealBuffVisibility");

	Params::TslBuffIconListWidget_GetHealBuffVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslBuffIconListWidget.GetRunBuffIconOpacity
// (Final, Native, Public, HasDefaults, Const)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FLinearColor UTslBuffIconListWidget::GetRunBuffIconOpacity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBuffIconListWidget", "GetRunBuffIconOpacity");

	Params::TslBuffIconListWidget_GetRunBuffIconOpacity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslBuffIconListWidget.GetRunBuffVisibility
// (Final, Native, Public, Const)
// Parameters:
// ESlateVisibility                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESlateVisibility UTslBuffIconListWidget::GetRunBuffVisibility() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslBuffIconListWidget", "GetRunBuffVisibility");

	Params::TslBuffIconListWidget_GetRunBuffVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslKeyReceiverWidget.KeyDown
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FKey                             InKey                                                  (Parm, NativeAccessSpecifierPublic)

void UTslKeyReceiverWidget::KeyDown(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslKeyReceiverWidget", "KeyDown");

	Params::TslKeyReceiverWidget_KeyDown Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslKeyReceiverWidget.KeyUp
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FKey                             InKey                                                  (Parm, NativeAccessSpecifierPublic)

void UTslKeyReceiverWidget::KeyUp(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslKeyReceiverWidget", "KeyUp");

	Params::TslKeyReceiverWidget_KeyUp Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslKeyReceiverWidget.UpdateKeyDown
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FKey                             InKey                                                  (Parm, NativeAccessSpecifierPublic)

void UTslKeyReceiverWidget::UpdateKeyDown(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslKeyReceiverWidget", "UpdateKeyDown");

	Params::TslKeyReceiverWidget_UpdateKeyDown Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslKeyReceiverWidget.UpdateKeyUp
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FKey                             InKey                                                  (Parm, NativeAccessSpecifierPublic)

void UTslKeyReceiverWidget::UpdateKeyUp(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslKeyReceiverWidget", "UpdateKeyUp");

	Params::TslKeyReceiverWidget_UpdateKeyUp Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslKeyReceiverWidget.GetLastDownedKeyName
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UTslKeyReceiverWidget::GetLastDownedKeyName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslKeyReceiverWidget", "GetLastDownedKeyName");

	Params::TslKeyReceiverWidget_GetLastDownedKeyName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslKeyReceiverWidget.IsInputKeyDown
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTslKeyReceiverWidget::IsInputKeyDown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslKeyReceiverWidget", "IsInputKeyDown");

	Params::TslKeyReceiverWidget_IsInputKeyDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslTeamInfoWidget.BindVoiceChatIfNeed
// (Final, Native, Private)

void UTslTeamInfoWidget::BindVoiceChatIfNeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslTeamInfoWidget", "BindVoiceChatIfNeed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslTeamInfoWidget.DecideTeamNameColor
// (Final, Native, Private)

void UTslTeamInfoWidget::DecideTeamNameColor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslTeamInfoWidget", "DecideTeamNameColor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslTeamInfoWidget.OnVoiceChat
// (Final, Native, Private)
// Parameters:
// bool                                    InbSpeaking                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMeterEnergy                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslTeamInfoWidget::OnVoiceChat(bool InbSpeaking, float InMeterEnergy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslTeamInfoWidget", "OnVoiceChat");

	Params::TslTeamInfoWidget_OnVoiceChat Parms{};

	Parms.InbSpeaking = InbSpeaking;
	Parms.InMeterEnergy = InMeterEnergy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslTeamInfoWidget.SetTeam
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ATeam*                            InTeam                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslTeamInfoWidget::SetTeam(class ATeam* InTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslTeamInfoWidget", "SetTeam");

	Params::TslTeamInfoWidget_SetTeam Parms{};

	Parms.InTeam = InTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslTeamInfoWidget.UpdateHealthGaugeAndVisibility
// (Final, Native, Private)

void UTslTeamInfoWidget::UpdateHealthGaugeAndVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslTeamInfoWidget", "UpdateHealthGaugeAndVisibility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslTeamInfoWidget.UpdateTeamInfoIcon
// (Final, Native, Private)

void UTslTeamInfoWidget::UpdateTeamInfoIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslTeamInfoWidget", "UpdateTeamInfoIcon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslTeamInfoWidget.UpdateTeamMarker
// (Final, Native, Private)

void UTslTeamInfoWidget::UpdateTeamMarker()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslTeamInfoWidget", "UpdateTeamMarker");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslTeamInfoWidget.UpdateTeamMemberColor
// (Final, Native, Private)

void UTslTeamInfoWidget::UpdateTeamMemberColor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslTeamInfoWidget", "UpdateTeamMemberColor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslTeamInfoWidget.UpdateTeamMemberName
// (Final, Native, Private)

void UTslTeamInfoWidget::UpdateTeamMemberName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslTeamInfoWidget", "UpdateTeamMemberName");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslTeamInfoWidget.UpdateVivoxChat
// (Final, Native, Private)
// Parameters:
// class FString                           UniqueId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsTeamChannel                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InbSpeaking                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMeterEnergy                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslTeamInfoWidget::UpdateVivoxChat(const class FString& UniqueId, bool bIsTeamChannel, bool InbSpeaking, float InMeterEnergy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslTeamInfoWidget", "UpdateVivoxChat");

	Params::TslTeamInfoWidget_UpdateVivoxChat Parms{};

	Parms.UniqueId = std::move(UniqueId);
	Parms.bIsTeamChannel = bIsTeamChannel;
	Parms.InbSpeaking = InbSpeaking;
	Parms.InMeterEnergy = InMeterEnergy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslTeamInfoWidget.UpdateVoiceImage
// (Final, Native, Private)

void UTslTeamInfoWidget::UpdateVoiceImage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslTeamInfoWidget", "UpdateVoiceImage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.WeaponSlotHudBaseWidget.OnMovingFinished
// (Final, Native, Public)

void UWeaponSlotHudBaseWidget::OnMovingFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponSlotHudBaseWidget", "OnMovingFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.WeaponSlotHudBaseWidget.OnMovingStarted
// (Final, Native, Public)

void UWeaponSlotHudBaseWidget::OnMovingStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponSlotHudBaseWidget", "OnMovingStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.WeaponSlotHudBaseWidget.OnNotifyWeaponArmed
// (Final, Native, Public)

void UWeaponSlotHudBaseWidget::OnNotifyWeaponArmed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponSlotHudBaseWidget", "OnNotifyWeaponArmed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.WeaponSlotHudBaseWidget.OnNotifyWeaponChange
// (Final, Native, Public)
// Parameters:
// int32                                   WeaponIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponSlotHudBaseWidget::OnNotifyWeaponChange(int32 WeaponIndex, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponSlotHudBaseWidget", "OnNotifyWeaponChange");

	Params::WeaponSlotHudBaseWidget_OnNotifyWeaponChange Parms{};

	Parms.WeaponIndex = WeaponIndex;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.WeaponSlotHudBaseWidget.OnNotifyWeaponUnarm
// (Final, Native, Public)
// Parameters:
// bool                                    bIsUnarmed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponSlotHudBaseWidget::OnNotifyWeaponUnarm(bool bIsUnarmed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponSlotHudBaseWidget", "OnNotifyWeaponUnarm");

	Params::WeaponSlotHudBaseWidget_OnNotifyWeaponUnarm Parms{};

	Parms.bIsUnarmed = bIsUnarmed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleHitComponent.OnDeath
// (Final, Native, Private, HasOutParams)
// Parameters:
// float                                   KillingDamage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageEvent                     DamageEvent                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class ATslPlayerState*                  PlayerInstigator                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslVehicleHitComponent::OnDeath(float KillingDamage, const struct FDamageEvent& DamageEvent, class ATslPlayerState* PlayerInstigator, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleHitComponent", "OnDeath");

	Params::TslVehicleHitComponent_OnDeath Parms{};

	Parms.KillingDamage = KillingDamage;
	Parms.DamageEvent = std::move(DamageEvent);
	Parms.PlayerInstigator = PlayerInstigator;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleHitComponent.OnHit
// (Native, Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class AActor*                           SelfActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UTslVehicleHitComponent::OnHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleHitComponent", "OnHit");

	Params::TslVehicleHitComponent_OnHit Parms{};

	Parms.SelfActor = SelfActor;
	Parms.OtherActor = OtherActor;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleHitComponent.OnSyncHit
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UTslVehicleHitComponent::OnSyncHit(const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleHitComponent", "OnSyncHit");

	Params::TslVehicleHitComponent_OnSyncHit Parms{};

	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleSeatComponent.KillAllRiders
// (Final, Native, Private, HasOutParams)
// Parameters:
// float                                   KillingDamage                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDamageEvent                     DamageEvent                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class ATslPlayerState*                  PlayerInstigator                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslVehicleSeatComponent::KillAllRiders(float KillingDamage, const struct FDamageEvent& DamageEvent, class ATslPlayerState* PlayerInstigator, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleSeatComponent", "KillAllRiders");

	Params::TslVehicleSeatComponent_KillAllRiders Parms{};

	Parms.KillingDamage = KillingDamage;
	Parms.DamageEvent = std::move(DamageEvent);
	Parms.PlayerInstigator = PlayerInstigator;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleSeatComponent.Leave
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ATslCharacter*                    Rider                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVehicleSeatInteractionComponent* Seat                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForce                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslVehicleSeatComponent::Leave(class ATslCharacter* Rider, class UVehicleSeatInteractionComponent* Seat, bool bForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleSeatComponent", "Leave");

	Params::TslVehicleSeatComponent_Leave Parms{};

	Parms.Rider = Rider;
	Parms.Seat = Seat;
	Parms.bForce = bForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleSeatComponent.OnFuelChange
// (Final, Native, Private)
// Parameters:
// float                                   CurrentFuel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LastFuel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FuelMax                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslVehicleSeatComponent::OnFuelChange(float CurrentFuel, float LastFuel, float FuelMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleSeatComponent", "OnFuelChange");

	Params::TslVehicleSeatComponent_OnFuelChange Parms{};

	Parms.CurrentFuel = CurrentFuel;
	Parms.LastFuel = LastFuel;
	Parms.FuelMax = FuelMax;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleSeatComponent.PostDriverLeave
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void UTslVehicleSeatComponent::PostDriverLeave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleSeatComponent", "PostDriverLeave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleSeatComponent.PostDriverRide
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void UTslVehicleSeatComponent::PostDriverRide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleSeatComponent", "PostDriverRide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleSeatComponent.Ride
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ATslCharacter*                    Rider                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVehicleSeatInteractionComponent* Seat                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslVehicleSeatComponent::Ride(class ATslCharacter* Rider, class UVehicleSeatInteractionComponent* Seat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleSeatComponent", "Ride");

	Params::TslVehicleSeatComponent_Ride Parms{};

	Parms.Rider = Rider;
	Parms.Seat = Seat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleSeatComponent.TryToFlip
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void UTslVehicleSeatComponent::TryToFlip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleSeatComponent", "TryToFlip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleSeatComponent.TryToLeave
// (Native, Public, BlueprintCallable)
// Parameters:
// class ATslCharacter*                    Rider                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForce                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslVehicleSeatComponent::TryToLeave(class ATslCharacter* Rider, bool bForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleSeatComponent", "TryToLeave");

	Params::TslVehicleSeatComponent_TryToLeave Parms{};

	Parms.Rider = Rider;
	Parms.bForce = bForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleSeatComponent.TryToRide
// (Native, Public, BlueprintCallable)
// Parameters:
// class ATslCharacter*                    Rider                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVehicleSeatInteractionComponent* Seat                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTslVehicleSeatComponent::TryToRide(class ATslCharacter* Rider, class UVehicleSeatInteractionComponent* Seat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleSeatComponent", "TryToRide");

	Params::TslVehicleSeatComponent_TryToRide Parms{};

	Parms.Rider = Rider;
	Parms.Seat = Seat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleSeatComponent.TryToStabilize
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void UTslVehicleSeatComponent::TryToStabilize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleSeatComponent", "TryToStabilize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslVehicleSeatComponent.GetDriver
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslCharacter* UTslVehicleSeatComponent::GetDriver() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleSeatComponent", "GetDriver");

	Params::TslVehicleSeatComponent_GetDriver Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslVehicleSeatComponent.GetLastDriver
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   LastDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ATslCharacter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslCharacter* UTslVehicleSeatComponent::GetLastDriver(float LastDuration) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleSeatComponent", "GetLastDriver");

	Params::TslVehicleSeatComponent_GetLastDriver Parms{};

	Parms.LastDuration = LastDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslVehicleSeatComponent.GetRiders
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class ATslCharacter*>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ATslCharacter*> UTslVehicleSeatComponent::GetRiders() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleSeatComponent", "GetRiders");

	Params::TslVehicleSeatComponent_GetRiders Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslVehicleSeatComponent.GetSeat
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   SeatIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UVehicleSeatInteractionComponent* ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UVehicleSeatInteractionComponent* UTslVehicleSeatComponent::GetSeat(int32 SeatIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleSeatComponent", "GetSeat");

	Params::TslVehicleSeatComponent_GetSeat Parms{};

	Parms.SeatIndex = SeatIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslVehicleSeatComponent.GetSeats
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UVehicleSeatInteractionComponent*>ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UVehicleSeatInteractionComponent*> UTslVehicleSeatComponent::GetSeats() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleSeatComponent", "GetSeats");

	Params::TslVehicleSeatComponent_GetSeats Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslVehicleSeatComponent.GetVehicleSeatIndex
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UVehicleSeatInteractionComponent* Seat                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTslVehicleSeatComponent::GetVehicleSeatIndex(class UVehicleSeatInteractionComponent* Seat) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslVehicleSeatComponent", "GetVehicleSeatIndex");

	Params::TslVehicleSeatComponent_GetVehicleSeatIndex Parms{};

	Parms.Seat = Seat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Trajectory.OnRep_WeaponSpread
// (Final, Native, Protected)
// Parameters:
// float                                   LastWeaponSpread                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWeapon_Trajectory::OnRep_WeaponSpread(float LastWeaponSpread)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Trajectory", "OnRep_WeaponSpread");

	Params::TslWeapon_Trajectory_OnRep_WeaponSpread Parms{};

	Parms.LastWeaponSpread = LastWeaponSpread;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Trajectory.ServerNotifyCrack
// (Net, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// class ATslCharacter*                    TargetCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              LocationRelative                                       (Parm, NativeAccessSpecifierPublic)
// float                                   BulletVelocity                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWeapon_Trajectory::ServerNotifyCrack(class ATslCharacter* TargetCharacter, const struct FVector_NetQuantize& LocationRelative, float BulletVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Trajectory", "ServerNotifyCrack");

	Params::TslWeapon_Trajectory_ServerNotifyCrack Parms{};

	Parms.TargetCharacter = TargetCharacter;
	Parms.LocationRelative = std::move(LocationRelative);
	Parms.BulletVelocity = BulletVelocity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Trajectory.ServerNotifyHit
// (Net, NetReliable, Native, Event, Protected, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FHitResult                       Impact                                                 (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              Origin                                                 (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          TraceStart                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          PreLocation                                            (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector_NetQuantizeNormal        ShootDir                                               (Parm, NativeAccessSpecifierPublic)
// float                                   TravelDistance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAttackId                        AttackId                                               (Parm, NativeAccessSpecifierPublic)
// uint32                                  HitSeq                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RelLocation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ATslWeapon_Trajectory::ServerNotifyHit(const struct FHitResult& Impact, const struct FVector_NetQuantize& Origin, const struct FVector& TraceStart, const struct FVector& PreLocation, const struct FVector_NetQuantizeNormal& ShootDir, float TravelDistance, const struct FAttackId& AttackId, uint32 HitSeq, const struct FVector& RelLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Trajectory", "ServerNotifyHit");

	Params::TslWeapon_Trajectory_ServerNotifyHit Parms{};

	Parms.Impact = std::move(Impact);
	Parms.Origin = std::move(Origin);
	Parms.TraceStart = std::move(TraceStart);
	Parms.PreLocation = std::move(PreLocation);
	Parms.ShootDir = std::move(ShootDir);
	Parms.TravelDistance = TravelDistance;
	Parms.AttackId = std::move(AttackId);
	Parms.HitSeq = HitSeq;
	Parms.RelLocation = std::move(RelLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Trajectory.SimulateHit_Reliable
// (Net, NetReliable, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// struct FHitResult                       Impact                                                 (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          RelLocation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ATslWeapon_Trajectory::SimulateHit_Reliable(const struct FHitResult& Impact, const struct FVector& RelLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Trajectory", "SimulateHit_Reliable");

	Params::TslWeapon_Trajectory_SimulateHit_Reliable Parms{};

	Parms.Impact = std::move(Impact);
	Parms.RelLocation = std::move(RelLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Trajectory.SimulateHit_UnReliable
// (Net, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// struct FHitResult                       Impact                                                 (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          RelLocation                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ATslWeapon_Trajectory::SimulateHit_UnReliable(const struct FHitResult& Impact, const struct FVector& RelLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Trajectory", "SimulateHit_UnReliable");

	Params::TslWeapon_Trajectory_SimulateHit_UnReliable Parms{};

	Parms.Impact = std::move(Impact);
	Parms.RelLocation = std::move(RelLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Trajectory.GetBulletLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector ATslWeapon_Trajectory::GetBulletLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Trajectory", "GetBulletLocation");

	Params::TslWeapon_Trajectory_GetBulletLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Trajectory.GetBulletRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ATslWeapon_Trajectory::GetBulletRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Trajectory", "GetBulletRotation");

	Params::TslWeapon_Trajectory_GetBulletRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Trajectory.GetCurrentRecoilTarget
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector2D ATslWeapon_Trajectory::GetCurrentRecoilTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Trajectory", "GetCurrentRecoilTarget");

	Params::TslWeapon_Trajectory_GetCurrentRecoilTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Trajectory.GetCurrentRecoilValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslWeapon_Trajectory::GetCurrentRecoilValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Trajectory", "GetCurrentRecoilValue");

	Params::TslWeapon_Trajectory_GetCurrentRecoilValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Trajectory.GetCurrentReoveryTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslWeapon_Trajectory::GetCurrentReoveryTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Trajectory", "GetCurrentReoveryTarget");

	Params::TslWeapon_Trajectory_GetCurrentReoveryTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Trajectory.GetCurrentStabilityVar
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ATslWeapon_Trajectory::GetCurrentStabilityVar() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Trajectory", "GetCurrentStabilityVar");

	Params::TslWeapon_Trajectory_GetCurrentStabilityVar Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Trajectory.GetRecoilInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRecoilInfo                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FRecoilInfo ATslWeapon_Trajectory::GetRecoilInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Trajectory", "GetRecoilInfo");

	Params::TslWeapon_Trajectory_GetRecoilInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Trajectory.GetTrajectoryConfig
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTrajectoryWeaponData            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTrajectoryWeaponData ATslWeapon_Trajectory::GetTrajectoryConfig() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Trajectory", "GetTrajectoryConfig");

	Params::TslWeapon_Trajectory_GetTrajectoryConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Trajectory.IsBulletInAir
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATslWeapon_Trajectory::IsBulletInAir() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Trajectory", "IsBulletInAir");

	Params::TslWeapon_Trajectory_IsBulletInAir Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Melee.ClientAttack
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// int32                                   AnimIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWeapon_Melee::ClientAttack(int32 AnimIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Melee", "ClientAttack");

	Params::TslWeapon_Melee_ClientAttack Parms{};

	Parms.AnimIndex = AnimIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Melee.ClientHit_Confirmed
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// struct FHitResult                       Impact                                                 (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ATslWeapon_Melee::ClientHit_Confirmed(const struct FHitResult& Impact)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Melee", "ClientHit_Confirmed");

	Params::TslWeapon_Melee_ClientHit_Confirmed Parms{};

	Parms.Impact = std::move(Impact);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Melee.OnAnimationNotify
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// FName                             NotifyName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWeapon_Melee::OnAnimationNotify(const FName& NotifyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Melee", "OnAnimationNotify");

	Params::TslWeapon_Melee_OnAnimationNotify Parms{};

	Parms.NotifyName = NotifyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Melee.OnMontageEnded
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWeapon_Melee::OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Melee", "OnMontageEnded");

	Params::TslWeapon_Melee_OnMontageEnded Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Melee.ServerAttack
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// int32                                   AnimIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWeapon_Melee::ServerAttack(int32 AnimIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Melee", "ServerAttack");

	Params::TslWeapon_Melee_ServerAttack Parms{};

	Parms.AnimIndex = AnimIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Melee.ServerNotifyHit
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// TArray<struct FHitResult>               Impacts                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FAttackId                        AttackId                                               (Parm, NativeAccessSpecifierPublic)
// uint32                                  HitSeq                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWeapon_Melee::ServerNotifyHit(const TArray<struct FHitResult>& Impacts, const struct FAttackId& AttackId, uint32 HitSeq)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Melee", "ServerNotifyHit");

	Params::TslWeapon_Melee_ServerNotifyHit Parms{};

	Parms.Impacts = std::move(Impacts);
	Parms.AttackId = std::move(AttackId);
	Parms.HitSeq = HitSeq;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Throwable.ClientNotifyReset
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void ATslWeapon_Throwable::ClientNotifyReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Throwable", "ClientNotifyReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Throwable.GetThrowableCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ATslWeapon_Throwable::GetThrowableCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Throwable", "GetThrowableCount");

	Params::TslWeapon_Throwable_GetThrowableCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Throwable.GetThrowableCountInInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ATslWeapon_Throwable::GetThrowableCountInInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Throwable", "GetThrowableCountInInventory");

	Params::TslWeapon_Throwable_GetThrowableCountInInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Throwable.OnAnimationNotify
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// FName                             NotifyName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWeapon_Throwable::OnAnimationNotify(const FName& NotifyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Throwable", "OnAnimationNotify");

	Params::TslWeapon_Throwable_OnAnimationNotify Parms{};

	Parms.NotifyName = NotifyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Throwable.OnRep_ThrowableState
// (Final, Native, Protected)
// Parameters:
// EThrowableState                         LastThrowableState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATslWeapon_Throwable::OnRep_ThrowableState(EThrowableState LastThrowableState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Throwable", "OnRep_ThrowableState");

	Params::TslWeapon_Throwable_OnRep_ThrowableState Parms{};

	Parms.LastThrowableState = LastThrowableState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Throwable.ServerFireProjectile
// (Net, NetReliable, Native, Event, Protected, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FVector                          RelativeLocation                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          AimDirection                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ATslWeapon_Throwable::ServerFireProjectile(const struct FVector& RelativeLocation, const struct FVector& AimDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Throwable", "ServerFireProjectile");

	Params::TslWeapon_Throwable_ServerFireProjectile Parms{};

	Parms.RelativeLocation = std::move(RelativeLocation);
	Parms.AimDirection = std::move(AimDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Throwable.ServerRequestCancelThrow
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void ATslWeapon_Throwable::ServerRequestCancelThrow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Throwable", "ServerRequestCancelThrow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Throwable.ServerStartCooking
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void ATslWeapon_Throwable::ServerStartCooking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Throwable", "ServerStartCooking");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Throwable.ServerStartPinOff
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)

void ATslWeapon_Throwable::ServerStartPinOff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Throwable", "ServerStartPinOff");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.TslWeapon_Throwable.CalculateFinalThrowVelocity
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          AimDirection                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FVector ATslWeapon_Throwable::CalculateFinalThrowVelocity(const struct FVector& AimDirection) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Throwable", "CalculateFinalThrowVelocity");

	Params::TslWeapon_Throwable_CalculateFinalThrowVelocity Parms{};

	Parms.AimDirection = std::move(AimDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.TslWeapon_Throwable.GetThrowableState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EThrowableState                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EThrowableState ATslWeapon_Throwable::GetThrowableState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TslWeapon_Throwable", "GetThrowableState");

	Params::TslWeapon_Throwable_GetThrowableState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.VivoxComponent.ApplyTimedVolumeModifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVivoxChannelType                       ChannelType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewModifier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RestoreDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVivoxComponent::ApplyTimedVolumeModifier(EVivoxChannelType ChannelType, float NewModifier, float Duration, float RestoreDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxComponent", "ApplyTimedVolumeModifier");

	Params::VivoxComponent_ApplyTimedVolumeModifier Parms{};

	Parms.ChannelType = ChannelType;
	Parms.NewModifier = NewModifier;
	Parms.Duration = Duration;
	Parms.RestoreDuration = RestoreDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VivoxComponent.ServerSetObserverTeamNum
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// int32                                   NewTeamNum                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVivoxComponent::ServerSetObserverTeamNum(int32 NewTeamNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxComponent", "ServerSetObserverTeamNum");

	Params::VivoxComponent_ServerSetObserverTeamNum Parms{};

	Parms.NewTeamNum = NewTeamNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VivoxComponent.ServerTestAccessToken
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)

void UVivoxComponent::ServerTestAccessToken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxComponent", "ServerTestAccessToken");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VivoxManager.OnAddKeyFail
// (Final, Native, Private)
// Parameters:
// class UVivoxResponse*                   Response                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVivoxManager::OnAddKeyFail(const class UVivoxResponse* Response)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxManager", "OnAddKeyFail");

	Params::VivoxManager_OnAddKeyFail Parms{};

	Parms.Response = Response;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VivoxManager.OnAddKeySuccess
// (Final, Native, Private)
// Parameters:
// class UVivoxResponse*                   Response                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVivoxManager::OnAddKeySuccess(const class UVivoxResponse* Response)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxManager", "OnAddKeySuccess");

	Params::VivoxManager_OnAddKeySuccess Parms{};

	Parms.Response = Response;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VivoxManager.OnChannelFail
// (Final, Native, Private)
// Parameters:
// class UVivoxResponse*                   Response                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVivoxManager::OnChannelFail(const class UVivoxResponse* Response)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxManager", "OnChannelFail");

	Params::VivoxManager_OnChannelFail Parms{};

	Parms.Response = Response;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VivoxManager.OnChannelSuccess
// (Final, Native, Private)
// Parameters:
// class UVivoxResponse*                   Response                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVivoxManager::OnChannelSuccess(const class UVivoxResponse* Response)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxManager", "OnChannelSuccess");

	Params::VivoxManager_OnChannelSuccess Parms{};

	Parms.Response = Response;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VivoxManager.OnRevokeKeyFail
// (Final, Native, Private)
// Parameters:
// class UVivoxResponse*                   Response                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVivoxManager::OnRevokeKeyFail(const class UVivoxResponse* Response)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxManager", "OnRevokeKeyFail");

	Params::VivoxManager_OnRevokeKeyFail Parms{};

	Parms.Response = Response;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.VivoxManager.OnRevokeKeySuccess
// (Final, Native, Private)
// Parameters:
// class UVivoxResponse*                   Response                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVivoxManager::OnRevokeKeySuccess(const class UVivoxResponse* Response)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VivoxManager", "OnRevokeKeySuccess");

	Params::VivoxManager_OnRevokeKeySuccess Parms{};

	Parms.Response = Response;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.WeaponAnimInfoComponent.SetAccessorySlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTslAccessoryComponent*           NewAccessoryComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAccessorySlot                          Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponAnimInfoComponent::SetAccessorySlot(class UTslAccessoryComponent* NewAccessoryComponent, EAccessorySlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimInfoComponent", "SetAccessorySlot");

	Params::WeaponAnimInfoComponent_SetAccessorySlot Parms{};

	Parms.NewAccessoryComponent = NewAccessoryComponent;
	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function TslGame.WeaponAnimInfoComponent.GetAccessorySlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAccessorySlot                          Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTslAccessoryComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTslAccessoryComponent* UWeaponAnimInfoComponent::GetAccessorySlot(EAccessorySlot Slot) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimInfoComponent", "GetAccessorySlot");

	Params::WeaponAnimInfoComponent_GetAccessorySlot Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.WeaponAnimInfoComponent.GetCurrentWeapon
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATslWeapon* UWeaponAnimInfoComponent::GetCurrentWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimInfoComponent", "GetCurrentWeapon");

	Params::WeaponAnimInfoComponent_GetCurrentWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.WeaponAnimInfoComponent.GetWeaponHandIK_Left
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon*                       Weapon                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UWeaponAnimInfoComponent::GetWeaponHandIK_Left(const class ATslWeapon* Weapon) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimInfoComponent", "GetWeaponHandIK_Left");

	Params::WeaponAnimInfoComponent_GetWeaponHandIK_Left Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.WeaponAnimInfoComponent.GetWeaponHandIK_Right
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon*                       Weapon                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UWeaponAnimInfoComponent::GetWeaponHandIK_Right(const class ATslWeapon* Weapon) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimInfoComponent", "GetWeaponHandIK_Right");

	Params::WeaponAnimInfoComponent_GetWeaponHandIK_Right Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.WeaponAnimInfoComponent.GetWeaponLeftHandIKTransform
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon*                       Weapon                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UWeaponAnimInfoComponent::GetWeaponLeftHandIKTransform(const class ATslWeapon* Weapon) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimInfoComponent", "GetWeaponLeftHandIKTransform");

	Params::WeaponAnimInfoComponent_GetWeaponLeftHandIKTransform Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function TslGame.WeaponAnimInfoComponent.HasWeaponLeftHandIKSocket
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ATslWeapon*                       Weapon                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponAnimInfoComponent::HasWeaponLeftHandIKSocket(const class ATslWeapon* Weapon) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimInfoComponent", "HasWeaponLeftHandIKSocket");

	Params::WeaponAnimInfoComponent_HasWeaponLeftHandIKSocket Parms{};

	Parms.Weapon = Weapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

