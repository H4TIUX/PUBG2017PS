#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AkAudio

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "AkAudio_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class AkAudio.AkAutoPlayInterface
// 0x0000 (0x0028 - 0x0028)
class IAkAutoPlayInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkAutoPlayInterface">();
	}
	static class IAkAutoPlayInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAkAutoPlayInterface>();
	}
};
static_assert(alignof(IAkAutoPlayInterface) == 0x000008, "Wrong alignment on IAkAutoPlayInterface");
static_assert(sizeof(IAkAutoPlayInterface) == 0x000028, "Wrong size on IAkAutoPlayInterface");

// Class AkAudio.AkAmbientSound
// 0x0020 (0x03C0 - 0x03A0)
class AAkAmbientSound final : public AActor
{
public:
	uint8                                         Pad_3A0[0x10];                                     // 0x03A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkComponent*                           AkComponent;                                       // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoPlayDistance;                                  // 0x03B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, SimpleDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3BC[0x4];                                      // 0x03BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsCurrentlyPlaying();
	void StartAmbientSound();
	void StopAmbientSound();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkAmbientSound">();
	}
	static class AAkAmbientSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAkAmbientSound>();
	}
};
static_assert(alignof(AAkAmbientSound) == 0x000008, "Wrong alignment on AAkAmbientSound");
static_assert(sizeof(AAkAmbientSound) == 0x0003C0, "Wrong size on AAkAmbientSound");
static_assert(offsetof(AAkAmbientSound, AkComponent) == 0x0003B0, "Member 'AAkAmbientSound::AkComponent' has a wrong offset!");
static_assert(offsetof(AAkAmbientSound, AutoPlayDistance) == 0x0003B8, "Member 'AAkAmbientSound::AutoPlayDistance' has a wrong offset!");

// Class AkAudio.AkAudioBank
// 0x0008 (0x0030 - 0x0028)
class UAkAudioBank final : public UObject
{
public:
	bool                                          AutoLoad;                                          // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkAudioBank">();
	}
	static class UAkAudioBank* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkAudioBank>();
	}
};
static_assert(alignof(UAkAudioBank) == 0x000008, "Wrong alignment on UAkAudioBank");
static_assert(sizeof(UAkAudioBank) == 0x000030, "Wrong size on UAkAudioBank");
static_assert(offsetof(UAkAudioBank, AutoLoad) == 0x000028, "Member 'UAkAudioBank::AutoLoad' has a wrong offset!");

// Class AkAudio.AkAudioEvent
// 0x0010 (0x0038 - 0x0028)
class UAkAudioEvent final : public UObject
{
public:
	class UAkAudioBank*                           RequiredBank;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAttenuationRadius;                              // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkAudioEvent">();
	}
	static class UAkAudioEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkAudioEvent>();
	}
};
static_assert(alignof(UAkAudioEvent) == 0x000008, "Wrong alignment on UAkAudioEvent");
static_assert(sizeof(UAkAudioEvent) == 0x000038, "Wrong size on UAkAudioEvent");
static_assert(offsetof(UAkAudioEvent, RequiredBank) == 0x000028, "Member 'UAkAudioEvent::RequiredBank' has a wrong offset!");
static_assert(offsetof(UAkAudioEvent, MaxAttenuationRadius) == 0x000030, "Member 'UAkAudioEvent::MaxAttenuationRadius' has a wrong offset!");

// Class AkAudio.AkAuxBus
// 0x0010 (0x0038 - 0x0028)
class UAkAuxBus final : public UObject
{
public:
	class UAkAudioBank*                           RequiredBank;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkAuxBus">();
	}
	static class UAkAuxBus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkAuxBus>();
	}
};
static_assert(alignof(UAkAuxBus) == 0x000008, "Wrong alignment on UAkAuxBus");
static_assert(sizeof(UAkAuxBus) == 0x000038, "Wrong size on UAkAuxBus");
static_assert(offsetof(UAkAuxBus, RequiredBank) == 0x000028, "Member 'UAkAuxBus::RequiredBank' has a wrong offset!");

// Class AkAudio.AkComponent
// 0x00F0 (0x03F0 - 0x0300)
class UAkComponent final : public USceneComponent
{
public:
	bool                                          StopWhenOwnerDestroyed;                            // 0x0300(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDynamicReverb;                                    // 0x0301(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDoppler;                                       // 0x0302(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_303[0x1];                                      // 0x0303(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttenuationScalingFactor;                          // 0x0304(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OcclusionRefreshInterval;                          // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          AkAudioEvent;                                      // 0x0310(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EventName;                                         // 0x0318(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_328[0xC8];                                     // 0x0328(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CalculateDynamicReverb();
	void CalculateRelativeSpeed();
	bool IsCurrentlyPlaying();
	int32 PostAkEvent(class UAkAudioEvent* AkEvent, const class FString& in_EventName);
	int32 PostAkEventByName(const class FString& in_EventName);
	int32 PostAssociatedAkEvent();
	void PostTrigger(const class FString& Trigger);
	void SetActiveListeners(int32 in_uListenerMask);
	void SetAttenuationScalingFactor(float Value);
	void SetOutputBusVolume(float BusVolume);
	void SetRTPCValue(const class FString& RTPC, float Value, int32 InterpolationTimeMs);
	void SetStopWhenOwnerDestroyed(bool bStopWhenOwnerDestroyed);
	void SetSwitch(const class FString& SwitchGroup, const class FString& SwitchState);
	void Stop();
	void StopPlayingID(int32 PlayingID);
	void UseReverbVolumes(bool inUseReverbVolumes);

	float GetAttenuationRadius() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkComponent">();
	}
	static class UAkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkComponent>();
	}
};
static_assert(alignof(UAkComponent) == 0x000008, "Wrong alignment on UAkComponent");
static_assert(sizeof(UAkComponent) == 0x0003F0, "Wrong size on UAkComponent");
static_assert(offsetof(UAkComponent, StopWhenOwnerDestroyed) == 0x000300, "Member 'UAkComponent::StopWhenOwnerDestroyed' has a wrong offset!");
static_assert(offsetof(UAkComponent, bDynamicReverb) == 0x000301, "Member 'UAkComponent::bDynamicReverb' has a wrong offset!");
static_assert(offsetof(UAkComponent, bUseDoppler) == 0x000302, "Member 'UAkComponent::bUseDoppler' has a wrong offset!");
static_assert(offsetof(UAkComponent, AttenuationScalingFactor) == 0x000304, "Member 'UAkComponent::AttenuationScalingFactor' has a wrong offset!");
static_assert(offsetof(UAkComponent, OcclusionRefreshInterval) == 0x000308, "Member 'UAkComponent::OcclusionRefreshInterval' has a wrong offset!");
static_assert(offsetof(UAkComponent, AkAudioEvent) == 0x000310, "Member 'UAkComponent::AkAudioEvent' has a wrong offset!");
static_assert(offsetof(UAkComponent, EventName) == 0x000318, "Member 'UAkComponent::EventName' has a wrong offset!");

// Class AkAudio.AkGameplayStatics
// 0x0000 (0x0028 - 0x0028)
class UAkGameplayStatics final : public UBlueprintFunctionLibrary
{
public:
	static void AddOutputCaptureMarker(const class FString& MarkerText);
	static void ClearBanks();
	static class UAkComponent* GetAkComponent(class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, EAttachLocation LocationType);
	static void LoadBank(class UAkAudioBank* Bank, const class FString& BankName);
	static void LoadBankByName(const class FString& BankName);
	static void LoadBanks(const TArray<class UAkAudioBank*>& SoundBanks, bool SynchronizeSoundBanks);
	static void LoadInitBank();
	static int32 PostEvent(class UAkAudioEvent* AkEvent, class AActor* Actor, bool bStopWhenAttachedToDestroyed, const class FString& EventName);
	static int32 PostEventAtLocation(class UAkAudioEvent* AkEvent, const struct FVector& Location, const struct FRotator& Orientation, const class FString& EventName, class UObject* WorldContextObject);
	static void PostEventAtLocationByName(const class FString& EventName, const struct FVector& Location, const struct FRotator& Orientation, class UObject* WorldContextObject);
	static int32 PostEventAttached(class UAkAudioEvent* AkEvent, class AActor* Actor, class FName AttachPointName, bool bStopWhenAttachedToDestroyed, const class FString& EventName);
	static void PostEventByName(const class FString& EventName, class AActor* Actor, bool bStopWhenAttachedToDestroyed);
	static void PostTrigger(class FName Trigger, class AActor* Actor);
	static void SetOcclusionRefreshInterval(float RefreshInterval, class AActor* Actor);
	static void SetOutputBusVolume(float BusVolume, class AActor* Actor);
	static void SetRTPCValue(class FName RTPC, float Value, int32 InterpolationTimeMs, class AActor* Actor);
	static void SetState(class FName StateGroup, class FName State);
	static void SetSwitch(class FName SwitchGroup, class FName SwitchState, class AActor* Actor);
	static class UAkComponent* SpawnAkComponentAtLocation(class UObject* WorldContextObject, class UAkAudioEvent* AkEvent, const struct FVector& Location, const struct FRotator& Orientation, bool AutoPost, const class FString& EventName, bool AutoDestroy);
	static void StartAllAmbientSounds(class UObject* WorldContextObject);
	static void StartOutputCapture(const class FString& Filename);
	static void StartProfilerCapture(const class FString& Filename);
	static void StopActor(class AActor* Actor);
	static void StopAll();
	static void StopAllAmbientSounds(class UObject* WorldContextObject);
	static void StopOutputCapture();
	static void StopProfilerCapture();
	static void UnloadBank(class UAkAudioBank* Bank, const class FString& BankName);
	static void UnloadBankByName(const class FString& BankName);
	static void UseReverbVolumes(bool inUseReverbVolumes, class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkGameplayStatics">();
	}
	static class UAkGameplayStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkGameplayStatics>();
	}
};
static_assert(alignof(UAkGameplayStatics) == 0x000008, "Wrong alignment on UAkGameplayStatics");
static_assert(sizeof(UAkGameplayStatics) == 0x000028, "Wrong size on UAkGameplayStatics");

// Class AkAudio.AkReverbVolume
// 0x0038 (0x0410 - 0x03D8)
class AAkReverbVolume final : public AVolume
{
public:
	uint8                                         bEnabled : 1;                                      // 0x03D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Net, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3D9[0x7];                                      // 0x03D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAuxBus*                              AuxBus;                                            // 0x03E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AuxBusName;                                        // 0x03E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SendLevel;                                         // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeRate;                                          // 0x03FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Priority;                                          // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_404[0x4];                                      // 0x0404(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AAkReverbVolume*                        NextLowerPriorityAkReverbVolume;                   // 0x0408(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkReverbVolume">();
	}
	static class AAkReverbVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAkReverbVolume>();
	}
};
static_assert(alignof(AAkReverbVolume) == 0x000008, "Wrong alignment on AAkReverbVolume");
static_assert(sizeof(AAkReverbVolume) == 0x000410, "Wrong size on AAkReverbVolume");
static_assert(offsetof(AAkReverbVolume, AuxBus) == 0x0003E0, "Member 'AAkReverbVolume::AuxBus' has a wrong offset!");
static_assert(offsetof(AAkReverbVolume, AuxBusName) == 0x0003E8, "Member 'AAkReverbVolume::AuxBusName' has a wrong offset!");
static_assert(offsetof(AAkReverbVolume, SendLevel) == 0x0003F8, "Member 'AAkReverbVolume::SendLevel' has a wrong offset!");
static_assert(offsetof(AAkReverbVolume, FadeRate) == 0x0003FC, "Member 'AAkReverbVolume::FadeRate' has a wrong offset!");
static_assert(offsetof(AAkReverbVolume, Priority) == 0x000400, "Member 'AAkReverbVolume::Priority' has a wrong offset!");
static_assert(offsetof(AAkReverbVolume, NextLowerPriorityAkReverbVolume) == 0x000408, "Member 'AAkReverbVolume::NextLowerPriorityAkReverbVolume' has a wrong offset!");

// Class AkAudio.AkSettings
// 0x0070 (0x0098 - 0x0028)
class UAkSettings final : public UObject
{
public:
	uint8                                         MaxSimultaneousReverbVolumes;                      // 0x0028(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFilePath                              WwiseProjectPath;                                  // 0x0030(0x0010)(Edit, Config, NativeAccessSpecifierPublic)
	struct FDirectoryPath                         WwiseWindowsInstallationPath;                      // 0x0040(0x0010)(Edit, Config, NativeAccessSpecifierPublic)
	struct FFilePath                              WwiseMacInstallationPath;                          // 0x0050(0x0010)(Edit, Config, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x38];                                      // 0x0060(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkSettings">();
	}
	static class UAkSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkSettings>();
	}
};
static_assert(alignof(UAkSettings) == 0x000008, "Wrong alignment on UAkSettings");
static_assert(sizeof(UAkSettings) == 0x000098, "Wrong size on UAkSettings");
static_assert(offsetof(UAkSettings, MaxSimultaneousReverbVolumes) == 0x000028, "Member 'UAkSettings::MaxSimultaneousReverbVolumes' has a wrong offset!");
static_assert(offsetof(UAkSettings, WwiseProjectPath) == 0x000030, "Member 'UAkSettings::WwiseProjectPath' has a wrong offset!");
static_assert(offsetof(UAkSettings, WwiseWindowsInstallationPath) == 0x000040, "Member 'UAkSettings::WwiseWindowsInstallationPath' has a wrong offset!");
static_assert(offsetof(UAkSettings, WwiseMacInstallationPath) == 0x000050, "Member 'UAkSettings::WwiseMacInstallationPath' has a wrong offset!");

// Class AkAudio.InterpTrackAkAudioEvent
// 0x0018 (0x00A8 - 0x0090)
class UInterpTrackAkAudioEvent final : public UInterpTrackVectorBase
{
public:
	TArray<struct FAkAudioEventTrackKey>          Events;                                            // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bContinueEventOnMatineeEnd : 1;                    // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackAkAudioEvent">();
	}
	static class UInterpTrackAkAudioEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackAkAudioEvent>();
	}
};
static_assert(alignof(UInterpTrackAkAudioEvent) == 0x000008, "Wrong alignment on UInterpTrackAkAudioEvent");
static_assert(sizeof(UInterpTrackAkAudioEvent) == 0x0000A8, "Wrong size on UInterpTrackAkAudioEvent");
static_assert(offsetof(UInterpTrackAkAudioEvent, Events) == 0x000090, "Member 'UInterpTrackAkAudioEvent::Events' has a wrong offset!");

// Class AkAudio.InterpTrackAkAudioRTPC
// 0x0018 (0x00A8 - 0x0090)
class UInterpTrackAkAudioRTPC final : public UInterpTrackFloatBase
{
public:
	class FString                                 Param;                                             // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPlayOnReverse : 1;                                // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bContinueRTPCOnMatineeEnd : 1;                     // 0x00A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackAkAudioRTPC">();
	}
	static class UInterpTrackAkAudioRTPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackAkAudioRTPC>();
	}
};
static_assert(alignof(UInterpTrackAkAudioRTPC) == 0x000008, "Wrong alignment on UInterpTrackAkAudioRTPC");
static_assert(sizeof(UInterpTrackAkAudioRTPC) == 0x0000A8, "Wrong size on UInterpTrackAkAudioRTPC");
static_assert(offsetof(UInterpTrackAkAudioRTPC, Param) == 0x000090, "Member 'UInterpTrackAkAudioRTPC::Param' has a wrong offset!");

// Class AkAudio.InterpTrackInstAkAudioEvent
// 0x0008 (0x0030 - 0x0028)
class UInterpTrackInstAkAudioEvent final : public UInterpTrackInst
{
public:
	float                                         LastUpdatePosition;                                // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackInstAkAudioEvent">();
	}
	static class UInterpTrackInstAkAudioEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackInstAkAudioEvent>();
	}
};
static_assert(alignof(UInterpTrackInstAkAudioEvent) == 0x000008, "Wrong alignment on UInterpTrackInstAkAudioEvent");
static_assert(sizeof(UInterpTrackInstAkAudioEvent) == 0x000030, "Wrong size on UInterpTrackInstAkAudioEvent");
static_assert(offsetof(UInterpTrackInstAkAudioEvent, LastUpdatePosition) == 0x000028, "Member 'UInterpTrackInstAkAudioEvent::LastUpdatePosition' has a wrong offset!");

// Class AkAudio.InterpTrackInstAkAudioRTPC
// 0x0008 (0x0030 - 0x0028)
class UInterpTrackInstAkAudioRTPC final : public UInterpTrackInst
{
public:
	float                                         LastUpdatePosition;                                // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackInstAkAudioRTPC">();
	}
	static class UInterpTrackInstAkAudioRTPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackInstAkAudioRTPC>();
	}
};
static_assert(alignof(UInterpTrackInstAkAudioRTPC) == 0x000008, "Wrong alignment on UInterpTrackInstAkAudioRTPC");
static_assert(sizeof(UInterpTrackInstAkAudioRTPC) == 0x000030, "Wrong size on UInterpTrackInstAkAudioRTPC");
static_assert(offsetof(UInterpTrackInstAkAudioRTPC, LastUpdatePosition) == 0x000028, "Member 'UInterpTrackInstAkAudioRTPC::LastUpdatePosition' has a wrong offset!");

}

