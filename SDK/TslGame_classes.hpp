#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TslGame

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "SlateCore_classes.hpp"
#include "OceanPlugin_classes.hpp"
#include "CustomizableObject_structs.hpp"
#include "CustomizableObject_classes.hpp"
#include "TslGame_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "CoherentUIGTPlugin_classes.hpp"
#include "EngineSettings_classes.hpp"
#include "InputCore_structs.hpp"


namespace SDK
{

// Class TslGame.InteractionComponent
// 0x0188 (0x0280 - 0x00F8)
class UInteractionComponent : public UActorComponent
{
public:
	uint8                                         Pad_F8[0x10];                                      // 0x00F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxInteractableDistance;                           // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   InteractionVerb;                                   // 0x0110(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   InteractiveObjectName;                             // 0x0128(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCastConfig                            CastConfig;                                        // 0x0140(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bUseTraceCheck;                                    // 0x0170(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnInteractBy;                                      // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ClientOnInteractBy;                                // 0x0188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_198[0xE8];                                     // 0x0198(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AllowInteractBy(const class ATslCharacter* Character) const;
	class FText GetInteractionVerb() const;
	class FText GetInteractiveObjectName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionComponent">();
	}
	static class UInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionComponent>();
	}
};
static_assert(alignof(UInteractionComponent) == 0x000008, "Wrong alignment on UInteractionComponent");
static_assert(sizeof(UInteractionComponent) == 0x000280, "Wrong size on UInteractionComponent");
static_assert(offsetof(UInteractionComponent, MaxInteractableDistance) == 0x000108, "Member 'UInteractionComponent::MaxInteractableDistance' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, InteractionVerb) == 0x000110, "Member 'UInteractionComponent::InteractionVerb' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, InteractiveObjectName) == 0x000128, "Member 'UInteractionComponent::InteractiveObjectName' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, CastConfig) == 0x000140, "Member 'UInteractionComponent::CastConfig' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, bUseTraceCheck) == 0x000170, "Member 'UInteractionComponent::bUseTraceCheck' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, OnInteractBy) == 0x000178, "Member 'UInteractionComponent::OnInteractBy' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, ClientOnInteractBy) == 0x000188, "Member 'UInteractionComponent::ClientOnInteractBy' has a wrong offset!");

// Class TslGame.VivoxBaseComponent
// 0x00A0 (0x0198 - 0x00F8)
class UVivoxBaseComponent : public UActorComponent
{
public:
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnVoiceChatUpdated;                                // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FVivoxConnectionInfo                   ConnectionInfo;                                    // 0x0110(0x0020)(Net, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_130[0x10];                                     // 0x0130(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TeamChannelUrl;                                    // 0x0140(0x0010)(Net, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 GlobalChannelUrl;                                  // 0x0150(0x0010)(Net, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_160[0x4];                                      // 0x0160(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ResetFailureDelaySeconds;                          // 0x0164(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_168[0x18];                                     // 0x0168(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpdatePositionIntervalSeconds;                     // 0x0180(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_184[0xC];                                      // 0x0184(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UserInputVolumeModifier;                           // 0x0190(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UserOutputVolumeModifier;                          // 0x0194(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ClientJoinGlobalChannel(const class FString& AccessToken);
	void ClientJoinTeamChannel(const class FString& AccessToken);
	void ClientLeaveGlobalChannel();
	void ClientLeaveTeamChannel();
	void ClientLogin(const class FString& AccessToken);
	void RefreshDevices();
	void ResetConnectionState();
	void ResetGlobalChannelJoinState();
	void ResetLoginState();
	void ResetTeamChannelJoinState();
	void ServerJoinGlobalChannel();
	void ServerJoinTeamChannel();
	void ServerLogin();
	void SetLocalVoiceInputMuted(bool bIsMuted);
	void SetLocalVoiceInputVolume(int32 UserSettingVolume);
	void SetLocalVoiceOutputMuted(bool bIsMuted);
	void SetLocalVoiceOutputVolume(int32 UserSettingVolume);
	void SetVoiceChannelType(EVivoxChannelType ChannelType);
	void UpdatePosition();

	float CalculateInputVolumeFromModifiers() const;
	float CalculateOutputVolumeFromModifiers() const;
	bool GetLocalVoiceInputMuted() const;
	int32 GetLocalVoiceInputVolume() const;
	bool GetLocalVoiceOutputMuted() const;
	int32 GetLocalVoiceOutputVolume() const;
	EVivoxChannelType GetVoiceChannelType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VivoxBaseComponent">();
	}
	static class UVivoxBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVivoxBaseComponent>();
	}
};
static_assert(alignof(UVivoxBaseComponent) == 0x000008, "Wrong alignment on UVivoxBaseComponent");
static_assert(sizeof(UVivoxBaseComponent) == 0x000198, "Wrong size on UVivoxBaseComponent");
static_assert(offsetof(UVivoxBaseComponent, OnVoiceChatUpdated) == 0x000100, "Member 'UVivoxBaseComponent::OnVoiceChatUpdated' has a wrong offset!");
static_assert(offsetof(UVivoxBaseComponent, ConnectionInfo) == 0x000110, "Member 'UVivoxBaseComponent::ConnectionInfo' has a wrong offset!");
static_assert(offsetof(UVivoxBaseComponent, TeamChannelUrl) == 0x000140, "Member 'UVivoxBaseComponent::TeamChannelUrl' has a wrong offset!");
static_assert(offsetof(UVivoxBaseComponent, GlobalChannelUrl) == 0x000150, "Member 'UVivoxBaseComponent::GlobalChannelUrl' has a wrong offset!");
static_assert(offsetof(UVivoxBaseComponent, ResetFailureDelaySeconds) == 0x000164, "Member 'UVivoxBaseComponent::ResetFailureDelaySeconds' has a wrong offset!");
static_assert(offsetof(UVivoxBaseComponent, UpdatePositionIntervalSeconds) == 0x000180, "Member 'UVivoxBaseComponent::UpdatePositionIntervalSeconds' has a wrong offset!");
static_assert(offsetof(UVivoxBaseComponent, UserInputVolumeModifier) == 0x000190, "Member 'UVivoxBaseComponent::UserInputVolumeModifier' has a wrong offset!");
static_assert(offsetof(UVivoxBaseComponent, UserOutputVolumeModifier) == 0x000194, "Member 'UVivoxBaseComponent::UserOutputVolumeModifier' has a wrong offset!");

// Class TslGame.AnimDB
// 0x0148 (0x0170 - 0x0028)
class UAnimDB final : public UDataAsset
{
public:
	struct FAnimInfo                              Stand_Info;                                        // 0x0028(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FAnimInfo                              Crouch_Info;                                       // 0x0090(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FAnimInfo                              Prone_Info;                                        // 0x00F8(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         BlendSpaceSpeed_Walk;                              // 0x0160(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendSpaceSpeed_Run;                               // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendSpaceSpeed_Sprint;                            // 0x0168(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetAnimSpeed(EAnimStanceType AnimStance, float Direction, float InSpeed, float* PlayRate, float* SprintAlpha) const;
	class UBlendSpace* GetBlendSpace(EAnimStanceType AnimStance, bool bIsFPP) const;
	class UBlendSpace* GetBlendSpaceRelaxed(EAnimStanceType AnimStance, bool bIsFPP) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimDB">();
	}
	static class UAnimDB* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimDB>();
	}
};
static_assert(alignof(UAnimDB) == 0x000008, "Wrong alignment on UAnimDB");
static_assert(sizeof(UAnimDB) == 0x000170, "Wrong size on UAnimDB");
static_assert(offsetof(UAnimDB, Stand_Info) == 0x000028, "Member 'UAnimDB::Stand_Info' has a wrong offset!");
static_assert(offsetof(UAnimDB, Crouch_Info) == 0x000090, "Member 'UAnimDB::Crouch_Info' has a wrong offset!");
static_assert(offsetof(UAnimDB, Prone_Info) == 0x0000F8, "Member 'UAnimDB::Prone_Info' has a wrong offset!");
static_assert(offsetof(UAnimDB, BlendSpaceSpeed_Walk) == 0x000160, "Member 'UAnimDB::BlendSpaceSpeed_Walk' has a wrong offset!");
static_assert(offsetof(UAnimDB, BlendSpaceSpeed_Run) == 0x000164, "Member 'UAnimDB::BlendSpaceSpeed_Run' has a wrong offset!");
static_assert(offsetof(UAnimDB, BlendSpaceSpeed_Sprint) == 0x000168, "Member 'UAnimDB::BlendSpaceSpeed_Sprint' has a wrong offset!");

// Class TslGame.FlashBangCaptureActor
// 0x0030 (0x03D0 - 0x03A0)
class AFlashBangCaptureActor final : public AActor
{
public:
	class USceneComponent*                        SceneRootComponent;                                // 0x03A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneCaptureComponent2D*               SceneCapture;                                      // 0x03A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  PlayerPawnReference;                               // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 CaptureTexture;                                    // 0x03B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C0[0x10];                                     // 0x03C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CaptureINIT(bool bDoDelay, float CaptureDelay, class APawn* PlayerRef, class UTextureRenderTarget2D* RenderTexture, const struct FPostProcessSettings& PP_Settings, bool bHidePawn);
	void CaptureScreen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashBangCaptureActor">();
	}
	static class AFlashBangCaptureActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlashBangCaptureActor>();
	}
};
static_assert(alignof(AFlashBangCaptureActor) == 0x000008, "Wrong alignment on AFlashBangCaptureActor");
static_assert(sizeof(AFlashBangCaptureActor) == 0x0003D0, "Wrong size on AFlashBangCaptureActor");
static_assert(offsetof(AFlashBangCaptureActor, SceneRootComponent) == 0x0003A0, "Member 'AFlashBangCaptureActor::SceneRootComponent' has a wrong offset!");
static_assert(offsetof(AFlashBangCaptureActor, SceneCapture) == 0x0003A8, "Member 'AFlashBangCaptureActor::SceneCapture' has a wrong offset!");
static_assert(offsetof(AFlashBangCaptureActor, PlayerPawnReference) == 0x0003B0, "Member 'AFlashBangCaptureActor::PlayerPawnReference' has a wrong offset!");
static_assert(offsetof(AFlashBangCaptureActor, CaptureTexture) == 0x0003B8, "Member 'AFlashBangCaptureActor::CaptureTexture' has a wrong offset!");

// Class TslGame.VehicleSeatActor
// 0x0088 (0x0428 - 0x03A0)
class AVehicleSeatActor : public AActor
{
public:
	float                                         ViewPitchMin;                                      // 0x03A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewPitchMax;                                      // 0x03A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewYawMin;                                        // 0x03A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewYawMax;                                        // 0x03AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            CurvePitchMax;                                     // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            CurvePitchMin;                                     // 0x03B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanOnlyFireWhileAiming;                           // 0x03C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C1[0x7];                                      // 0x03C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        SeatBlendspaceAiming;                              // 0x03C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      SeatAnimationIdle;                                 // 0x03D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAimOffsetBlendSpace*                   SeatIdleAO;                                        // 0x03D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        TransitionOutBlendspace;                           // 0x03E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        TransitionInBlendspace;                            // 0x03E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRestricWeaponUse;                                 // 0x03F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F1[0x7];                                      // 0x03F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EWeaponClass>                          AllowedWeaponClasses;                              // 0x03F8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseEntryVelocityRestriction;                      // 0x0408(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_409[0x3];                                      // 0x0409(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxVelocityForEntry;                               // 0x040C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATslCharacter*                          Rider;                                             // 0x0410(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_418[0xC];                                      // 0x0418(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	EVehicleAnimType                              SeatAnimationType;                                 // 0x0424(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_425[0x3];                                      // 0x0425(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AllowInteract(const class ATslCharacter* OtherCharacter);
	class FText GetAdditionalMessage(const class ATslCharacter* Character);
	float GetMaxPitchByYaw(float CurrentYaw);
	float GetMinPitchByYaw(float CurrentYaw);
	void OnRep_Rider();

	bool GetCanFireOnlyWhileAimed() const;
	class ATslCharacter* GetRider() const;
	class UBlendSpaceBase* GetSeatAimingBlendspace() const;
	class UAnimSequenceBase* GetSeatIdleAnimation() const;
	class UAimOffsetBlendSpace* GetSeatIdleAO() const;
	class UBlendSpaceBase* GetTransitionInBlendspace() const;
	class UBlendSpaceBase* GetTransitionOutBlendspace() const;
	EVehicleAnimType GetVehicleAnimType() const;
	TScriptInterface<class ITslVehicleInterface> GetVehicleInterface() const;
	class APawn* GetVehiclePawn() const;
	class UTslVehicleSeatComponent* GetVehicleSeatComponent() const;
	bool IsEntryAllowedByVelocity() const;
	bool IsWeaponClassAllowed(EWeaponClass InClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleSeatActor">();
	}
	static class AVehicleSeatActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVehicleSeatActor>();
	}
};
static_assert(alignof(AVehicleSeatActor) == 0x000008, "Wrong alignment on AVehicleSeatActor");
static_assert(sizeof(AVehicleSeatActor) == 0x000428, "Wrong size on AVehicleSeatActor");
static_assert(offsetof(AVehicleSeatActor, ViewPitchMin) == 0x0003A0, "Member 'AVehicleSeatActor::ViewPitchMin' has a wrong offset!");
static_assert(offsetof(AVehicleSeatActor, ViewPitchMax) == 0x0003A4, "Member 'AVehicleSeatActor::ViewPitchMax' has a wrong offset!");
static_assert(offsetof(AVehicleSeatActor, ViewYawMin) == 0x0003A8, "Member 'AVehicleSeatActor::ViewYawMin' has a wrong offset!");
static_assert(offsetof(AVehicleSeatActor, ViewYawMax) == 0x0003AC, "Member 'AVehicleSeatActor::ViewYawMax' has a wrong offset!");
static_assert(offsetof(AVehicleSeatActor, CurvePitchMax) == 0x0003B0, "Member 'AVehicleSeatActor::CurvePitchMax' has a wrong offset!");
static_assert(offsetof(AVehicleSeatActor, CurvePitchMin) == 0x0003B8, "Member 'AVehicleSeatActor::CurvePitchMin' has a wrong offset!");
static_assert(offsetof(AVehicleSeatActor, bCanOnlyFireWhileAiming) == 0x0003C0, "Member 'AVehicleSeatActor::bCanOnlyFireWhileAiming' has a wrong offset!");
static_assert(offsetof(AVehicleSeatActor, SeatBlendspaceAiming) == 0x0003C8, "Member 'AVehicleSeatActor::SeatBlendspaceAiming' has a wrong offset!");
static_assert(offsetof(AVehicleSeatActor, SeatAnimationIdle) == 0x0003D0, "Member 'AVehicleSeatActor::SeatAnimationIdle' has a wrong offset!");
static_assert(offsetof(AVehicleSeatActor, SeatIdleAO) == 0x0003D8, "Member 'AVehicleSeatActor::SeatIdleAO' has a wrong offset!");
static_assert(offsetof(AVehicleSeatActor, TransitionOutBlendspace) == 0x0003E0, "Member 'AVehicleSeatActor::TransitionOutBlendspace' has a wrong offset!");
static_assert(offsetof(AVehicleSeatActor, TransitionInBlendspace) == 0x0003E8, "Member 'AVehicleSeatActor::TransitionInBlendspace' has a wrong offset!");
static_assert(offsetof(AVehicleSeatActor, bRestricWeaponUse) == 0x0003F0, "Member 'AVehicleSeatActor::bRestricWeaponUse' has a wrong offset!");
static_assert(offsetof(AVehicleSeatActor, AllowedWeaponClasses) == 0x0003F8, "Member 'AVehicleSeatActor::AllowedWeaponClasses' has a wrong offset!");
static_assert(offsetof(AVehicleSeatActor, bUseEntryVelocityRestriction) == 0x000408, "Member 'AVehicleSeatActor::bUseEntryVelocityRestriction' has a wrong offset!");
static_assert(offsetof(AVehicleSeatActor, MaxVelocityForEntry) == 0x00040C, "Member 'AVehicleSeatActor::MaxVelocityForEntry' has a wrong offset!");
static_assert(offsetof(AVehicleSeatActor, Rider) == 0x000410, "Member 'AVehicleSeatActor::Rider' has a wrong offset!");
static_assert(offsetof(AVehicleSeatActor, SeatAnimationType) == 0x000424, "Member 'AVehicleSeatActor::SeatAnimationType' has a wrong offset!");

// Class TslGame.ParachuteVehicleSeatActor
// 0x0000 (0x0428 - 0x0428)
class AParachuteVehicleSeatActor : public AVehicleSeatActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParachuteVehicleSeatActor">();
	}
	static class AParachuteVehicleSeatActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AParachuteVehicleSeatActor>();
	}
};
static_assert(alignof(AParachuteVehicleSeatActor) == 0x000008, "Wrong alignment on AParachuteVehicleSeatActor");
static_assert(sizeof(AParachuteVehicleSeatActor) == 0x000428, "Wrong size on AParachuteVehicleSeatActor");

// Class TslGame.TslPopupInterface
// 0x0000 (0x0028 - 0x0028)
class ITslPopupInterface final : public IInterface
{
public:
	void SetPopup(EPopupStyle PopupStyle, const class FText& Message, const TDelegate<void(EPopupButtonID ButtonID)>& PressedDelegate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslPopupInterface">();
	}
	static class ITslPopupInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITslPopupInterface>();
	}
};
static_assert(alignof(ITslPopupInterface) == 0x000008, "Wrong alignment on ITslPopupInterface");
static_assert(sizeof(ITslPopupInterface) == 0x000028, "Wrong size on ITslPopupInterface");

// Class TslGame.GameEventObserver
// 0x0050 (0x0078 - 0x0028)
class UGameEventObserver final : public UObject
{
public:
	UMulticastDelegateProperty_                   OnMatchStarted;                                    // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMatchEnded;                                      // 0x0038(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnKillOtherPlayer;                                 // 0x0048(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDie;                                             // 0x0058(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDamage;                                          // 0x0068(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameEventObserver">();
	}
	static class UGameEventObserver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameEventObserver>();
	}
};
static_assert(alignof(UGameEventObserver) == 0x000008, "Wrong alignment on UGameEventObserver");
static_assert(sizeof(UGameEventObserver) == 0x000078, "Wrong size on UGameEventObserver");
static_assert(offsetof(UGameEventObserver, OnMatchStarted) == 0x000028, "Member 'UGameEventObserver::OnMatchStarted' has a wrong offset!");
static_assert(offsetof(UGameEventObserver, OnMatchEnded) == 0x000038, "Member 'UGameEventObserver::OnMatchEnded' has a wrong offset!");
static_assert(offsetof(UGameEventObserver, OnKillOtherPlayer) == 0x000048, "Member 'UGameEventObserver::OnKillOtherPlayer' has a wrong offset!");
static_assert(offsetof(UGameEventObserver, OnDie) == 0x000058, "Member 'UGameEventObserver::OnDie' has a wrong offset!");
static_assert(offsetof(UGameEventObserver, OnDamage) == 0x000068, "Member 'UGameEventObserver::OnDamage' has a wrong offset!");

// Class TslGame.ActionInputEventHolder
// 0x0028 (0x0050 - 0x0028)
class UActionInputEventHolder final : public UObject
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionInputEventHolder">();
	}
	static class UActionInputEventHolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionInputEventHolder>();
	}
};
static_assert(alignof(UActionInputEventHolder) == 0x000008, "Wrong alignment on UActionInputEventHolder");
static_assert(sizeof(UActionInputEventHolder) == 0x000050, "Wrong size on UActionInputEventHolder");

// Class TslGame.HackReporterComponent
// 0x0048 (0x0140 - 0x00F8)
class UHackReporterComponent final : public UActorComponent
{
public:
	uint8                                         Pad_F8[0x48];                                      // 0x00F8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ServerOnWallHackDetected(float Distance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HackReporterComponent">();
	}
	static class UHackReporterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHackReporterComponent>();
	}
};
static_assert(alignof(UHackReporterComponent) == 0x000008, "Wrong alignment on UHackReporterComponent");
static_assert(sizeof(UHackReporterComponent) == 0x000140, "Wrong size on UHackReporterComponent");

// Class TslGame.TslBaseHUD
// 0x0088 (0x0510 - 0x0488)
class ATslBaseHUD : public AHUD
{
public:
	TSubclassOf<class UUserWidget>                MainUMGHudClass;                                   // 0x0488(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_490[0x8];                                      // 0x0490(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UActionInputEventHolder*>        ActionInputEventHolderArray;                       // 0x0498(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class FString, struct FTslWidgetState>   WidgetStateMap;                                    // 0x04A8(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class FString>                         UseMouseWidgetStack;                               // 0x04F8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UUserWidget*                            MainUMGHud;                                        // 0x0508(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BindActionKeyDelegateEvent(class FName ActionName, EInputEvent InputEvent, TDelegate<void()> ActionKeyDelegate);
	void DestroyAllWidgets();
	class UUserWidget* GetMainUMGHud();
	void HidePopupDialog(const class FString& PopupWidgetName);
	bool HideWidgetByEscape();
	void ShowPopupDialog(const class FString& PopupWidgetName, EPopupStyle PopupStyle, const class FText& Message, const TDelegate<void(EPopupButtonID ButtonID)>& PressedDelegate);
	void UnbindActionKeyDelegateEvent(class FName ActionName, EInputEvent InputEvent);
	void WidgetCreate(const class FString& WidgetName, const struct FTslWidgetConfig& Config);
	void WidgetShow(const class FString& WidgetName, EWidgetShowType ShowType, class UObject* OptionalParam);
	void WidgetToggle(const class FString& WidgetName);

	class UUserWidget* GetWidget(const class FString& WidgetName) const;
	bool IsWidgetShow(const class FString& WidgetName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslBaseHUD">();
	}
	static class ATslBaseHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslBaseHUD>();
	}
};
static_assert(alignof(ATslBaseHUD) == 0x000008, "Wrong alignment on ATslBaseHUD");
static_assert(sizeof(ATslBaseHUD) == 0x000510, "Wrong size on ATslBaseHUD");
static_assert(offsetof(ATslBaseHUD, MainUMGHudClass) == 0x000488, "Member 'ATslBaseHUD::MainUMGHudClass' has a wrong offset!");
static_assert(offsetof(ATslBaseHUD, ActionInputEventHolderArray) == 0x000498, "Member 'ATslBaseHUD::ActionInputEventHolderArray' has a wrong offset!");
static_assert(offsetof(ATslBaseHUD, WidgetStateMap) == 0x0004A8, "Member 'ATslBaseHUD::WidgetStateMap' has a wrong offset!");
static_assert(offsetof(ATslBaseHUD, UseMouseWidgetStack) == 0x0004F8, "Member 'ATslBaseHUD::UseMouseWidgetStack' has a wrong offset!");
static_assert(offsetof(ATslBaseHUD, MainUMGHud) == 0x000508, "Member 'ATslBaseHUD::MainUMGHud' has a wrong offset!");

// Class TslGame.HighlightSession
// 0x0070 (0x0098 - 0x0028)
class UHighlightSession final : public UObject
{
public:
	struct FHighlightRecordConfig                 Config_Kill;                                       // 0x0028(0x000C)(Config, NativeAccessSpecifierPrivate)
	struct FHighlightRecordConfig                 Config_KillGroggy;                                 // 0x0034(0x000C)(Config, NativeAccessSpecifierPrivate)
	struct FHighlightRecordConfig                 Config_Die;                                        // 0x0040(0x000C)(Config, NativeAccessSpecifierPrivate)
	struct FHighlightRecordConfig                 Config_DieGroggy;                                  // 0x004C(0x000C)(Config, NativeAccessSpecifierPrivate)
	struct FHighlightRecordConfig                 Config_EndMatch;                                   // 0x0058(0x000C)(Config, NativeAccessSpecifierPrivate)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ATslHUD*                                TslHUD;                                            // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x28];                                      // 0x0070(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Die(bool bGroggy);
	void FinishRecord();
	void KillOtherPlayer(bool bGroggy);
	void MatchEnded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HighlightSession">();
	}
	static class UHighlightSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHighlightSession>();
	}
};
static_assert(alignof(UHighlightSession) == 0x000008, "Wrong alignment on UHighlightSession");
static_assert(sizeof(UHighlightSession) == 0x000098, "Wrong size on UHighlightSession");
static_assert(offsetof(UHighlightSession, Config_Kill) == 0x000028, "Member 'UHighlightSession::Config_Kill' has a wrong offset!");
static_assert(offsetof(UHighlightSession, Config_KillGroggy) == 0x000034, "Member 'UHighlightSession::Config_KillGroggy' has a wrong offset!");
static_assert(offsetof(UHighlightSession, Config_Die) == 0x000040, "Member 'UHighlightSession::Config_Die' has a wrong offset!");
static_assert(offsetof(UHighlightSession, Config_DieGroggy) == 0x00004C, "Member 'UHighlightSession::Config_DieGroggy' has a wrong offset!");
static_assert(offsetof(UHighlightSession, Config_EndMatch) == 0x000058, "Member 'UHighlightSession::Config_EndMatch' has a wrong offset!");
static_assert(offsetof(UHighlightSession, TslHUD) == 0x000068, "Member 'UHighlightSession::TslHUD' has a wrong offset!");

// Class TslGame.WeaponClone
// 0x0018 (0x0040 - 0x0028)
class UWeaponClone final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ATslWeapon*                             ClonedWeapon;                                      // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Update();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponClone">();
	}
	static class UWeaponClone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponClone>();
	}
};
static_assert(alignof(UWeaponClone) == 0x000008, "Wrong alignment on UWeaponClone");
static_assert(sizeof(UWeaponClone) == 0x000040, "Wrong size on UWeaponClone");
static_assert(offsetof(UWeaponClone, ClonedWeapon) == 0x000038, "Member 'UWeaponClone::ClonedWeapon' has a wrong offset!");

// Class TslGame.AirborneEjectionArea
// 0x0010 (0x03B0 - 0x03A0)
class AAirborneEjectionArea final : public AActor
{
public:
	class USphereComponent*                       SphereComponent;                                   // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Radius;                                            // 0x03A8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3AC[0x4];                                      // 0x03AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AirborneEjectionArea">();
	}
	static class AAirborneEjectionArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAirborneEjectionArea>();
	}
};
static_assert(alignof(AAirborneEjectionArea) == 0x000008, "Wrong alignment on AAirborneEjectionArea");
static_assert(sizeof(AAirborneEjectionArea) == 0x0003B0, "Wrong size on AAirborneEjectionArea");
static_assert(offsetof(AAirborneEjectionArea, SphereComponent) == 0x0003A0, "Member 'AAirborneEjectionArea::SphereComponent' has a wrong offset!");
static_assert(offsetof(AAirborneEjectionArea, Radius) == 0x0003A8, "Member 'AAirborneEjectionArea::Radius' has a wrong offset!");

// Class TslGame.DroppedItemActorComponent
// 0x0020 (0x02A0 - 0x0280)
class UDroppedItemActorComponent final : public UInteractionComponent
{
public:
	uint8                                         Pad_280[0x20];                                     // 0x0280(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AllowInteractDelegate(const class ATslCharacter* OtherCharacter);
	void OnInteractDelegate(class ATslCharacter* OtherCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DroppedItemActorComponent">();
	}
	static class UDroppedItemActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDroppedItemActorComponent>();
	}
};
static_assert(alignof(UDroppedItemActorComponent) == 0x000008, "Wrong alignment on UDroppedItemActorComponent");
static_assert(sizeof(UDroppedItemActorComponent) == 0x0002A0, "Wrong size on UDroppedItemActorComponent");

// Class TslGame.AnimNotify_CharacterAnimationNotify
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_CharacterAnimationNotify final : public UAnimNotify
{
public:
	class FName                                   NotifyName;                                        // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_CharacterAnimationNotify">();
	}
	static class UAnimNotify_CharacterAnimationNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_CharacterAnimationNotify>();
	}
};
static_assert(alignof(UAnimNotify_CharacterAnimationNotify) == 0x000008, "Wrong alignment on UAnimNotify_CharacterAnimationNotify");
static_assert(sizeof(UAnimNotify_CharacterAnimationNotify) == 0x000040, "Wrong size on UAnimNotify_CharacterAnimationNotify");
static_assert(offsetof(UAnimNotify_CharacterAnimationNotify, NotifyName) == 0x000038, "Member 'UAnimNotify_CharacterAnimationNotify::NotifyName' has a wrong offset!");

// Class TslGame.OnceInteractionComponent
// 0x0010 (0x0290 - 0x0280)
class UOnceInteractionComponent final : public UInteractionComponent
{
public:
	TArray<class FName>                           CharacterHistory;                                  // 0x0280(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnceInteractionComponent">();
	}
	static class UOnceInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnceInteractionComponent>();
	}
};
static_assert(alignof(UOnceInteractionComponent) == 0x000008, "Wrong alignment on UOnceInteractionComponent");
static_assert(sizeof(UOnceInteractionComponent) == 0x000290, "Wrong size on UOnceInteractionComponent");
static_assert(offsetof(UOnceInteractionComponent, CharacterHistory) == 0x000280, "Member 'UOnceInteractionComponent::CharacterHistory' has a wrong offset!");

// Class TslGame.AnimNotify_UnarmedAttack
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_UnarmedAttack final : public UAnimNotify
{
public:
	class FName                                   NotifyName;                                        // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_UnarmedAttack">();
	}
	static class UAnimNotify_UnarmedAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_UnarmedAttack>();
	}
};
static_assert(alignof(UAnimNotify_UnarmedAttack) == 0x000008, "Wrong alignment on UAnimNotify_UnarmedAttack");
static_assert(sizeof(UAnimNotify_UnarmedAttack) == 0x000040, "Wrong size on UAnimNotify_UnarmedAttack");
static_assert(offsetof(UAnimNotify_UnarmedAttack, NotifyName) == 0x000038, "Member 'UAnimNotify_UnarmedAttack::NotifyName' has a wrong offset!");

// Class TslGame.InteractorComponent
// 0x0000 (0x00F8 - 0x00F8)
class UInteractorComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractorComponent">();
	}
	static class UInteractorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractorComponent>();
	}
};
static_assert(alignof(UInteractorComponent) == 0x000008, "Wrong alignment on UInteractorComponent");
static_assert(sizeof(UInteractorComponent) == 0x0000F8, "Wrong size on UInteractorComponent");

// Class TslGame.AnimNotify_WeaponAnimationNotify
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_WeaponAnimationNotify final : public UAnimNotify
{
public:
	class FName                                   NotifyName;                                        // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_WeaponAnimationNotify">();
	}
	static class UAnimNotify_WeaponAnimationNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_WeaponAnimationNotify>();
	}
};
static_assert(alignof(UAnimNotify_WeaponAnimationNotify) == 0x000008, "Wrong alignment on UAnimNotify_WeaponAnimationNotify");
static_assert(sizeof(UAnimNotify_WeaponAnimationNotify) == 0x000040, "Wrong size on UAnimNotify_WeaponAnimationNotify");
static_assert(offsetof(UAnimNotify_WeaponAnimationNotify, NotifyName) == 0x000038, "Member 'UAnimNotify_WeaponAnimationNotify::NotifyName' has a wrong offset!");

// Class TslGame.Item
// 0x0160 (0x0188 - 0x0028)
class UItem : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bStackable : 1;                                    // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUsable : 1;                                       // 0x0038(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableSpawnInGame : 1;                           // 0x0038(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StackCount;                                        // 0x003C(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ItemName;                                          // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ItemCategory;                                      // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ItemDetailedName;                                  // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   ItemDescription;                                   // 0x0088(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         ItemMaxInteractableDistance;                       // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackCountMax;                                     // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpacePerItem;                                      // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UStaticMesh>             DroppedMesh;                                       // 0x00B0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DroppedMeshScale;                                  // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture>                Icon;                                              // 0x00D8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                ToolTipIcon;                                       // 0x00F8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IconSizeRatio;                                     // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ToolTipIconSizeRatio;                              // 0x011C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          DropSoundAk;                                       // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          PickUpSoundAk;                                     // 0x0128(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          InventoryPutSoundAk;                               // 0x0130(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortPriority;                                      // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LobbyItemID;                                       // 0x013C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLobbyItemDesc                         LobbyItemDesc;                                     // 0x0140(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EItemCategory                                 Category;                                          // 0x0170(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SubCategory;                                       // 0x0178(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsToy;                                            // 0x0180(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UTexture* GetIconTexture();
	bool PickUpBy(class ATslCharacter* Character, class FName TargetContainer, const class FString& Options);
	bool UseBy(class ATslCharacter* Character);

	bool IsAttachment() const;
	bool IsCastableItem() const;
	bool IsEquipable() const;
	bool IsPackageItem() const;
	bool IsToy() const;
	bool IsWeapon() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Item">();
	}
	static class UItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItem>();
	}
};
static_assert(alignof(UItem) == 0x000008, "Wrong alignment on UItem");
static_assert(sizeof(UItem) == 0x000188, "Wrong size on UItem");
static_assert(offsetof(UItem, StackCount) == 0x00003C, "Member 'UItem::StackCount' has a wrong offset!");
static_assert(offsetof(UItem, ItemName) == 0x000040, "Member 'UItem::ItemName' has a wrong offset!");
static_assert(offsetof(UItem, ItemCategory) == 0x000058, "Member 'UItem::ItemCategory' has a wrong offset!");
static_assert(offsetof(UItem, ItemDetailedName) == 0x000070, "Member 'UItem::ItemDetailedName' has a wrong offset!");
static_assert(offsetof(UItem, ItemDescription) == 0x000088, "Member 'UItem::ItemDescription' has a wrong offset!");
static_assert(offsetof(UItem, ItemMaxInteractableDistance) == 0x0000A0, "Member 'UItem::ItemMaxInteractableDistance' has a wrong offset!");
static_assert(offsetof(UItem, StackCountMax) == 0x0000A4, "Member 'UItem::StackCountMax' has a wrong offset!");
static_assert(offsetof(UItem, SpacePerItem) == 0x0000A8, "Member 'UItem::SpacePerItem' has a wrong offset!");
static_assert(offsetof(UItem, DroppedMesh) == 0x0000B0, "Member 'UItem::DroppedMesh' has a wrong offset!");
static_assert(offsetof(UItem, DroppedMeshScale) == 0x0000D0, "Member 'UItem::DroppedMeshScale' has a wrong offset!");
static_assert(offsetof(UItem, Icon) == 0x0000D8, "Member 'UItem::Icon' has a wrong offset!");
static_assert(offsetof(UItem, ToolTipIcon) == 0x0000F8, "Member 'UItem::ToolTipIcon' has a wrong offset!");
static_assert(offsetof(UItem, IconSizeRatio) == 0x000118, "Member 'UItem::IconSizeRatio' has a wrong offset!");
static_assert(offsetof(UItem, ToolTipIconSizeRatio) == 0x00011C, "Member 'UItem::ToolTipIconSizeRatio' has a wrong offset!");
static_assert(offsetof(UItem, DropSoundAk) == 0x000120, "Member 'UItem::DropSoundAk' has a wrong offset!");
static_assert(offsetof(UItem, PickUpSoundAk) == 0x000128, "Member 'UItem::PickUpSoundAk' has a wrong offset!");
static_assert(offsetof(UItem, InventoryPutSoundAk) == 0x000130, "Member 'UItem::InventoryPutSoundAk' has a wrong offset!");
static_assert(offsetof(UItem, SortPriority) == 0x000138, "Member 'UItem::SortPriority' has a wrong offset!");
static_assert(offsetof(UItem, LobbyItemID) == 0x00013C, "Member 'UItem::LobbyItemID' has a wrong offset!");
static_assert(offsetof(UItem, LobbyItemDesc) == 0x000140, "Member 'UItem::LobbyItemDesc' has a wrong offset!");
static_assert(offsetof(UItem, Category) == 0x000170, "Member 'UItem::Category' has a wrong offset!");
static_assert(offsetof(UItem, SubCategory) == 0x000178, "Member 'UItem::SubCategory' has a wrong offset!");
static_assert(offsetof(UItem, bIsToy) == 0x000180, "Member 'UItem::bIsToy' has a wrong offset!");

// Class TslGame.EquipableItem
// 0x00B8 (0x0240 - 0x0188)
class UEquipableItem : public UItem
{
public:
	EEquipSlotID                                  EquipSlotID;                                       // 0x0188(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x3];                                      // 0x0189(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpaceExtension;                                    // 0x018C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageReductionRate;                               // 0x0190(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurabilityMax;                                     // 0x0194(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DestroyByDurability;                               // 0x0198(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_199[0x3];                                      // 0x0199(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Durability;                                        // 0x019C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDurabilityConsumeType                        DurabilityConsumeType;                             // 0x01A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCustomizableObjectIdentifier          CustomizableObjectIdentifierForMale;               // 0x01A8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCustomizableObjectIdentifier          CustomizableObjectIdentifierForFemale;             // 0x01D8(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          EquipedSoundAk;                                    // 0x0208(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEquipableItemSoundGroup                      SoundGroup;                                        // 0x0210(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEquipableItemSoundType                       SoundType;                                         // 0x0211(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanZombieEquip;                                   // 0x0212(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUnequipable;                                    // 0x0213(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_214[0x4];                                      // 0x0214(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture>                HudDisplayEquipIcon;                               // 0x0218(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Net, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanEquipTo(class ATslCharacter* Character);
	bool EquipBy(class ATslCharacter* Character, const struct FEquipPosition& Position);
	void UnequipBy(class ATslCharacter* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquipableItem">();
	}
	static class UEquipableItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEquipableItem>();
	}
};
static_assert(alignof(UEquipableItem) == 0x000008, "Wrong alignment on UEquipableItem");
static_assert(sizeof(UEquipableItem) == 0x000240, "Wrong size on UEquipableItem");
static_assert(offsetof(UEquipableItem, EquipSlotID) == 0x000188, "Member 'UEquipableItem::EquipSlotID' has a wrong offset!");
static_assert(offsetof(UEquipableItem, SpaceExtension) == 0x00018C, "Member 'UEquipableItem::SpaceExtension' has a wrong offset!");
static_assert(offsetof(UEquipableItem, DamageReductionRate) == 0x000190, "Member 'UEquipableItem::DamageReductionRate' has a wrong offset!");
static_assert(offsetof(UEquipableItem, DurabilityMax) == 0x000194, "Member 'UEquipableItem::DurabilityMax' has a wrong offset!");
static_assert(offsetof(UEquipableItem, DestroyByDurability) == 0x000198, "Member 'UEquipableItem::DestroyByDurability' has a wrong offset!");
static_assert(offsetof(UEquipableItem, Durability) == 0x00019C, "Member 'UEquipableItem::Durability' has a wrong offset!");
static_assert(offsetof(UEquipableItem, DurabilityConsumeType) == 0x0001A0, "Member 'UEquipableItem::DurabilityConsumeType' has a wrong offset!");
static_assert(offsetof(UEquipableItem, CustomizableObjectIdentifierForMale) == 0x0001A8, "Member 'UEquipableItem::CustomizableObjectIdentifierForMale' has a wrong offset!");
static_assert(offsetof(UEquipableItem, CustomizableObjectIdentifierForFemale) == 0x0001D8, "Member 'UEquipableItem::CustomizableObjectIdentifierForFemale' has a wrong offset!");
static_assert(offsetof(UEquipableItem, EquipedSoundAk) == 0x000208, "Member 'UEquipableItem::EquipedSoundAk' has a wrong offset!");
static_assert(offsetof(UEquipableItem, SoundGroup) == 0x000210, "Member 'UEquipableItem::SoundGroup' has a wrong offset!");
static_assert(offsetof(UEquipableItem, SoundType) == 0x000211, "Member 'UEquipableItem::SoundType' has a wrong offset!");
static_assert(offsetof(UEquipableItem, bCanZombieEquip) == 0x000212, "Member 'UEquipableItem::bCanZombieEquip' has a wrong offset!");
static_assert(offsetof(UEquipableItem, bIsUnequipable) == 0x000213, "Member 'UEquipableItem::bIsUnequipable' has a wrong offset!");
static_assert(offsetof(UEquipableItem, HudDisplayEquipIcon) == 0x000218, "Member 'UEquipableItem::HudDisplayEquipIcon' has a wrong offset!");

// Class TslGame.ParachuteItem
// 0x0008 (0x0248 - 0x0240)
class UParachuteItem final : public UEquipableItem
{
public:
	TSubclassOf<class AParachuteVehicle>          ParachuteType;                                     // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParachuteItem">();
	}
	static class UParachuteItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParachuteItem>();
	}
};
static_assert(alignof(UParachuteItem) == 0x000008, "Wrong alignment on UParachuteItem");
static_assert(sizeof(UParachuteItem) == 0x000248, "Wrong size on UParachuteItem");
static_assert(offsetof(UParachuteItem, ParachuteType) == 0x000240, "Member 'UParachuteItem::ParachuteType' has a wrong offset!");

// Class TslGame.AsyncStaticMeshComponent
// 0x0070 (0x0880 - 0x0810)
class UAsyncStaticMeshComponent final : public UStaticMeshComponent
{
public:
	UMulticastDelegateProperty_                   OnStaticMeshLoaded;                                // 0x0808(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             StaticMeshAsset;                                   // 0x0818(0x0020)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_838[0x8];                                      // 0x0838(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            ErrorStaticMesh;                                   // 0x0840(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ClientCollisionProfileNameOverride;                // 0x0848(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UStaticMesh>             PendingStaticMeshAsset;                            // 0x0850(0x0020)(Transient, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_870[0x10];                                     // 0x0870(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearStaticMeshAsset();
	void SetStaticMeshAsset(TSoftObjectPtr<class UStaticMesh> Asset);

	TSoftObjectPtr<class UStaticMesh> GetStaticMeshAsset() const;
	bool IsSameMesh(const TSoftObjectPtr<class UStaticMesh>& Asset) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncStaticMeshComponent">();
	}
	static class UAsyncStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncStaticMeshComponent>();
	}
};
static_assert(alignof(UAsyncStaticMeshComponent) == 0x000010, "Wrong alignment on UAsyncStaticMeshComponent");
static_assert(sizeof(UAsyncStaticMeshComponent) == 0x000880, "Wrong size on UAsyncStaticMeshComponent");
static_assert(offsetof(UAsyncStaticMeshComponent, OnStaticMeshLoaded) == 0x000808, "Member 'UAsyncStaticMeshComponent::OnStaticMeshLoaded' has a wrong offset!");
static_assert(offsetof(UAsyncStaticMeshComponent, StaticMeshAsset) == 0x000818, "Member 'UAsyncStaticMeshComponent::StaticMeshAsset' has a wrong offset!");
static_assert(offsetof(UAsyncStaticMeshComponent, ErrorStaticMesh) == 0x000840, "Member 'UAsyncStaticMeshComponent::ErrorStaticMesh' has a wrong offset!");
static_assert(offsetof(UAsyncStaticMeshComponent, ClientCollisionProfileNameOverride) == 0x000848, "Member 'UAsyncStaticMeshComponent::ClientCollisionProfileNameOverride' has a wrong offset!");
static_assert(offsetof(UAsyncStaticMeshComponent, PendingStaticMeshAsset) == 0x000850, "Member 'UAsyncStaticMeshComponent::PendingStaticMeshAsset' has a wrong offset!");

// Class TslGame.BTDecorator_HasLoSTo
// 0x0028 (0x0090 - 0x0068)
class UBTDecorator_HasLoSTo final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 EnemyKey;                                          // 0x0068(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_HasLoSTo">();
	}
	static class UBTDecorator_HasLoSTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_HasLoSTo>();
	}
};
static_assert(alignof(UBTDecorator_HasLoSTo) == 0x000008, "Wrong alignment on UBTDecorator_HasLoSTo");
static_assert(sizeof(UBTDecorator_HasLoSTo) == 0x000090, "Wrong size on UBTDecorator_HasLoSTo");
static_assert(offsetof(UBTDecorator_HasLoSTo, EnemyKey) == 0x000068, "Member 'UBTDecorator_HasLoSTo::EnemyKey' has a wrong offset!");

// Class TslGame.BTTask_FindPointNearEnemy
// 0x0000 (0x0098 - 0x0098)
class UBTTask_FindPointNearEnemy final : public UBTTask_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_FindPointNearEnemy">();
	}
	static class UBTTask_FindPointNearEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_FindPointNearEnemy>();
	}
};
static_assert(alignof(UBTTask_FindPointNearEnemy) == 0x000008, "Wrong alignment on UBTTask_FindPointNearEnemy");
static_assert(sizeof(UBTTask_FindPointNearEnemy) == 0x000098, "Wrong size on UBTTask_FindPointNearEnemy");

// Class TslGame.TslBuff
// 0x0060 (0x0400 - 0x03A0)
class ATslBuff : public AActor
{
public:
	class FName                                   OverlapId;                                         // 0x03A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBuffOverlapSolveMethod                       OverlapSolveMethod;                                // 0x03A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A9[0x3];                                      // 0x03A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BuffTickInterval;                                  // 0x03AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BuffTickFirstDelay;                                // 0x03B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BuffDuration;                                      // 0x03B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Infinite;                                          // 0x03B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B9[0x7];                                      // 0x03B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachSocket;                                      // 0x03C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ATslServerParticle>         AttachServerPaticleClass;                          // 0x03C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsDebuff;                                          // 0x03D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D1[0x7];                                      // 0x03D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBuffComponet*                          OwnerBuffComponent;                                // 0x03D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E0[0x10];                                     // 0x03E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ATslServerParticle*                     AttachedServerPaticle;                             // 0x03F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F8[0x8];                                      // 0x03F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanApplyBuff();
	void StartBuffBlueprint();
	void StopBuffBlueprint(bool bCanceled);
	void TickBuff();

	struct FAttackId GetAttackId() const;
	class APawn* GetOwnerPawn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslBuff">();
	}
	static class ATslBuff* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslBuff>();
	}
};
static_assert(alignof(ATslBuff) == 0x000008, "Wrong alignment on ATslBuff");
static_assert(sizeof(ATslBuff) == 0x000400, "Wrong size on ATslBuff");
static_assert(offsetof(ATslBuff, OverlapId) == 0x0003A0, "Member 'ATslBuff::OverlapId' has a wrong offset!");
static_assert(offsetof(ATslBuff, OverlapSolveMethod) == 0x0003A8, "Member 'ATslBuff::OverlapSolveMethod' has a wrong offset!");
static_assert(offsetof(ATslBuff, BuffTickInterval) == 0x0003AC, "Member 'ATslBuff::BuffTickInterval' has a wrong offset!");
static_assert(offsetof(ATslBuff, BuffTickFirstDelay) == 0x0003B0, "Member 'ATslBuff::BuffTickFirstDelay' has a wrong offset!");
static_assert(offsetof(ATslBuff, BuffDuration) == 0x0003B4, "Member 'ATslBuff::BuffDuration' has a wrong offset!");
static_assert(offsetof(ATslBuff, Infinite) == 0x0003B8, "Member 'ATslBuff::Infinite' has a wrong offset!");
static_assert(offsetof(ATslBuff, AttachSocket) == 0x0003C0, "Member 'ATslBuff::AttachSocket' has a wrong offset!");
static_assert(offsetof(ATslBuff, AttachServerPaticleClass) == 0x0003C8, "Member 'ATslBuff::AttachServerPaticleClass' has a wrong offset!");
static_assert(offsetof(ATslBuff, IsDebuff) == 0x0003D0, "Member 'ATslBuff::IsDebuff' has a wrong offset!");
static_assert(offsetof(ATslBuff, OwnerBuffComponent) == 0x0003D8, "Member 'ATslBuff::OwnerBuffComponent' has a wrong offset!");
static_assert(offsetof(ATslBuff, AttachedServerPaticle) == 0x0003F0, "Member 'ATslBuff::AttachedServerPaticle' has a wrong offset!");

// Class TslGame.BuffComponet
// 0x0010 (0x0108 - 0x00F8)
class UBuffComponet final : public UActorComponent
{
public:
	TArray<class ATslBuff*>                       Buffs;                                             // 0x00F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	class ATslBuff* AddBuff(TSubclassOf<class ATslBuff> TslBuffClass);
	class ATslBuff* FindBuffWithOverlapId(class FName BuffOverlapId);
	void RemoveBuff(class FName OverlapId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuffComponet">();
	}
	static class UBuffComponet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuffComponet>();
	}
};
static_assert(alignof(UBuffComponet) == 0x000008, "Wrong alignment on UBuffComponet");
static_assert(sizeof(UBuffComponet) == 0x000108, "Wrong size on UBuffComponet");
static_assert(offsetof(UBuffComponet, Buffs) == 0x0000F8, "Member 'UBuffComponet::Buffs' has a wrong offset!");

// Class TslGame.CameraSettings
// 0x0070 (0x0098 - 0x0028)
class UCameraSettings final : public UObject
{
public:
	float                                         CameraPitchMinStand;                               // 0x0028(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraPitchMaxStand;                               // 0x002C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraYawMinStand;                                 // 0x0030(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraYawMaxStand;                                 // 0x0034(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraPitchMinProne;                               // 0x0038(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraPitchMaxProne;                               // 0x003C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraYawMinProne;                                 // 0x0040(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraYawMaxProne;                                 // 0x0044(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FPSShowOnHighScopingFOV;                           // 0x0048(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TPSShowOnHighScopingFOV;                           // 0x004C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraPitchMinInVehicle;                           // 0x0050(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraPitchMaxInVehicle;                           // 0x0054(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraYawMinInVehicle;                             // 0x0058(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraYawMaxInVehicle;                             // 0x005C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HeadBoneName;                                      // 0x0060(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         HideMaterialsWhenCameraIsInHead;                   // 0x0068(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         HideMaterialsOnScopeMode;                          // 0x0078(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         HideMaterialsOnHighScopeMode;                      // 0x0088(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraSettings">();
	}
	static class UCameraSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraSettings>();
	}
};
static_assert(alignof(UCameraSettings) == 0x000008, "Wrong alignment on UCameraSettings");
static_assert(sizeof(UCameraSettings) == 0x000098, "Wrong size on UCameraSettings");
static_assert(offsetof(UCameraSettings, CameraPitchMinStand) == 0x000028, "Member 'UCameraSettings::CameraPitchMinStand' has a wrong offset!");
static_assert(offsetof(UCameraSettings, CameraPitchMaxStand) == 0x00002C, "Member 'UCameraSettings::CameraPitchMaxStand' has a wrong offset!");
static_assert(offsetof(UCameraSettings, CameraYawMinStand) == 0x000030, "Member 'UCameraSettings::CameraYawMinStand' has a wrong offset!");
static_assert(offsetof(UCameraSettings, CameraYawMaxStand) == 0x000034, "Member 'UCameraSettings::CameraYawMaxStand' has a wrong offset!");
static_assert(offsetof(UCameraSettings, CameraPitchMinProne) == 0x000038, "Member 'UCameraSettings::CameraPitchMinProne' has a wrong offset!");
static_assert(offsetof(UCameraSettings, CameraPitchMaxProne) == 0x00003C, "Member 'UCameraSettings::CameraPitchMaxProne' has a wrong offset!");
static_assert(offsetof(UCameraSettings, CameraYawMinProne) == 0x000040, "Member 'UCameraSettings::CameraYawMinProne' has a wrong offset!");
static_assert(offsetof(UCameraSettings, CameraYawMaxProne) == 0x000044, "Member 'UCameraSettings::CameraYawMaxProne' has a wrong offset!");
static_assert(offsetof(UCameraSettings, FPSShowOnHighScopingFOV) == 0x000048, "Member 'UCameraSettings::FPSShowOnHighScopingFOV' has a wrong offset!");
static_assert(offsetof(UCameraSettings, TPSShowOnHighScopingFOV) == 0x00004C, "Member 'UCameraSettings::TPSShowOnHighScopingFOV' has a wrong offset!");
static_assert(offsetof(UCameraSettings, CameraPitchMinInVehicle) == 0x000050, "Member 'UCameraSettings::CameraPitchMinInVehicle' has a wrong offset!");
static_assert(offsetof(UCameraSettings, CameraPitchMaxInVehicle) == 0x000054, "Member 'UCameraSettings::CameraPitchMaxInVehicle' has a wrong offset!");
static_assert(offsetof(UCameraSettings, CameraYawMinInVehicle) == 0x000058, "Member 'UCameraSettings::CameraYawMinInVehicle' has a wrong offset!");
static_assert(offsetof(UCameraSettings, CameraYawMaxInVehicle) == 0x00005C, "Member 'UCameraSettings::CameraYawMaxInVehicle' has a wrong offset!");
static_assert(offsetof(UCameraSettings, HeadBoneName) == 0x000060, "Member 'UCameraSettings::HeadBoneName' has a wrong offset!");
static_assert(offsetof(UCameraSettings, HideMaterialsWhenCameraIsInHead) == 0x000068, "Member 'UCameraSettings::HideMaterialsWhenCameraIsInHead' has a wrong offset!");
static_assert(offsetof(UCameraSettings, HideMaterialsOnScopeMode) == 0x000078, "Member 'UCameraSettings::HideMaterialsOnScopeMode' has a wrong offset!");
static_assert(offsetof(UCameraSettings, HideMaterialsOnHighScopeMode) == 0x000088, "Member 'UCameraSettings::HideMaterialsOnHighScopeMode' has a wrong offset!");

// Class TslGame.CastableInterface
// 0x0000 (0x0028 - 0x0028)
class ICastableInterface final : public IInterface
{
public:
	struct FCastConfig GetCastConfig() const;
	class FText GetCastFailMessage(const class ATslCharacter* Character) const;
	bool IsCastable(class ATslCharacter* Character) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CastableInterface">();
	}
	static class ICastableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICastableInterface>();
	}
};
static_assert(alignof(ICastableInterface) == 0x000008, "Wrong alignment on ICastableInterface");
static_assert(sizeof(ICastableInterface) == 0x000028, "Wrong size on ICastableInterface");

// Class TslGame.CastComponent
// 0x0028 (0x0120 - 0x00F8)
class UCastComponent final : public UActorComponent
{
public:
	TDelegate<void(class UObject* CastObject)>    OnFinishCast;                                      // 0x00F8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(class UObject* CastObject)>    OnCancelCast;                                      // 0x0108(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CancelCast();
	bool StartCast(TScriptInterface<class ICastableInterface> CastableInterface);

	ECastAnim GetCastAnim() const;
	ECastLevel GetCastLevel() const;
	class FText GetCastName() const;
	class UObject* GetCastObject() const;
	ECastPriority GetCastPriority() const;
	float GetElapsedCastTime() const;
	float GetTotalCastTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CastComponent">();
	}
	static class UCastComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCastComponent>();
	}
};
static_assert(alignof(UCastComponent) == 0x000008, "Wrong alignment on UCastComponent");
static_assert(sizeof(UCastComponent) == 0x000120, "Wrong size on UCastComponent");
static_assert(offsetof(UCastComponent, OnFinishCast) == 0x0000F8, "Member 'UCastComponent::OnFinishCast' has a wrong offset!");
static_assert(offsetof(UCastComponent, OnCancelCast) == 0x000108, "Member 'UCastComponent::OnCancelCast' has a wrong offset!");

// Class TslGame.CharacterBreathComponent
// 0x0098 (0x0190 - 0x00F8)
class UCharacterBreathComponent final : public UActorComponent
{
public:
	uint8                                         Pad_F8[0x10];                                      // 0x00F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Breath;                                            // 0x0108(0x0004)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BreathMax;                                         // 0x010C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                BreathPointOffsetAtStand;                          // 0x0110(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                BreathPointOffsetAtCrouch;                         // 0x011C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                BreathPointOffsetAtProne;                          // 0x0128(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                BreathPointOffsetAtGroggy;                         // 0x0134(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	TSubclassOf<class ACharacterBreathBuff>       RestorationBuff;                                   // 0x0140(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ACharacterBreathBuff>       ApneaDebuff;                                       // 0x0148(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ACharacterBreathBuff>       HoldBreathDebuff;                                  // 0x0150(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinimumBreathStartHoldingBreath;                   // 0x0158(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACharacterBreathBuff>       SprintDebuff;                                      // 0x0160(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinimumBreathStartSprinting;                       // 0x0168(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_16C[0x24];                                     // 0x016C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBreath(float Value);
	void OnRep_Breath(float LastBreath);

	bool CanStartHoldingBreath() const;
	bool CanStartSprinting() const;
	float GetBreath() const;
	float GetBreathMax() const;
	float GetBreathRatio() const;
	bool IsConsuming() const;
	bool IsInApnea() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterBreathComponent">();
	}
	static class UCharacterBreathComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterBreathComponent>();
	}
};
static_assert(alignof(UCharacterBreathComponent) == 0x000008, "Wrong alignment on UCharacterBreathComponent");
static_assert(sizeof(UCharacterBreathComponent) == 0x000190, "Wrong size on UCharacterBreathComponent");
static_assert(offsetof(UCharacterBreathComponent, Breath) == 0x000108, "Member 'UCharacterBreathComponent::Breath' has a wrong offset!");
static_assert(offsetof(UCharacterBreathComponent, BreathMax) == 0x00010C, "Member 'UCharacterBreathComponent::BreathMax' has a wrong offset!");
static_assert(offsetof(UCharacterBreathComponent, BreathPointOffsetAtStand) == 0x000110, "Member 'UCharacterBreathComponent::BreathPointOffsetAtStand' has a wrong offset!");
static_assert(offsetof(UCharacterBreathComponent, BreathPointOffsetAtCrouch) == 0x00011C, "Member 'UCharacterBreathComponent::BreathPointOffsetAtCrouch' has a wrong offset!");
static_assert(offsetof(UCharacterBreathComponent, BreathPointOffsetAtProne) == 0x000128, "Member 'UCharacterBreathComponent::BreathPointOffsetAtProne' has a wrong offset!");
static_assert(offsetof(UCharacterBreathComponent, BreathPointOffsetAtGroggy) == 0x000134, "Member 'UCharacterBreathComponent::BreathPointOffsetAtGroggy' has a wrong offset!");
static_assert(offsetof(UCharacterBreathComponent, RestorationBuff) == 0x000140, "Member 'UCharacterBreathComponent::RestorationBuff' has a wrong offset!");
static_assert(offsetof(UCharacterBreathComponent, ApneaDebuff) == 0x000148, "Member 'UCharacterBreathComponent::ApneaDebuff' has a wrong offset!");
static_assert(offsetof(UCharacterBreathComponent, HoldBreathDebuff) == 0x000150, "Member 'UCharacterBreathComponent::HoldBreathDebuff' has a wrong offset!");
static_assert(offsetof(UCharacterBreathComponent, MinimumBreathStartHoldingBreath) == 0x000158, "Member 'UCharacterBreathComponent::MinimumBreathStartHoldingBreath' has a wrong offset!");
static_assert(offsetof(UCharacterBreathComponent, SprintDebuff) == 0x000160, "Member 'UCharacterBreathComponent::SprintDebuff' has a wrong offset!");
static_assert(offsetof(UCharacterBreathComponent, MinimumBreathStartSprinting) == 0x000168, "Member 'UCharacterBreathComponent::MinimumBreathStartSprinting' has a wrong offset!");

// Class TslGame.CharacterStudio
// 0x0090 (0x0430 - 0x03A0)
class ACharacterStudio : public AActor
{
public:
	class USpringArmComponent*                    SpringArmComponent;                                // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraComponent*                       CameraComponent;                                   // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneCaptureComponent2D*               SceneCaptureComponent;                             // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 TextureTarget;                                     // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseDynamicResolution;                             // 0x03C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C1[0x3];                                      // 0x03C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxViewDistance;                                   // 0x03C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ATslCharacterProxy>         MaleCharacterProxyClass;                           // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ATslCharacterProxy>         FemaleCharacterProxyClass;                         // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             CharacterInitialTransform;                         // 0x03E0(0x0030)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	class ATslCharacterProxy*                     CharacterProxy;                                    // 0x0410(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        CharacterRotationPivot;                            // 0x0418(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               SceneCaptureMaterial;                              // 0x0420(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddYaw(float Yaw);
	class ATslCharacter* GetCharacter();
	class UMaterialInstanceDynamic* GetSceneCaptureMaterial();
	void SetCharacter(class ATslCharacter* Character);
	void SetSceneCaptureMaterial(class UMaterialInstanceDynamic* Mid);
	void Update();

	bool IsCharacterValid() const;
	bool IsUsingDynamicResolution() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterStudio">();
	}
	static class ACharacterStudio* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharacterStudio>();
	}
};
static_assert(alignof(ACharacterStudio) == 0x000010, "Wrong alignment on ACharacterStudio");
static_assert(sizeof(ACharacterStudio) == 0x000430, "Wrong size on ACharacterStudio");
static_assert(offsetof(ACharacterStudio, SpringArmComponent) == 0x0003A0, "Member 'ACharacterStudio::SpringArmComponent' has a wrong offset!");
static_assert(offsetof(ACharacterStudio, CameraComponent) == 0x0003A8, "Member 'ACharacterStudio::CameraComponent' has a wrong offset!");
static_assert(offsetof(ACharacterStudio, SceneCaptureComponent) == 0x0003B0, "Member 'ACharacterStudio::SceneCaptureComponent' has a wrong offset!");
static_assert(offsetof(ACharacterStudio, TextureTarget) == 0x0003B8, "Member 'ACharacterStudio::TextureTarget' has a wrong offset!");
static_assert(offsetof(ACharacterStudio, bUseDynamicResolution) == 0x0003C0, "Member 'ACharacterStudio::bUseDynamicResolution' has a wrong offset!");
static_assert(offsetof(ACharacterStudio, MaxViewDistance) == 0x0003C4, "Member 'ACharacterStudio::MaxViewDistance' has a wrong offset!");
static_assert(offsetof(ACharacterStudio, MaleCharacterProxyClass) == 0x0003C8, "Member 'ACharacterStudio::MaleCharacterProxyClass' has a wrong offset!");
static_assert(offsetof(ACharacterStudio, FemaleCharacterProxyClass) == 0x0003D0, "Member 'ACharacterStudio::FemaleCharacterProxyClass' has a wrong offset!");
static_assert(offsetof(ACharacterStudio, CharacterInitialTransform) == 0x0003E0, "Member 'ACharacterStudio::CharacterInitialTransform' has a wrong offset!");
static_assert(offsetof(ACharacterStudio, CharacterProxy) == 0x000410, "Member 'ACharacterStudio::CharacterProxy' has a wrong offset!");
static_assert(offsetof(ACharacterStudio, CharacterRotationPivot) == 0x000418, "Member 'ACharacterStudio::CharacterRotationPivot' has a wrong offset!");
static_assert(offsetof(ACharacterStudio, SceneCaptureMaterial) == 0x000420, "Member 'ACharacterStudio::SceneCaptureMaterial' has a wrong offset!");

// Class TslGame.CoherentCommonBinder
// 0x0078 (0x00A0 - 0x0028)
class UCoherentCommonBinder : public UObject
{
public:
	uint8                                         Pad_28[0x60];                                      // 0x0028(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DefaultLobbyUrl;                                   // 0x0088(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindDelegate();
	void BindUI();
	void OnWebPageOnPlatformFailed();
	void Test();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoherentCommonBinder">();
	}
	static class UCoherentCommonBinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoherentCommonBinder>();
	}
};
static_assert(alignof(UCoherentCommonBinder) == 0x000008, "Wrong alignment on UCoherentCommonBinder");
static_assert(sizeof(UCoherentCommonBinder) == 0x0000A0, "Wrong size on UCoherentCommonBinder");
static_assert(offsetof(UCoherentCommonBinder, DefaultLobbyUrl) == 0x000088, "Member 'UCoherentCommonBinder::DefaultLobbyUrl' has a wrong offset!");

// Class TslGame.CoherentWidgetBinder
// 0x0010 (0x00B0 - 0x00A0)
class UCoherentWidgetBinder : public UCoherentCommonBinder
{
public:
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoherentWidgetBinder">();
	}
	static class UCoherentWidgetBinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoherentWidgetBinder>();
	}
};
static_assert(alignof(UCoherentWidgetBinder) == 0x000008, "Wrong alignment on UCoherentWidgetBinder");
static_assert(sizeof(UCoherentWidgetBinder) == 0x0000B0, "Wrong size on UCoherentWidgetBinder");

// Class TslGame.LobbyCoherentWidgetBinder
// 0x0000 (0x00B0 - 0x00B0)
class ULobbyCoherentWidgetBinder final : public UCoherentWidgetBinder
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyCoherentWidgetBinder">();
	}
	static class ULobbyCoherentWidgetBinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyCoherentWidgetBinder>();
	}
};
static_assert(alignof(ULobbyCoherentWidgetBinder) == 0x000008, "Wrong alignment on ULobbyCoherentWidgetBinder");
static_assert(sizeof(ULobbyCoherentWidgetBinder) == 0x0000B0, "Wrong size on ULobbyCoherentWidgetBinder");

// Class TslGame.TslBasePlayerController
// 0x0000 (0x06D0 - 0x06D0)
class ATslBasePlayerController : public APlayerController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslBasePlayerController">();
	}
	static class ATslBasePlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslBasePlayerController>();
	}
};
static_assert(alignof(ATslBasePlayerController) == 0x000008, "Wrong alignment on ATslBasePlayerController");
static_assert(sizeof(ATslBasePlayerController) == 0x0006D0, "Wrong size on ATslBasePlayerController");

// Class TslGame.TslPlayerController
// 0x0328 (0x09F8 - 0x06D0)
class ATslPlayerController : public ATslBasePlayerController
{
public:
	uint8                                         Pad_6D0[0x28];                                     // 0x06D0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         BitPad_6F8_0 : 1;                                  // 0x06F8(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bIsSpectated : 1;                                  // 0x06F8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_6F9[0x3];                                      // 0x06F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CameraPeekLeftMove;                                // 0x06FC(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                CameraPeekRightMove;                               // 0x0708(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_714[0x10];                                     // 0x0714(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	ECameraViewBehaviour                          CameraViewBehaviour;                               // 0x0724(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_725[0x23];                                     // 0x0725(0x0023)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector_NetQuantizeNormal              SpectatorAccumViewRotation;                        // 0x0748(0x000C)(Net, Transient, Protected, NativeAccessSpecifierProtected)
	EObserverAuthorityType                        ObserverAuthorityType;                             // 0x0754(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_755[0x13];                                     // 0x0755(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorComponent*                        InteractionTargetComponent;                        // 0x0768(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATslCharacter*                          SpectatorViewCharacter;                            // 0x0770(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_778[0x10];                                     // 0x0778(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class ATslAchievement*                        Achievement;                                       // 0x0788(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_790[0x10];                                     // 0x0790(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshComponent*                         SpectatorScopeMesh;                                // 0x07A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7A8[0x58];                                     // 0x07A8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNearClippingLevelOverZ>        NearClippingLevelsOverZ;                           // 0x0800(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	float                                         MaxValidPing;                                      // 0x0810(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DefaultFOV;                                        // 0x0814(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVivoxComponent*                        VivoxComponent;                                    // 0x0818(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ATeam*>                          Teams;                                             // 0x0820(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ATslCharacter>>   ReplicateTeamMembers;                              // 0x0830(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_840[0x50];                                     // 0x0840(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class ATslCharacter>>   ReplicateCharacter;                                // 0x0890(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ACarePackageItem>> ReplicateCarePackageItemList;                      // 0x08A0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8B0[0x20];                                     // 0x08B0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeathResultDelaySeconds;                           // 0x08D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8D4[0xBC];                                     // 0x08D4(0x00BC)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPingPongSummary                       PingPongSummary;                                   // 0x0990(0x000C)(BlueprintVisible, BlueprintReadOnly, Net, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_99C[0x5C];                                     // 0x099C(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Admin(const class FString& ServerAdminCommand);
	void BEClient(const class FString& Command);
	void BEServer(const class FString& Command, const class FString& Arg0, const class FString& Arg1, const class FString& Arg2);
	void BP_Test_SpawnVehicle(int32 VehicleIndex);
	void Cheat_ServerSpawnVehicle(int32 VehicleIndex);
	void ClientAdminCopyString(const class FString& inString);
	void ClientEndOnlineGame();
	void ClientGameStarted();
	void ClientInteract(class AActor* TargetObject);
	void ClientInteractByComponent(class UActorComponent* TargetComponent);
	void ClientNotifyHeal(float HealthStart, float Health, float MaxHealth);
	void ClientNotifyHeal_Reliable(float HealthStart, float Health, float MaxHealth);
	void ClientNotifyHeal_Unreliable(float HealthStart, float Health, float MaxHealth);
	void ClientNotifyHealAmount(float Heal);
	void ClientNotifyHealAmount_Reliable(float Heal);
	void ClientNotifyHealAmount_Unreliable(float Heal);
	void ClientNotifyNextGasIn(const struct FVector_NetQuantize& PoisonGasWarningPosition, float PoisonGasWarningRadius);
	void ClientNotifyRestrictingPlayArea();
	void ClientNotifySpeedBoost(float Boost);
	void ClientNotifyStartBuff(class FName BuffName, bool bStart);
	void ClientOnCharacterDeath(bool bIsTeamMatch, bool bHasAliveTeamMember, const struct FTslReportedInfo& InKillerInfo, bool InbCanReport);
	void ClientOnCharacterRestart();
	void ClientSendPacketReliable(const TArray<uint8>& Packet);
	void ClientSendPacketUnreliable(const TArray<uint8>& Packet);
	void ClientSendRoundEndEvent(bool bIsWinner, int32 ExpendedTimeInSeconds);
	void ClientSetCanAllSpectate(bool InbCanSpectate);
	void ClientSetSpectatorCamera(const struct FVector& CameraLocation, const struct FRotator& CameraRotation);
	void ClientSetTslPlayerMatchResultInfos(const TArray<struct FTslPlayerMatchResultInfo>& InTslPlayerMatchResultInfos);
	void ClientShowCastingBar(float CastTime, const class FText& CastName, bool OnOff);
	void ClientShowMatchResult();
	void ClientStartOnlineGame();
	void ClientUpdateSpectatorCameraMode(class FName InCameraName, bool InbFirstPerson, bool InbIsInVehicle, bool InbIsScoping);
	void DropItem(const class FString& ItemTypeName);
	void DumpActorDetailByRaycast();
	TArray<TSubclassOf<class UItem>> GetGearProfile(int32 ProfileIndex);
	class FText GetHudDebugText();
	void HideMatchResult();
	void HideTslDebugInfomation();
	void KickCharacter(class ATslCharacter* TslCharacter, const class FText& Reason);
	void NextSetViewTarget();
	void ObserverTeleportTo(const struct FVector& Location);
	void OffItemStackCountHandlingMode();
	void OnCancelInteractionCast(class UObject* CastObject);
	void OnClickedReportButton(EReportCause ReportCause, ESubjectToReport SubjectToReport);
	void OnExecuteExitCommand();
	void OnFinishInteractionCast(class UObject* CastObject);
	void OnItemStackCountHandlingMode();
	void OnMoveToVehicleSeat(uint8 idx);
	void OnRep_CameraViewBehaviour();
	void OnRep_Team();
	void OnShowCastingBarWidget(float CastTime, const class FText& CastName, bool OnOff);
	void OnUpdateSpectatorCameraMode(class ATslCharacter* TslCharacter, class FName InCameraName, bool InbFirstPerson, bool InbIsInVehicle, bool InbIsScoping);
	void ReliablePing(int32 SeqID, int64 DateTimeTick);
	void ReliablePong(int32 SeqID, int64 DateTimeTickFromServer);
	void SaveGearProfile(int32 ProfileIndex, const TArray<TSubclassOf<class UItem>>& inArray);
	void Say(const class FString& Msg);
	void SendSystemMessage(ESystemMessageType MessageType, const class FText& Message, float MessageDuration);
	void ServerAdmin(const class FString& AdminCommand);
	void ServerApplyReport(EReportCause ReportCause, const struct FTslReportedInfo& InReportedInfo);
	void ServerBEServerCommand(const class FString& Command, const class FString& Arg0, const class FString& Arg1, const class FString& Arg2);
	void ServerBroadCastCastingBar(float CastTime, const class FText& CastName, bool OnOff);
	void ServerBroadCastUsedUpdateCameraMode(class FName InCameraName, bool InbFirstPerson, bool InbIsInVehicle, bool InbIsScoping);
	void ServerCancelInteraction(class UActorComponent* InteractionComponent);
	void ServerCheat(const class FString& Msg);
	void ServerKickCharacter(class ATslCharacter* TslCharacter, const class FText& Reason);
	void ServerLeaveMatchIntentionally();
	void ServerMapLoadFinishedOnClient();
	void ServerMoveToVehicleSeat(int32 SeatIndex);
	void ServerNextSetViewTarget(bool bIsPrev);
	void ServerNotifyHitToGlassWindow(class UTslGlassWindowComponent* GlassWindowComponent, const struct FHitResult& Hit);
	void ServerNotifyHitToGlassWindowInst(class UTslInstancedGlassWindowComponent* GlassWindowInstComponent, const struct FHitResult& Hit);
	void ServerPickUpDroppedItem(class UObject* DroppedItemObject, class FName TargetContainer, const class FString& Options);
	void ServerPickUpItemFromPackage(class UItem* Item, class AItemPackage* Package, class FName TargetContainer, const class FString& Options);
	void ServerSay(const class FString& Msg);
	void ServerSendPacketReliable(const TArray<uint8>& Packet);
	void ServerSendPacketUnreliable(const TArray<uint8>& Packet);
	void ServerSetAccumViewRotation(const struct FVector_NetQuantizeNormal& InAccumViewRotation);
	void ServerSetClientFps(float Fps);
	void ServerSetIsReviving(bool InbIsReviving);
	void ServerSetThirdPerson(bool bNewThirdPerson);
	void ServerSetViewTarget(class AActor* NewViewTarget);
	void ServerSpawnVehicle();
	void ServerStartHoldRotation(const struct FRotator& Current);
	void ServerStartInteraction(class UInteractionComponent* InteractionComponent);
	void ServerStartInteractionByComponent(class UActorComponent* InteractionComponent);
	void ServerStopHoldRotation(const struct FRotator& DeltaRotation, bool bUseInterp);
	void ServerSuicide();
	void ServerTryInteract(class AActor* TargetObject);
	void ServerTryInteractByComponent(class UActorComponent* TargetComponent);
	void ServerViewTargetReplicateUpdate();
	void SetCanSeeTerrainThroughFogInTheAir(bool bCanSee);
	void SetCustomDepth(bool bOn);
	void SetDefaultFOV(float NewFOV);
	void ShowGotoLobbyPopUp(EPopupButtonID ButtonID);
	void ShowInGameMenu();
	void ShowMatchResult();
	void ShowPlayerControllerBindActions_Admin();
	void ShowTeamDeathPopup();
	void ShowTslDebugInfomation();
	void SimulateInputKey(const struct FKey& Key, bool bPressed);
	void Suicide();
	void ToggleInventory();
	void UnreliablePing(int32 SeqID, int64 DateTimeTick);
	void UnreliablePong(int32 SeqID, int64 DateTimeTickFromServer);

	bool CanReport() const;
	bool CanSeeTerrainThroughFogInTheAir() const;
	bool CompleteReportKiller() const;
	int32 GetAliveTeamMemberCount() const;
	bool GetCanAllSpectate() const;
	TArray<class ATeam*> GetClientTeam(bool IncludeSelf) const;
	class FString GetKillerName() const;
	EObserverAuthorityType GetObserverAuthorityType() const;
	EObserverCameraMode GetObserverCameraMode() const;
	class FText GetOtherCastingName() const;
	float GetOtherCastTime() const;
	float GetOtherElapsedCastTime() const;
	TArray<class ACarePackageItem*> GetReplicateCarePackageItems() const;
	TArray<class ATslCharacter*> GetReplicateCharacters() const;
	TArray<class ATslCharacter*> GetReplicateTeamMembers() const;
	class FString GetSpectatingPlayerName() const;
	struct FRotator GetTargetViewRotation() const;
	int32 GetTeamMemberCount() const;
	class ATslCharacter* GetTslCharacter() const;
	TArray<struct FTslPlayerMatchResultInfo> GetTslPlayerMatchResultInfos() const;
	class ATeam* GetViewTargetTeam() const;
	class ATslCharacter* GetViewTargetTslCharacter() const;
	class UVivoxComponent* GetVivoxComponent() const;
	bool IsGameInputAllowed() const;
	bool IsGroggying() const;
	bool IsHighPing() const;
	bool IsItemStackCountHandlingMode() const;
	bool IsObserving() const;
	bool IsReplaying() const;
	bool IsSameObservingCameraMode(EObserverCameraMode CameraType) const;
	bool IsSpectating() const;
	bool IsSpectatorState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslPlayerController">();
	}
	static class ATslPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslPlayerController>();
	}
};
static_assert(alignof(ATslPlayerController) == 0x000008, "Wrong alignment on ATslPlayerController");
static_assert(sizeof(ATslPlayerController) == 0x0009F8, "Wrong size on ATslPlayerController");
static_assert(offsetof(ATslPlayerController, CameraPeekLeftMove) == 0x0006FC, "Member 'ATslPlayerController::CameraPeekLeftMove' has a wrong offset!");
static_assert(offsetof(ATslPlayerController, CameraPeekRightMove) == 0x000708, "Member 'ATslPlayerController::CameraPeekRightMove' has a wrong offset!");
static_assert(offsetof(ATslPlayerController, CameraViewBehaviour) == 0x000724, "Member 'ATslPlayerController::CameraViewBehaviour' has a wrong offset!");
static_assert(offsetof(ATslPlayerController, SpectatorAccumViewRotation) == 0x000748, "Member 'ATslPlayerController::SpectatorAccumViewRotation' has a wrong offset!");
static_assert(offsetof(ATslPlayerController, ObserverAuthorityType) == 0x000754, "Member 'ATslPlayerController::ObserverAuthorityType' has a wrong offset!");
static_assert(offsetof(ATslPlayerController, InteractionTargetComponent) == 0x000768, "Member 'ATslPlayerController::InteractionTargetComponent' has a wrong offset!");
static_assert(offsetof(ATslPlayerController, SpectatorViewCharacter) == 0x000770, "Member 'ATslPlayerController::SpectatorViewCharacter' has a wrong offset!");
static_assert(offsetof(ATslPlayerController, Achievement) == 0x000788, "Member 'ATslPlayerController::Achievement' has a wrong offset!");
static_assert(offsetof(ATslPlayerController, SpectatorScopeMesh) == 0x0007A0, "Member 'ATslPlayerController::SpectatorScopeMesh' has a wrong offset!");
static_assert(offsetof(ATslPlayerController, NearClippingLevelsOverZ) == 0x000800, "Member 'ATslPlayerController::NearClippingLevelsOverZ' has a wrong offset!");
static_assert(offsetof(ATslPlayerController, MaxValidPing) == 0x000810, "Member 'ATslPlayerController::MaxValidPing' has a wrong offset!");
static_assert(offsetof(ATslPlayerController, DefaultFOV) == 0x000814, "Member 'ATslPlayerController::DefaultFOV' has a wrong offset!");
static_assert(offsetof(ATslPlayerController, VivoxComponent) == 0x000818, "Member 'ATslPlayerController::VivoxComponent' has a wrong offset!");
static_assert(offsetof(ATslPlayerController, Teams) == 0x000820, "Member 'ATslPlayerController::Teams' has a wrong offset!");
static_assert(offsetof(ATslPlayerController, ReplicateTeamMembers) == 0x000830, "Member 'ATslPlayerController::ReplicateTeamMembers' has a wrong offset!");
static_assert(offsetof(ATslPlayerController, ReplicateCharacter) == 0x000890, "Member 'ATslPlayerController::ReplicateCharacter' has a wrong offset!");
static_assert(offsetof(ATslPlayerController, ReplicateCarePackageItemList) == 0x0008A0, "Member 'ATslPlayerController::ReplicateCarePackageItemList' has a wrong offset!");
static_assert(offsetof(ATslPlayerController, DeathResultDelaySeconds) == 0x0008D0, "Member 'ATslPlayerController::DeathResultDelaySeconds' has a wrong offset!");
static_assert(offsetof(ATslPlayerController, PingPongSummary) == 0x000990, "Member 'ATslPlayerController::PingPongSummary' has a wrong offset!");

// Class TslGame.ConnectionHandlerInterface
// 0x0000 (0x0028 - 0x0028)
class IConnectionHandlerInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConnectionHandlerInterface">();
	}
	static class IConnectionHandlerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IConnectionHandlerInterface>();
	}
};
static_assert(alignof(IConnectionHandlerInterface) == 0x000008, "Wrong alignment on IConnectionHandlerInterface");
static_assert(sizeof(IConnectionHandlerInterface) == 0x000028, "Wrong size on IConnectionHandlerInterface");

// Class TslGame.DeployedItem
// 0x0018 (0x03B8 - 0x03A0)
class ADeployedItem final : public AActor
{
public:
	TSubclassOf<class UItem>                      ItemType;                                          // 0x03A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackCount;                                        // 0x03A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3AC[0x4];                                      // 0x03AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneComponent;                                    // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeployedItem">();
	}
	static class ADeployedItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeployedItem>();
	}
};
static_assert(alignof(ADeployedItem) == 0x000008, "Wrong alignment on ADeployedItem");
static_assert(sizeof(ADeployedItem) == 0x0003B8, "Wrong size on ADeployedItem");
static_assert(offsetof(ADeployedItem, ItemType) == 0x0003A0, "Member 'ADeployedItem::ItemType' has a wrong offset!");
static_assert(offsetof(ADeployedItem, StackCount) == 0x0003A8, "Member 'ADeployedItem::StackCount' has a wrong offset!");
static_assert(offsetof(ADeployedItem, SceneComponent) == 0x0003B0, "Member 'ADeployedItem::SceneComponent' has a wrong offset!");

// Class TslGame.SubActor
// 0x0008 (0x03A8 - 0x03A0)
class ASubActor : public AActor
{
public:
	class ATslCharacter*                          NetOwnerCharacter;                                 // 0x03A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubActor">();
	}
	static class ASubActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASubActor>();
	}
};
static_assert(alignof(ASubActor) == 0x000008, "Wrong alignment on ASubActor");
static_assert(sizeof(ASubActor) == 0x0003A8, "Wrong size on ASubActor");
static_assert(offsetof(ASubActor, NetOwnerCharacter) == 0x0003A0, "Member 'ASubActor::NetOwnerCharacter' has a wrong offset!");

// Class TslGame.SlotInterface
// 0x0000 (0x0028 - 0x0028)
class ISlotInterface final : public IInterface
{
public:
	class UTexture* GetIconTexture();

	class UAkAudioEvent* GetDropSound() const;
	float GetIconSizeRatio() const;
	class FText GetSlotCategory() const;
	class FText GetSlotDescription() const;
	class FText GetSlotDetailedName() const;
	class FText GetSlotName() const;
	int32 GetSortPriority() const;
	float GetSpace() const;
	int32 GetStackCount() const;
	int32 GetStackCountMax() const;
	float GetToolTipIconSizeRatio() const;
	class UTexture* GetToolTipIconTexture() const;
	float GetUnitSpace() const;
	bool IsAttachment() const;
	bool IsCastableItem() const;
	bool IsEquipable() const;
	bool IsPackageItem() const;
	bool IsStackable() const;
	bool IsWeapon() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlotInterface">();
	}
	static class ISlotInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISlotInterface>();
	}
};
static_assert(alignof(ISlotInterface) == 0x000008, "Wrong alignment on ISlotInterface");
static_assert(sizeof(ISlotInterface) == 0x000028, "Wrong size on ISlotInterface");

// Class TslGame.SlotContainerInterface
// 0x0000 (0x0028 - 0x0028)
class ISlotContainerInterface final : public IInterface
{
public:
	void DoActionWithSlot(TScriptInterface<class ISlotInterface> Slot, class FName ActionName, const class FString& Options);
	void DoSlotAction(class FName ActionName, const class FString& Options);
	void DoSlotActionDefault(TScriptInterface<class ISlotInterface> Slot);
	void DropSlotOnOtherContainer(TScriptInterface<class ISlotInterface> Slot, TScriptInterface<class ISlotContainerInterface> OtherContainer, const class FString& Options);
	TArray<class FName> GetAvailableSlotActions(TScriptInterface<class ISlotInterface> Slot);
	TScriptInterface<class ISlotInterface> GetSlotContext();
	void HideSlotContextMenu();
	void ShowSlotContextMenu(TScriptInterface<class ISlotInterface> Slot);

	class FName GetActionName(TScriptInterface<class ISlotInterface> Slot, TScriptInterface<class ISlotContainerInterface> OtherContainer, const class FString& Options) const;
	TArray<TScriptInterface<class ISlotInterface>> GetAllSlots() const;
	class FName GetDefaultActionName(TScriptInterface<class ISlotInterface> Slot) const;
	class FName GetSlotContainerName() const;
	class AActor* GetSlotContainerOwner() const;
	bool IsEnableAction(TScriptInterface<class ISlotInterface> Slot, TScriptInterface<class ISlotContainerInterface> OtherContainer, const class FString& Options) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SlotContainerInterface">();
	}
	static class ISlotContainerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISlotContainerInterface>();
	}
};
static_assert(alignof(ISlotContainerInterface) == 0x000008, "Wrong alignment on ISlotContainerInterface");
static_assert(sizeof(ISlotContainerInterface) == 0x000028, "Wrong size on ISlotContainerInterface");

// Class TslGame.ItemSlotContainer
// 0x0030 (0x03D8 - 0x03A8)
class AItemSlotContainer : public ASubActor
{
public:
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(TScriptInterface<class ISlotContainerInterface> ItemSlotContainerInterface)> OnCreateAndShowContextMenuWidget;                  // 0x03B0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnDestroyContextMenuWidget;                        // 0x03C0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D0[0x8];                                      // 0x03D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSlotContainer">();
	}
	static class AItemSlotContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemSlotContainer>();
	}
};
static_assert(alignof(AItemSlotContainer) == 0x000008, "Wrong alignment on AItemSlotContainer");
static_assert(sizeof(AItemSlotContainer) == 0x0003D8, "Wrong size on AItemSlotContainer");
static_assert(offsetof(AItemSlotContainer, OnCreateAndShowContextMenuWidget) == 0x0003B0, "Member 'AItemSlotContainer::OnCreateAndShowContextMenuWidget' has a wrong offset!");
static_assert(offsetof(AItemSlotContainer, OnDestroyContextMenuWidget) == 0x0003C0, "Member 'AItemSlotContainer::OnDestroyContextMenuWidget' has a wrong offset!");

// Class TslGame.ItemExplorerInterface
// 0x0000 (0x0028 - 0x0028)
class IItemExplorerInterface final : public IInterface
{
public:
	void UpdateItemList();

	TArray<TScriptInterface<class ISlotInterface>> GetExplorableItemSlotList() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemExplorerInterface">();
	}
	static class IItemExplorerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IItemExplorerInterface>();
	}
};
static_assert(alignof(IItemExplorerInterface) == 0x000008, "Wrong alignment on IItemExplorerInterface");
static_assert(sizeof(IItemExplorerInterface) == 0x000028, "Wrong size on IItemExplorerInterface");

// Class TslGame.ItemExplorer
// 0x0030 (0x0408 - 0x03D8)
class AItemExplorer : public AItemSlotContainer
{
public:
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             OnUpdateItemList;                                  // 0x03E0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnClearItemList;                                   // 0x03F0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_400[0x8];                                      // 0x0400(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemExplorer">();
	}
	static class AItemExplorer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemExplorer>();
	}
};
static_assert(alignof(AItemExplorer) == 0x000008, "Wrong alignment on AItemExplorer");
static_assert(sizeof(AItemExplorer) == 0x000408, "Wrong size on AItemExplorer");
static_assert(offsetof(AItemExplorer, OnUpdateItemList) == 0x0003E0, "Member 'AItemExplorer::OnUpdateItemList' has a wrong offset!");
static_assert(offsetof(AItemExplorer, OnClearItemList) == 0x0003F0, "Member 'AItemExplorer::OnClearItemList' has a wrong offset!");

// Class TslGame.ExplorableItemInterface
// 0x0000 (0x0028 - 0x0028)
class IExplorableItemInterface final : public IInterface
{
public:
	float GetExplorationDistance() const;
	class FName GetInteractiveActionName() const;
	bool IsValidExplorableItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExplorableItemInterface">();
	}
	static class IExplorableItemInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IExplorableItemInterface>();
	}
};
static_assert(alignof(IExplorableItemInterface) == 0x000008, "Wrong alignment on IExplorableItemInterface");
static_assert(sizeof(IExplorableItemInterface) == 0x000028, "Wrong size on IExplorableItemInterface");

// Class TslGame.ItemPackage
// 0x00F8 (0x0500 - 0x0408)
class AItemPackage : public AItemExplorer
{
public:
	uint8                                         Pad_408[0x10];                                     // 0x0408(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   PackageName;                                       // 0x0418(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   PackageCategory;                                   // 0x0430(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   PackageDetailedName;                               // 0x0448(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   PackageDescription;                                // 0x0460(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UTexture*                               PackageIcon;                                       // 0x0478(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PackageIconSizeRatio;                              // 0x0480(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_484[0x4];                                      // 0x0484(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               PackageToolTipIcon;                                // 0x0488(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PackageToolTipIconSizeRatio;                       // 0x0490(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_494[0x4];                                      // 0x0494(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UStaticMesh>             PackageMesh;                                       // 0x0498(0x0020)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          BoxComponent;                                      // 0x04B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOnceInteractionComponent*              InteractionComponent;                              // 0x04C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DestroyByEmptyItem;                                // 0x04C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C9[0x7];                                      // 0x04C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UItem*>                          Items;                                             // 0x04D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, RepNotify, NativeAccessSpecifierPublic)
	class FString                                 CreatorName;                                       // 0x04E0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortPriority;                                      // 0x04F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F4[0xC];                                      // 0x04F4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AllowInteract(const class ATslCharacter* OtherCharacter);
	void ClientOnInteractBy(class ATslCharacter* OtherCharacter);
	void Items_RepNotify();

	bool IsOpenedBy(class ATslCharacter* Character) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemPackage">();
	}
	static class AItemPackage* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemPackage>();
	}
};
static_assert(alignof(AItemPackage) == 0x000008, "Wrong alignment on AItemPackage");
static_assert(sizeof(AItemPackage) == 0x000500, "Wrong size on AItemPackage");
static_assert(offsetof(AItemPackage, PackageName) == 0x000418, "Member 'AItemPackage::PackageName' has a wrong offset!");
static_assert(offsetof(AItemPackage, PackageCategory) == 0x000430, "Member 'AItemPackage::PackageCategory' has a wrong offset!");
static_assert(offsetof(AItemPackage, PackageDetailedName) == 0x000448, "Member 'AItemPackage::PackageDetailedName' has a wrong offset!");
static_assert(offsetof(AItemPackage, PackageDescription) == 0x000460, "Member 'AItemPackage::PackageDescription' has a wrong offset!");
static_assert(offsetof(AItemPackage, PackageIcon) == 0x000478, "Member 'AItemPackage::PackageIcon' has a wrong offset!");
static_assert(offsetof(AItemPackage, PackageIconSizeRatio) == 0x000480, "Member 'AItemPackage::PackageIconSizeRatio' has a wrong offset!");
static_assert(offsetof(AItemPackage, PackageToolTipIcon) == 0x000488, "Member 'AItemPackage::PackageToolTipIcon' has a wrong offset!");
static_assert(offsetof(AItemPackage, PackageToolTipIconSizeRatio) == 0x000490, "Member 'AItemPackage::PackageToolTipIconSizeRatio' has a wrong offset!");
static_assert(offsetof(AItemPackage, PackageMesh) == 0x000498, "Member 'AItemPackage::PackageMesh' has a wrong offset!");
static_assert(offsetof(AItemPackage, BoxComponent) == 0x0004B8, "Member 'AItemPackage::BoxComponent' has a wrong offset!");
static_assert(offsetof(AItemPackage, InteractionComponent) == 0x0004C0, "Member 'AItemPackage::InteractionComponent' has a wrong offset!");
static_assert(offsetof(AItemPackage, DestroyByEmptyItem) == 0x0004C8, "Member 'AItemPackage::DestroyByEmptyItem' has a wrong offset!");
static_assert(offsetof(AItemPackage, Items) == 0x0004D0, "Member 'AItemPackage::Items' has a wrong offset!");
static_assert(offsetof(AItemPackage, CreatorName) == 0x0004E0, "Member 'AItemPackage::CreatorName' has a wrong offset!");
static_assert(offsetof(AItemPackage, SortPriority) == 0x0004F0, "Member 'AItemPackage::SortPriority' has a wrong offset!");

// Class TslGame.VivoxResponse
// 0x0070 (0x0098 - 0x0028)
class UVivoxResponse : public UObject
{
public:
	uint8                                         Pad_28[0x70];                                      // 0x0028(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VivoxResponse">();
	}
	static class UVivoxResponse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVivoxResponse>();
	}
};
static_assert(alignof(UVivoxResponse) == 0x000008, "Wrong alignment on UVivoxResponse");
static_assert(sizeof(UVivoxResponse) == 0x000098, "Wrong size on UVivoxResponse");

// Class TslGame.SignInResponse
// 0x0030 (0x00C8 - 0x0098)
class USignInResponse final : public UVivoxResponse
{
public:
	uint8                                         Pad_98[0x30];                                      // 0x0098(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SignInResponse">();
	}
	static class USignInResponse* GetDefaultObj()
	{
		return GetDefaultObjImpl<USignInResponse>();
	}
};
static_assert(alignof(USignInResponse) == 0x000008, "Wrong alignment on USignInResponse");
static_assert(sizeof(USignInResponse) == 0x0000C8, "Wrong size on USignInResponse");

// Class TslGame.DeployedItemPackage
// 0x0018 (0x03B8 - 0x03A0)
class ADeployedItemPackage final : public AActor
{
public:
	TSubclassOf<class AItemPackage>               ItemPackageType;                                   // 0x03A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FPackagedItemInfo>              ItemInfos;                                         // 0x03A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeployedItemPackage">();
	}
	static class ADeployedItemPackage* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADeployedItemPackage>();
	}
};
static_assert(alignof(ADeployedItemPackage) == 0x000008, "Wrong alignment on ADeployedItemPackage");
static_assert(sizeof(ADeployedItemPackage) == 0x0003B8, "Wrong size on ADeployedItemPackage");
static_assert(offsetof(ADeployedItemPackage, ItemPackageType) == 0x0003A0, "Member 'ADeployedItemPackage::ItemPackageType' has a wrong offset!");
static_assert(offsetof(ADeployedItemPackage, ItemInfos) == 0x0003A8, "Member 'ADeployedItemPackage::ItemInfos' has a wrong offset!");

// Class TslGame.DoorDataAsset
// 0x0038 (0x0060 - 0x0028)
class UDoorDataAsset final : public UDataAsset
{
public:
	float                                         OpenAngle;                                         // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            OpenCurve;                                         // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OpenCurveDuration;                                 // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CloseCurve;                                        // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloseCurveDuration;                                // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          OpenSound;                                         // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          CloseSound;                                        // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoorDataAsset">();
	}
	static class UDoorDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoorDataAsset>();
	}
};
static_assert(alignof(UDoorDataAsset) == 0x000008, "Wrong alignment on UDoorDataAsset");
static_assert(sizeof(UDoorDataAsset) == 0x000060, "Wrong size on UDoorDataAsset");
static_assert(offsetof(UDoorDataAsset, OpenAngle) == 0x000028, "Member 'UDoorDataAsset::OpenAngle' has a wrong offset!");
static_assert(offsetof(UDoorDataAsset, OpenCurve) == 0x000030, "Member 'UDoorDataAsset::OpenCurve' has a wrong offset!");
static_assert(offsetof(UDoorDataAsset, OpenCurveDuration) == 0x000038, "Member 'UDoorDataAsset::OpenCurveDuration' has a wrong offset!");
static_assert(offsetof(UDoorDataAsset, CloseCurve) == 0x000040, "Member 'UDoorDataAsset::CloseCurve' has a wrong offset!");
static_assert(offsetof(UDoorDataAsset, CloseCurveDuration) == 0x000048, "Member 'UDoorDataAsset::CloseCurveDuration' has a wrong offset!");
static_assert(offsetof(UDoorDataAsset, OpenSound) == 0x000050, "Member 'UDoorDataAsset::OpenSound' has a wrong offset!");
static_assert(offsetof(UDoorDataAsset, CloseSound) == 0x000058, "Member 'UDoorDataAsset::CloseSound' has a wrong offset!");

// Class TslGame.UiHelperFunctions
// 0x0000 (0x0028 - 0x0028)
class UUiHelperFunctions final : public UBlueprintFunctionLibrary
{
public:
	static void DrawDottedLine(struct FPaintContext& Context, const struct FVector2D& PositionA, const struct FVector2D& PositionB, float DottedLength, float DottedInterval, const struct FLinearColor& Tint, bool bAntiAlias);
	static int32 GetBluezoneGpsState(class UUserWidget* Widget);
	static float GetBluezoneReleaseTime(class UUserWidget* Widget);
	static float GetBluezoneWarningTime(class UUserWidget* Widget);
	static int32 GetCharacterStateByTeam(class ATeam* Team);
	static struct FVector GetCurrentPlayzonePosition_BluezoneGPS(class UUserWidget* Widget);
	static float GetCurrentPlayzoneRadius_BluezoneGPS(class UUserWidget* Widget);
	static class UWidget* GetDownWidgetByTslFocusableWidget(class UWidget* Widget);
	static float GetDurabilityRatio(TScriptInterface<class ISlotInterface> ItemSlot);
	static float GetGroggyHealthRatioByTeam(class ATeam* Team);
	static float GetHealthRatioByTeam(class ATeam* Team);
	static class ATslCharacter* GetLastSpectatedCharacter(class UUserWidget* Widget);
	static class UWidget* GetLeftWidgetByTslFocusableWidget(class UWidget* Widget);
	static struct FLinearColor GetMarkerColor(int32 MarkerNum);
	static struct FVector GetNextPlayzonePosition_BluezoneGPS(class UUserWidget* Widget);
	static float GetNextPlayzoneRadius_BluezoneGPS(class UUserWidget* Widget);
	static class ATslCharacter* GetOwningTslCharacter(class UUserWidget* Widget);
	static class ATslPlayerController* GetOwningTslPlayerController(class UUserWidget* Widget);
	static class FString GetPlayerName(class ATslCharacter* Character);
	static TArray<struct FReportCauseData> GetReportCauses();
	static class UWidget* GetRightWidgetByTslFocusableWidget(class UWidget* Widget);
	static TArray<class ATslCharacter*> GetSortedReplicateCharactersByLastHitTime(class UUserWidget* Widget);
	static TArray<class ATslCharacter*> GetSortedReplicateCharactersBySpectatorPawnDistance(class UUserWidget* Widget);
	static TArray<struct FSubjectToReport> GetSubjectToReport();
	static ESubjectToReport GetSubjectToReportType(class UUserWidget* Widget);
	static TArray<struct FLinearColor> GetTeamColors(int32 TeamCount);
	static int32 GetTeamId(class ATslCharacter* Character);
	static class ATslHUD* GetTslHUD(class UUserWidget* Widget);
	static class ATslSpectatorPawn* GetTslSpectatorPawn(class UUserWidget* Widget);
	static class UWidget* GetUpWidgetByTslFocusableWidget(class UWidget* Widget);
	static TSubclassOf<class UUserWidget> GetVehicleUI(class APawn* VehiclePawn);
	static class ATslCharacter* GetViewTargetTslCharacter(class UUserWidget* Widget);
	static bool HaveDurability(TScriptInterface<class ISlotInterface> ItemSlot);
	static bool IsAttacked(int32 State);
	static bool IsBluezoneGpsReset(class UUserWidget* Widget);
	static bool IsGroggyByTeam(class ATeam* Team);
	static bool IsHitted(int32 State);
	static bool IsInNextPlayzone(class UUserWidget* Widget);
	static bool IsKickEnableCharacter(class ATslCharacter* Character);
	static bool IsLastSpectatedCharacter(class UUserWidget* Widget, class ATslCharacter* Character);
	static bool IsLastSpectatorTeam(class UUserWidget* Widget, class ATslCharacter* Character);
	static bool IsThereAnyPlayingAnimation(class UUserWidget* Widget, const TArray<class UWidgetAnimation*>& AnimationArray);
	static bool IsWarning(class UUserWidget* Widget);
	static TArray<TScriptInterface<class ISlotInterface>> SortItem(const TArray<TScriptInterface<class ISlotInterface>>& InItemList);
	static TArray<struct FTslPlayerMatchResultInfo> SortPlayerMatchResultInfosByRanking(const TArray<struct FTslPlayerMatchResultInfo>& PlayerMatchResultInfos);
	static TArray<class UWidget*> SortWidgetFormPositionX(const TArray<class UWidget*>& Widgets, bool bDescendingOrder);
	static TArray<class UWidget*> SortWidgetFormPositionY(const TArray<class UWidget*>& Widgets, bool bDescendingOrder);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UiHelperFunctions">();
	}
	static class UUiHelperFunctions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUiHelperFunctions>();
	}
};
static_assert(alignof(UUiHelperFunctions) == 0x000008, "Wrong alignment on UUiHelperFunctions");
static_assert(sizeof(UUiHelperFunctions) == 0x000028, "Wrong size on UUiHelperFunctions");

// Class TslGame.TslReactionDoorData
// 0x0040 (0x0068 - 0x0028)
class UTslReactionDoorData final : public UDataAsset
{
public:
	float                                         PointDamageImpulse;                                // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PointDamageRadius;                                 // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreakingRadius;                                    // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreakingImpulse;                                   // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreakingMinDamage;                                 // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageAccumulateTimeout;                           // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZombieDamageAccumulateTimeout;                     // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TopImpactSoketName;                                // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CenterImpactSoketName;                             // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BottomImpactSoketName;                             // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          DestructibleSoundAk;                               // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslReactionDoorData">();
	}
	static class UTslReactionDoorData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslReactionDoorData>();
	}
};
static_assert(alignof(UTslReactionDoorData) == 0x000008, "Wrong alignment on UTslReactionDoorData");
static_assert(sizeof(UTslReactionDoorData) == 0x000068, "Wrong size on UTslReactionDoorData");
static_assert(offsetof(UTslReactionDoorData, PointDamageImpulse) == 0x000028, "Member 'UTslReactionDoorData::PointDamageImpulse' has a wrong offset!");
static_assert(offsetof(UTslReactionDoorData, PointDamageRadius) == 0x00002C, "Member 'UTslReactionDoorData::PointDamageRadius' has a wrong offset!");
static_assert(offsetof(UTslReactionDoorData, BreakingRadius) == 0x000030, "Member 'UTslReactionDoorData::BreakingRadius' has a wrong offset!");
static_assert(offsetof(UTslReactionDoorData, BreakingImpulse) == 0x000034, "Member 'UTslReactionDoorData::BreakingImpulse' has a wrong offset!");
static_assert(offsetof(UTslReactionDoorData, BreakingMinDamage) == 0x000038, "Member 'UTslReactionDoorData::BreakingMinDamage' has a wrong offset!");
static_assert(offsetof(UTslReactionDoorData, DamageAccumulateTimeout) == 0x00003C, "Member 'UTslReactionDoorData::DamageAccumulateTimeout' has a wrong offset!");
static_assert(offsetof(UTslReactionDoorData, ZombieDamageAccumulateTimeout) == 0x000040, "Member 'UTslReactionDoorData::ZombieDamageAccumulateTimeout' has a wrong offset!");
static_assert(offsetof(UTslReactionDoorData, TopImpactSoketName) == 0x000048, "Member 'UTslReactionDoorData::TopImpactSoketName' has a wrong offset!");
static_assert(offsetof(UTslReactionDoorData, CenterImpactSoketName) == 0x000050, "Member 'UTslReactionDoorData::CenterImpactSoketName' has a wrong offset!");
static_assert(offsetof(UTslReactionDoorData, BottomImpactSoketName) == 0x000058, "Member 'UTslReactionDoorData::BottomImpactSoketName' has a wrong offset!");
static_assert(offsetof(UTslReactionDoorData, DestructibleSoundAk) == 0x000060, "Member 'UTslReactionDoorData::DestructibleSoundAk' has a wrong offset!");

// Class TslGame.DoorFrameComponent
// 0x0070 (0x0880 - 0x0810)
class UDoorFrameComponent final : public UStaticMeshComponent
{
public:
	uint8                                         Pad_808[0x8];                                      // 0x0808(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             DoorTransform;                                     // 0x0810(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                SoundOffsetFromDoor;                               // 0x0840(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_84C[0x4];                                      // 0x084C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            DoorStaticMesh;                                    // 0x0850(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleMesh*                      DoorDestructibleMesh;                              // 0x0858(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDoorDataAsset*                         DoorDataAsset;                                     // 0x0860(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTslReactionDoorData*                   ReactionDoorData;                                  // 0x0868(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_870[0x10];                                     // 0x0870(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UStaticMesh* GetDoorStaticMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoorFrameComponent">();
	}
	static class UDoorFrameComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoorFrameComponent>();
	}
};
static_assert(alignof(UDoorFrameComponent) == 0x000010, "Wrong alignment on UDoorFrameComponent");
static_assert(sizeof(UDoorFrameComponent) == 0x000880, "Wrong size on UDoorFrameComponent");
static_assert(offsetof(UDoorFrameComponent, DoorTransform) == 0x000810, "Member 'UDoorFrameComponent::DoorTransform' has a wrong offset!");
static_assert(offsetof(UDoorFrameComponent, SoundOffsetFromDoor) == 0x000840, "Member 'UDoorFrameComponent::SoundOffsetFromDoor' has a wrong offset!");
static_assert(offsetof(UDoorFrameComponent, DoorStaticMesh) == 0x000850, "Member 'UDoorFrameComponent::DoorStaticMesh' has a wrong offset!");
static_assert(offsetof(UDoorFrameComponent, DoorDestructibleMesh) == 0x000858, "Member 'UDoorFrameComponent::DoorDestructibleMesh' has a wrong offset!");
static_assert(offsetof(UDoorFrameComponent, DoorDataAsset) == 0x000860, "Member 'UDoorFrameComponent::DoorDataAsset' has a wrong offset!");
static_assert(offsetof(UDoorFrameComponent, ReactionDoorData) == 0x000868, "Member 'UDoorFrameComponent::ReactionDoorData' has a wrong offset!");

// Class TslGame.DroppedItem
// 0x0008 (0x03A8 - 0x03A0)
class ADroppedItem final : public AActor
{
public:
	class UItem*                                  Item;                                              // 0x03A0(0x0008)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Item_RepNotify();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DroppedItem">();
	}
	static class ADroppedItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADroppedItem>();
	}
};
static_assert(alignof(ADroppedItem) == 0x000008, "Wrong alignment on ADroppedItem");
static_assert(sizeof(ADroppedItem) == 0x0003A8, "Wrong size on ADroppedItem");
static_assert(offsetof(ADroppedItem, Item) == 0x0003A0, "Member 'ADroppedItem::Item' has a wrong offset!");

// Class TslGame.TslVehicleSeatActor
// 0x0008 (0x0430 - 0x0428)
class ATslVehicleSeatActor : public AVehicleSeatActor
{
public:
	ERiderType                                    RiderType;                                         // 0x0428(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_429[0x7];                                      // 0x0429(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslVehicleSeatActor">();
	}
	static class ATslVehicleSeatActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslVehicleSeatActor>();
	}
};
static_assert(alignof(ATslVehicleSeatActor) == 0x000008, "Wrong alignment on ATslVehicleSeatActor");
static_assert(sizeof(ATslVehicleSeatActor) == 0x000430, "Wrong size on ATslVehicleSeatActor");
static_assert(offsetof(ATslVehicleSeatActor, RiderType) == 0x000428, "Member 'ATslVehicleSeatActor::RiderType' has a wrong offset!");

// Class TslGame.TslMotoSeatActor
// 0x0000 (0x0430 - 0x0430)
class ATslMotoSeatActor : public ATslVehicleSeatActor
{
public:
	void HandleFlipAndKickstand();

	bool IsEntryAllowed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslMotoSeatActor">();
	}
	static class ATslMotoSeatActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslMotoSeatActor>();
	}
};
static_assert(alignof(ATslMotoSeatActor) == 0x000008, "Wrong alignment on ATslMotoSeatActor");
static_assert(sizeof(ATslMotoSeatActor) == 0x000430, "Wrong size on ATslMotoSeatActor");

// Class TslGame.DroppedItemGridManager
// 0x00B0 (0x0450 - 0x03A0)
class ADroppedItemGridManager final : public AInfo
{
public:
	float                                         MaxGridSize;                                       // 0x03A0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxGridLayerNum;                                   // 0x03A4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxItemNumPerGroup;                                // 0x03A8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3AC[0xA4];                                     // 0x03AC(0x00A4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DroppedItemGridManager">();
	}
	static class ADroppedItemGridManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADroppedItemGridManager>();
	}
};
static_assert(alignof(ADroppedItemGridManager) == 0x000008, "Wrong alignment on ADroppedItemGridManager");
static_assert(sizeof(ADroppedItemGridManager) == 0x000450, "Wrong size on ADroppedItemGridManager");
static_assert(offsetof(ADroppedItemGridManager, MaxGridSize) == 0x0003A0, "Member 'ADroppedItemGridManager::MaxGridSize' has a wrong offset!");
static_assert(offsetof(ADroppedItemGridManager, MaxGridLayerNum) == 0x0003A4, "Member 'ADroppedItemGridManager::MaxGridLayerNum' has a wrong offset!");
static_assert(offsetof(ADroppedItemGridManager, MaxItemNumPerGroup) == 0x0003A8, "Member 'ADroppedItemGridManager::MaxItemNumPerGroup' has a wrong offset!");

// Class TslGame.DroppedItemGroup
// 0x0010 (0x03B0 - 0x03A0)
class ADroppedItemGroup final : public AActor
{
public:
	uint8                                         Pad_3A0[0x4];                                      // 0x03A0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomSpawnRadius;                                 // 0x03A4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxRandomSpawnCount;                               // 0x03A8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3AC[0x4];                                      // 0x03AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AddItem(class UItem* NewItem, const struct FVector& NewWorldLocation);
	void OnItemBeginPlay();
	void OnItemEndPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DroppedItemGroup">();
	}
	static class ADroppedItemGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADroppedItemGroup>();
	}
};
static_assert(alignof(ADroppedItemGroup) == 0x000008, "Wrong alignment on ADroppedItemGroup");
static_assert(sizeof(ADroppedItemGroup) == 0x0003B0, "Wrong size on ADroppedItemGroup");
static_assert(offsetof(ADroppedItemGroup, RandomSpawnRadius) == 0x0003A4, "Member 'ADroppedItemGroup::RandomSpawnRadius' has a wrong offset!");
static_assert(offsetof(ADroppedItemGroup, MaxRandomSpawnCount) == 0x0003A8, "Member 'ADroppedItemGroup::MaxRandomSpawnCount' has a wrong offset!");

// Class TslGame.DroppedItemInterface
// 0x0000 (0x0028 - 0x0028)
class IDroppedItemInterface final : public IInterface
{
public:
	class UItem* GetDroppedItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DroppedItemInterface">();
	}
	static class IDroppedItemInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDroppedItemInterface>();
	}
};
static_assert(alignof(IDroppedItemInterface) == 0x000008, "Wrong alignment on IDroppedItemInterface");
static_assert(sizeof(IDroppedItemInterface) == 0x000028, "Wrong size on IDroppedItemInterface");

// Class TslGame.ExportableDataAsset
// 0x0020 (0x0048 - 0x0028)
class UExportableDataAsset : public UDataAsset
{
public:
	struct FDirectoryPath                         JsonSaveDirectory;                                 // 0x0028(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
	class FString                                 JsonSaveFileName;                                  // 0x0038(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExportableDataAsset">();
	}
	static class UExportableDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExportableDataAsset>();
	}
};
static_assert(alignof(UExportableDataAsset) == 0x000008, "Wrong alignment on UExportableDataAsset");
static_assert(sizeof(UExportableDataAsset) == 0x000048, "Wrong size on UExportableDataAsset");
static_assert(offsetof(UExportableDataAsset, JsonSaveDirectory) == 0x000028, "Member 'UExportableDataAsset::JsonSaveDirectory' has a wrong offset!");
static_assert(offsetof(UExportableDataAsset, JsonSaveFileName) == 0x000038, "Member 'UExportableDataAsset::JsonSaveFileName' has a wrong offset!");

// Class TslGame.LobbyCustomizableData
// 0x0020 (0x0068 - 0x0048)
class ULobbyCustomizableData final : public UExportableDataAsset
{
public:
	TArray<struct FLobbyFaceElement>              Faces;                                             // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FLobbyHairElement>              Hairs;                                             // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyCustomizableData">();
	}
	static class ULobbyCustomizableData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyCustomizableData>();
	}
};
static_assert(alignof(ULobbyCustomizableData) == 0x000008, "Wrong alignment on ULobbyCustomizableData");
static_assert(sizeof(ULobbyCustomizableData) == 0x000068, "Wrong size on ULobbyCustomizableData");
static_assert(offsetof(ULobbyCustomizableData, Faces) == 0x000048, "Member 'ULobbyCustomizableData::Faces' has a wrong offset!");
static_assert(offsetof(ULobbyCustomizableData, Hairs) == 0x000058, "Member 'ULobbyCustomizableData::Hairs' has a wrong offset!");

// Class TslGame.LobbyItemExporter
// 0x0000 (0x0048 - 0x0048)
class ULobbyItemExporter final : public UExportableDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyItemExporter">();
	}
	static class ULobbyItemExporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyItemExporter>();
	}
};
static_assert(alignof(ULobbyItemExporter) == 0x000008, "Wrong alignment on ULobbyItemExporter");
static_assert(sizeof(ULobbyItemExporter) == 0x000048, "Wrong size on ULobbyItemExporter");

// Class TslGame.GameStateListenerComponent
// 0x0020 (0x0118 - 0x00F8)
class UGameStateListenerComponent final : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   OnMatchStateChange;                                // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnGameModeEvent;                                   // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateListenerComponent">();
	}
	static class UGameStateListenerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameStateListenerComponent>();
	}
};
static_assert(alignof(UGameStateListenerComponent) == 0x000008, "Wrong alignment on UGameStateListenerComponent");
static_assert(sizeof(UGameStateListenerComponent) == 0x000118, "Wrong size on UGameStateListenerComponent");
static_assert(offsetof(UGameStateListenerComponent, OnMatchStateChange) == 0x0000F8, "Member 'UGameStateListenerComponent::OnMatchStateChange' has a wrong offset!");
static_assert(offsetof(UGameStateListenerComponent, OnGameModeEvent) == 0x000108, "Member 'UGameStateListenerComponent::OnGameModeEvent' has a wrong offset!");

// Class TslGame.GeneralItemSpawner
// 0x0000 (0x0028 - 0x0028)
class UGeneralItemSpawner : public UObject
{
public:
	TArray<struct FItemInitiator> CreateItemInitiators();
	TArray<class UItem*> CreateItems();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneralItemSpawner">();
	}
	static class UGeneralItemSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneralItemSpawner>();
	}
};
static_assert(alignof(UGeneralItemSpawner) == 0x000008, "Wrong alignment on UGeneralItemSpawner");
static_assert(sizeof(UGeneralItemSpawner) == 0x000028, "Wrong size on UGeneralItemSpawner");

// Class TslGame.TableGeneralItemSpawner
// 0x00C0 (0x00E8 - 0x0028)
class UTableGeneralItemSpawner final : public UGeneralItemSpawner
{
public:
	class UDataTable*                             RawItemSpawnDataTable;                             // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             RawItemSpawnTogetherDataTable;                     // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGeneralItemSpawnProb>          SpawnProbArray;                                    // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0xA0];                                      // 0x0048(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TableGeneralItemSpawner">();
	}
	static class UTableGeneralItemSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTableGeneralItemSpawner>();
	}
};
static_assert(alignof(UTableGeneralItemSpawner) == 0x000008, "Wrong alignment on UTableGeneralItemSpawner");
static_assert(sizeof(UTableGeneralItemSpawner) == 0x0000E8, "Wrong size on UTableGeneralItemSpawner");
static_assert(offsetof(UTableGeneralItemSpawner, RawItemSpawnDataTable) == 0x000028, "Member 'UTableGeneralItemSpawner::RawItemSpawnDataTable' has a wrong offset!");
static_assert(offsetof(UTableGeneralItemSpawner, RawItemSpawnTogetherDataTable) == 0x000030, "Member 'UTableGeneralItemSpawner::RawItemSpawnTogetherDataTable' has a wrong offset!");
static_assert(offsetof(UTableGeneralItemSpawner, SpawnProbArray) == 0x000038, "Member 'UTableGeneralItemSpawner::SpawnProbArray' has a wrong offset!");

// Class TslGame.InteractionInterface
// 0x0000 (0x0028 - 0x0028)
class IInteractionInterface final : public IInterface
{
public:
	bool AllowInteractBy(const class ATslCharacter* Character) const;
	class FText GetInteractionVerb() const;
	class FText GetInteractiveObjectName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionInterface">();
	}
	static class IInteractionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInteractionInterface>();
	}
};
static_assert(alignof(IInteractionInterface) == 0x000008, "Wrong alignment on IInteractionInterface");
static_assert(sizeof(IInteractionInterface) == 0x000028, "Wrong size on IInteractionInterface");

// Class TslGame.DoublePhaseInteractionComponent
// 0x00D0 (0x0350 - 0x0280)
class UDoublePhaseInteractionComponent final : public UInteractionComponent
{
public:
	class FText                                   FirstInteractionVerb;                              // 0x0280(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   FirstInteractiveObjectName;                        // 0x0298(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   SecondInteractionVerb;                             // 0x02B0(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   SecondInteractiveObjectName;                       // 0x02C8(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnSecondInteractBy;                                // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ClientOnSecondInteractBy;                          // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_300[0x50];                                     // 0x0300(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoublePhaseInteractionComponent">();
	}
	static class UDoublePhaseInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoublePhaseInteractionComponent>();
	}
};
static_assert(alignof(UDoublePhaseInteractionComponent) == 0x000008, "Wrong alignment on UDoublePhaseInteractionComponent");
static_assert(sizeof(UDoublePhaseInteractionComponent) == 0x000350, "Wrong size on UDoublePhaseInteractionComponent");
static_assert(offsetof(UDoublePhaseInteractionComponent, FirstInteractionVerb) == 0x000280, "Member 'UDoublePhaseInteractionComponent::FirstInteractionVerb' has a wrong offset!");
static_assert(offsetof(UDoublePhaseInteractionComponent, FirstInteractiveObjectName) == 0x000298, "Member 'UDoublePhaseInteractionComponent::FirstInteractiveObjectName' has a wrong offset!");
static_assert(offsetof(UDoublePhaseInteractionComponent, SecondInteractionVerb) == 0x0002B0, "Member 'UDoublePhaseInteractionComponent::SecondInteractionVerb' has a wrong offset!");
static_assert(offsetof(UDoublePhaseInteractionComponent, SecondInteractiveObjectName) == 0x0002C8, "Member 'UDoublePhaseInteractionComponent::SecondInteractiveObjectName' has a wrong offset!");
static_assert(offsetof(UDoublePhaseInteractionComponent, OnSecondInteractBy) == 0x0002E0, "Member 'UDoublePhaseInteractionComponent::OnSecondInteractBy' has a wrong offset!");
static_assert(offsetof(UDoublePhaseInteractionComponent, ClientOnSecondInteractBy) == 0x0002F0, "Member 'UDoublePhaseInteractionComponent::ClientOnSecondInteractBy' has a wrong offset!");

// Class TslGame.AmmoItem
// 0x0010 (0x0198 - 0x0188)
class UAmmoItem final : public UItem
{
public:
	class UTexture*                               AmmoIcon;                                          // 0x0188(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmmoIconRatio;                                     // 0x0190(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_194[0x4];                                      // 0x0194(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AmmoItem">();
	}
	static class UAmmoItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAmmoItem>();
	}
};
static_assert(alignof(UAmmoItem) == 0x000008, "Wrong alignment on UAmmoItem");
static_assert(sizeof(UAmmoItem) == 0x000198, "Wrong size on UAmmoItem");
static_assert(offsetof(UAmmoItem, AmmoIcon) == 0x000188, "Member 'UAmmoItem::AmmoIcon' has a wrong offset!");
static_assert(offsetof(UAmmoItem, AmmoIconRatio) == 0x000190, "Member 'UAmmoItem::AmmoIconRatio' has a wrong offset!");

// Class TslGame.AttachableItem
// 0x00F8 (0x0280 - 0x0188)
class UAttachableItem final : public UItem
{
public:
	struct FWeaponAttachmentData                  AttachmentData;                                    // 0x0188(0x00B8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UStaticMesh>             AttachmentMeshAsset;                               // 0x0240(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FWeaponAttachmentWeaponTagData> AttachmentWeaponTagData;                           // 0x0260(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          EquipOnPickUp;                                     // 0x0270(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          AttachedSoundAk;                                   // 0x0278(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	struct FWeaponAttachmentData GetAttachmentData(class FName WeaponTag) const;
	EWeaponAttachmentSlotID GetAttachmentSlotID(class FName WeaponTag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttachableItem">();
	}
	static class UAttachableItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttachableItem>();
	}
};
static_assert(alignof(UAttachableItem) == 0x000008, "Wrong alignment on UAttachableItem");
static_assert(sizeof(UAttachableItem) == 0x000280, "Wrong size on UAttachableItem");
static_assert(offsetof(UAttachableItem, AttachmentData) == 0x000188, "Member 'UAttachableItem::AttachmentData' has a wrong offset!");
static_assert(offsetof(UAttachableItem, AttachmentMeshAsset) == 0x000240, "Member 'UAttachableItem::AttachmentMeshAsset' has a wrong offset!");
static_assert(offsetof(UAttachableItem, AttachmentWeaponTagData) == 0x000260, "Member 'UAttachableItem::AttachmentWeaponTagData' has a wrong offset!");
static_assert(offsetof(UAttachableItem, EquipOnPickUp) == 0x000270, "Member 'UAttachableItem::EquipOnPickUp' has a wrong offset!");
static_assert(offsetof(UAttachableItem, AttachedSoundAk) == 0x000278, "Member 'UAttachableItem::AttachedSoundAk' has a wrong offset!");

// Class TslGame.CastableItem
// 0x0038 (0x01C0 - 0x0188)
class UCastableItem : public UItem
{
public:
	struct FCastConfig                            CastConfig;                                        // 0x0188(0x0030)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          bCanUseInWater;                                    // 0x01B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B9[0x7];                                      // 0x01B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CastableItem">();
	}
	static class UCastableItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCastableItem>();
	}
};
static_assert(alignof(UCastableItem) == 0x000008, "Wrong alignment on UCastableItem");
static_assert(sizeof(UCastableItem) == 0x0001C0, "Wrong size on UCastableItem");
static_assert(offsetof(UCastableItem, CastConfig) == 0x000188, "Member 'UCastableItem::CastConfig' has a wrong offset!");
static_assert(offsetof(UCastableItem, bCanUseInWater) == 0x0001B8, "Member 'UCastableItem::bCanUseInWater' has a wrong offset!");

// Class TslGame.CustomEquipableItem
// 0x0100 (0x0340 - 0x0240)
class UCustomEquipableItem final : public UEquipableItem
{
public:
	int32                                         ItemLevel;                                         // 0x0240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_244[0xC];                                      // 0x0244(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SlotOffset_Primary;                                // 0x0250(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTransform                             SlotOffset_Secondary;                              // 0x0280(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTransform                             SlotOffset_SideArm;                                // 0x02B0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTransform                             SlotOffset_Melee;                                  // 0x02E0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTransform                             SlotOffset_Thrown;                                 // 0x0310(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	int32 GetItemLevel() const;
	struct FTransform GetOffset_Melee() const;
	struct FTransform GetOffset_Primary() const;
	struct FTransform GetOffset_Secondary() const;
	struct FTransform GetOffset_SideArm() const;
	struct FTransform GetOffset_Thrown() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomEquipableItem">();
	}
	static class UCustomEquipableItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomEquipableItem>();
	}
};
static_assert(alignof(UCustomEquipableItem) == 0x000010, "Wrong alignment on UCustomEquipableItem");
static_assert(sizeof(UCustomEquipableItem) == 0x000340, "Wrong size on UCustomEquipableItem");
static_assert(offsetof(UCustomEquipableItem, ItemLevel) == 0x000240, "Member 'UCustomEquipableItem::ItemLevel' has a wrong offset!");
static_assert(offsetof(UCustomEquipableItem, SlotOffset_Primary) == 0x000250, "Member 'UCustomEquipableItem::SlotOffset_Primary' has a wrong offset!");
static_assert(offsetof(UCustomEquipableItem, SlotOffset_Secondary) == 0x000280, "Member 'UCustomEquipableItem::SlotOffset_Secondary' has a wrong offset!");
static_assert(offsetof(UCustomEquipableItem, SlotOffset_SideArm) == 0x0002B0, "Member 'UCustomEquipableItem::SlotOffset_SideArm' has a wrong offset!");
static_assert(offsetof(UCustomEquipableItem, SlotOffset_Melee) == 0x0002E0, "Member 'UCustomEquipableItem::SlotOffset_Melee' has a wrong offset!");
static_assert(offsetof(UCustomEquipableItem, SlotOffset_Thrown) == 0x000310, "Member 'UCustomEquipableItem::SlotOffset_Thrown' has a wrong offset!");

// Class TslGame.ThrowableItem
// 0x0018 (0x0258 - 0x0240)
class UThrowableItem final : public UEquipableItem
{
public:
	uint8                                         Pad_240[0x8];                                      // 0x0240(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATslWeapon>                 WeaponType;                                        // 0x0248(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATslWeapon*                             EquippedWeapon;                                    // 0x0250(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class ATslWeapon* GetDefaultWeaponObject() const;
	class ATslWeapon* GetEquippedWeapon() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThrowableItem">();
	}
	static class UThrowableItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThrowableItem>();
	}
};
static_assert(alignof(UThrowableItem) == 0x000008, "Wrong alignment on UThrowableItem");
static_assert(sizeof(UThrowableItem) == 0x000258, "Wrong size on UThrowableItem");
static_assert(offsetof(UThrowableItem, WeaponType) == 0x000248, "Member 'UThrowableItem::WeaponType' has a wrong offset!");
static_assert(offsetof(UThrowableItem, EquippedWeapon) == 0x000250, "Member 'UThrowableItem::EquippedWeapon' has a wrong offset!");

// Class TslGame.TslWeapon
// 0x0408 (0x07A8 - 0x03A0)
class ATslWeapon : public AActor
{
public:
	uint8                                         Pad_3A0[0x8];                                      // 0x03A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture*                               WeaponIcon;                                        // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponIconRatio;                                   // 0x03B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B4[0x4];                                      // 0x03B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCanvasIcon                            PrimaryIcon;                                       // 0x03B8(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCanvasIcon                            SecondaryIcon;                                     // 0x03D0(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCanvasIcon                            PrimaryClipIcon;                                   // 0x03E8(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCanvasIcon                            SecondaryClipIcon;                                 // 0x0400(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         AmmoIconsCount;                                    // 0x0418(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrimaryClipIconOffset;                             // 0x041C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecondaryClipIconOffset;                           // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_424[0x4];                                      // 0x0424(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCanvasIcon                            Crosshair[0x5];                                    // 0x0428(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FCanvasIcon                            AimingCrosshair[0x5];                              // 0x04A0(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          UseLaserDot;                                       // 0x0518(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCustomCrosshair;                                // 0x0519(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCustomAimingCrosshair;                          // 0x051A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideCrosshairWhileNotAiming;                      // 0x051B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51C[0x4];                                      // 0x051C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnUpdatedAttachment;                               // 0x0520(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ATslCharacter*                          MyPawn;                                            // 0x0530(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FWeaponData                            WeaponConfig;                                      // 0x0538(0x0090)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EWeaponHand                                   WeaponHand;                                        // 0x05C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C9[0x7];                                      // 0x05C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 Mesh3P;                                            // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        RootScene;                                         // 0x05D8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        HandIK_Left;                                       // 0x05E0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        HandIK_Right;                                      // 0x05E8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F0[0x1];                                      // 0x05F0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EAttachmentCalculateType                      AttachmentAniRateCalculateType;                    // 0x05F1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachmentCalculateType                      AttachmentRecoilPatternScaleCalculateType;         // 0x05F2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F3[0x5];                                      // 0x05F3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWeaponAttachmentPositionData>  AttachmentPositionData;                            // 0x05F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FWeaponAttachmentAssetData>     DefaultAttachedItemAssets;                         // 0x0608(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UAttachableItem>>    AttachedItemClasses;                               // 0x0618(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class FName                                   WeaponTag;                                         // 0x0628(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_630[0x18];                                     // 0x0630(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EWeaponAttachmentSlotID, class UAsyncStaticMeshComponent*> AttachedStaticComponentMap;                        // 0x0648(0x0050)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UAkComponent*                           AkComponent;                                       // 0x0698(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MuzzleAttachPoint;                                 // 0x06A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FiringAttachPoint;                                 // 0x06A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ScopingAttachPoint;                                // 0x06B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        MuzzleFx;                                          // 0x06B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ShellFxAttachPoint;                                // 0x06C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ATslParticle>               ShellFxClass;                                      // 0x06C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               MuzzlePSC;                                         // 0x06D0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               MuzzlePSCSecondary;                                // 0x06D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShake>               FireCameraShake;                                   // 0x06E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UForceFeedbackEffect*                   FireForceFeedback;                                 // 0x06E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          FireSoundAk;                                       // 0x06F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          FireLoopSoundAk;                                   // 0x06F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          FireFinishSoundAk;                                 // 0x0700(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          OutOfAmmoSoundAk;                                  // 0x0708(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          ReloadSoundAk;                                     // 0x0710(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          EquipSoundAk;                                      // 0x0718(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          AimingStartSoundAk;                                // 0x0720(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          AimingFinishSoundAk;                               // 0x0728(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          ScopingStartSoundAk;                               // 0x0730(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          ScopingFinishSoundAk;                              // 0x0738(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAnimWeaponType                               AnimWeaponType;                                    // 0x0740(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_741[0x7];                                      // 0x0741(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWeaponBasicAnim                       WeaponAnim;                                        // 0x0748(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FWeaponRollAnim                        ProneRollAnim;                                     // 0x0760(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         HipDuration;                                       // 0x0770(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bLoopedMuzzleFX : 1;                               // 0x0774(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bLoopedFireSound : 1;                              // 0x0774(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_775[0x33];                                     // 0x0775(0x0033)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttachWeaponToMesh();
	void AttachWeaponToSlot(int32 SlotIndex);
	void ClientInitByReconnection(bool bIsArmed);
	void OnAnimationNotify(const class FName& NotifyName);
	void OnRep_AttachedItemClasses();
	void OnRep_MyPawn();
	void ServerLogFireWeapon(const struct FAttackId& AttackId);
	void SetCurrentWeaponZero(float newZero);
	void SimulatePhysicalBodyHit(const struct FHitResult& Impact, const struct FVector& ShotDirection);
	void Weapon_AttachHand();
	void Weapon_AttachShoulder();

	TArray<struct FWeaponAttachmentAssetData> GetAllWeaponAttachmentAssets() const;
	TArray<struct FWeaponAttachmentData> GetAllWeaponAttachmentData() const;
	EAnimWeaponType GetAnimWeaponType() const;
	TArray<class UAsyncStaticMeshComponent*> GetAttachedMesh() const;
	float GetCurrentWeaponZero() const;
	bool GetDoGripPose() const;
	class USceneComponent* GetHandIK_Left() const;
	class USceneComponent* GetHandIK_Right() const;
	class FText GetItemName() const;
	struct FVector GetLowerRailOffset() const;
	class ATslCharacter* GetPawnOwner() const;
	class UAnimMontage* GetRecoilMontage() const;
	float GetStanceSwayModifier(EAnimStance Stance) const;
	struct FVector GetSwayModifier() const;
	EThrownWeaponType GetThrownType() const;
	float GetWeaponAnimationKick() const;
	const struct FWeaponAttachmentAssetData GetWeaponAttachmentAsset(EWeaponAttachmentSlotID SlotID) const;
	TArray<struct FWeaponAttachmentAssetData> GetWeaponAttachmentAssetDatas() const;
	const struct FWeaponAttachmentData GetWeaponAttachmentData(EWeaponAttachmentSlotID SlotID) const;
	class FName GetWeaponAttachmentPoint(EWeaponAttachmentSlotID SlotID, class FName Tag) const;
	EWeaponClass GetWeaponClassEnum() const;
	const struct FWeaponData GetWeaponConfig() const;
	float GetWeaponDamage() const;
	float GetWeaponEquipDuration() const;
	EWeaponGripLeftHand GetWeaponGripTypeLeft() const;
	class USkeletalMeshComponent* GetWeaponMesh() const;
	float GetWeaponReadyDuration() const;
	bool IsCustomSightAttached(EWeaponAttachmentSlotID SlotID) const;
	bool IsWeaponAttachedToShoulder() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslWeapon">();
	}
	static class ATslWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslWeapon>();
	}
};
static_assert(alignof(ATslWeapon) == 0x000008, "Wrong alignment on ATslWeapon");
static_assert(sizeof(ATslWeapon) == 0x0007A8, "Wrong size on ATslWeapon");
static_assert(offsetof(ATslWeapon, WeaponIcon) == 0x0003A8, "Member 'ATslWeapon::WeaponIcon' has a wrong offset!");
static_assert(offsetof(ATslWeapon, WeaponIconRatio) == 0x0003B0, "Member 'ATslWeapon::WeaponIconRatio' has a wrong offset!");
static_assert(offsetof(ATslWeapon, PrimaryIcon) == 0x0003B8, "Member 'ATslWeapon::PrimaryIcon' has a wrong offset!");
static_assert(offsetof(ATslWeapon, SecondaryIcon) == 0x0003D0, "Member 'ATslWeapon::SecondaryIcon' has a wrong offset!");
static_assert(offsetof(ATslWeapon, PrimaryClipIcon) == 0x0003E8, "Member 'ATslWeapon::PrimaryClipIcon' has a wrong offset!");
static_assert(offsetof(ATslWeapon, SecondaryClipIcon) == 0x000400, "Member 'ATslWeapon::SecondaryClipIcon' has a wrong offset!");
static_assert(offsetof(ATslWeapon, AmmoIconsCount) == 0x000418, "Member 'ATslWeapon::AmmoIconsCount' has a wrong offset!");
static_assert(offsetof(ATslWeapon, PrimaryClipIconOffset) == 0x00041C, "Member 'ATslWeapon::PrimaryClipIconOffset' has a wrong offset!");
static_assert(offsetof(ATslWeapon, SecondaryClipIconOffset) == 0x000420, "Member 'ATslWeapon::SecondaryClipIconOffset' has a wrong offset!");
static_assert(offsetof(ATslWeapon, Crosshair) == 0x000428, "Member 'ATslWeapon::Crosshair' has a wrong offset!");
static_assert(offsetof(ATslWeapon, AimingCrosshair) == 0x0004A0, "Member 'ATslWeapon::AimingCrosshair' has a wrong offset!");
static_assert(offsetof(ATslWeapon, UseLaserDot) == 0x000518, "Member 'ATslWeapon::UseLaserDot' has a wrong offset!");
static_assert(offsetof(ATslWeapon, UseCustomCrosshair) == 0x000519, "Member 'ATslWeapon::UseCustomCrosshair' has a wrong offset!");
static_assert(offsetof(ATslWeapon, UseCustomAimingCrosshair) == 0x00051A, "Member 'ATslWeapon::UseCustomAimingCrosshair' has a wrong offset!");
static_assert(offsetof(ATslWeapon, bHideCrosshairWhileNotAiming) == 0x00051B, "Member 'ATslWeapon::bHideCrosshairWhileNotAiming' has a wrong offset!");
static_assert(offsetof(ATslWeapon, OnUpdatedAttachment) == 0x000520, "Member 'ATslWeapon::OnUpdatedAttachment' has a wrong offset!");
static_assert(offsetof(ATslWeapon, MyPawn) == 0x000530, "Member 'ATslWeapon::MyPawn' has a wrong offset!");
static_assert(offsetof(ATslWeapon, WeaponConfig) == 0x000538, "Member 'ATslWeapon::WeaponConfig' has a wrong offset!");
static_assert(offsetof(ATslWeapon, WeaponHand) == 0x0005C8, "Member 'ATslWeapon::WeaponHand' has a wrong offset!");
static_assert(offsetof(ATslWeapon, Mesh3P) == 0x0005D0, "Member 'ATslWeapon::Mesh3P' has a wrong offset!");
static_assert(offsetof(ATslWeapon, RootScene) == 0x0005D8, "Member 'ATslWeapon::RootScene' has a wrong offset!");
static_assert(offsetof(ATslWeapon, HandIK_Left) == 0x0005E0, "Member 'ATslWeapon::HandIK_Left' has a wrong offset!");
static_assert(offsetof(ATslWeapon, HandIK_Right) == 0x0005E8, "Member 'ATslWeapon::HandIK_Right' has a wrong offset!");
static_assert(offsetof(ATslWeapon, AttachmentAniRateCalculateType) == 0x0005F1, "Member 'ATslWeapon::AttachmentAniRateCalculateType' has a wrong offset!");
static_assert(offsetof(ATslWeapon, AttachmentRecoilPatternScaleCalculateType) == 0x0005F2, "Member 'ATslWeapon::AttachmentRecoilPatternScaleCalculateType' has a wrong offset!");
static_assert(offsetof(ATslWeapon, AttachmentPositionData) == 0x0005F8, "Member 'ATslWeapon::AttachmentPositionData' has a wrong offset!");
static_assert(offsetof(ATslWeapon, DefaultAttachedItemAssets) == 0x000608, "Member 'ATslWeapon::DefaultAttachedItemAssets' has a wrong offset!");
static_assert(offsetof(ATslWeapon, AttachedItemClasses) == 0x000618, "Member 'ATslWeapon::AttachedItemClasses' has a wrong offset!");
static_assert(offsetof(ATslWeapon, WeaponTag) == 0x000628, "Member 'ATslWeapon::WeaponTag' has a wrong offset!");
static_assert(offsetof(ATslWeapon, AttachedStaticComponentMap) == 0x000648, "Member 'ATslWeapon::AttachedStaticComponentMap' has a wrong offset!");
static_assert(offsetof(ATslWeapon, AkComponent) == 0x000698, "Member 'ATslWeapon::AkComponent' has a wrong offset!");
static_assert(offsetof(ATslWeapon, MuzzleAttachPoint) == 0x0006A0, "Member 'ATslWeapon::MuzzleAttachPoint' has a wrong offset!");
static_assert(offsetof(ATslWeapon, FiringAttachPoint) == 0x0006A8, "Member 'ATslWeapon::FiringAttachPoint' has a wrong offset!");
static_assert(offsetof(ATslWeapon, ScopingAttachPoint) == 0x0006B0, "Member 'ATslWeapon::ScopingAttachPoint' has a wrong offset!");
static_assert(offsetof(ATslWeapon, MuzzleFx) == 0x0006B8, "Member 'ATslWeapon::MuzzleFx' has a wrong offset!");
static_assert(offsetof(ATslWeapon, ShellFxAttachPoint) == 0x0006C0, "Member 'ATslWeapon::ShellFxAttachPoint' has a wrong offset!");
static_assert(offsetof(ATslWeapon, ShellFxClass) == 0x0006C8, "Member 'ATslWeapon::ShellFxClass' has a wrong offset!");
static_assert(offsetof(ATslWeapon, MuzzlePSC) == 0x0006D0, "Member 'ATslWeapon::MuzzlePSC' has a wrong offset!");
static_assert(offsetof(ATslWeapon, MuzzlePSCSecondary) == 0x0006D8, "Member 'ATslWeapon::MuzzlePSCSecondary' has a wrong offset!");
static_assert(offsetof(ATslWeapon, FireCameraShake) == 0x0006E0, "Member 'ATslWeapon::FireCameraShake' has a wrong offset!");
static_assert(offsetof(ATslWeapon, FireForceFeedback) == 0x0006E8, "Member 'ATslWeapon::FireForceFeedback' has a wrong offset!");
static_assert(offsetof(ATslWeapon, FireSoundAk) == 0x0006F0, "Member 'ATslWeapon::FireSoundAk' has a wrong offset!");
static_assert(offsetof(ATslWeapon, FireLoopSoundAk) == 0x0006F8, "Member 'ATslWeapon::FireLoopSoundAk' has a wrong offset!");
static_assert(offsetof(ATslWeapon, FireFinishSoundAk) == 0x000700, "Member 'ATslWeapon::FireFinishSoundAk' has a wrong offset!");
static_assert(offsetof(ATslWeapon, OutOfAmmoSoundAk) == 0x000708, "Member 'ATslWeapon::OutOfAmmoSoundAk' has a wrong offset!");
static_assert(offsetof(ATslWeapon, ReloadSoundAk) == 0x000710, "Member 'ATslWeapon::ReloadSoundAk' has a wrong offset!");
static_assert(offsetof(ATslWeapon, EquipSoundAk) == 0x000718, "Member 'ATslWeapon::EquipSoundAk' has a wrong offset!");
static_assert(offsetof(ATslWeapon, AimingStartSoundAk) == 0x000720, "Member 'ATslWeapon::AimingStartSoundAk' has a wrong offset!");
static_assert(offsetof(ATslWeapon, AimingFinishSoundAk) == 0x000728, "Member 'ATslWeapon::AimingFinishSoundAk' has a wrong offset!");
static_assert(offsetof(ATslWeapon, ScopingStartSoundAk) == 0x000730, "Member 'ATslWeapon::ScopingStartSoundAk' has a wrong offset!");
static_assert(offsetof(ATslWeapon, ScopingFinishSoundAk) == 0x000738, "Member 'ATslWeapon::ScopingFinishSoundAk' has a wrong offset!");
static_assert(offsetof(ATslWeapon, AnimWeaponType) == 0x000740, "Member 'ATslWeapon::AnimWeaponType' has a wrong offset!");
static_assert(offsetof(ATslWeapon, WeaponAnim) == 0x000748, "Member 'ATslWeapon::WeaponAnim' has a wrong offset!");
static_assert(offsetof(ATslWeapon, ProneRollAnim) == 0x000760, "Member 'ATslWeapon::ProneRollAnim' has a wrong offset!");
static_assert(offsetof(ATslWeapon, HipDuration) == 0x000770, "Member 'ATslWeapon::HipDuration' has a wrong offset!");

// Class TslGame.WeaponItem
// 0x0050 (0x0290 - 0x0240)
class UWeaponItem final : public UEquipableItem
{
public:
	uint8                                         Pad_240[0x8];                                      // 0x0240(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATslWeapon>                 WeaponType;                                        // 0x0248(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmmoCount;                                         // 0x0250(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmmoPerClip;                                       // 0x0254(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FWeaponAttachmentTagData>       AttachmentTagData;                                 // 0x0258(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   WeaponTag;                                         // 0x0268(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAttachableItem*>                AttachedItems;                                     // 0x0270(0x0010)(Net, ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	EFiringMode                                   FiringMode;                                        // 0x0280(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_281[0x7];                                      // 0x0281(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ATslWeapon*                             EquippedWeapon;                                    // 0x0288(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool AttachItem(class UAttachableItem* Item);
	class UAttachableItem* DetachItem(EWeaponAttachmentSlotID SlotID);
	void SetFiringMode(EFiringMode fMode);

	TArray<class UAttachableItem*> GetAllAttachedItems() const;
	int32 GetAttachableItemCount() const;
	class UAttachableItem* GetAttachedItem(EWeaponAttachmentSlotID SlotID) const;
	class ATslWeapon* GetDefaultWeaponObject() const;
	class ATslWeapon* GetEquippedWeapon() const;
	EFiringMode GetFiringMode() const;
	bool HasAttachmentSlot(EWeaponAttachmentSlotID SlotID) const;
	bool IsAttachable(class UAttachableItem* Item) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponItem">();
	}
	static class UWeaponItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponItem>();
	}
};
static_assert(alignof(UWeaponItem) == 0x000008, "Wrong alignment on UWeaponItem");
static_assert(sizeof(UWeaponItem) == 0x000290, "Wrong size on UWeaponItem");
static_assert(offsetof(UWeaponItem, WeaponType) == 0x000248, "Member 'UWeaponItem::WeaponType' has a wrong offset!");
static_assert(offsetof(UWeaponItem, AmmoCount) == 0x000250, "Member 'UWeaponItem::AmmoCount' has a wrong offset!");
static_assert(offsetof(UWeaponItem, AmmoPerClip) == 0x000254, "Member 'UWeaponItem::AmmoPerClip' has a wrong offset!");
static_assert(offsetof(UWeaponItem, AttachmentTagData) == 0x000258, "Member 'UWeaponItem::AttachmentTagData' has a wrong offset!");
static_assert(offsetof(UWeaponItem, WeaponTag) == 0x000268, "Member 'UWeaponItem::WeaponTag' has a wrong offset!");
static_assert(offsetof(UWeaponItem, AttachedItems) == 0x000270, "Member 'UWeaponItem::AttachedItems' has a wrong offset!");
static_assert(offsetof(UWeaponItem, FiringMode) == 0x000280, "Member 'UWeaponItem::FiringMode' has a wrong offset!");
static_assert(offsetof(UWeaponItem, EquippedWeapon) == 0x000288, "Member 'UWeaponItem::EquippedWeapon' has a wrong offset!");

// Class TslGame.RandomlyGeneratableItem
// 0x0068 (0x01F0 - 0x0188)
class URandomlyGeneratableItem final : public UItem
{
public:
	class FString                                 RandomExpression;                                  // 0x0188(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bOpenByKey : 1;                                    // 0x0198(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bOpenByPoint : 1;                                  // 0x0198(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_199[0x7];                                      // 0x0199(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   OpenKeyItem;                                       // 0x01A0(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OpenKeyItemCount;                                  // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PointOpenPrice;                                    // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExchangeBundleId;                                  // 0x01C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CC[0x4];                                      // 0x01CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLobbyItemBundle>               BundleList;                                        // 0x01D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           ReferenceItems;                                    // 0x01E0(0x0010)(Edit, ZeroConstructor, EditConst, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RandomlyGeneratableItem">();
	}
	static class URandomlyGeneratableItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<URandomlyGeneratableItem>();
	}
};
static_assert(alignof(URandomlyGeneratableItem) == 0x000008, "Wrong alignment on URandomlyGeneratableItem");
static_assert(sizeof(URandomlyGeneratableItem) == 0x0001F0, "Wrong size on URandomlyGeneratableItem");
static_assert(offsetof(URandomlyGeneratableItem, RandomExpression) == 0x000188, "Member 'URandomlyGeneratableItem::RandomExpression' has a wrong offset!");
static_assert(offsetof(URandomlyGeneratableItem, OpenKeyItem) == 0x0001A0, "Member 'URandomlyGeneratableItem::OpenKeyItem' has a wrong offset!");
static_assert(offsetof(URandomlyGeneratableItem, OpenKeyItemCount) == 0x0001C0, "Member 'URandomlyGeneratableItem::OpenKeyItemCount' has a wrong offset!");
static_assert(offsetof(URandomlyGeneratableItem, PointOpenPrice) == 0x0001C4, "Member 'URandomlyGeneratableItem::PointOpenPrice' has a wrong offset!");
static_assert(offsetof(URandomlyGeneratableItem, ExchangeBundleId) == 0x0001C8, "Member 'URandomlyGeneratableItem::ExchangeBundleId' has a wrong offset!");
static_assert(offsetof(URandomlyGeneratableItem, BundleList) == 0x0001D0, "Member 'URandomlyGeneratableItem::BundleList' has a wrong offset!");
static_assert(offsetof(URandomlyGeneratableItem, ReferenceItems) == 0x0001E0, "Member 'URandomlyGeneratableItem::ReferenceItems' has a wrong offset!");

// Class TslGame.UseByPickupItem
// 0x0000 (0x0188 - 0x0188)
class UUseByPickupItem final : public UItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UseByPickupItem">();
	}
	static class UUseByPickupItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUseByPickupItem>();
	}
};
static_assert(alignof(UUseByPickupItem) == 0x000008, "Wrong alignment on UUseByPickupItem");
static_assert(sizeof(UUseByPickupItem) == 0x000188, "Wrong size on UUseByPickupItem");

// Class TslGame.ItemSpawnProcessor
// 0x0010 (0x0038 - 0x0028)
class UItemSpawnProcessor : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ProcessGroup(class UItemSpotGroupComponent* SpotGroup, const TArray<class UItemSpotComponent*>& Spots);
	void ProcessSpawnItem(class UItemSpotGroupComponent* Spawner);

	bool CheckItemGroup(class UItemSpotGroupComponent* SpotGroup) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSpawnProcessor">();
	}
	static class UItemSpawnProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemSpawnProcessor>();
	}
};
static_assert(alignof(UItemSpawnProcessor) == 0x000008, "Wrong alignment on UItemSpawnProcessor");
static_assert(sizeof(UItemSpawnProcessor) == 0x000038, "Wrong size on UItemSpawnProcessor");

// Class TslGame.SpawnTableItemSpawnProcessor
// 0x0F30 (0x0F68 - 0x0038)
class USpawnTableItemSpawnProcessor final : public UItemSpawnProcessor
{
public:
	TArray<struct FItemSpotGroupTypeProperty>     RawSpotGroupProperties;                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             RawItemSpawnDataTable;                             // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             RawItemSpawnTogetherDataTable;                     // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0xEB8];                                     // 0x0058(0x0EB8)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseActorSpawn;                                    // 0x0F10(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F11[0x57];                                     // 0x0F11(0x0057)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnTableItemSpawnProcessor">();
	}
	static class USpawnTableItemSpawnProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnTableItemSpawnProcessor>();
	}
};
static_assert(alignof(USpawnTableItemSpawnProcessor) == 0x000008, "Wrong alignment on USpawnTableItemSpawnProcessor");
static_assert(sizeof(USpawnTableItemSpawnProcessor) == 0x000F68, "Wrong size on USpawnTableItemSpawnProcessor");
static_assert(offsetof(USpawnTableItemSpawnProcessor, RawSpotGroupProperties) == 0x000038, "Member 'USpawnTableItemSpawnProcessor::RawSpotGroupProperties' has a wrong offset!");
static_assert(offsetof(USpawnTableItemSpawnProcessor, RawItemSpawnDataTable) == 0x000048, "Member 'USpawnTableItemSpawnProcessor::RawItemSpawnDataTable' has a wrong offset!");
static_assert(offsetof(USpawnTableItemSpawnProcessor, RawItemSpawnTogetherDataTable) == 0x000050, "Member 'USpawnTableItemSpawnProcessor::RawItemSpawnTogetherDataTable' has a wrong offset!");
static_assert(offsetof(USpawnTableItemSpawnProcessor, bUseActorSpawn) == 0x000F10, "Member 'USpawnTableItemSpawnProcessor::bUseActorSpawn' has a wrong offset!");

// Class TslGame.ItemSpot
// 0x0008 (0x03A8 - 0x03A0)
class AItemSpot final : public AActor
{
public:
	class UItemSpotGroupComponent*                SpotGroupComponent;                                // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSpot">();
	}
	static class AItemSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemSpot>();
	}
};
static_assert(alignof(AItemSpot) == 0x000008, "Wrong alignment on AItemSpot");
static_assert(sizeof(AItemSpot) == 0x0003A8, "Wrong size on AItemSpot");
static_assert(offsetof(AItemSpot, SpotGroupComponent) == 0x0003A0, "Member 'AItemSpot::SpotGroupComponent' has a wrong offset!");

// Class TslGame.ItemSpotComponent
// 0x0010 (0x0310 - 0x0300)
class UItemSpotComponent final : public USceneComponent
{
public:
	EItemSpotType                                 ItemSpotType;                                      // 0x0300(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_301[0xF];                                      // 0x0301(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSpotComponent">();
	}
	static class UItemSpotComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemSpotComponent>();
	}
};
static_assert(alignof(UItemSpotComponent) == 0x000008, "Wrong alignment on UItemSpotComponent");
static_assert(sizeof(UItemSpotComponent) == 0x000310, "Wrong size on UItemSpotComponent");
static_assert(offsetof(UItemSpotComponent, ItemSpotType) == 0x000300, "Member 'UItemSpotComponent::ItemSpotType' has a wrong offset!");

// Class TslGame.ItemSpotGroupComponent
// 0x0010 (0x0310 - 0x0300)
class UItemSpotGroupComponent final : public USceneComponent
{
public:
	EItemSpotGroupType                            SpotGroupType;                                     // 0x0300(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_301[0xF];                                      // 0x0301(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSpotGroupComponent">();
	}
	static class UItemSpotGroupComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemSpotGroupComponent>();
	}
};
static_assert(alignof(UItemSpotGroupComponent) == 0x000008, "Wrong alignment on UItemSpotGroupComponent");
static_assert(sizeof(UItemSpotGroupComponent) == 0x000310, "Wrong size on UItemSpotGroupComponent");
static_assert(offsetof(UItemSpotGroupComponent, SpotGroupType) == 0x000300, "Member 'UItemSpotGroupComponent::SpotGroupType' has a wrong offset!");

// Class TslGame.ItemStudio
// 0x0060 (0x0400 - 0x03A0)
class AItemStudio : public AActor
{
public:
	class FName                                   CameraSocketName;                                  // 0x03A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 TextureTarget;                                     // 0x03A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxViewDistance;                                   // 0x03B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B4[0x4];                                      // 0x03B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       CameraComponent;                                   // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneCaptureComponent2D*               SceneCaptureComponent;                             // 0x03C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C8[0x8];                                      // 0x03C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             DefaultCameraSocketTransform;                      // 0x03D0(0x0030)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void AddYaw(float Value);
	void SetItem(class UItem* Item);
	void SetTextureRenderTarget(class UTextureRenderTarget2D* NewTextureTarget);
	void UpdateComponentToWorld(class UMeshComponent* Mesh);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemStudio">();
	}
	static class AItemStudio* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemStudio>();
	}
};
static_assert(alignof(AItemStudio) == 0x000010, "Wrong alignment on AItemStudio");
static_assert(sizeof(AItemStudio) == 0x000400, "Wrong size on AItemStudio");
static_assert(offsetof(AItemStudio, CameraSocketName) == 0x0003A0, "Member 'AItemStudio::CameraSocketName' has a wrong offset!");
static_assert(offsetof(AItemStudio, TextureTarget) == 0x0003A8, "Member 'AItemStudio::TextureTarget' has a wrong offset!");
static_assert(offsetof(AItemStudio, MaxViewDistance) == 0x0003B0, "Member 'AItemStudio::MaxViewDistance' has a wrong offset!");
static_assert(offsetof(AItemStudio, CameraComponent) == 0x0003B8, "Member 'AItemStudio::CameraComponent' has a wrong offset!");
static_assert(offsetof(AItemStudio, SceneCaptureComponent) == 0x0003C0, "Member 'AItemStudio::SceneCaptureComponent' has a wrong offset!");
static_assert(offsetof(AItemStudio, DefaultCameraSocketTransform) == 0x0003D0, "Member 'AItemStudio::DefaultCameraSocketTransform' has a wrong offset!");

// Class TslGame.ItemToolTipWidget
// 0x0000 (0x0240 - 0x0240)
class UItemToolTipWidget : public UUserWidget
{
public:
	void UpdateEquipmentSlotItemToolTip(class UEquipableItem* EquipableItem);
	void UpdateSlotInfo(const TScriptInterface<class ISlotInterface>& SlotInterface);
	void UpdateToolTipBySlotInterface(TScriptInterface<class ISlotInterface> SlotInterface, TScriptInterface<class ISlotContainerInterface> Container);
	void UpdateVicinityOrInventorySlotItemToolTip(class UEquipableItem* EquipableItem, class UEquipableItem* EquipmentSlotItem);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemToolTipWidget">();
	}
	static class UItemToolTipWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemToolTipWidget>();
	}
};
static_assert(alignof(UItemToolTipWidget) == 0x000008, "Wrong alignment on UItemToolTipWidget");
static_assert(sizeof(UItemToolTipWidget) == 0x000240, "Wrong size on UItemToolTipWidget");

// Class TslGame.LevelAttribute
// 0x0020 (0x03C0 - 0x03A0)
class ALevelAttribute final : public AInfo
{
public:
	int32                                         NumMapBlock;                                       // 0x03A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox2D                                 MapRect2D;                                         // 0x03A4(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     MapImageMaterial;                                  // 0x03B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelAttribute">();
	}
	static class ALevelAttribute* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALevelAttribute>();
	}
};
static_assert(alignof(ALevelAttribute) == 0x000008, "Wrong alignment on ALevelAttribute");
static_assert(sizeof(ALevelAttribute) == 0x0003C0, "Wrong size on ALevelAttribute");
static_assert(offsetof(ALevelAttribute, NumMapBlock) == 0x0003A0, "Member 'ALevelAttribute::NumMapBlock' has a wrong offset!");
static_assert(offsetof(ALevelAttribute, MapRect2D) == 0x0003A4, "Member 'ALevelAttribute::MapRect2D' has a wrong offset!");
static_assert(offsetof(ALevelAttribute, MapImageMaterial) == 0x0003B8, "Member 'ALevelAttribute::MapImageMaterial' has a wrong offset!");

// Class TslGame.LobbyItemBundleIdPublisher
// 0x0028 (0x0050 - 0x0028)
class ULobbyItemBundleIdPublisher final : public UObject
{
public:
	class FString                                 LobbyItemPath;                                     // 0x0028(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyItemBundleIdPublisher">();
	}
	static class ULobbyItemBundleIdPublisher* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyItemBundleIdPublisher>();
	}
};
static_assert(alignof(ULobbyItemBundleIdPublisher) == 0x000008, "Wrong alignment on ULobbyItemBundleIdPublisher");
static_assert(sizeof(ULobbyItemBundleIdPublisher) == 0x000050, "Wrong size on ULobbyItemBundleIdPublisher");
static_assert(offsetof(ULobbyItemBundleIdPublisher, LobbyItemPath) == 0x000028, "Member 'ULobbyItemBundleIdPublisher::LobbyItemPath' has a wrong offset!");

// Class TslGame.LobbyLink
// 0x00A8 (0x00D0 - 0x0028)
class ULobbyLink final : public UObject
{
public:
	uint8                                         Pad_28[0xA8];                                      // 0x0028(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyLink">();
	}
	static class ULobbyLink* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyLink>();
	}
};
static_assert(alignof(ULobbyLink) == 0x000008, "Wrong alignment on ULobbyLink");
static_assert(sizeof(ULobbyLink) == 0x0000D0, "Wrong size on ULobbyLink");

// Class TslGame.LobbyWidget
// 0x0000 (0x0240 - 0x0240)
class ULobbyWidget : public UUserWidget
{
public:
	void GameStateChanging(class FName NewState, class FName OldState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyWidget">();
	}
	static class ULobbyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyWidget>();
	}
};
static_assert(alignof(ULobbyWidget) == 0x000008, "Wrong alignment on ULobbyWidget");
static_assert(sizeof(ULobbyWidget) == 0x000240, "Wrong size on ULobbyWidget");

// Class TslGame.MatchPreparer
// 0x0030 (0x0058 - 0x0028)
class UMatchPreparer : public UObject
{
public:
	int32                                         WarmupTime;                                        // 0x0028(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WarmupTimeInPIE;                                   // 0x002C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void TimerGameStartCountDown();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchPreparer">();
	}
	static class UMatchPreparer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchPreparer>();
	}
};
static_assert(alignof(UMatchPreparer) == 0x000008, "Wrong alignment on UMatchPreparer");
static_assert(sizeof(UMatchPreparer) == 0x000058, "Wrong size on UMatchPreparer");
static_assert(offsetof(UMatchPreparer, WarmupTime) == 0x000028, "Member 'UMatchPreparer::WarmupTime' has a wrong offset!");
static_assert(offsetof(UMatchPreparer, WarmupTimeInPIE) == 0x00002C, "Member 'UMatchPreparer::WarmupTimeInPIE' has a wrong offset!");

// Class TslGame.AirborneMatchPreparer
// 0x0048 (0x00A0 - 0x0058)
class UAirborneMatchPreparer final : public UMatchPreparer
{
public:
	TSubclassOf<class ATransportAircraftVehicle>  AircraftClass;                                     // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class ATransportAircraftVehicle*>      Aircrafts;                                         // 0x0060(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	int32                                         AircraftCount;                                     // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AircraftCapacityOverride;                          // 0x0074(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AircraftAltitude;                                  // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EndThetaDegree;                                    // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AircraftIntervalDistance;                          // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_84[0x1C];                                      // 0x0084(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AllowDealDamage();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AirborneMatchPreparer">();
	}
	static class UAirborneMatchPreparer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAirborneMatchPreparer>();
	}
};
static_assert(alignof(UAirborneMatchPreparer) == 0x000008, "Wrong alignment on UAirborneMatchPreparer");
static_assert(sizeof(UAirborneMatchPreparer) == 0x0000A0, "Wrong size on UAirborneMatchPreparer");
static_assert(offsetof(UAirborneMatchPreparer, AircraftClass) == 0x000058, "Member 'UAirborneMatchPreparer::AircraftClass' has a wrong offset!");
static_assert(offsetof(UAirborneMatchPreparer, Aircrafts) == 0x000060, "Member 'UAirborneMatchPreparer::Aircrafts' has a wrong offset!");
static_assert(offsetof(UAirborneMatchPreparer, AircraftCount) == 0x000070, "Member 'UAirborneMatchPreparer::AircraftCount' has a wrong offset!");
static_assert(offsetof(UAirborneMatchPreparer, AircraftCapacityOverride) == 0x000074, "Member 'UAirborneMatchPreparer::AircraftCapacityOverride' has a wrong offset!");
static_assert(offsetof(UAirborneMatchPreparer, AircraftAltitude) == 0x000078, "Member 'UAirborneMatchPreparer::AircraftAltitude' has a wrong offset!");
static_assert(offsetof(UAirborneMatchPreparer, EndThetaDegree) == 0x00007C, "Member 'UAirborneMatchPreparer::EndThetaDegree' has a wrong offset!");
static_assert(offsetof(UAirborneMatchPreparer, AircraftIntervalDistance) == 0x000080, "Member 'UAirborneMatchPreparer::AircraftIntervalDistance' has a wrong offset!");

// Class TslGame.NormalMatchPreparer
// 0x0018 (0x0070 - 0x0058)
class UNormalMatchPreparer final : public UMatchPreparer
{
public:
	uint8                                         Pad_58[0x10];                                      // 0x0058(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AvailablePlayerStartCount;                         // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NormalMatchPreparer">();
	}
	static class UNormalMatchPreparer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNormalMatchPreparer>();
	}
};
static_assert(alignof(UNormalMatchPreparer) == 0x000008, "Wrong alignment on UNormalMatchPreparer");
static_assert(sizeof(UNormalMatchPreparer) == 0x000070, "Wrong size on UNormalMatchPreparer");
static_assert(offsetof(UNormalMatchPreparer, AvailablePlayerStartCount) == 0x000068, "Member 'UNormalMatchPreparer::AvailablePlayerStartCount' has a wrong offset!");

// Class TslGame.MaterialMergeSettings
// 0x0080 (0x00A8 - 0x0028)
class UMaterialMergeSettings final : public UObject
{
public:
	uint8                                         Pad_28[0x58];                                      // 0x0028(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterial*                              MasterMaterial;                                    // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterial*                              MergedMaterial;                                    // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FMaterialMergerParameters>      ParameterList;                                     // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bUpdateParameterList;                              // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialMergeSettings">();
	}
	static class UMaterialMergeSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialMergeSettings>();
	}
};
static_assert(alignof(UMaterialMergeSettings) == 0x000008, "Wrong alignment on UMaterialMergeSettings");
static_assert(sizeof(UMaterialMergeSettings) == 0x0000A8, "Wrong size on UMaterialMergeSettings");
static_assert(offsetof(UMaterialMergeSettings, MasterMaterial) == 0x000080, "Member 'UMaterialMergeSettings::MasterMaterial' has a wrong offset!");
static_assert(offsetof(UMaterialMergeSettings, MergedMaterial) == 0x000088, "Member 'UMaterialMergeSettings::MergedMaterial' has a wrong offset!");
static_assert(offsetof(UMaterialMergeSettings, ParameterList) == 0x000090, "Member 'UMaterialMergeSettings::ParameterList' has a wrong offset!");
static_assert(offsetof(UMaterialMergeSettings, bUpdateParameterList) == 0x0000A0, "Member 'UMaterialMergeSettings::bUpdateParameterList' has a wrong offset!");

// Class TslGame.ModeController
// 0x0000 (0x0498 - 0x0498)
class AModeController : public AAIController
{
public:
	bool HandleServerAdminBlueprint(const class FString& AdminCommand);
	void SendSystemMessageToAll(ESystemMessageType MessageType, const class FText& Message, float MessageDuration);

	bool CanDealDamage(const class ATslPlayerState* DamageInstigator, const class ATslPlayerState* DamagedPlayer) const;
	class ATslGameMode* GetGameMode() const;
	class ATslGameState* GetGameState() const;
	bool IsPlayInEditor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModeController">();
	}
	static class AModeController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AModeController>();
	}
};
static_assert(alignof(AModeController) == 0x000008, "Wrong alignment on AModeController");
static_assert(sizeof(AModeController) == 0x000498, "Wrong size on AModeController");

// Class TslGame.BattleRoyaleModeController
// 0x0080 (0x0518 - 0x0498)
class ABattleRoyaleModeController final : public AModeController
{
public:
	TArray<struct FBattleRoyalePoisionGasData>    NormalPoisonGasDataArray;                          // 0x0498(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBattleRoyalePoisionGasData>    FastPoisonGasDataArray;                            // 0x04A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         FastZonePlayerCount;                               // 0x04B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BattleRoyaleZoneTypeCheckTime;                     // 0x04BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 PoisonWarningTime;                                 // 0x04C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         WaterVolumeRayHeight;                              // 0x04D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D4[0xC];                                      // 0x04D4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATslPhysicsVolume*>              OceanPhysicsVolume;                                // 0x04E0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ATslPassBluezoneArea*>           PassBluezoneAreas;                                 // 0x04F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_500[0x18];                                     // 0x0500(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitRadius();
	bool SetNextGasInBlackboard();

	int32 GetMaxPhaseCount() const;
	float GetPoisonGasDamagePerSecond() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleRoyaleModeController">();
	}
	static class ABattleRoyaleModeController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattleRoyaleModeController>();
	}
};
static_assert(alignof(ABattleRoyaleModeController) == 0x000008, "Wrong alignment on ABattleRoyaleModeController");
static_assert(sizeof(ABattleRoyaleModeController) == 0x000518, "Wrong size on ABattleRoyaleModeController");
static_assert(offsetof(ABattleRoyaleModeController, NormalPoisonGasDataArray) == 0x000498, "Member 'ABattleRoyaleModeController::NormalPoisonGasDataArray' has a wrong offset!");
static_assert(offsetof(ABattleRoyaleModeController, FastPoisonGasDataArray) == 0x0004A8, "Member 'ABattleRoyaleModeController::FastPoisonGasDataArray' has a wrong offset!");
static_assert(offsetof(ABattleRoyaleModeController, FastZonePlayerCount) == 0x0004B8, "Member 'ABattleRoyaleModeController::FastZonePlayerCount' has a wrong offset!");
static_assert(offsetof(ABattleRoyaleModeController, BattleRoyaleZoneTypeCheckTime) == 0x0004BC, "Member 'ABattleRoyaleModeController::BattleRoyaleZoneTypeCheckTime' has a wrong offset!");
static_assert(offsetof(ABattleRoyaleModeController, PoisonWarningTime) == 0x0004C0, "Member 'ABattleRoyaleModeController::PoisonWarningTime' has a wrong offset!");
static_assert(offsetof(ABattleRoyaleModeController, WaterVolumeRayHeight) == 0x0004D0, "Member 'ABattleRoyaleModeController::WaterVolumeRayHeight' has a wrong offset!");
static_assert(offsetof(ABattleRoyaleModeController, OceanPhysicsVolume) == 0x0004E0, "Member 'ABattleRoyaleModeController::OceanPhysicsVolume' has a wrong offset!");
static_assert(offsetof(ABattleRoyaleModeController, PassBluezoneAreas) == 0x0004F0, "Member 'ABattleRoyaleModeController::PassBluezoneAreas' has a wrong offset!");

// Class TslGame.CarePackageController
// 0x0030 (0x04C8 - 0x0498)
class ACarePackageController final : public AModeController
{
public:
	TSubclassOf<class 
AAircraftCarePackage>       AircraftCarePackageClass;                          // 0x0498(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              StartDelay;                                        // 0x04A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              SpawnInterval;                                     // 0x04A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         FlyingHeight;                                      // 0x04B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CarePackageLifeTime;                               // 0x04B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WhiteZoneSpawnInnerRate;                           // 0x04B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DropAreaRate;                                      // 0x04BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C0[0x8];                                      // 0x04C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitCarePackageSetting();
	bool SetNextCarePackageInBlackboard();
	struct FVector SpawnAircraftCarePackage(bool CopyIntersectionInfo);

	float GetSpawnInterval() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CarePackageController">();
	}
	static class ACarePackageController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACarePackageController>();
	}
};
static_assert(alignof(ACarePackageController) == 0x000008, "Wrong alignment on ACarePackageController");
static_assert(sizeof(ACarePackageController) == 0x0004C8, "Wrong size on ACarePackageController");
static_assert(offsetof(ACarePackageController, AircraftCarePackageClass) == 0x000498, "Member 'ACarePackageController::AircraftCarePackageClass' has a wrong offset!");
static_assert(offsetof(ACarePackageController, StartDelay) == 0x0004A0, "Member 'ACarePackageController::StartDelay' has a wrong offset!");
static_assert(offsetof(ACarePackageController, SpawnInterval) == 0x0004A8, "Member 'ACarePackageController::SpawnInterval' has a wrong offset!");
static_assert(offsetof(ACarePackageController, FlyingHeight) == 0x0004B0, "Member 'ACarePackageController::FlyingHeight' has a wrong offset!");
static_assert(offsetof(ACarePackageController, CarePackageLifeTime) == 0x0004B4, "Member 'ACarePackageController::CarePackageLifeTime' has a wrong offset!");
static_assert(offsetof(ACarePackageController, WhiteZoneSpawnInnerRate) == 0x0004B8, "Member 'ACarePackageController::WhiteZoneSpawnInnerRate' has a wrong offset!");
static_assert(offsetof(ACarePackageController, DropAreaRate) == 0x0004BC, "Member 'ACarePackageController::DropAreaRate' has a wrong offset!");

// Class TslGame.RedZoneController
// 0x0080 (0x0518 - 0x0498)
class ARedZoneController final : public AModeController
{
public:
	TSubclassOf<class ATslProjectile>             BombTemplateClass;                                 // 0x0498(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StartDelay;                                        // 0x04A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              NextCreateRedZoneInterval;                         // 0x04A4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         BombingDelay;                                      // 0x04AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OuterRadius;                                       // 0x04B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              LimitExceptExplosionRadius;                        // 0x04B4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         ExceptExplosionRadius;                             // 0x04BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RedZoneDuration;                                   // 0x04C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              BombingInterval;                                   // 0x04C4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         RedZoneLifeTime;                                   // 0x04CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReyStartHeight;                                    // 0x04D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RedZoneRadiusOffsetRate;                           // 0x04D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   RedZoneStartText;                                  // 0x04D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	int32                                         RedZoneProjectileCount;                            // 0x04F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RayCheckAroundLength;                              // 0x04F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F8[0x10];                                     // 0x04F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATslPhysicsVolume*>              OceanPhysicsVolume;                                // 0x0508(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	void InitRedZoneSetting();
	bool SetNextRedZoneInBlackboard();
	void SpawnBombProjectile();

	float GetRandomBombingInterval() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RedZoneController">();
	}
	static class ARedZoneController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARedZoneController>();
	}
};
static_assert(alignof(ARedZoneController) == 0x000008, "Wrong alignment on ARedZoneController");
static_assert(sizeof(ARedZoneController) == 0x000518, "Wrong size on ARedZoneController");
static_assert(offsetof(ARedZoneController, BombTemplateClass) == 0x000498, "Member 'ARedZoneController::BombTemplateClass' has a wrong offset!");
static_assert(offsetof(ARedZoneController, StartDelay) == 0x0004A0, "Member 'ARedZoneController::StartDelay' has a wrong offset!");
static_assert(offsetof(ARedZoneController, NextCreateRedZoneInterval) == 0x0004A4, "Member 'ARedZoneController::NextCreateRedZoneInterval' has a wrong offset!");
static_assert(offsetof(ARedZoneController, BombingDelay) == 0x0004AC, "Member 'ARedZoneController::BombingDelay' has a wrong offset!");
static_assert(offsetof(ARedZoneController, OuterRadius) == 0x0004B0, "Member 'ARedZoneController::OuterRadius' has a wrong offset!");
static_assert(offsetof(ARedZoneController, LimitExceptExplosionRadius) == 0x0004B4, "Member 'ARedZoneController::LimitExceptExplosionRadius' has a wrong offset!");
static_assert(offsetof(ARedZoneController, ExceptExplosionRadius) == 0x0004BC, "Member 'ARedZoneController::ExceptExplosionRadius' has a wrong offset!");
static_assert(offsetof(ARedZoneController, RedZoneDuration) == 0x0004C0, "Member 'ARedZoneController::RedZoneDuration' has a wrong offset!");
static_assert(offsetof(ARedZoneController, BombingInterval) == 0x0004C4, "Member 'ARedZoneController::BombingInterval' has a wrong offset!");
static_assert(offsetof(ARedZoneController, RedZoneLifeTime) == 0x0004CC, "Member 'ARedZoneController::RedZoneLifeTime' has a wrong offset!");
static_assert(offsetof(ARedZoneController, ReyStartHeight) == 0x0004D0, "Member 'ARedZoneController::ReyStartHeight' has a wrong offset!");
static_assert(offsetof(ARedZoneController, RedZoneRadiusOffsetRate) == 0x0004D4, "Member 'ARedZoneController::RedZoneRadiusOffsetRate' has a wrong offset!");
static_assert(offsetof(ARedZoneController, RedZoneStartText) == 0x0004D8, "Member 'ARedZoneController::RedZoneStartText' has a wrong offset!");
static_assert(offsetof(ARedZoneController, RedZoneProjectileCount) == 0x0004F0, "Member 'ARedZoneController::RedZoneProjectileCount' has a wrong offset!");
static_assert(offsetof(ARedZoneController, RayCheckAroundLength) == 0x0004F4, "Member 'ARedZoneController::RayCheckAroundLength' has a wrong offset!");
static_assert(offsetof(ARedZoneController, OceanPhysicsVolume) == 0x000508, "Member 'ARedZoneController::OceanPhysicsVolume' has a wrong offset!");

// Class TslGame.MutableCharacter
// 0x0050 (0x0810 - 0x07C0)
class AMutableCharacter : public ACharacter
{
public:
	uint8                                         Pad_7C0[0x20];                                     // 0x07C0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	EGender                                       Gender;                                            // 0x07E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7E1[0x7];                                      // 0x07E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCustomizableObjectInstance*            CustomizableObjectInstance;                        // 0x07E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTslCustomizableSkeletalComponent*      CustomizableSkeletalComponent;                     // 0x07F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<uint8>                                 InstanceDescriptor;                                // 0x07F8(0x0010)(Edit, Net, ZeroConstructor, EditConst, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_808[0x8];                                      // 0x0808(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_InstanceDescriptor();
	void UpdateAppearence();

	EGender GetGender() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MutableCharacter">();
	}
	static class AMutableCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMutableCharacter>();
	}
};
static_assert(alignof(AMutableCharacter) == 0x000010, "Wrong alignment on AMutableCharacter");
static_assert(sizeof(AMutableCharacter) == 0x000810, "Wrong size on AMutableCharacter");
static_assert(offsetof(AMutableCharacter, Gender) == 0x0007E0, "Member 'AMutableCharacter::Gender' has a wrong offset!");
static_assert(offsetof(AMutableCharacter, CustomizableObjectInstance) == 0x0007E8, "Member 'AMutableCharacter::CustomizableObjectInstance' has a wrong offset!");
static_assert(offsetof(AMutableCharacter, CustomizableSkeletalComponent) == 0x0007F0, "Member 'AMutableCharacter::CustomizableSkeletalComponent' has a wrong offset!");
static_assert(offsetof(AMutableCharacter, InstanceDescriptor) == 0x0007F8, "Member 'AMutableCharacter::InstanceDescriptor' has a wrong offset!");

// Class TslGame.LobbyCharacter
// 0x0030 (0x0840 - 0x0810)
class ALobbyCharacter : public AMutableCharacter
{
public:
	uint8                                         Pad_810[0x30];                                     // 0x0810(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString GetNetId() const;
	class FString GetNickName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyCharacter">();
	}
	static class ALobbyCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALobbyCharacter>();
	}
};
static_assert(alignof(ALobbyCharacter) == 0x000010, "Wrong alignment on ALobbyCharacter");
static_assert(sizeof(ALobbyCharacter) == 0x000840, "Wrong size on ALobbyCharacter");

// Class TslGame.TestMutableCharacter
// 0x0000 (0x0810 - 0x0810)
class ATestMutableCharacter final : public AMutableCharacter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TestMutableCharacter">();
	}
	static class ATestMutableCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATestMutableCharacter>();
	}
};
static_assert(alignof(ATestMutableCharacter) == 0x000010, "Wrong alignment on ATestMutableCharacter");
static_assert(sizeof(ATestMutableCharacter) == 0x000810, "Wrong size on ATestMutableCharacter");

// Class TslGame.TslVaultingHelper
// 0x0010 (0x03B0 - 0x03A0)
class ATslVaultingHelper final : public AActor
{
public:
	class USceneComponent*                        RootSceneComponent;                                // 0x03A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        ActorAttachScene;                                  // 0x03A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	struct FVector GetActorAttachScene() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslVaultingHelper">();
	}
	static class ATslVaultingHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslVaultingHelper>();
	}
};
static_assert(alignof(ATslVaultingHelper) == 0x000008, "Wrong alignment on ATslVaultingHelper");
static_assert(sizeof(ATslVaultingHelper) == 0x0003B0, "Wrong size on ATslVaultingHelper");
static_assert(offsetof(ATslVaultingHelper, RootSceneComponent) == 0x0003A0, "Member 'ATslVaultingHelper::RootSceneComponent' has a wrong offset!");
static_assert(offsetof(ATslVaultingHelper, ActorAttachScene) == 0x0003A8, "Member 'ATslVaultingHelper::ActorAttachScene' has a wrong offset!");

// Class TslGame.TslWeapon_Gun
// 0x0250 (0x09F8 - 0x07A8)
class ATslWeapon_Gun : public ATslWeapon
{
public:
	bool                                          bSpawnBulletFromBarrel;                            // 0x07A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A9[0x7];                                      // 0x07A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AmmoPerClip;                                       // 0x07B0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentAmmoInClip;                                 // 0x07B4(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsHipped : 1;                                     // 0x07B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_7B9[0x3];                                      // 0x07B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeBetweenShots;                                  // 0x07BC(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C0[0x20];                                     // 0x07C0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FiringModeIndex;                                   // 0x07E0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7E4[0x54];                                     // 0x07E4(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWeaponGunData                         WeaponGunConfig;                                   // 0x0838(0x0090)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FWeaponDeviationData                   WeaponDeviationConfig;                             // 0x08C8(0x0040)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FWeaponGunAnim                         WeaponGunAnim;                                     // 0x0908(0x00F0)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void AnimCall_FireWeapon();
	void AnimCall_FireWeaponCycle();
	void AnimCall_ReloadChargeWeapon();
	void AnimCall_ReloadTacticalWeapon();
	void AnimCall_ToggleFireMode();
	void CancelReloadImpl();
	bool CheckMiddlePointCollision();
	void Client_StartManualFireCycle();
	void ClientCancelReload();
	void ClientNotifyAmmo(int32 InCurrentAmmoInClip);
	void ClientNotifyStopReloadByOne();
	void ClientSimulateWeaponFire(const struct FHitResult& ExceptTrajectoryHitResult);
	void ClientStopSimulatingWeaponFire();
	void ManualFireCycleFinished();
	void OnAnimationNotify(const class FName& NotifyName);
	void OnAttachmentScopeLoaded();
	void OnRep_AmmoCount(int32 LastCurrentAmmoInClip);
	void OnRep_AttachedItemClasses();
	void OnRep_TimeBetweenShots(float LastTimeBetweenShots);
	void PlayLongTailSound();
	void PlayWeaponCycleCameraAnim();
	void ProcessBoltAction();
	void Server_StartManualFireCycle();
	void ServerCancelReload();
	void ServerHandleFiring(const struct FHitResult& ExceptTrajectoryHitResult);
	void ServerSetHip(bool bNewIsHipped);
	void ServerStartFire();
	void ServerStartReload();
	void ServerStopFire();
	void ServerStopReload();
	void SetFiringMode(EFiringMode FiringMode);
	void SetSpawnBulletFromBarrel(bool DoSpawnBulletFromBarrel);
	void SetWeaponReloadInterrupted(bool bIsInterrupted);
	void SimulateWeaponReload(const EWeaponReloadAnimExec& ReloadAnimExec);
	void StartManualFireCycle();
	void StopReloadAnimByOne();

	float GetADSRecoilKick() const;
	TSubclassOf<class UAmmoItem> GetAmmoItemClass() const;
	int32 GetAmmoPerClip() const;
	class UAnimMontage* GetCharacterChargeReloadFromAttach() const;
	class UAnimMontage* GetCharacterFireCycle() const;
	class UAnimMontage* GetCharacterFireMontage() const;
	class UAnimMontage* GetCharacterFireSelectorMontage() const;
	class UBlendSpace1D* GetCharacterGripBlendspace() const;
	class UBlendSpaceBase* GetCharacterLHGripBlendspace() const;
	class UAnimMontage* GetCharacterReloadByOneSingleMontage() const;
	class UAnimMontage* GetCharacterReloadByOneStartMontage() const;
	class UAnimMontage* GetCharacterReloadByOneStopMontage() const;
	class UAnimMontage* GetCharacterReloadChargeMontage() const;
	class UAnimMontage* GetCharacterReloadTacticalMontage() const;
	class UAnimMontage* GetCharacterTacticalReloadFromAttach() const;
	int32 GetCurrentAmmo() const;
	int32 GetCurrentAmmoInClip() const;
	int32 GetCurrentAmmoInInventory() const;
	float GetCurrentDeviation() const;
	class UAmmoItem* GetDefaultAmmoObject() const;
	EFiringMode GetFiringMode() const;
	int32 GetGripTypeIndex() const;
	struct FVector GetMagDropAngularVelocity() const;
	struct FVector GetMagDropLinearVelocity() const;
	float GetMagOutDuration() const;
	int32 GetMaxAmmo() const;
	float GetMovementModifierAim() const;
	float GetMovementModifierScope() const;
	int32 GetNumOfFiringMode() const;
	struct FVector GetRecoilADSSocketOffsetScale() const;
	float GetReloadAnimationPlayRate() const;
	class UAnimMontage* GetWeaponChargeReload() const;
	float GetWeaponCurrentDeviationValue() const;
	float GetWeaponCurrentRecoilValue() const;
	float GetWeaponFullRealoadTimeWithAttachments() const;
	float GetWeaponFullReloadTime() const;
	struct FWeaponGunAnim GetWeaponGunAnimConfig() const;
	struct FWeaponGunData GetWeaponGunConfig() const;
	struct FVector GetWeaponHandOffset() const;
	struct FVector GetWeaponHandOffsetFPP() const;
	class UAnimMontage* GetWeaponTacticalReload() const;
	bool IsReloading() const;
	bool IsReloadInterrupted() const;
	bool IsWeaponCycleInProgress() const;
	bool WeaponCycleDone() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslWeapon_Gun">();
	}
	static class ATslWeapon_Gun* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslWeapon_Gun>();
	}
};
static_assert(alignof(ATslWeapon_Gun) == 0x000008, "Wrong alignment on ATslWeapon_Gun");
static_assert(sizeof(ATslWeapon_Gun) == 0x0009F8, "Wrong size on ATslWeapon_Gun");
static_assert(offsetof(ATslWeapon_Gun, bSpawnBulletFromBarrel) == 0x0007A8, "Member 'ATslWeapon_Gun::bSpawnBulletFromBarrel' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Gun, AmmoPerClip) == 0x0007B0, "Member 'ATslWeapon_Gun::AmmoPerClip' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Gun, CurrentAmmoInClip) == 0x0007B4, "Member 'ATslWeapon_Gun::CurrentAmmoInClip' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Gun, TimeBetweenShots) == 0x0007BC, "Member 'ATslWeapon_Gun::TimeBetweenShots' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Gun, FiringModeIndex) == 0x0007E0, "Member 'ATslWeapon_Gun::FiringModeIndex' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Gun, WeaponGunConfig) == 0x000838, "Member 'ATslWeapon_Gun::WeaponGunConfig' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Gun, WeaponDeviationConfig) == 0x0008C8, "Member 'ATslWeapon_Gun::WeaponDeviationConfig' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Gun, WeaponGunAnim) == 0x000908, "Member 'ATslWeapon_Gun::WeaponGunAnim' has a wrong offset!");

// Class TslGame.WeaponProcessor
// 0x00D0 (0x0470 - 0x03A0)
class AWeaponProcessor final : public AActor
{
public:
	uint8                                         Pad_3A0[0x8];                                      // 0x03A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnWeaponProcessorArmed;                            // 0x03A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B8[0x80];                                     // 0x03B8(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATslWeapon*>                     EquippedWeapons;                                   // 0x0438(0x0010)(Net, ZeroConstructor, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentWeaponIndex;                                // 0x0448(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44C[0x24];                                     // 0x044C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientForceRemoveWeapon(int32 WeaponIndex);
	void ClientInitByReconnection(int32 InitWeaponIndex);
	void ClientSetWeaponIndex(int32 WeaponIndex);
	class ATslWeapon* FindWeapon(TSubclassOf<class ATslWeapon> WeaponClass);
	void NotifyWeaponUpdate();
	void OnRep_CurrentWeaponIndex(int32 LastWeaponIndex);
	void OnRep_EquippedWeapons(const TArray<class ATslWeapon*>& LastEquippedWeapons);
	void ServerArmWeapon(int32 WeaponIndex, bool bNeedAnimation);
	void ServerUnarmCurrentWeapon();
	void SimulateArmWeapon(int32 WeaponIndex, bool bNeedAnimation);
	void SimulateUnArmWeapon(int32 WeaponIndex);

	class ATslWeapon* GetCurrentWeapon() const;
	int32 GetUnarmedWeaponIndex() const;
	class ATslWeapon* GetWeapon() const;
	class ATslWeapon* GetWeaponByIndex(int32 Index_0) const;
	class ATslWeapon_Gun* GetWeaponGun() const;
	int32 GetWeaponIndex() const;
	class ATslWeapon_Throwable* GetWeaponThrowable() const;
	bool IsUnarmed() const;
	bool IsUnarmedWeapon(int32 WeaponIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponProcessor">();
	}
	static class AWeaponProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWeaponProcessor>();
	}
};
static_assert(alignof(AWeaponProcessor) == 0x000008, "Wrong alignment on AWeaponProcessor");
static_assert(sizeof(AWeaponProcessor) == 0x000470, "Wrong size on AWeaponProcessor");
static_assert(offsetof(AWeaponProcessor, OnWeaponProcessorArmed) == 0x0003A8, "Member 'AWeaponProcessor::OnWeaponProcessorArmed' has a wrong offset!");
static_assert(offsetof(AWeaponProcessor, EquippedWeapons) == 0x000438, "Member 'AWeaponProcessor::EquippedWeapons' has a wrong offset!");
static_assert(offsetof(AWeaponProcessor, CurrentWeaponIndex) == 0x000448, "Member 'AWeaponProcessor::CurrentWeaponIndex' has a wrong offset!");

// Class TslGame.VaultingData
// 0x00C8 (0x00F0 - 0x0028)
class UVaultingData final : public UDataAsset
{
public:
	float                                         LocationStartNormalScale;                          // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationStartZOffset;                              // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationEndNormalScale;                            // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationEndZOffset;                                // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsClimb;                                          // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSlide;                                          // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VaultInitialTimer;                                 // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ApexAdditiveStartTime;                             // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ApexAdditiveEndTime;                               // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreApexSpeedScale;                                 // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostApexSpeedScale;                                // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VaultEndToFallTimerCutoff;                         // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StartCutoffByDistance_InMap;                       // 0x0054(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              StartCutoffByDistance_OutMap;                      // 0x005C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              StartCutoffBySpeed_InMap;                          // 0x0064(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              StartCutoffBySpeed_OutMap;                         // 0x006C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              PlayrateBySpeed_InMap_PreApex;                     // 0x0074(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              PlayrateBySpeed_OutMap_PreApex;                    // 0x007C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              PlayrateBySpeed_InMap_PostApex;                    // 0x0084(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              PlayrateBySpeed_OutMap_PostApex;                   // 0x008C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      AnimationSequence;                                 // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AnimationCurve;                                    // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CharLocationInterpSpeedInMap;                      // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              CharLocationInterpSpeedOutMap;                     // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              TimerProgressionByDistanceInMap;                   // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              TimerProgressionByDistanceOutMap;                  // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TimerProgressionVTimerMax;                         // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VaultEndTimerNormal;                               // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VaultEndTimerFall;                                 // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterPostVaultVelocityScalar;                  // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimBlendInTime;                                   // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimBlendOutTime;                                  // 0x00DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanVaultWithWeapon;                               // 0x00E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCancellable;                                    // 0x00E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E2[0x2];                                       // 0x00E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinCancelVTimer;                                   // 0x00E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxCancelVTimer;                                   // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TaskEndVTimer;                                     // 0x00EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UCurveFloat* GetAnimationCurve() const;
	float GetAnimationLength() const;
	float GetBlendSpeedByDistance(float InDistance) const;
	class UAnimSequenceBase* GetVaultAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VaultingData">();
	}
	static class UVaultingData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVaultingData>();
	}
};
static_assert(alignof(UVaultingData) == 0x000008, "Wrong alignment on UVaultingData");
static_assert(sizeof(UVaultingData) == 0x0000F0, "Wrong size on UVaultingData");
static_assert(offsetof(UVaultingData, LocationStartNormalScale) == 0x000028, "Member 'UVaultingData::LocationStartNormalScale' has a wrong offset!");
static_assert(offsetof(UVaultingData, LocationStartZOffset) == 0x00002C, "Member 'UVaultingData::LocationStartZOffset' has a wrong offset!");
static_assert(offsetof(UVaultingData, LocationEndNormalScale) == 0x000030, "Member 'UVaultingData::LocationEndNormalScale' has a wrong offset!");
static_assert(offsetof(UVaultingData, LocationEndZOffset) == 0x000034, "Member 'UVaultingData::LocationEndZOffset' has a wrong offset!");
static_assert(offsetof(UVaultingData, bIsClimb) == 0x000038, "Member 'UVaultingData::bIsClimb' has a wrong offset!");
static_assert(offsetof(UVaultingData, bIsSlide) == 0x000039, "Member 'UVaultingData::bIsSlide' has a wrong offset!");
static_assert(offsetof(UVaultingData, VaultInitialTimer) == 0x00003C, "Member 'UVaultingData::VaultInitialTimer' has a wrong offset!");
static_assert(offsetof(UVaultingData, ApexAdditiveStartTime) == 0x000040, "Member 'UVaultingData::ApexAdditiveStartTime' has a wrong offset!");
static_assert(offsetof(UVaultingData, ApexAdditiveEndTime) == 0x000044, "Member 'UVaultingData::ApexAdditiveEndTime' has a wrong offset!");
static_assert(offsetof(UVaultingData, PreApexSpeedScale) == 0x000048, "Member 'UVaultingData::PreApexSpeedScale' has a wrong offset!");
static_assert(offsetof(UVaultingData, PostApexSpeedScale) == 0x00004C, "Member 'UVaultingData::PostApexSpeedScale' has a wrong offset!");
static_assert(offsetof(UVaultingData, VaultEndToFallTimerCutoff) == 0x000050, "Member 'UVaultingData::VaultEndToFallTimerCutoff' has a wrong offset!");
static_assert(offsetof(UVaultingData, StartCutoffByDistance_InMap) == 0x000054, "Member 'UVaultingData::StartCutoffByDistance_InMap' has a wrong offset!");
static_assert(offsetof(UVaultingData, StartCutoffByDistance_OutMap) == 0x00005C, "Member 'UVaultingData::StartCutoffByDistance_OutMap' has a wrong offset!");
static_assert(offsetof(UVaultingData, StartCutoffBySpeed_InMap) == 0x000064, "Member 'UVaultingData::StartCutoffBySpeed_InMap' has a wrong offset!");
static_assert(offsetof(UVaultingData, StartCutoffBySpeed_OutMap) == 0x00006C, "Member 'UVaultingData::StartCutoffBySpeed_OutMap' has a wrong offset!");
static_assert(offsetof(UVaultingData, PlayrateBySpeed_InMap_PreApex) == 0x000074, "Member 'UVaultingData::PlayrateBySpeed_InMap_PreApex' has a wrong offset!");
static_assert(offsetof(UVaultingData, PlayrateBySpeed_OutMap_PreApex) == 0x00007C, "Member 'UVaultingData::PlayrateBySpeed_OutMap_PreApex' has a wrong offset!");
static_assert(offsetof(UVaultingData, PlayrateBySpeed_InMap_PostApex) == 0x000084, "Member 'UVaultingData::PlayrateBySpeed_InMap_PostApex' has a wrong offset!");
static_assert(offsetof(UVaultingData, PlayrateBySpeed_OutMap_PostApex) == 0x00008C, "Member 'UVaultingData::PlayrateBySpeed_OutMap_PostApex' has a wrong offset!");
static_assert(offsetof(UVaultingData, AnimationSequence) == 0x000098, "Member 'UVaultingData::AnimationSequence' has a wrong offset!");
static_assert(offsetof(UVaultingData, AnimationCurve) == 0x0000A0, "Member 'UVaultingData::AnimationCurve' has a wrong offset!");
static_assert(offsetof(UVaultingData, CharLocationInterpSpeedInMap) == 0x0000A8, "Member 'UVaultingData::CharLocationInterpSpeedInMap' has a wrong offset!");
static_assert(offsetof(UVaultingData, CharLocationInterpSpeedOutMap) == 0x0000B0, "Member 'UVaultingData::CharLocationInterpSpeedOutMap' has a wrong offset!");
static_assert(offsetof(UVaultingData, TimerProgressionByDistanceInMap) == 0x0000B8, "Member 'UVaultingData::TimerProgressionByDistanceInMap' has a wrong offset!");
static_assert(offsetof(UVaultingData, TimerProgressionByDistanceOutMap) == 0x0000C0, "Member 'UVaultingData::TimerProgressionByDistanceOutMap' has a wrong offset!");
static_assert(offsetof(UVaultingData, TimerProgressionVTimerMax) == 0x0000C8, "Member 'UVaultingData::TimerProgressionVTimerMax' has a wrong offset!");
static_assert(offsetof(UVaultingData, VaultEndTimerNormal) == 0x0000CC, "Member 'UVaultingData::VaultEndTimerNormal' has a wrong offset!");
static_assert(offsetof(UVaultingData, VaultEndTimerFall) == 0x0000D0, "Member 'UVaultingData::VaultEndTimerFall' has a wrong offset!");
static_assert(offsetof(UVaultingData, CharacterPostVaultVelocityScalar) == 0x0000D4, "Member 'UVaultingData::CharacterPostVaultVelocityScalar' has a wrong offset!");
static_assert(offsetof(UVaultingData, AnimBlendInTime) == 0x0000D8, "Member 'UVaultingData::AnimBlendInTime' has a wrong offset!");
static_assert(offsetof(UVaultingData, AnimBlendOutTime) == 0x0000DC, "Member 'UVaultingData::AnimBlendOutTime' has a wrong offset!");
static_assert(offsetof(UVaultingData, bCanVaultWithWeapon) == 0x0000E0, "Member 'UVaultingData::bCanVaultWithWeapon' has a wrong offset!");
static_assert(offsetof(UVaultingData, bIsCancellable) == 0x0000E1, "Member 'UVaultingData::bIsCancellable' has a wrong offset!");
static_assert(offsetof(UVaultingData, MinCancelVTimer) == 0x0000E4, "Member 'UVaultingData::MinCancelVTimer' has a wrong offset!");
static_assert(offsetof(UVaultingData, MaxCancelVTimer) == 0x0000E8, "Member 'UVaultingData::MaxCancelVTimer' has a wrong offset!");
static_assert(offsetof(UVaultingData, TaskEndVTimer) == 0x0000EC, "Member 'UVaultingData::TaskEndVTimer' has a wrong offset!");

// Class TslGame.TslCharacter
// 0x0D10 (0x1520 - 0x0810)
#pragma pack(push, 0x1)
class alignas(0x10) ATslCharacter : public AMutableCharacter
{
public:
	class UTslPawnInputBindingComponent*          TslPawnInputBindingComponent;                      // 0x0810(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           TimerHandle_Targeting_HoldADS;                     // 0x0818(0x0008)(NativeAccessSpecifierPublic)
	bool                                          bShouldAiming;                                     // 0x0820(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPeekLeftToggled;                                  // 0x0821(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPeekRightToggled;                                 // 0x0822(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_823[0x1];                                      // 0x0823(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ATslPlayerState>         CurrentAttackerPlayerState;                        // 0x0824(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ATslPlayerState>         LastAttackedPlayerState;                           // 0x082C(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_834[0x4C];                                     // 0x0834(0x004C)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   NoBagSpaceDelgate;                                 // 0x0880(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_890[0x58];                                     // 0x0890(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            LastPossessedController;                           // 0x08E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAkAudioBank*>                   Banks;                                             // 0x08F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UBuffComponet*                          BuffComponent;                                     // 0x0900(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_908[0x40];                                     // 0x0908(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	ECastAnim                                     Remote_CastAnim;                                   // 0x0948(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_949[0x7];                                      // 0x0949(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ATslCharacter*                          RevivingCharacter;                                 // 0x0950(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATslPlayerState*                        GroggyPlayerInstigator;                            // 0x0958(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_960[0x78];                                     // 0x0960(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BuffFinalSpreadFactor;                             // 0x09D8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9DC[0x4];                                      // 0x09DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AInventoryFacade*                       InventoryFacade;                                   // 0x09E0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AWeaponProcessor*                       WeaponProcessor;                                   // 0x09E8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         CharacterState;                                    // 0x09F0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9F1[0x1F];                                     // 0x09F1(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AItemPackage>               DropPackageType;                                   // 0x0A10(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          SoundClearAk;                                      // 0x0A18(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          RemoteVolumeControlOn;                             // 0x0A20(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkAudioEvent*                          RemoteVolumeControlOff;                            // 0x0A28(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            CameraFovRatioCurve;                               // 0x0A30(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HeavyFallVerticalVelocityThreshold;                // 0x0A38(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ExtremeFallVerticalVelocityThreshold;              // 0x0A3C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ProneFallVerticalVelocityThreshold;                // 0x0A40(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HeavyFallMovementStopTime;                         // 0x0A44(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ExtremeFallMovementStopTime;                       // 0x0A48(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A4C[0x4];                                      // 0x0A4C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Punch_Damage;                                      // 0x0A50(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PunchHeavy_Damage;                                 // 0x0A54(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UDamageType>                UnarmedDamageType;                                 // 0x0A58(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UDamageType>                ZombieDamageType;                                  // 0x0A60(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Punch_Distance;                                    // 0x0A68(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PunchHeavy_Distance;                               // 0x0A6C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Punch_Radius;                                      // 0x0A70(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PunchHeavy_Radius;                                 // 0x0A74(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                Punch_InitialLocation;                             // 0x0A78(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A84[0x4];                                      // 0x0A84(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LeanLeftTraceOffset;                               // 0x0A88(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                LeanRightTraceOffset;                              // 0x0A94(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AA0[0x8];                                      // 0x0AA0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeanOffset_Stand;                                  // 0x0AA8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LeanOffset_Crouch;                                 // 0x0AAC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LeanOffset_Prone;                                  // 0x0AB0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AB4[0x10];                                     // 0x0AB4(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Sprint_MaxSpeed;                                   // 0x0AC4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Sprint_MinSpeed;                                   // 0x0AC8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SprintingFOV;                                      // 0x0ACC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinimumBreathToHold;                               // 0x0AD0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_AD4[0x4];                                      // 0x0AD4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SwimPoint;                                         // 0x0AD8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SwimableWaterDepth;                                // 0x0AE0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CrouchWaterDepth;                                  // 0x0AE4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ProneWaterDepth;                                   // 0x0AE8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WaterFloorDetectionLength;                         // 0x0AEC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SwimMaxControllerPitch;                            // 0x0AF0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UnderwaterSwimGapFromSurface;                      // 0x0AF4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ATslParticle>               SwimTrailEffectClass;                              // 0x0AF8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATslParticle*                           SwimTrailEffect;                                   // 0x0B00(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ParticleSocket_SwimIdleRipple;                     // 0x0B08(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ATslParticle>               SwimIdleRippleEffectClass;                         // 0x0B10(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         maxNumSwimIdleRippleEffect;                        // 0x0B18(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SwimIdleRippleOffsetFromSurface;                   // 0x0B1C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B20[0x10];                                     // 0x0B20(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterBreathComponent*              BreathComponent;                                   // 0x0B30(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   BreathPoint;                                       // 0x0B38(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ATslParticle>               UnderwaterChokeEffectClass;                        // 0x0B40(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATslParticle*                           UnderwaterChokeEffect;                             // 0x0B48(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         IndoorCheckDistance;                               // 0x0B50(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B54[0x4];                                      // 0x0B54(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IndoorCheckHalfConeAngle;                          // 0x0B58(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         IndoorCheckSuccessRate;                            // 0x0B5C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         IndoorCheckSamplingQueueSize;                      // 0x0B60(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         IndoorCheckAccuracyMultiplier;                     // 0x0B64(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B68[0x10];                                     // 0x0B68(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FootSoundObstructionCheckInterval;                 // 0x0B78(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FootSoundObstructionCheckMaxDistance;              // 0x0B7C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B80[0x8];                                      // 0x0B80(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ParachuteAttachPoint;                              // 0x0B88(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ReleasingParachuteAltitude;                        // 0x0B90(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ForceReleasingParachuteAltitude;                   // 0x0B94(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinimumParachuteAltitude;                          // 0x0B98(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B9C[0x4];                                      // 0x0B9C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ParachuteType;                                     // 0x0BA0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bParachuteLandingAssist;                           // 0x0BA8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BA9[0x7];                                      // 0x0BA9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCastComponent*                         CastComponent;                                     // 0x0BB0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStanceComponent*                       StanceComponent;                                   // 0x0BB8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHackReporterComponent*                 HackReporterComponent;                             // 0x0BC0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAcceptHitsWhileNotAlive;                          // 0x0BC8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BC9[0x3];                                      // 0x0BC9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SimulatedHit_Initial;                              // 0x0BCC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SimulatedHit_RecoveryPerSecond;                    // 0x0BD0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SimulatedHit_Value;                                // 0x0BD4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SimulatedHit_ImpulsePower;                         // 0x0BD8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SimlatedHit_PunchLightPower;                       // 0x0BDC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SimlatedHit_PunchHeavyPower;                       // 0x0BE0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BE4[0x4];                                      // 0x0BE4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATslParticle>               PunchImpactEffect;                                 // 0x0BE8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BF0[0x28];                                     // 0x0BF0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UCharacterWeaponAnimInfoComponent*      WeaponAnimInfoComponent;                           // 0x0C18(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTslAccessoryComponent*                 CharacterAccessory_Primary;                        // 0x0C20(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTslAccessoryComponent*                 CharacterAccessory_Secondary;                      // 0x0C28(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTslAccessoryComponent*                 CharacterAccessory_Sidearm;                        // 0x0C30(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTslAccessoryComponent*                 CharacterAccessory_Melee;                          // 0x0C38(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTslAccessoryComponent*                 CharacterAccessory_Thrown;                         // 0x0C40(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ATslParticle>               FootStepEffectClassInDirt;                         // 0x0C48(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ATslParticle>               FootStepEffectClassInGrass;                        // 0x0C50(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ATslParticle>               FootStepEffectClassInRock;                         // 0x0C58(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ATslParticle>               FootStepEffectClassInSand;                         // 0x0C60(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ParticleSocketFootLeft;                            // 0x0C68(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ParticleSocketFootRight;                           // 0x0C70(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ATslParticle>               FootStepEffectClassInWater;                        // 0x0C78(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATslParticle*                           FootStepEffect;                                    // 0x0C80(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATeam*                                  Team;                                              // 0x0C88(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C90[0x18];                                     // 0x0C90(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UTslViewTargetTempComponent*            ViewTargetTempComponent;                           // 0x0CA8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTslCharacterValidateLocationComponent* ValidateLocationComponent;                         // 0x0CB0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTslThrowableTrajectoryViewComponent*   ThrowableTrajectoryViewComponent;                  // 0x0CB8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CC0[0x8];                                      // 0x0CC0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HeadAttachPoint;                                   // 0x0CC8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraHeadHideDistance;                            // 0x0CD0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CD4[0xC];                                      // 0x0CD4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CrouchedCameraMove;                                // 0x0CE0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                PronedCameraMove;                                  // 0x0CEC(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                GroggyCameraMove;                                  // 0x0CF8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         CrouchedCameraMoveSpeed;                           // 0x0D04(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PronedCameraMoveSpeed;                             // 0x0D08(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GroggyCameraMoveSpeed;                             // 0x0D0C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D10[0x48];                                     // 0x0D10(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTakeHitInfo                           LastTakeHitInfo;                                   // 0x0D58(0x0040)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D98[0x4];                                      // 0x0D98(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetingSpeedModifier;                            // 0x0D9C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETargetingType                                TargetingType;                                     // 0x0DA0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA1[0x3];                                      // 0x0DA1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Stand_RunningSpeedModifier;                        // 0x0DA4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Stand_SprintingSpeedModifier;                      // 0x0DA8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Stand_SprintingBigGunModifier;                     // 0x0DAC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Stand_SprintingRifleModifier;                      // 0x0DB0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Stand_SprintingSmallGunMOdifier;                   // 0x0DB4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Crouch_RunningSpeedModifier;                       // 0x0DB8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Crouch_SprintingSpeedModifier;                     // 0x0DBC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Prone_RunningSpeedModifier;                        // 0x0DC0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Prone_SprintingSpeedModifier;                      // 0x0DC4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReviveCastingTime;                                 // 0x0DC8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bWantsToRun : 1;                                   // 0x0DCC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bWantsToSprint : 1;                                // 0x0DCC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bWantsToSprintingAuto : 1;                         // 0x0DCC(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bWantsToRollingLeft : 1;                           // 0x0DCC(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bWantsToRollingRight : 1;                          // 0x0DCC(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsPeekLeft : 1;                                   // 0x0DCC(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsPeekRight : 1;                                  // 0x0DCC(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         IgnoreRotation : 1;                                // 0x0DCC(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsGroggying : 1;                                  // 0x0DCD(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, Net, EditConst, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsThirdPerson : 1;                                // 0x0DCD(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BitPad_DCD_2 : 1;                                  // 0x0DCD(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bIsReviving : 1;                                   // 0x0DCD(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsWeaponObstructed : 1;                           // 0x0DCD(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsCoatEquipped : 1;                               // 0x0DCD(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsZombie : 1;                                     // 0x0DCD(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsThrowHigh : 1;                                  // 0x0DCD(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_DCE[0x2];                                      // 0x0DCE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOutSidePlayerArea;                                // 0x0DD0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseRightShoulderAiming;                           // 0x0DD1(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DD2[0x2];                                      // 0x0DD2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               GunDirectionSway;                                  // 0x0DD4(0x000C)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector_NetQuantizeNormal              AimOffsets;                                        // 0x0DE0(0x000C)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FVector_NetQuantizeNormal              LastAimOffsets;                                    // 0x0DEC(0x000C)(Protected, NativeAccessSpecifierProtected)
	float                                         AimoffsetsLastRepTime;                             // 0x0DF8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DFC[0x44];                                     // 0x0DFC(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            Curve_JumpCamera;                                  // 0x0E40(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           Curve_FPPCameraOffsetByFOV;                        // 0x0E48(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            Curve_DBNOFadeOut;                                 // 0x0E50(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DBNOFadeOutLerpSpeed;                              // 0x0E58(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E5C[0x4];                                      // 0x0E5C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            Curve_StandWalk;                                   // 0x0E60(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            Curve_StandRun;                                    // 0x0E68(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            Curve_StandSprint;                                 // 0x0E70(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            Curve_CrouchWalk;                                  // 0x0E78(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            Curve_CrouchRun;                                   // 0x0E80(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            Curve_CrouchSprint;                                // 0x0E88(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            Curve_ProneWalk;                                   // 0x0E90(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            Curve_ProneRun;                                    // 0x0E98(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            Curve_ProneSprint;                                 // 0x0EA0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            Curve_Swim;                                        // 0x0EA8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            Curve_UnderwaterSwim;                              // 0x0EB0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            Curve_StandScope;                                  // 0x0EB8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            Curve_CrouchScope;                                 // 0x0EC0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            Curve_ProneScope;                                  // 0x0EC8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            Curve_StandAim;                                    // 0x0ED0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            Curve_CrouchAim;                                   // 0x0ED8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            Curve_ProneAim;                                    // 0x0EE0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            Curve_DBNO;                                        // 0x0EE8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            Curve_GroundAngle;                                 // 0x0EF0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           Curve_WeaponSway;                                  // 0x0EF8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            Curve_TurningLerp;                                 // 0x0F00(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            Curve_TurningLerpLocomotion;                       // 0x0F08(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DirectionalSpeedModifier;                          // 0x0F10(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PointDamageForceMultiplier;                        // 0x0F14(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PointDamageForce_MapMin;                           // 0x0F18(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PointDamageForce_MapMax;                           // 0x0F1C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RadialDamageForceMultiplier;                       // 0x0F20(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERadialImpulseFalloff                         RadialDamageFalloffType;                           // 0x0F24(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F25[0x3];                                      // 0x0F25(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           RollLeftAnim;                                      // 0x0F28(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           RollRightAnim;                                     // 0x0F30(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCharacterAnim                         CharacterAnim;                                     // 0x0F38(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class AController*                            NetOwnerController;                                // 0x0F48(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LeanAlphaSpeed;                                    // 0x0F50(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnSpeedHip;                                      // 0x0F54(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnSpeedAimed;                                    // 0x0F58(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnSpeedOverLimit;                                // 0x0F5C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinTurnAngleHip;                                   // 0x0F60(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinTurnAngleAim;                                   // 0x0F64(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnLinearEndThreshold;                            // 0x0F68(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNonLinearTurn;                                    // 0x0F6C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F6D[0x3];                                      // 0x0F6D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnNonLinearEndThreshold;                         // 0x0F70(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnNonLinearInterpSpeed;                          // 0x0F74(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapsuleTurnInterpSpeedLocomotion;                  // 0x0F78(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapsuleTurnInterpSpeedLocomotionSprint;            // 0x0F7C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapsuleTurnInterpSpeedLocomotionProne;             // 0x0F80(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapsuleTurnInterpSpeedStationary;                  // 0x0F84(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F88[0x18];                                     // 0x0F88(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FPPCameraBoneName;                                 // 0x0FA0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TPPCameraBoneName;                                 // 0x0FA8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FB0[0xC];                                      // 0x0FB0(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AimStateDefaultTime;                               // 0x0FBC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimStateReturnTime;                                // 0x0FC0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimStateDrawTime;                                  // 0x0FC4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FC8[0x8];                                      // 0x0FC8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAimStateActive;                                   // 0x0FD0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FD1[0x3];                                      // 0x0FD1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CanGroggyDamageTime;                               // 0x0FD4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   GroggyStartText;                                   // 0x0FD8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   GroggyCancelText;                                  // 0x0FF0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FText                                   GroggyFinishText;                                  // 0x1008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         GamepadRunningValue;                               // 0x1020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1024[0xC];                                     // 0x1024(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               BlendTargetViewRotation;                           // 0x1030(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              DesiredDirection;                                  // 0x103C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1044[0x4];                                     // 0x1044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATslBuff>                   InvulnerablilityBuff;                              // 0x1048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvulnerablilityEffectVisible;                    // 0x1050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1051[0x7];                                     // 0x1051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UActorComponent>>    ComponentsToDestroyOnDedicatedServer;              // 0x1058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FZombieCustomizationData>       ZombieCustomizationData;                           // 0x1068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsHoldingBreath;                                  // 0x1078(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1079[0x3];                                     // 0x1079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Health;                                            // 0x107C(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthMax;                                         // 0x1080(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroggyHealth;                                      // 0x1084(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroggyHealthMax;                                   // 0x1088(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecreaseGroggyHealthPerSecond;                     // 0x108C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroggyDamageWeight;                                // 0x1090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1094[0x4];                                     // 0x1094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                GroggyDamageType;                                  // 0x1098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthByRevive;                                    // 0x10A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10A4[0x4];                                     // 0x10A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          GroggyToDieAkEvent;                                // 0x10A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoostGauge;                                        // 0x10B0(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BoostGaugeMax;                                     // 0x10B4(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecreaseTimerSecond;                               // 0x10B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecreaseBoostGaugeByTime;                          // 0x10BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBuffWithBoostGauge>            BuffWithBoostGauge;                                // 0x10C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UItem>                      MedKitClass;                                       // 0x10D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UItem>                      FirstAidClass;                                     // 0x10D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UItem>                      BandageClass;                                      // 0x10E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UItem>                      AdrenalineClass;                                   // 0x10E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UItem>                      PainKillerClass;                                   // 0x10F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UItem>                      EnergyDrinkClass;                                  // 0x10F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UItem>>              BoostItemClasses;                                  // 0x1100(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UItem>>              HealItemClasses;                                   // 0x1110(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class UItem>                      GrenadeClass;                                      // 0x1120(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UItem>                      MolotovClass;                                      // 0x1128(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UItem>                      SmokeBombClass;                                    // 0x1130(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UItem>                      FlashBangClass;                                    // 0x1138(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1140[0x4];                                     // 0x1140(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ATslPlayerState>         LaunchInstigator;                                  // 0x1144(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  LaunchCauser;                                      // 0x114C(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_1154[0x4];                                     // 0x1154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        LastLaunchTime;                                    // 0x1158(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerState*                           AuthorizedPlayerState;                             // 0x1160(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEquipableItemSoundType                       ShoesSoundType;                                    // 0x1168(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1169[0x7];                                     // 0x1169(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractorComponent*                   InteractorComponent;                               // 0x1170(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionComponent*                  InteractionComponent;                              // 0x1178(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVehicleRiderComponent*                 VehicleRiderComponent;                             // 0x1180(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ATslPostProcessEffect>      OutSidePlayerAreaEffectClass;                      // 0x1188(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATslPostProcessEffect*                  OutSidePlayerAreaEffect;                           // 0x1190(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ATslPostProcessEffect>      DBNOEffectClass;                                   // 0x1198(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATslPostProcessEffect*                  DBNOEffect;                                        // 0x11A0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11A8[0x1E0];                                   // 0x11A8(0x01E0)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 ShadowMesh;                                        // 0x1388(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetingFOV;                                      // 0x1390(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimingDelay;                                       // 0x1394(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1398[0x4];                                     // 0x1398(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScopingDelay;                                      // 0x139C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AttackStateOffDelayTime;                           // 0x13A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitStateOffDelayTime;                              // 0x13A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitMePlayerStateOffDelayTime;                      // 0x13A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13AC[0x34];                                    // 0x13AC(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageHeadScale;                                   // 0x13E0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageArmScale;                                    // 0x13E4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageStomachScale;                                // 0x13E8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageLegScale;                                    // 0x13EC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           HeadBoneNames;                                     // 0x13F0(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           ArmBoneNames;                                      // 0x1400(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           TorsoBoneNames;                                    // 0x1410(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           StomachBoneNames;                                  // 0x1420(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           LegBoneNames;                                      // 0x1430(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1440[0x4];                                     // 0x1440(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FallDamageFactor;                                  // 0x1444(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FallDamageVelocityMin;                             // 0x1448(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsActiveRagdollActive;                            // 0x144C(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_144D[0x3];                                     // 0x144D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CorpseLifeSpan;                                    // 0x1450(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1454[0x2C];                                    // 0x1454(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                JumpStartLocation_CP;                              // 0x1480(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LandPredictedLocation_CP;                          // 0x148C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FallHeight_CP;                                     // 0x1498(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVaulting_CP;                                    // 0x149C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149D[0x3];                                     // 0x149D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VaultTimer_CP;                                     // 0x14A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VaultEndVelocity_CP;                               // 0x14A4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                VaultLastLocation_CP;                              // 0x14B0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsClimbing_CP;                                    // 0x14BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndVaultToFall_CP;                                // 0x14BD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14BE[0x2];                                     // 0x14BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                VaultEndVelocityVectorMutliplier;                  // 0x14C0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         VaultEndVelocityVectorClamp;                       // 0x14CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATslVaultingHelper*                     VaultingHelperRef;                                 // 0x14D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVaultingSystemEnabled;                          // 0x14D8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14D9[0x3];                                     // 0x14D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VaultingDirection_CP;                              // 0x14DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVaultingData*                          CurrentVaultData_CP;                               // 0x14E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bServerFinishedVault;                              // 0x14E8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14E9[0x3];                                     // 0x14E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpDelay;                                         // 0x14EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpLastTimer;                                     // 0x14F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWantsToVault;                                     // 0x14F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWantsToCancelVault;                               // 0x14F5(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14F6[0x2];                                     // 0x14F6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VaultProbeLoopTime;                                // 0x14F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TO_CulledMovementTickrate;                         // 0x14FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TO_CulledActorTickInterval;                        // 0x1500(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TO_MinimumDistance;                                // 0x1504(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRunTickOptimization;                              // 0x1508(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRunTickOptimization_Anim;                         // 0x1509(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRunTickOptimization_Movement;                     // 0x150A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_150B[0x1];                                     // 0x150B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TO_RenderedTolerance;                              // 0x150C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTickOptimization_Move_Active;                     // 0x1510(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTickOptimization_Anim_Active;                     // 0x1511(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTickOptimization_Actor_Active;                    // 0x1512(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1513[0x5];                                     // 0x1513(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBuffMoveSpeedFactor(float MoveSpeedFactor);
	void AdminFreeMoveMode();
	void AdminInvulnerable();
	void AdminSetUpWeapon();
	bool AllowInteract(const class ATslCharacter* OtherCharacter);
	void Anim_MagazineHandAttach(bool bAttach);
	void Anim_MagazineShow(bool bShow);
	void ApplyRagdollPhysicsForce();
	void BindCallbackToHUD(class ATslPlayerController* InController);
	void Camera_AimoffsetFix_FppToTpp();
	void Camera_AimoffsetFix_TppToFpp();
	bool CheckEquipmentSlot(const struct FEquipPosition& InSlotData);
	void CheckForCoat();
	void CheckJumpAndVault(bool bForceVelocity, const struct FVector& InForcedVelocity);
	void CheckMuzzleBulletSpawn();
	void CheckMuzzleCollision();
	void Client_CastCancelNotify();
	void Client_CastFinishNotify();
	void Client_PlayUnarmedAttack(int32 AnimationIndex);
	void ClientForceInitStance(EStanceMode ToStance);
	void ClientMyCharacterPlayPickUpAnimation(const struct FVector_NetQuantize& InteractionObject, float Duration);
	void ClientNotifyCrack(const struct FVector_NetQuantize& LocationRelative, float BulletVelocity);
	void ClientPlayPickUpAnimation(const struct FVector_NetQuantize& InteractionObject);
	void ClientProcessRevive(float RemainGroggyHealth);
	void ClientRevivedCastingWidgetShow(bool bVisible);
	void ClientSendGroggyMessage(class ATslPlayerState* GroggyCauserPlayerState, class ATslPlayerState* VictimPlayerState, const class UDamageType* GroggyCauserDamageType, EDamageReason DamageReason, const class FText& DamageCauserName);
	void ClientSetTargeting(ETargetingType NewTargetingType);
	void ClientSimulationArmorDestruction(EEquipSlotID SlotID, const struct FTransform& Impact);
	void ClientSoundPlay(class UAkAudioEvent* SoundAk);
	void DelayedFire();
	void DisableCollision();
	void EnableAudioTest();
	class ATslWeapon* FindWeapon(TSubclassOf<class ATslWeapon> WeaponClass);
	void FixupCamera();
	struct FVector GetADSSocketOffset();
	class UBuffComponet* GetBuffComponent();
	struct FRotator GetCurrentSway();
	class AInventoryFacade* GetInventoryFacade();
	class FName GetReactionBone(class FName BoneName);
	float GetSpeedKmPerHour2D();
	class AWeaponProcessor* GetWeaponProcessor();
	void GiveWeapon(TSubclassOf<class ATslWeapon> WeaponClass);
	void HandleCapsuleCollision();
	void HandleTargeting_HoldADS();
	void HandleVaultEnd_CP(const struct FVector& InVaultEndVelocity);
	bool HasWeapon(TSubclassOf<class ATslWeapon> WeaponClass);
	void HaveNotAnyHealItemNotifyMessage();
	void HiddenCrosshair();
	bool IsOutSidePlayerArea();
	void LocalMagazineDrop(const struct FVector& InitialVelocity);
	void NotHaveBoostItemNotifyMessage();
	void NotHaveHealItemNotifyMessage(const class FText& ItemName);
	void NotHaveThrowItemNotifyMessage(const class FText& ItemName);
	void OnBlockingWidgetOpened(class UWidget* Widget);
	void OnCancelInteractBy(class ATslCharacter* OtherCharacter);
	void OnChangeBreath(float Breath, float LastBreath, float BreathMax);
	void OnDecreaseMaxFlyAccerleration();
	void OnFreeMoveMode();
	void OnIncreaseMaxFlyAccerleration();
	void OnInteractBy(class ATslCharacter* OtherCharacter);
	void OnInvulnerable();
	void OnRep_AimOffsets(const struct FVector_NetQuantizeNormal& PrevAimOffsets);
	void OnRep_BoostGauge(float LastBoostGauge);
	void OnRep_CharacterState();
	void OnRep_GroggyHealth(float LastGroggyHealth);
	void OnRep_Health(float LastHealth);
	void OnRep_IsCrouched();
	void OnRep_IsGroggying();
	void OnRep_LastTakeHitInfo();
	void OnRep_OutSidePlayerArea(bool bLastOutSidePlayerArea);
	void OnRep_ReviveCastingTime();
	void OnRep_ShoesSoundType();
	void OnRep_TargetingType();
	void OnRep_WeaponProcessor();
	void OnStartInteractBy(class ATslCharacter* OtherCharacter);
	void OnStartTargeting_HoldADS();
	void OnStopFire();
	void OnStopTargeting();
	void OnStopTargeting_HoldADS();
	void OnTest_InspectObject();
	void OnTest_SetupWeapon();
	void OnUnarm();
	void OnUnarmPad();
	void OnWeapon_1();
	void OnWeapon_2();
	void OnWeapon_3();
	void OnWeapon_4();
	void OnWeapon_5();
	bool PickUpItem(class UItem* Item, class FName TargetContainer, const class FString& Options);
	void PlayCameraAnim(class UCameraAnim* CameraAnim);
	void PrepareParachute(class UClass* ParachuteType_0);
	void ProcessDBNO(float GroggyHealthPercent);
	void ProcessRevive(float RemainGroggyHealthPercent);
	void PunchStart(const EPunchDamageType& PunchDamageType, float PunchDistance, float PunchRadius);
	void ReevaluaeTargetingState();
	void ResetParachute();
	void ResetUnarmedAttack();
	void RunVaultCheck_BP();
	void SendSystemMessage(ESystemMessageType MessageType, const class FText& Message);
	void Server_CastCancelNotify();
	void Server_CastFinishNotify();
	void Server_PlayUnarmedAttack(int32 AnimationIndex);
	void Server_SetAimState(bool IsActive);
	void Server_SetCanGroggyDamage(bool bInCanGroggyDamage);
	void Server_SetCastAnim(ECastAnim InCastAnim);
	void Server_SetCoatEquipped(bool IsEquipped);
	void Server_SetFiringMode(EFiringMode fMode);
	void Server_SetParachuteLandingAssist(bool bAssistActive);
	void Server_SetThrowMode(bool bNewVal);
	void Server_SetVaultCancel(bool InCancel);
	void Server_SetWeaponObstruction(bool bNewObstruction);
	void Server_UnarmedHitNotify(const struct FHitResult& Hit, EPunchDamageType PunchDamageType, uint32 HitSeq);
	void ServerSetAimOffsets(const struct FVector_NetQuantizeNormal& NewAimOffsets);
	void ServerSetGunDirectionSway(const struct FRotator& InGunDirectionSway);
	void ServerSetHoldingBreath(bool bNewHoldingBreath);
	void ServerSetPeekLeft(bool bNewPeekLeft, bool InbUseRightShoulderAiming);
	void ServerSetPeekRight(bool bNewPeekRight, bool InbUseRightShoulderAiming);
	void ServerSetRolling(bool bNewRolling, bool bIsLeft);
	void ServerSetRunning(bool bNewRunning);
	void ServerSetSprinting(bool bNewSprinting);
	void ServerSetSprintingAuto(bool bNewSprintingAuto);
	void ServerSetTargeting(ETargetingType NewTargetingType);
	void SetAccessorySlot(class UTslAccessoryComponent* AccessoryComponent, EAccessorySlot Slot);
	void SetAccessorySlot_Melee(class UTslAccessoryComponent* AccessoryComponent);
	void SetAccessorySlot_Primary(class UTslAccessoryComponent* AccessoryComponent);
	void SetAccessorySlot_Secondary(class UTslAccessoryComponent* AccessoryComponent);
	void SetAccessorySlot_SideArm(class UTslAccessoryComponent* AccessoryComponent);
	void SetAccessorySlot_Thrown(class UTslAccessoryComponent* AccessoryComponent);
	void SetActiveRagdoll(bool bIsActive);
	void SetADSSocketOffset(const struct FVector& NewOffset);
	void SetAimStateActive(bool IsActive);
	void SetAnimationAkRTPC(const class FString& RTPCName, float RTPCValue);
	void SetAnimationAkSwitch(const class FString& SwitchGroup, const class FString& SwitchState);
	void SetBoostGauge(float NewBoostGauge);
	void SetBuffFinalSpreadFactor(float FinalSpreadFactor);
	void SetBulletSpawnOverride(bool InOverride);
	void SetCanGroggyDamage(bool bInCanGroggyDamage);
	void SetCharacterVaultingData(float InVaultTimer, bool InIsVaulting, bool InIsClimbing, bool InEndVaultToFall, float InDirection);
	void SetCustomDepth(bool bOn);
	void SetJumpStartLocationAndFallheight(const struct FVector& JumpStartLoc, float FallHeight);
	void SetLaunchEvent(const struct FAttackId& AttackId, class ATslPlayerState* InPlayerState, class AActor* Causer);
	void SetMovementEnabled(bool IsEnabled);
	void SetOutSidePlayerArea(bool bNewOutSidePlayerArea);
	void SetParachuteLandingAssist(bool bAssistActive);
	void SetServerVaultFinished(bool InFinished);
	void SetSwayDebuffParameters(float SwaySpeed, float SwayVerticalMultiplier, float SwayHorizontalMultiplier);
	void SetTickOptimization_Actor(bool bActivate);
	void SetTickOptimization_Anim(bool bActivate);
	void SetTickOptimization_Movement(bool bActivate);
	void SetTPPSpringarmOffset(float VerticalOffset);
	void SetupWeaponBlueprint();
	void SetWeaponInertia(const struct FRotator& InInertia);
	void SetWorldTransformIdentity();
	void ShowDynamicCrosshair(bool bShow);
	void SimulateHeadShot(const struct FTransform& SpawnTransform, const struct FTransform& ImpactTransform);
	void SimulatePhysicalHitRecovery();
	void SpawnBulletPassByEffect(const struct FVector& Location, float BulletVelocity);
	void SpawnPunchImpact(const struct FVector& InLocation, const struct FRotator& InRotation);
	void SpawnPunchImpact_Reliable(const struct FVector& InLocation, const struct FRotator& InRotation);
	void STAT_TickBegin();
	void STAT_TickEnd();
	void StopAllAnimMontages();
	void TickOptimization_Eval();
	void ToggleAnimDynamics();
	void UnBindCallbackToHUD(class ATslPlayerController* InController);
	void UpdateWeaponAttachPoint();

	bool Anim_IsMagazineVisible() const;
	bool CanSwim() const;
	class UTslAccessoryComponent* GetAccessorySlot(EAccessorySlot Slot) const;
	class UCameraComponent* GetActiveCamera() const;
	class AActor* GetActorCanInteract() const;
	struct FRotator GetAimOffsets() const;
	float GetAimStateAlpha() const;
	float GetAimStateTimer() const;
	EAnimStance GetAnimStance() const;
	EAnimWeaponType GetAnimWeaponType() const;
	class UCharacterBreathComponent* GetBreathComponent() const;
	bool GetBulletSpawnOverride() const;
	float GetCameraAnimOverrideAlpha() const;
	struct FVector GetCameraDOF() const;
	class UObject* GetCastObject() const;
	TScriptInterface<class IInteractionInterface> GetComponentCanInteract() const;
	bool GetCtrlShortCutOnOff() const;
	float GetCurrentHeightFromWaterFloor() const;
	struct FTransform GetCurrentMagazineLocation() const;
	class UStaticMesh* GetCurrentMagazineMesh() const;
	float GetCurrentWaterDepth() const;
	float GetCurrentWaterSurfaceBaseZ() const;
	float GetCurrentWaterSurfaceZ() const;
	class ATslWeapon* GetCurrentWeapon() const;
	struct FRotator GetDesiredRotation() const;
	float GetDirectionalSpeedModifier(EMovementType StanceType) const;
	class FString GetDirectionString() const;
	TSubclassOf<class AItemPackage> GetDropPackageType() const;
	bool GetDynamicCrosshairHidden() const;
	struct FRotator GetFreelookDeltaRotation() const;
	struct FRotator GetFreelookSavedRotation() const;
	float GetIndoorFactor() const;
	class FString GetInteractionString() const;
	struct FVector GetInteractObjectLocation() const;
	struct FRotator GetLastMoveRotation() const;
	float GetLeanLeftAlpha() const;
	float GetLeanRightAlpha() const;
	class FString GetLocationString() const;
	float GetMaxGroundSpeedOnSlope() const;
	float GetMaxSprintSpeed() const;
	TScriptInterface<class IInteractionInterface> GetObjectCanInteract() const;
	class AParachuteVehicle* GetParachute() const;
	bool GetParachuteLandingAssist() const;
	class FString GetPlayerName() const;
	float GetRunningSpeedModifier_Crouch() const;
	float GetRunningSpeedModifier_Prone() const;
	float GetRunningSpeedModifier_Stand() const;
	bool GetServerVaultFinished() const;
	class FString GetShortPlayerName() const;
	float GetSpeedModifierByWeaponClass() const;
	float GetSprintCurrentValue() const;
	float GetSprintingSpeedModifier_Crouch() const;
	float GetSprintingSpeedModifier_Prone() const;
	float GetSprintingSpeedModifier_Stand() const;
	EStanceMode GetStance() const;
	float GetTargetingSpeedModifier() const;
	class ATeam* GetTeam() const;
	class UCurveFloat* GetTPPCameraCurve() const;
	float GetTPPSpringarmOffset() const;
	class UTslCharacterMovement* GetTslCharacterMovement() const;
	class ATslPlayerController* GetTslPlayerController() const;
	class ATslPlayerState* GetTslPlayerState() const;
	class UVaultingData* GetVaultingDataByEnum(EVaultAnimType InVaultType) const;
	float GetVaultingDirection() const;
	float GetVaultTimer() const;
	TScriptInterface<class ITslVehicleInterface> GetVehicleInterface() const;
	class APawn* GetVehiclePawn() const;
	class UVehicleRiderComponent* GetVehicleRiderComponent() const;
	class UVehicleSeatInteractionComponent* GetVehicleSeat() const;
	class UTslVehicleSeatComponent* GetVehicleSeatComponent() const;
	bool GetWantsToJump() const;
	class ATslWeapon* GetWeapon() const;
	float GetWeaponADSTimeModifier() const;
	class ATslWeapon_Gun* GetWeaponGun() const;
	float GetWeaponGunCollisionAlpha() const;
	struct FTransform GetWeaponHandIK_Left() const;
	struct FTransform GetWeaponHandIK_Right() const;
	struct FRotator GetWeaponInertia() const;
	struct FTransform GetWeaponLeftHandIKTransform() const;
	float GetWeaponMovementModifierAim() const;
	float GetWeaponMovementModifierScope() const;
	bool GetWeaponObstructionRemote() const;
	float GetWeaponReloadPlayRate() const;
	class ATslWeapon_Throwable* GetWeaponThrowable() const;
	bool HasWeaponLeftHandIKSocket() const;
	bool IsActiveRagdoll() const;
	bool IsAlive() const;
	bool IsAnimDynamicsEnabled() const;
	bool IsAttacked() const;
	bool IsAudioTestEnabled() const;
	bool IsCameraUnderwater() const;
	bool IsCasting() const;
	bool IsCoatEquipped() const;
	bool IsCycleInProgress() const;
	bool IsDying() const;
	bool IsFallingFromHighAltitude() const;
	bool IsFallingWithParachute() const;
	bool IsFiring() const;
	bool IsFirstPerson() const;
	bool IsFloating() const;
	bool IsForcedProneAfterFall() const;
	bool IsForceRotation() const;
	bool IsForcingFall() const;
	bool IsFreelooking() const;
	bool IsGroggying() const;
	bool IsHipped() const;
	bool IsHitted() const;
	bool IsHoldingBreath() const;
	bool IsInAircraft() const;
	bool IsIndoor() const;
	bool IsInteracting() const;
	bool IsInVehicle() const;
	bool IsInWaterVolume() const;
	bool IsLocalOrSpectating() const;
	bool IsMagazineGunAttached() const;
	bool IsMagazineHandAttached() const;
	bool IsMeleeAttacking() const;
	bool IsMouseUse() const;
	bool IsMoving() const;
	bool IsParachuting() const;
	bool IsPeekLeft() const;
	bool IsPeekRight() const;
	bool IsPlayingPickUpAnimation() const;
	bool IsQuickThrowHigh() const;
	bool IsQuitter() const;
	bool IsReviving() const;
	bool IsRolling() const;
	bool IsRunning() const;
	bool IsScoping() const;
	bool IsSitting() const;
	bool IsSpectatingCharacter() const;
	bool IsSprinting() const;
	bool IsSwimming() const;
	bool IsTargeting() const;
	bool IsTeamMatch() const;
	bool IsUnderRoof() const;
	bool IsUnderwater() const;
	bool IsUpperCollision() const;
	bool IsUsingRightShoulderAiming() const;
	bool IsVaultCancelled() const;
	bool IsVaulting() const;
	bool IsVaultingDebugEnabled() const;
	bool IsVaultingEnabled() const;
	bool IsVehicleDriver() const;
	bool IsVehiclePassenger() const;
	bool IsWeaponArmed() const;
	bool IsWeaponUsingHighMagnificationScope() const;
	bool IsZombie() const;
	bool IsZooming() const;
	bool TickOptimization_IsOverMinimumDistance() const;
	bool TickOptimization_ShouldRunAnimUpdate() const;
	bool TickOptimization_ShouldRunMovementUpdate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslCharacter">();
	}
	static class ATslCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslCharacter>();
	}
};
#pragma pack(pop)
static_assert(alignof(ATslCharacter) == 0x000010, "Wrong alignment on ATslCharacter");
static_assert(sizeof(ATslCharacter) == 0x001520, "Wrong size on ATslCharacter");
static_assert(offsetof(ATslCharacter, TslPawnInputBindingComponent) == 0x000810, "Member 'ATslCharacter::TslPawnInputBindingComponent' has a wrong offset!");
static_assert(offsetof(ATslCharacter, TimerHandle_Targeting_HoldADS) == 0x000818, "Member 'ATslCharacter::TimerHandle_Targeting_HoldADS' has a wrong offset!");
static_assert(offsetof(ATslCharacter, bShouldAiming) == 0x000820, "Member 'ATslCharacter::bShouldAiming' has a wrong offset!");
static_assert(offsetof(ATslCharacter, bPeekLeftToggled) == 0x000821, "Member 'ATslCharacter::bPeekLeftToggled' has a wrong offset!");
static_assert(offsetof(ATslCharacter, bPeekRightToggled) == 0x000822, "Member 'ATslCharacter::bPeekRightToggled' has a wrong offset!");
static_assert(offsetof(ATslCharacter, CurrentAttackerPlayerState) == 0x000824, "Member 'ATslCharacter::CurrentAttackerPlayerState' has a wrong offset!");
static_assert(offsetof(ATslCharacter, LastAttackedPlayerState) == 0x00082C, "Member 'ATslCharacter::LastAttackedPlayerState' has a wrong offset!");
static_assert(offsetof(ATslCharacter, NoBagSpaceDelgate) == 0x000880, "Member 'ATslCharacter::NoBagSpaceDelgate' has a wrong offset!");
static_assert(offsetof(ATslCharacter, LastPossessedController) == 0x0008E8, "Member 'ATslCharacter::LastPossessedController' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Banks) == 0x0008F0, "Member 'ATslCharacter::Banks' has a wrong offset!");
static_assert(offsetof(ATslCharacter, BuffComponent) == 0x000900, "Member 'ATslCharacter::BuffComponent' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Remote_CastAnim) == 0x000948, "Member 'ATslCharacter::Remote_CastAnim' has a wrong offset!");
static_assert(offsetof(ATslCharacter, RevivingCharacter) == 0x000950, "Member 'ATslCharacter::RevivingCharacter' has a wrong offset!");
static_assert(offsetof(ATslCharacter, GroggyPlayerInstigator) == 0x000958, "Member 'ATslCharacter::GroggyPlayerInstigator' has a wrong offset!");
static_assert(offsetof(ATslCharacter, BuffFinalSpreadFactor) == 0x0009D8, "Member 'ATslCharacter::BuffFinalSpreadFactor' has a wrong offset!");
static_assert(offsetof(ATslCharacter, InventoryFacade) == 0x0009E0, "Member 'ATslCharacter::InventoryFacade' has a wrong offset!");
static_assert(offsetof(ATslCharacter, WeaponProcessor) == 0x0009E8, "Member 'ATslCharacter::WeaponProcessor' has a wrong offset!");
static_assert(offsetof(ATslCharacter, CharacterState) == 0x0009F0, "Member 'ATslCharacter::CharacterState' has a wrong offset!");
static_assert(offsetof(ATslCharacter, DropPackageType) == 0x000A10, "Member 'ATslCharacter::DropPackageType' has a wrong offset!");
static_assert(offsetof(ATslCharacter, SoundClearAk) == 0x000A18, "Member 'ATslCharacter::SoundClearAk' has a wrong offset!");
static_assert(offsetof(ATslCharacter, RemoteVolumeControlOn) == 0x000A20, "Member 'ATslCharacter::RemoteVolumeControlOn' has a wrong offset!");
static_assert(offsetof(ATslCharacter, RemoteVolumeControlOff) == 0x000A28, "Member 'ATslCharacter::RemoteVolumeControlOff' has a wrong offset!");
static_assert(offsetof(ATslCharacter, CameraFovRatioCurve) == 0x000A30, "Member 'ATslCharacter::CameraFovRatioCurve' has a wrong offset!");
static_assert(offsetof(ATslCharacter, HeavyFallVerticalVelocityThreshold) == 0x000A38, "Member 'ATslCharacter::HeavyFallVerticalVelocityThreshold' has a wrong offset!");
static_assert(offsetof(ATslCharacter, ExtremeFallVerticalVelocityThreshold) == 0x000A3C, "Member 'ATslCharacter::ExtremeFallVerticalVelocityThreshold' has a wrong offset!");
static_assert(offsetof(ATslCharacter, ProneFallVerticalVelocityThreshold) == 0x000A40, "Member 'ATslCharacter::ProneFallVerticalVelocityThreshold' has a wrong offset!");
static_assert(offsetof(ATslCharacter, HeavyFallMovementStopTime) == 0x000A44, "Member 'ATslCharacter::HeavyFallMovementStopTime' has a wrong offset!");
static_assert(offsetof(ATslCharacter, ExtremeFallMovementStopTime) == 0x000A48, "Member 'ATslCharacter::ExtremeFallMovementStopTime' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Punch_Damage) == 0x000A50, "Member 'ATslCharacter::Punch_Damage' has a wrong offset!");
static_assert(offsetof(ATslCharacter, PunchHeavy_Damage) == 0x000A54, "Member 'ATslCharacter::PunchHeavy_Damage' has a wrong offset!");
static_assert(offsetof(ATslCharacter, UnarmedDamageType) == 0x000A58, "Member 'ATslCharacter::UnarmedDamageType' has a wrong offset!");
static_assert(offsetof(ATslCharacter, ZombieDamageType) == 0x000A60, "Member 'ATslCharacter::ZombieDamageType' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Punch_Distance) == 0x000A68, "Member 'ATslCharacter::Punch_Distance' has a wrong offset!");
static_assert(offsetof(ATslCharacter, PunchHeavy_Distance) == 0x000A6C, "Member 'ATslCharacter::PunchHeavy_Distance' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Punch_Radius) == 0x000A70, "Member 'ATslCharacter::Punch_Radius' has a wrong offset!");
static_assert(offsetof(ATslCharacter, PunchHeavy_Radius) == 0x000A74, "Member 'ATslCharacter::PunchHeavy_Radius' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Punch_InitialLocation) == 0x000A78, "Member 'ATslCharacter::Punch_InitialLocation' has a wrong offset!");
static_assert(offsetof(ATslCharacter, LeanLeftTraceOffset) == 0x000A88, "Member 'ATslCharacter::LeanLeftTraceOffset' has a wrong offset!");
static_assert(offsetof(ATslCharacter, LeanRightTraceOffset) == 0x000A94, "Member 'ATslCharacter::LeanRightTraceOffset' has a wrong offset!");
static_assert(offsetof(ATslCharacter, LeanOffset_Stand) == 0x000AA8, "Member 'ATslCharacter::LeanOffset_Stand' has a wrong offset!");
static_assert(offsetof(ATslCharacter, LeanOffset_Crouch) == 0x000AAC, "Member 'ATslCharacter::LeanOffset_Crouch' has a wrong offset!");
static_assert(offsetof(ATslCharacter, LeanOffset_Prone) == 0x000AB0, "Member 'ATslCharacter::LeanOffset_Prone' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Sprint_MaxSpeed) == 0x000AC4, "Member 'ATslCharacter::Sprint_MaxSpeed' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Sprint_MinSpeed) == 0x000AC8, "Member 'ATslCharacter::Sprint_MinSpeed' has a wrong offset!");
static_assert(offsetof(ATslCharacter, SprintingFOV) == 0x000ACC, "Member 'ATslCharacter::SprintingFOV' has a wrong offset!");
static_assert(offsetof(ATslCharacter, MinimumBreathToHold) == 0x000AD0, "Member 'ATslCharacter::MinimumBreathToHold' has a wrong offset!");
static_assert(offsetof(ATslCharacter, SwimPoint) == 0x000AD8, "Member 'ATslCharacter::SwimPoint' has a wrong offset!");
static_assert(offsetof(ATslCharacter, SwimableWaterDepth) == 0x000AE0, "Member 'ATslCharacter::SwimableWaterDepth' has a wrong offset!");
static_assert(offsetof(ATslCharacter, CrouchWaterDepth) == 0x000AE4, "Member 'ATslCharacter::CrouchWaterDepth' has a wrong offset!");
static_assert(offsetof(ATslCharacter, ProneWaterDepth) == 0x000AE8, "Member 'ATslCharacter::ProneWaterDepth' has a wrong offset!");
static_assert(offsetof(ATslCharacter, WaterFloorDetectionLength) == 0x000AEC, "Member 'ATslCharacter::WaterFloorDetectionLength' has a wrong offset!");
static_assert(offsetof(ATslCharacter, SwimMaxControllerPitch) == 0x000AF0, "Member 'ATslCharacter::SwimMaxControllerPitch' has a wrong offset!");
static_assert(offsetof(ATslCharacter, UnderwaterSwimGapFromSurface) == 0x000AF4, "Member 'ATslCharacter::UnderwaterSwimGapFromSurface' has a wrong offset!");
static_assert(offsetof(ATslCharacter, SwimTrailEffectClass) == 0x000AF8, "Member 'ATslCharacter::SwimTrailEffectClass' has a wrong offset!");
static_assert(offsetof(ATslCharacter, SwimTrailEffect) == 0x000B00, "Member 'ATslCharacter::SwimTrailEffect' has a wrong offset!");
static_assert(offsetof(ATslCharacter, ParticleSocket_SwimIdleRipple) == 0x000B08, "Member 'ATslCharacter::ParticleSocket_SwimIdleRipple' has a wrong offset!");
static_assert(offsetof(ATslCharacter, SwimIdleRippleEffectClass) == 0x000B10, "Member 'ATslCharacter::SwimIdleRippleEffectClass' has a wrong offset!");
static_assert(offsetof(ATslCharacter, maxNumSwimIdleRippleEffect) == 0x000B18, "Member 'ATslCharacter::maxNumSwimIdleRippleEffect' has a wrong offset!");
static_assert(offsetof(ATslCharacter, SwimIdleRippleOffsetFromSurface) == 0x000B1C, "Member 'ATslCharacter::SwimIdleRippleOffsetFromSurface' has a wrong offset!");
static_assert(offsetof(ATslCharacter, BreathComponent) == 0x000B30, "Member 'ATslCharacter::BreathComponent' has a wrong offset!");
static_assert(offsetof(ATslCharacter, BreathPoint) == 0x000B38, "Member 'ATslCharacter::BreathPoint' has a wrong offset!");
static_assert(offsetof(ATslCharacter, UnderwaterChokeEffectClass) == 0x000B40, "Member 'ATslCharacter::UnderwaterChokeEffectClass' has a wrong offset!");
static_assert(offsetof(ATslCharacter, UnderwaterChokeEffect) == 0x000B48, "Member 'ATslCharacter::UnderwaterChokeEffect' has a wrong offset!");
static_assert(offsetof(ATslCharacter, IndoorCheckDistance) == 0x000B50, "Member 'ATslCharacter::IndoorCheckDistance' has a wrong offset!");
static_assert(offsetof(ATslCharacter, IndoorCheckHalfConeAngle) == 0x000B58, "Member 'ATslCharacter::IndoorCheckHalfConeAngle' has a wrong offset!");
static_assert(offsetof(ATslCharacter, IndoorCheckSuccessRate) == 0x000B5C, "Member 'ATslCharacter::IndoorCheckSuccessRate' has a wrong offset!");
static_assert(offsetof(ATslCharacter, IndoorCheckSamplingQueueSize) == 0x000B60, "Member 'ATslCharacter::IndoorCheckSamplingQueueSize' has a wrong offset!");
static_assert(offsetof(ATslCharacter, IndoorCheckAccuracyMultiplier) == 0x000B64, "Member 'ATslCharacter::IndoorCheckAccuracyMultiplier' has a wrong offset!");
static_assert(offsetof(ATslCharacter, FootSoundObstructionCheckInterval) == 0x000B78, "Member 'ATslCharacter::FootSoundObstructionCheckInterval' has a wrong offset!");
static_assert(offsetof(ATslCharacter, FootSoundObstructionCheckMaxDistance) == 0x000B7C, "Member 'ATslCharacter::FootSoundObstructionCheckMaxDistance' has a wrong offset!");
static_assert(offsetof(ATslCharacter, ParachuteAttachPoint) == 0x000B88, "Member 'ATslCharacter::ParachuteAttachPoint' has a wrong offset!");
static_assert(offsetof(ATslCharacter, ReleasingParachuteAltitude) == 0x000B90, "Member 'ATslCharacter::ReleasingParachuteAltitude' has a wrong offset!");
static_assert(offsetof(ATslCharacter, ForceReleasingParachuteAltitude) == 0x000B94, "Member 'ATslCharacter::ForceReleasingParachuteAltitude' has a wrong offset!");
static_assert(offsetof(ATslCharacter, MinimumParachuteAltitude) == 0x000B98, "Member 'ATslCharacter::MinimumParachuteAltitude' has a wrong offset!");
static_assert(offsetof(ATslCharacter, ParachuteType) == 0x000BA0, "Member 'ATslCharacter::ParachuteType' has a wrong offset!");
static_assert(offsetof(ATslCharacter, bParachuteLandingAssist) == 0x000BA8, "Member 'ATslCharacter::bParachuteLandingAssist' has a wrong offset!");
static_assert(offsetof(ATslCharacter, CastComponent) == 0x000BB0, "Member 'ATslCharacter::CastComponent' has a wrong offset!");
static_assert(offsetof(ATslCharacter, StanceComponent) == 0x000BB8, "Member 'ATslCharacter::StanceComponent' has a wrong offset!");
static_assert(offsetof(ATslCharacter, HackReporterComponent) == 0x000BC0, "Member 'ATslCharacter::HackReporterComponent' has a wrong offset!");
static_assert(offsetof(ATslCharacter, bAcceptHitsWhileNotAlive) == 0x000BC8, "Member 'ATslCharacter::bAcceptHitsWhileNotAlive' has a wrong offset!");
static_assert(offsetof(ATslCharacter, SimulatedHit_Initial) == 0x000BCC, "Member 'ATslCharacter::SimulatedHit_Initial' has a wrong offset!");
static_assert(offsetof(ATslCharacter, SimulatedHit_RecoveryPerSecond) == 0x000BD0, "Member 'ATslCharacter::SimulatedHit_RecoveryPerSecond' has a wrong offset!");
static_assert(offsetof(ATslCharacter, SimulatedHit_Value) == 0x000BD4, "Member 'ATslCharacter::SimulatedHit_Value' has a wrong offset!");
static_assert(offsetof(ATslCharacter, SimulatedHit_ImpulsePower) == 0x000BD8, "Member 'ATslCharacter::SimulatedHit_ImpulsePower' has a wrong offset!");
static_assert(offsetof(ATslCharacter, SimlatedHit_PunchLightPower) == 0x000BDC, "Member 'ATslCharacter::SimlatedHit_PunchLightPower' has a wrong offset!");
static_assert(offsetof(ATslCharacter, SimlatedHit_PunchHeavyPower) == 0x000BE0, "Member 'ATslCharacter::SimlatedHit_PunchHeavyPower' has a wrong offset!");
static_assert(offsetof(ATslCharacter, PunchImpactEffect) == 0x000BE8, "Member 'ATslCharacter::PunchImpactEffect' has a wrong offset!");
static_assert(offsetof(ATslCharacter, WeaponAnimInfoComponent) == 0x000C18, "Member 'ATslCharacter::WeaponAnimInfoComponent' has a wrong offset!");
static_assert(offsetof(ATslCharacter, CharacterAccessory_Primary) == 0x000C20, "Member 'ATslCharacter::CharacterAccessory_Primary' has a wrong offset!");
static_assert(offsetof(ATslCharacter, CharacterAccessory_Secondary) == 0x000C28, "Member 'ATslCharacter::CharacterAccessory_Secondary' has a wrong offset!");
static_assert(offsetof(ATslCharacter, CharacterAccessory_Sidearm) == 0x000C30, "Member 'ATslCharacter::CharacterAccessory_Sidearm' has a wrong offset!");
static_assert(offsetof(ATslCharacter, CharacterAccessory_Melee) == 0x000C38, "Member 'ATslCharacter::CharacterAccessory_Melee' has a wrong offset!");
static_assert(offsetof(ATslCharacter, CharacterAccessory_Thrown) == 0x000C40, "Member 'ATslCharacter::CharacterAccessory_Thrown' has a wrong offset!");
static_assert(offsetof(ATslCharacter, FootStepEffectClassInDirt) == 0x000C48, "Member 'ATslCharacter::FootStepEffectClassInDirt' has a wrong offset!");
static_assert(offsetof(ATslCharacter, FootStepEffectClassInGrass) == 0x000C50, "Member 'ATslCharacter::FootStepEffectClassInGrass' has a wrong offset!");
static_assert(offsetof(ATslCharacter, FootStepEffectClassInRock) == 0x000C58, "Member 'ATslCharacter::FootStepEffectClassInRock' has a wrong offset!");
static_assert(offsetof(ATslCharacter, FootStepEffectClassInSand) == 0x000C60, "Member 'ATslCharacter::FootStepEffectClassInSand' has a wrong offset!");
static_assert(offsetof(ATslCharacter, ParticleSocketFootLeft) == 0x000C68, "Member 'ATslCharacter::ParticleSocketFootLeft' has a wrong offset!");
static_assert(offsetof(ATslCharacter, ParticleSocketFootRight) == 0x000C70, "Member 'ATslCharacter::ParticleSocketFootRight' has a wrong offset!");
static_assert(offsetof(ATslCharacter, FootStepEffectClassInWater) == 0x000C78, "Member 'ATslCharacter::FootStepEffectClassInWater' has a wrong offset!");
static_assert(offsetof(ATslCharacter, FootStepEffect) == 0x000C80, "Member 'ATslCharacter::FootStepEffect' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Team) == 0x000C88, "Member 'ATslCharacter::Team' has a wrong offset!");
static_assert(offsetof(ATslCharacter, ViewTargetTempComponent) == 0x000CA8, "Member 'ATslCharacter::ViewTargetTempComponent' has a wrong offset!");
static_assert(offsetof(ATslCharacter, ValidateLocationComponent) == 0x000CB0, "Member 'ATslCharacter::ValidateLocationComponent' has a wrong offset!");
static_assert(offsetof(ATslCharacter, ThrowableTrajectoryViewComponent) == 0x000CB8, "Member 'ATslCharacter::ThrowableTrajectoryViewComponent' has a wrong offset!");
static_assert(offsetof(ATslCharacter, HeadAttachPoint) == 0x000CC8, "Member 'ATslCharacter::HeadAttachPoint' has a wrong offset!");
static_assert(offsetof(ATslCharacter, CameraHeadHideDistance) == 0x000CD0, "Member 'ATslCharacter::CameraHeadHideDistance' has a wrong offset!");
static_assert(offsetof(ATslCharacter, CrouchedCameraMove) == 0x000CE0, "Member 'ATslCharacter::CrouchedCameraMove' has a wrong offset!");
static_assert(offsetof(ATslCharacter, PronedCameraMove) == 0x000CEC, "Member 'ATslCharacter::PronedCameraMove' has a wrong offset!");
static_assert(offsetof(ATslCharacter, GroggyCameraMove) == 0x000CF8, "Member 'ATslCharacter::GroggyCameraMove' has a wrong offset!");
static_assert(offsetof(ATslCharacter, CrouchedCameraMoveSpeed) == 0x000D04, "Member 'ATslCharacter::CrouchedCameraMoveSpeed' has a wrong offset!");
static_assert(offsetof(ATslCharacter, PronedCameraMoveSpeed) == 0x000D08, "Member 'ATslCharacter::PronedCameraMoveSpeed' has a wrong offset!");
static_assert(offsetof(ATslCharacter, GroggyCameraMoveSpeed) == 0x000D0C, "Member 'ATslCharacter::GroggyCameraMoveSpeed' has a wrong offset!");
static_assert(offsetof(ATslCharacter, LastTakeHitInfo) == 0x000D58, "Member 'ATslCharacter::LastTakeHitInfo' has a wrong offset!");
static_assert(offsetof(ATslCharacter, TargetingSpeedModifier) == 0x000D9C, "Member 'ATslCharacter::TargetingSpeedModifier' has a wrong offset!");
static_assert(offsetof(ATslCharacter, TargetingType) == 0x000DA0, "Member 'ATslCharacter::TargetingType' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Stand_RunningSpeedModifier) == 0x000DA4, "Member 'ATslCharacter::Stand_RunningSpeedModifier' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Stand_SprintingSpeedModifier) == 0x000DA8, "Member 'ATslCharacter::Stand_SprintingSpeedModifier' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Stand_SprintingBigGunModifier) == 0x000DAC, "Member 'ATslCharacter::Stand_SprintingBigGunModifier' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Stand_SprintingRifleModifier) == 0x000DB0, "Member 'ATslCharacter::Stand_SprintingRifleModifier' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Stand_SprintingSmallGunMOdifier) == 0x000DB4, "Member 'ATslCharacter::Stand_SprintingSmallGunMOdifier' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Crouch_RunningSpeedModifier) == 0x000DB8, "Member 'ATslCharacter::Crouch_RunningSpeedModifier' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Crouch_SprintingSpeedModifier) == 0x000DBC, "Member 'ATslCharacter::Crouch_SprintingSpeedModifier' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Prone_RunningSpeedModifier) == 0x000DC0, "Member 'ATslCharacter::Prone_RunningSpeedModifier' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Prone_SprintingSpeedModifier) == 0x000DC4, "Member 'ATslCharacter::Prone_SprintingSpeedModifier' has a wrong offset!");
static_assert(offsetof(ATslCharacter, ReviveCastingTime) == 0x000DC8, "Member 'ATslCharacter::ReviveCastingTime' has a wrong offset!");
static_assert(offsetof(ATslCharacter, bOutSidePlayerArea) == 0x000DD0, "Member 'ATslCharacter::bOutSidePlayerArea' has a wrong offset!");
static_assert(offsetof(ATslCharacter, bUseRightShoulderAiming) == 0x000DD1, "Member 'ATslCharacter::bUseRightShoulderAiming' has a wrong offset!");
static_assert(offsetof(ATslCharacter, GunDirectionSway) == 0x000DD4, "Member 'ATslCharacter::GunDirectionSway' has a wrong offset!");
static_assert(offsetof(ATslCharacter, AimOffsets) == 0x000DE0, "Member 'ATslCharacter::AimOffsets' has a wrong offset!");
static_assert(offsetof(ATslCharacter, LastAimOffsets) == 0x000DEC, "Member 'ATslCharacter::LastAimOffsets' has a wrong offset!");
static_assert(offsetof(ATslCharacter, AimoffsetsLastRepTime) == 0x000DF8, "Member 'ATslCharacter::AimoffsetsLastRepTime' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Curve_JumpCamera) == 0x000E40, "Member 'ATslCharacter::Curve_JumpCamera' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Curve_FPPCameraOffsetByFOV) == 0x000E48, "Member 'ATslCharacter::Curve_FPPCameraOffsetByFOV' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Curve_DBNOFadeOut) == 0x000E50, "Member 'ATslCharacter::Curve_DBNOFadeOut' has a wrong offset!");
static_assert(offsetof(ATslCharacter, DBNOFadeOutLerpSpeed) == 0x000E58, "Member 'ATslCharacter::DBNOFadeOutLerpSpeed' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Curve_StandWalk) == 0x000E60, "Member 'ATslCharacter::Curve_StandWalk' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Curve_StandRun) == 0x000E68, "Member 'ATslCharacter::Curve_StandRun' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Curve_StandSprint) == 0x000E70, "Member 'ATslCharacter::Curve_StandSprint' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Curve_CrouchWalk) == 0x000E78, "Member 'ATslCharacter::Curve_CrouchWalk' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Curve_CrouchRun) == 0x000E80, "Member 'ATslCharacter::Curve_CrouchRun' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Curve_CrouchSprint) == 0x000E88, "Member 'ATslCharacter::Curve_CrouchSprint' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Curve_ProneWalk) == 0x000E90, "Member 'ATslCharacter::Curve_ProneWalk' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Curve_ProneRun) == 0x000E98, "Member 'ATslCharacter::Curve_ProneRun' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Curve_ProneSprint) == 0x000EA0, "Member 'ATslCharacter::Curve_ProneSprint' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Curve_Swim) == 0x000EA8, "Member 'ATslCharacter::Curve_Swim' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Curve_UnderwaterSwim) == 0x000EB0, "Member 'ATslCharacter::Curve_UnderwaterSwim' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Curve_StandScope) == 0x000EB8, "Member 'ATslCharacter::Curve_StandScope' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Curve_CrouchScope) == 0x000EC0, "Member 'ATslCharacter::Curve_CrouchScope' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Curve_ProneScope) == 0x000EC8, "Member 'ATslCharacter::Curve_ProneScope' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Curve_StandAim) == 0x000ED0, "Member 'ATslCharacter::Curve_StandAim' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Curve_CrouchAim) == 0x000ED8, "Member 'ATslCharacter::Curve_CrouchAim' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Curve_ProneAim) == 0x000EE0, "Member 'ATslCharacter::Curve_ProneAim' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Curve_DBNO) == 0x000EE8, "Member 'ATslCharacter::Curve_DBNO' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Curve_GroundAngle) == 0x000EF0, "Member 'ATslCharacter::Curve_GroundAngle' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Curve_WeaponSway) == 0x000EF8, "Member 'ATslCharacter::Curve_WeaponSway' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Curve_TurningLerp) == 0x000F00, "Member 'ATslCharacter::Curve_TurningLerp' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Curve_TurningLerpLocomotion) == 0x000F08, "Member 'ATslCharacter::Curve_TurningLerpLocomotion' has a wrong offset!");
static_assert(offsetof(ATslCharacter, DirectionalSpeedModifier) == 0x000F10, "Member 'ATslCharacter::DirectionalSpeedModifier' has a wrong offset!");
static_assert(offsetof(ATslCharacter, PointDamageForceMultiplier) == 0x000F14, "Member 'ATslCharacter::PointDamageForceMultiplier' has a wrong offset!");
static_assert(offsetof(ATslCharacter, PointDamageForce_MapMin) == 0x000F18, "Member 'ATslCharacter::PointDamageForce_MapMin' has a wrong offset!");
static_assert(offsetof(ATslCharacter, PointDamageForce_MapMax) == 0x000F1C, "Member 'ATslCharacter::PointDamageForce_MapMax' has a wrong offset!");
static_assert(offsetof(ATslCharacter, RadialDamageForceMultiplier) == 0x000F20, "Member 'ATslCharacter::RadialDamageForceMultiplier' has a wrong offset!");
static_assert(offsetof(ATslCharacter, RadialDamageFalloffType) == 0x000F24, "Member 'ATslCharacter::RadialDamageFalloffType' has a wrong offset!");
static_assert(offsetof(ATslCharacter, RollLeftAnim) == 0x000F28, "Member 'ATslCharacter::RollLeftAnim' has a wrong offset!");
static_assert(offsetof(ATslCharacter, RollRightAnim) == 0x000F30, "Member 'ATslCharacter::RollRightAnim' has a wrong offset!");
static_assert(offsetof(ATslCharacter, CharacterAnim) == 0x000F38, "Member 'ATslCharacter::CharacterAnim' has a wrong offset!");
static_assert(offsetof(ATslCharacter, NetOwnerController) == 0x000F48, "Member 'ATslCharacter::NetOwnerController' has a wrong offset!");
static_assert(offsetof(ATslCharacter, LeanAlphaSpeed) == 0x000F50, "Member 'ATslCharacter::LeanAlphaSpeed' has a wrong offset!");
static_assert(offsetof(ATslCharacter, TurnSpeedHip) == 0x000F54, "Member 'ATslCharacter::TurnSpeedHip' has a wrong offset!");
static_assert(offsetof(ATslCharacter, TurnSpeedAimed) == 0x000F58, "Member 'ATslCharacter::TurnSpeedAimed' has a wrong offset!");
static_assert(offsetof(ATslCharacter, TurnSpeedOverLimit) == 0x000F5C, "Member 'ATslCharacter::TurnSpeedOverLimit' has a wrong offset!");
static_assert(offsetof(ATslCharacter, MinTurnAngleHip) == 0x000F60, "Member 'ATslCharacter::MinTurnAngleHip' has a wrong offset!");
static_assert(offsetof(ATslCharacter, MinTurnAngleAim) == 0x000F64, "Member 'ATslCharacter::MinTurnAngleAim' has a wrong offset!");
static_assert(offsetof(ATslCharacter, TurnLinearEndThreshold) == 0x000F68, "Member 'ATslCharacter::TurnLinearEndThreshold' has a wrong offset!");
static_assert(offsetof(ATslCharacter, bNonLinearTurn) == 0x000F6C, "Member 'ATslCharacter::bNonLinearTurn' has a wrong offset!");
static_assert(offsetof(ATslCharacter, TurnNonLinearEndThreshold) == 0x000F70, "Member 'ATslCharacter::TurnNonLinearEndThreshold' has a wrong offset!");
static_assert(offsetof(ATslCharacter, TurnNonLinearInterpSpeed) == 0x000F74, "Member 'ATslCharacter::TurnNonLinearInterpSpeed' has a wrong offset!");
static_assert(offsetof(ATslCharacter, CapsuleTurnInterpSpeedLocomotion) == 0x000F78, "Member 'ATslCharacter::CapsuleTurnInterpSpeedLocomotion' has a wrong offset!");
static_assert(offsetof(ATslCharacter, CapsuleTurnInterpSpeedLocomotionSprint) == 0x000F7C, "Member 'ATslCharacter::CapsuleTurnInterpSpeedLocomotionSprint' has a wrong offset!");
static_assert(offsetof(ATslCharacter, CapsuleTurnInterpSpeedLocomotionProne) == 0x000F80, "Member 'ATslCharacter::CapsuleTurnInterpSpeedLocomotionProne' has a wrong offset!");
static_assert(offsetof(ATslCharacter, CapsuleTurnInterpSpeedStationary) == 0x000F84, "Member 'ATslCharacter::CapsuleTurnInterpSpeedStationary' has a wrong offset!");
static_assert(offsetof(ATslCharacter, FPPCameraBoneName) == 0x000FA0, "Member 'ATslCharacter::FPPCameraBoneName' has a wrong offset!");
static_assert(offsetof(ATslCharacter, TPPCameraBoneName) == 0x000FA8, "Member 'ATslCharacter::TPPCameraBoneName' has a wrong offset!");
static_assert(offsetof(ATslCharacter, AimStateDefaultTime) == 0x000FBC, "Member 'ATslCharacter::AimStateDefaultTime' has a wrong offset!");
static_assert(offsetof(ATslCharacter, AimStateReturnTime) == 0x000FC0, "Member 'ATslCharacter::AimStateReturnTime' has a wrong offset!");
static_assert(offsetof(ATslCharacter, AimStateDrawTime) == 0x000FC4, "Member 'ATslCharacter::AimStateDrawTime' has a wrong offset!");
static_assert(offsetof(ATslCharacter, bAimStateActive) == 0x000FD0, "Member 'ATslCharacter::bAimStateActive' has a wrong offset!");
static_assert(offsetof(ATslCharacter, CanGroggyDamageTime) == 0x000FD4, "Member 'ATslCharacter::CanGroggyDamageTime' has a wrong offset!");
static_assert(offsetof(ATslCharacter, GroggyStartText) == 0x000FD8, "Member 'ATslCharacter::GroggyStartText' has a wrong offset!");
static_assert(offsetof(ATslCharacter, GroggyCancelText) == 0x000FF0, "Member 'ATslCharacter::GroggyCancelText' has a wrong offset!");
static_assert(offsetof(ATslCharacter, GroggyFinishText) == 0x001008, "Member 'ATslCharacter::GroggyFinishText' has a wrong offset!");
static_assert(offsetof(ATslCharacter, GamepadRunningValue) == 0x001020, "Member 'ATslCharacter::GamepadRunningValue' has a wrong offset!");
static_assert(offsetof(ATslCharacter, BlendTargetViewRotation) == 0x001030, "Member 'ATslCharacter::BlendTargetViewRotation' has a wrong offset!");
static_assert(offsetof(ATslCharacter, DesiredDirection) == 0x00103C, "Member 'ATslCharacter::DesiredDirection' has a wrong offset!");
static_assert(offsetof(ATslCharacter, InvulnerablilityBuff) == 0x001048, "Member 'ATslCharacter::InvulnerablilityBuff' has a wrong offset!");
static_assert(offsetof(ATslCharacter, bInvulnerablilityEffectVisible) == 0x001050, "Member 'ATslCharacter::bInvulnerablilityEffectVisible' has a wrong offset!");
static_assert(offsetof(ATslCharacter, ComponentsToDestroyOnDedicatedServer) == 0x001058, "Member 'ATslCharacter::ComponentsToDestroyOnDedicatedServer' has a wrong offset!");
static_assert(offsetof(ATslCharacter, ZombieCustomizationData) == 0x001068, "Member 'ATslCharacter::ZombieCustomizationData' has a wrong offset!");
static_assert(offsetof(ATslCharacter, bIsHoldingBreath) == 0x001078, "Member 'ATslCharacter::bIsHoldingBreath' has a wrong offset!");
static_assert(offsetof(ATslCharacter, Health) == 0x00107C, "Member 'ATslCharacter::Health' has a wrong offset!");
static_assert(offsetof(ATslCharacter, HealthMax) == 0x001080, "Member 'ATslCharacter::HealthMax' has a wrong offset!");
static_assert(offsetof(ATslCharacter, GroggyHealth) == 0x001084, "Member 'ATslCharacter::GroggyHealth' has a wrong offset!");
static_assert(offsetof(ATslCharacter, GroggyHealthMax) == 0x001088, "Member 'ATslCharacter::GroggyHealthMax' has a wrong offset!");
static_assert(offsetof(ATslCharacter, DecreaseGroggyHealthPerSecond) == 0x00108C, "Member 'ATslCharacter::DecreaseGroggyHealthPerSecond' has a wrong offset!");
static_assert(offsetof(ATslCharacter, GroggyDamageWeight) == 0x001090, "Member 'ATslCharacter::GroggyDamageWeight' has a wrong offset!");
static_assert(offsetof(ATslCharacter, GroggyDamageType) == 0x001098, "Member 'ATslCharacter::GroggyDamageType' has a wrong offset!");
static_assert(offsetof(ATslCharacter, HealthByRevive) == 0x0010A0, "Member 'ATslCharacter::HealthByRevive' has a wrong offset!");
static_assert(offsetof(ATslCharacter, GroggyToDieAkEvent) == 0x0010A8, "Member 'ATslCharacter::GroggyToDieAkEvent' has a wrong offset!");
static_assert(offsetof(ATslCharacter, BoostGauge) == 0x0010B0, "Member 'ATslCharacter::BoostGauge' has a wrong offset!");
static_assert(offsetof(ATslCharacter, BoostGaugeMax) == 0x0010B4, "Member 'ATslCharacter::BoostGaugeMax' has a wrong offset!");
static_assert(offsetof(ATslCharacter, DecreaseTimerSecond) == 0x0010B8, "Member 'ATslCharacter::DecreaseTimerSecond' has a wrong offset!");
static_assert(offsetof(ATslCharacter, DecreaseBoostGaugeByTime) == 0x0010BC, "Member 'ATslCharacter::DecreaseBoostGaugeByTime' has a wrong offset!");
static_assert(offsetof(ATslCharacter, BuffWithBoostGauge) == 0x0010C0, "Member 'ATslCharacter::BuffWithBoostGauge' has a wrong offset!");
static_assert(offsetof(ATslCharacter, MedKitClass) == 0x0010D0, "Member 'ATslCharacter::MedKitClass' has a wrong offset!");
static_assert(offsetof(ATslCharacter, FirstAidClass) == 0x0010D8, "Member 'ATslCharacter::FirstAidClass' has a wrong offset!");
static_assert(offsetof(ATslCharacter, BandageClass) == 0x0010E0, "Member 'ATslCharacter::BandageClass' has a wrong offset!");
static_assert(offsetof(ATslCharacter, AdrenalineClass) == 0x0010E8, "Member 'ATslCharacter::AdrenalineClass' has a wrong offset!");
static_assert(offsetof(ATslCharacter, PainKillerClass) == 0x0010F0, "Member 'ATslCharacter::PainKillerClass' has a wrong offset!");
static_assert(offsetof(ATslCharacter, EnergyDrinkClass) == 0x0010F8, "Member 'ATslCharacter::EnergyDrinkClass' has a wrong offset!");
static_assert(offsetof(ATslCharacter, BoostItemClasses) == 0x001100, "Member 'ATslCharacter::BoostItemClasses' has a wrong offset!");
static_assert(offsetof(ATslCharacter, HealItemClasses) == 0x001110, "Member 'ATslCharacter::HealItemClasses' has a wrong offset!");
static_assert(offsetof(ATslCharacter, GrenadeClass) == 0x001120, "Member 'ATslCharacter::GrenadeClass' has a wrong offset!");
static_assert(offsetof(ATslCharacter, MolotovClass) == 0x001128, "Member 'ATslCharacter::MolotovClass' has a wrong offset!");
static_assert(offsetof(ATslCharacter, SmokeBombClass) == 0x001130, "Member 'ATslCharacter::SmokeBombClass' has a wrong offset!");
static_assert(offsetof(ATslCharacter, FlashBangClass) == 0x001138, "Member 'ATslCharacter::FlashBangClass' has a wrong offset!");
static_assert(offsetof(ATslCharacter, LaunchInstigator) == 0x001144, "Member 'ATslCharacter::LaunchInstigator' has a wrong offset!");
static_assert(offsetof(ATslCharacter, LaunchCauser) == 0x00114C, "Member 'ATslCharacter::LaunchCauser' has a wrong offset!");
static_assert(offsetof(ATslCharacter, LastLaunchTime) == 0x001158, "Member 'ATslCharacter::LastLaunchTime' has a wrong offset!");
static_assert(offsetof(ATslCharacter, AuthorizedPlayerState) == 0x001160, "Member 'ATslCharacter::AuthorizedPlayerState' has a wrong offset!");
static_assert(offsetof(ATslCharacter, ShoesSoundType) == 0x001168, "Member 'ATslCharacter::ShoesSoundType' has a wrong offset!");
static_assert(offsetof(ATslCharacter, InteractorComponent) == 0x001170, "Member 'ATslCharacter::InteractorComponent' has a wrong offset!");
static_assert(offsetof(ATslCharacter, InteractionComponent) == 0x001178, "Member 'ATslCharacter::InteractionComponent' has a wrong offset!");
static_assert(offsetof(ATslCharacter, VehicleRiderComponent) == 0x001180, "Member 'ATslCharacter::VehicleRiderComponent' has a wrong offset!");
static_assert(offsetof(ATslCharacter, OutSidePlayerAreaEffectClass) == 0x001188, "Member 'ATslCharacter::OutSidePlayerAreaEffectClass' has a wrong offset!");
static_assert(offsetof(ATslCharacter, OutSidePlayerAreaEffect) == 0x001190, "Member 'ATslCharacter::OutSidePlayerAreaEffect' has a wrong offset!");
static_assert(offsetof(ATslCharacter, DBNOEffectClass) == 0x001198, "Member 'ATslCharacter::DBNOEffectClass' has a wrong offset!");
static_assert(offsetof(ATslCharacter, DBNOEffect) == 0x0011A0, "Member 'ATslCharacter::DBNOEffect' has a wrong offset!");
static_assert(offsetof(ATslCharacter, ShadowMesh) == 0x001388, "Member 'ATslCharacter::ShadowMesh' has a wrong offset!");
static_assert(offsetof(ATslCharacter, TargetingFOV) == 0x001390, "Member 'ATslCharacter::TargetingFOV' has a wrong offset!");
static_assert(offsetof(ATslCharacter, AimingDelay) == 0x001394, "Member 'ATslCharacter::AimingDelay' has a wrong offset!");
static_assert(offsetof(ATslCharacter, ScopingDelay) == 0x00139C, "Member 'ATslCharacter::ScopingDelay' has a wrong offset!");
static_assert(offsetof(ATslCharacter, AttackStateOffDelayTime) == 0x0013A0, "Member 'ATslCharacter::AttackStateOffDelayTime' has a wrong offset!");
static_assert(offsetof(ATslCharacter, HitStateOffDelayTime) == 0x0013A4, "Member 'ATslCharacter::HitStateOffDelayTime' has a wrong offset!");
static_assert(offsetof(ATslCharacter, HitMePlayerStateOffDelayTime) == 0x0013A8, "Member 'ATslCharacter::HitMePlayerStateOffDelayTime' has a wrong offset!");
static_assert(offsetof(ATslCharacter, DamageHeadScale) == 0x0013E0, "Member 'ATslCharacter::DamageHeadScale' has a wrong offset!");
static_assert(offsetof(ATslCharacter, DamageArmScale) == 0x0013E4, "Member 'ATslCharacter::DamageArmScale' has a wrong offset!");
static_assert(offsetof(ATslCharacter, DamageStomachScale) == 0x0013E8, "Member 'ATslCharacter::DamageStomachScale' has a wrong offset!");
static_assert(offsetof(ATslCharacter, DamageLegScale) == 0x0013EC, "Member 'ATslCharacter::DamageLegScale' has a wrong offset!");
static_assert(offsetof(ATslCharacter, HeadBoneNames) == 0x0013F0, "Member 'ATslCharacter::HeadBoneNames' has a wrong offset!");
static_assert(offsetof(ATslCharacter, ArmBoneNames) == 0x001400, "Member 'ATslCharacter::ArmBoneNames' has a wrong offset!");
static_assert(offsetof(ATslCharacter, TorsoBoneNames) == 0x001410, "Member 'ATslCharacter::TorsoBoneNames' has a wrong offset!");
static_assert(offsetof(ATslCharacter, StomachBoneNames) == 0x001420, "Member 'ATslCharacter::StomachBoneNames' has a wrong offset!");
static_assert(offsetof(ATslCharacter, LegBoneNames) == 0x001430, "Member 'ATslCharacter::LegBoneNames' has a wrong offset!");
static_assert(offsetof(ATslCharacter, FallDamageFactor) == 0x001444, "Member 'ATslCharacter::FallDamageFactor' has a wrong offset!");
static_assert(offsetof(ATslCharacter, FallDamageVelocityMin) == 0x001448, "Member 'ATslCharacter::FallDamageVelocityMin' has a wrong offset!");
static_assert(offsetof(ATslCharacter, bIsActiveRagdollActive) == 0x00144C, "Member 'ATslCharacter::bIsActiveRagdollActive' has a wrong offset!");
static_assert(offsetof(ATslCharacter, CorpseLifeSpan) == 0x001450, "Member 'ATslCharacter::CorpseLifeSpan' has a wrong offset!");
static_assert(offsetof(ATslCharacter, JumpStartLocation_CP) == 0x001480, "Member 'ATslCharacter::JumpStartLocation_CP' has a wrong offset!");
static_assert(offsetof(ATslCharacter, LandPredictedLocation_CP) == 0x00148C, "Member 'ATslCharacter::LandPredictedLocation_CP' has a wrong offset!");
static_assert(offsetof(ATslCharacter, FallHeight_CP) == 0x001498, "Member 'ATslCharacter::FallHeight_CP' has a wrong offset!");
static_assert(offsetof(ATslCharacter, bIsVaulting_CP) == 0x00149C, "Member 'ATslCharacter::bIsVaulting_CP' has a wrong offset!");
static_assert(offsetof(ATslCharacter, VaultTimer_CP) == 0x0014A0, "Member 'ATslCharacter::VaultTimer_CP' has a wrong offset!");
static_assert(offsetof(ATslCharacter, VaultEndVelocity_CP) == 0x0014A4, "Member 'ATslCharacter::VaultEndVelocity_CP' has a wrong offset!");
static_assert(offsetof(ATslCharacter, VaultLastLocation_CP) == 0x0014B0, "Member 'ATslCharacter::VaultLastLocation_CP' has a wrong offset!");
static_assert(offsetof(ATslCharacter, bIsClimbing_CP) == 0x0014BC, "Member 'ATslCharacter::bIsClimbing_CP' has a wrong offset!");
static_assert(offsetof(ATslCharacter, bEndVaultToFall_CP) == 0x0014BD, "Member 'ATslCharacter::bEndVaultToFall_CP' has a wrong offset!");
static_assert(offsetof(ATslCharacter, VaultEndVelocityVectorMutliplier) == 0x0014C0, "Member 'ATslCharacter::VaultEndVelocityVectorMutliplier' has a wrong offset!");
static_assert(offsetof(ATslCharacter, VaultEndVelocityVectorClamp) == 0x0014CC, "Member 'ATslCharacter::VaultEndVelocityVectorClamp' has a wrong offset!");
static_assert(offsetof(ATslCharacter, VaultingHelperRef) == 0x0014D0, "Member 'ATslCharacter::VaultingHelperRef' has a wrong offset!");
static_assert(offsetof(ATslCharacter, bIsVaultingSystemEnabled) == 0x0014D8, "Member 'ATslCharacter::bIsVaultingSystemEnabled' has a wrong offset!");
static_assert(offsetof(ATslCharacter, VaultingDirection_CP) == 0x0014DC, "Member 'ATslCharacter::VaultingDirection_CP' has a wrong offset!");
static_assert(offsetof(ATslCharacter, CurrentVaultData_CP) == 0x0014E0, "Member 'ATslCharacter::CurrentVaultData_CP' has a wrong offset!");
static_assert(offsetof(ATslCharacter, bServerFinishedVault) == 0x0014E8, "Member 'ATslCharacter::bServerFinishedVault' has a wrong offset!");
static_assert(offsetof(ATslCharacter, JumpDelay) == 0x0014EC, "Member 'ATslCharacter::JumpDelay' has a wrong offset!");
static_assert(offsetof(ATslCharacter, JumpLastTimer) == 0x0014F0, "Member 'ATslCharacter::JumpLastTimer' has a wrong offset!");
static_assert(offsetof(ATslCharacter, bWantsToVault) == 0x0014F4, "Member 'ATslCharacter::bWantsToVault' has a wrong offset!");
static_assert(offsetof(ATslCharacter, bWantsToCancelVault) == 0x0014F5, "Member 'ATslCharacter::bWantsToCancelVault' has a wrong offset!");
static_assert(offsetof(ATslCharacter, VaultProbeLoopTime) == 0x0014F8, "Member 'ATslCharacter::VaultProbeLoopTime' has a wrong offset!");
static_assert(offsetof(ATslCharacter, TO_CulledMovementTickrate) == 0x0014FC, "Member 'ATslCharacter::TO_CulledMovementTickrate' has a wrong offset!");
static_assert(offsetof(ATslCharacter, TO_CulledActorTickInterval) == 0x001500, "Member 'ATslCharacter::TO_CulledActorTickInterval' has a wrong offset!");
static_assert(offsetof(ATslCharacter, TO_MinimumDistance) == 0x001504, "Member 'ATslCharacter::TO_MinimumDistance' has a wrong offset!");
static_assert(offsetof(ATslCharacter, bRunTickOptimization) == 0x001508, "Member 'ATslCharacter::bRunTickOptimization' has a wrong offset!");
static_assert(offsetof(ATslCharacter, bRunTickOptimization_Anim) == 0x001509, "Member 'ATslCharacter::bRunTickOptimization_Anim' has a wrong offset!");
static_assert(offsetof(ATslCharacter, bRunTickOptimization_Movement) == 0x00150A, "Member 'ATslCharacter::bRunTickOptimization_Movement' has a wrong offset!");
static_assert(offsetof(ATslCharacter, TO_RenderedTolerance) == 0x00150C, "Member 'ATslCharacter::TO_RenderedTolerance' has a wrong offset!");
static_assert(offsetof(ATslCharacter, bTickOptimization_Move_Active) == 0x001510, "Member 'ATslCharacter::bTickOptimization_Move_Active' has a wrong offset!");
static_assert(offsetof(ATslCharacter, bTickOptimization_Anim_Active) == 0x001511, "Member 'ATslCharacter::bTickOptimization_Anim_Active' has a wrong offset!");
static_assert(offsetof(ATslCharacter, bTickOptimization_Actor_Active) == 0x001512, "Member 'ATslCharacter::bTickOptimization_Actor_Active' has a wrong offset!");

// Class TslGame.TslBot
// 0x0000 (0x1520 - 0x1520)
class ATslBot final : public ATslCharacter
{
public:
	class UBehaviorTree*                          BotBehavior;                                       // 0x1518(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslBot">();
	}
	static class ATslBot* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslBot>();
	}
};
static_assert(alignof(ATslBot) == 0x000010, "Wrong alignment on ATslBot");
static_assert(sizeof(ATslBot) == 0x001520, "Wrong size on ATslBot");
static_assert(offsetof(ATslBot, BotBehavior) == 0x001518, "Member 'ATslBot::BotBehavior' has a wrong offset!");

// Class TslGame.ObserverTagWidget
// 0x0010 (0x0250 - 0x0240)
class UObserverTagWidget : public UUserWidget
{
public:
	class ATslCharacter*                          Character;                                         // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetZ;                                           // 0x0248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x024C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetCharacterIconPosition_UC(const struct FVector2D& Pos_UC, bool IsHidden);

	bool IsLastSpectatedCharacter() const;
	bool IsTeamMember() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObserverTagWidget">();
	}
	static class UObserverTagWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObserverTagWidget>();
	}
};
static_assert(alignof(UObserverTagWidget) == 0x000008, "Wrong alignment on UObserverTagWidget");
static_assert(sizeof(UObserverTagWidget) == 0x000250, "Wrong size on UObserverTagWidget");
static_assert(offsetof(UObserverTagWidget, Character) == 0x000240, "Member 'UObserverTagWidget::Character' has a wrong offset!");
static_assert(offsetof(UObserverTagWidget, OffsetZ) == 0x000248, "Member 'UObserverTagWidget::OffsetZ' has a wrong offset!");
static_assert(offsetof(UObserverTagWidget, Distance) == 0x00024C, "Member 'UObserverTagWidget::Distance' has a wrong offset!");

// Class TslGame.TslVehicleInterface
// 0x0000 (0x0028 - 0x0028)
class ITslVehicleInterface final : public IInterface
{
public:
	class ATslPlayerController* GetTslPlayerController() const;
	class USkeletalMeshComponent* GetVehicleMeshComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslVehicleInterface">();
	}
	static class ITslVehicleInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITslVehicleInterface>();
	}
};
static_assert(alignof(ITslVehicleInterface) == 0x000008, "Wrong alignment on ITslVehicleInterface");
static_assert(sizeof(ITslVehicleInterface) == 0x000028, "Wrong size on ITslVehicleInterface");

// Class TslGame.ParachuteVehicle
// 0x0138 (0x0538 - 0x0400)
class AParachuteVehicle : public APawn
{
public:
	uint8                                         Pad_400[0x8];                                      // 0x0400(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             OnRelease;                                         // 0x0408(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnLand;                                            // 0x0418(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          ReleaseSound_Local;                                // 0x0428(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          ReleaseSound_Remote;                               // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          LandSound_Local;                                   // 0x0438(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          LandSound_Remote;                                  // 0x0440(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          FallingStartSound_Local;                           // 0x0448(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          FallingStartSound_Remote;                          // 0x0450(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           AkSoundCom;                                        // 0x0458(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTslPawnInputBindingComponent*          TslPawnInputBindingComponent;                      // 0x0460(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 MeshComponent;                                     // 0x0468(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParachuteVehicleMovement*              ParachuteMovementComponent;                        // 0x0470(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFreeFallMovement*                      FreeFallMovementComponent;                         // 0x0478(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTslVehicleSeatComponent*               VehicleSeatComponent;                              // 0x0480(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDoublePhaseInteractionComponent*       InteractionComponent;                              // 0x0488(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ATslCharacter>           LastDriver;                                        // 0x0490(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_498[0x8];                                      // 0x0498(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FreeFallFirstPersonCameraName;                     // 0x04A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   FreeFallThirdPersonCameraName;                     // 0x04A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FreeFallCameraPitchMin;                            // 0x04B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FreeFallCameraPitchMax;                            // 0x04B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ReleasingAltitude;                                 // 0x04B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ForceReleasingAltitude;                            // 0x04BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C0[0x4];                                      // 0x04C0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SweepMoveHeight;                                   // 0x04C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LandingHeight;                                     // 0x04C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LandingDuration;                                   // 0x04CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D0[0x8];                                      // 0x04D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATslBuff>                   LandingBuff;                                       // 0x04D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4E0[0xC];                                      // 0x04E0(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StuckCheckDistance;                                // 0x04EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StuckCheckDuration;                                // 0x04F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F4[0xC];                                      // 0x04F4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         BitPad_500_0 : 1;                                  // 0x0500(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         ForwardInputRepApplied : 1;                        // 0x0500(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         ForwardInputRepIsForward : 1;                      // 0x0500(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         RightInputRepApplied : 1;                          // 0x0500(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         RightInputRepIsRight : 1;                          // 0x0500(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bIsReleased : 1;                                   // 0x0500(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bIsDriven : 1;                                     // 0x0500(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_501[0x3];                                      // 0x0501(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               InitialRotation;                                   // 0x0504(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                InitialVelocity;                                   // 0x0510(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                RideSocketOffset;                                  // 0x051C(0x000C)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                LeaveSocketOffset;                                 // 0x0528(0x000C)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_534[0x4];                                      // 0x0534(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AllowInteractBy(const class ATslCharacter* Character);
	bool AllowSecondInteractBy(const class ATslCharacter* Character);
	void Land();
	void OnDriverLeave();
	void OnDriverRide();
	void OnInteractBy(class ATslCharacter* Character);
	void OnPostDriverLeave();
	void OnRep_IsDriven();
	void OnRep_IsReleased();
	void OnRide(class ATslCharacter* Rider, class UVehicleSeatInteractionComponent* Seat);
	void OnSecondInteractBy(class ATslCharacter* Character);
	void PhysicsVolumeChanged(class APhysicsVolume* NewVolume);
	void ServerRelease();

	bool CanRelease() const;
	bool CanReleaseByInput() const;
	float GetAltitudeFromFloor() const;
	bool IsDriven() const;
	bool IsReleased() const;
	bool IsStuck() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParachuteVehicle">();
	}
	static class AParachuteVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AParachuteVehicle>();
	}
};
static_assert(alignof(AParachuteVehicle) == 0x000008, "Wrong alignment on AParachuteVehicle");
static_assert(sizeof(AParachuteVehicle) == 0x000538, "Wrong size on AParachuteVehicle");
static_assert(offsetof(AParachuteVehicle, OnRelease) == 0x000408, "Member 'AParachuteVehicle::OnRelease' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, OnLand) == 0x000418, "Member 'AParachuteVehicle::OnLand' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, ReleaseSound_Local) == 0x000428, "Member 'AParachuteVehicle::ReleaseSound_Local' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, ReleaseSound_Remote) == 0x000430, "Member 'AParachuteVehicle::ReleaseSound_Remote' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, LandSound_Local) == 0x000438, "Member 'AParachuteVehicle::LandSound_Local' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, LandSound_Remote) == 0x000440, "Member 'AParachuteVehicle::LandSound_Remote' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, FallingStartSound_Local) == 0x000448, "Member 'AParachuteVehicle::FallingStartSound_Local' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, FallingStartSound_Remote) == 0x000450, "Member 'AParachuteVehicle::FallingStartSound_Remote' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, AkSoundCom) == 0x000458, "Member 'AParachuteVehicle::AkSoundCom' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, TslPawnInputBindingComponent) == 0x000460, "Member 'AParachuteVehicle::TslPawnInputBindingComponent' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, MeshComponent) == 0x000468, "Member 'AParachuteVehicle::MeshComponent' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, ParachuteMovementComponent) == 0x000470, "Member 'AParachuteVehicle::ParachuteMovementComponent' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, FreeFallMovementComponent) == 0x000478, "Member 'AParachuteVehicle::FreeFallMovementComponent' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, VehicleSeatComponent) == 0x000480, "Member 'AParachuteVehicle::VehicleSeatComponent' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, InteractionComponent) == 0x000488, "Member 'AParachuteVehicle::InteractionComponent' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, LastDriver) == 0x000490, "Member 'AParachuteVehicle::LastDriver' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, FreeFallFirstPersonCameraName) == 0x0004A0, "Member 'AParachuteVehicle::FreeFallFirstPersonCameraName' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, FreeFallThirdPersonCameraName) == 0x0004A8, "Member 'AParachuteVehicle::FreeFallThirdPersonCameraName' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, FreeFallCameraPitchMin) == 0x0004B0, "Member 'AParachuteVehicle::FreeFallCameraPitchMin' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, FreeFallCameraPitchMax) == 0x0004B4, "Member 'AParachuteVehicle::FreeFallCameraPitchMax' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, ReleasingAltitude) == 0x0004B8, "Member 'AParachuteVehicle::ReleasingAltitude' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, ForceReleasingAltitude) == 0x0004BC, "Member 'AParachuteVehicle::ForceReleasingAltitude' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, SweepMoveHeight) == 0x0004C4, "Member 'AParachuteVehicle::SweepMoveHeight' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, LandingHeight) == 0x0004C8, "Member 'AParachuteVehicle::LandingHeight' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, LandingDuration) == 0x0004CC, "Member 'AParachuteVehicle::LandingDuration' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, LandingBuff) == 0x0004D8, "Member 'AParachuteVehicle::LandingBuff' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, StuckCheckDistance) == 0x0004EC, "Member 'AParachuteVehicle::StuckCheckDistance' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, StuckCheckDuration) == 0x0004F0, "Member 'AParachuteVehicle::StuckCheckDuration' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, InitialRotation) == 0x000504, "Member 'AParachuteVehicle::InitialRotation' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, InitialVelocity) == 0x000510, "Member 'AParachuteVehicle::InitialVelocity' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, RideSocketOffset) == 0x00051C, "Member 'AParachuteVehicle::RideSocketOffset' has a wrong offset!");
static_assert(offsetof(AParachuteVehicle, LeaveSocketOffset) == 0x000528, "Member 'AParachuteVehicle::LeaveSocketOffset' has a wrong offset!");

// Class TslGame.TslGameSession
// 0x0318 (0x06D0 - 0x03B8)
class ATslGameSession final : public AGameSession
{
public:
	uint8                                         Pad_3B8[0x318];                                    // 0x03B8(0x0318)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslGameSession">();
	}
	static class ATslGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslGameSession>();
	}
};
static_assert(alignof(ATslGameSession) == 0x000008, "Wrong alignment on ATslGameSession");
static_assert(sizeof(ATslGameSession) == 0x0006D0, "Wrong size on ATslGameSession");

// Class TslGame.ReplicatedRootComponent
// 0x0000 (0x0300 - 0x0300)
class UReplicatedRootComponent final : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplicatedRootComponent">();
	}
	static class UReplicatedRootComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReplicatedRootComponent>();
	}
};
static_assert(alignof(UReplicatedRootComponent) == 0x000008, "Wrong alignment on UReplicatedRootComponent");
static_assert(sizeof(UReplicatedRootComponent) == 0x000300, "Wrong size on UReplicatedRootComponent");

// Class TslGame.ReplicationTrigger
// 0x0030 (0x03D0 - 0x03A0)
class AReplicationTrigger final : public AActor
{
public:
	uint8                                         Pad_3A0[0x8];                                      // 0x03A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         TargetReplicatedActors;                            // 0x03A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B8[0x4];                                      // 0x03B8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReplicationGroupCount;                             // 0x03BC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C0[0x4];                                      // 0x03C0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReplicationGroupIntervalSeconds;                   // 0x03C4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C8[0x8];                                      // 0x03C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnableReplicationGroup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplicationTrigger">();
	}
	static class AReplicationTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReplicationTrigger>();
	}
};
static_assert(alignof(AReplicationTrigger) == 0x000008, "Wrong alignment on AReplicationTrigger");
static_assert(sizeof(AReplicationTrigger) == 0x0003D0, "Wrong size on AReplicationTrigger");
static_assert(offsetof(AReplicationTrigger, TargetReplicatedActors) == 0x0003A8, "Member 'AReplicationTrigger::TargetReplicatedActors' has a wrong offset!");
static_assert(offsetof(AReplicationTrigger, ReplicationGroupCount) == 0x0003BC, "Member 'AReplicationTrigger::ReplicationGroupCount' has a wrong offset!");
static_assert(offsetof(AReplicationTrigger, ReplicationGroupIntervalSeconds) == 0x0003C4, "Member 'AReplicationTrigger::ReplicationGroupIntervalSeconds' has a wrong offset!");

// Class TslGame.TslSpectatorPawnMovement
// 0x0028 (0x01C8 - 0x01A0)
class UTslSpectatorPawnMovement final : public USpectatorPawnMovement
{
public:
	uint8                                         Pad_1A0[0x4];                                      // 0x01A0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FastMoveModifier;                                  // 0x01A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SlowMoveModifier;                                  // 0x01A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinFreeMoveSpeed;                                  // 0x01AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxFreeMoveSpeed;                                  // 0x01B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinFreeMoveSpeedHeight;                            // 0x01B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxFreeMoveSpeedHeight;                            // 0x01B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AbsoluteMinZ;                                      // 0x01BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AbsoluteMaxZ;                                      // 0x01C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C4[0x4];                                      // 0x01C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslSpectatorPawnMovement">();
	}
	static class UTslSpectatorPawnMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslSpectatorPawnMovement>();
	}
};
static_assert(alignof(UTslSpectatorPawnMovement) == 0x000008, "Wrong alignment on UTslSpectatorPawnMovement");
static_assert(sizeof(UTslSpectatorPawnMovement) == 0x0001C8, "Wrong size on UTslSpectatorPawnMovement");
static_assert(offsetof(UTslSpectatorPawnMovement, FastMoveModifier) == 0x0001A4, "Member 'UTslSpectatorPawnMovement::FastMoveModifier' has a wrong offset!");
static_assert(offsetof(UTslSpectatorPawnMovement, SlowMoveModifier) == 0x0001A8, "Member 'UTslSpectatorPawnMovement::SlowMoveModifier' has a wrong offset!");
static_assert(offsetof(UTslSpectatorPawnMovement, MinFreeMoveSpeed) == 0x0001AC, "Member 'UTslSpectatorPawnMovement::MinFreeMoveSpeed' has a wrong offset!");
static_assert(offsetof(UTslSpectatorPawnMovement, MaxFreeMoveSpeed) == 0x0001B0, "Member 'UTslSpectatorPawnMovement::MaxFreeMoveSpeed' has a wrong offset!");
static_assert(offsetof(UTslSpectatorPawnMovement, MinFreeMoveSpeedHeight) == 0x0001B4, "Member 'UTslSpectatorPawnMovement::MinFreeMoveSpeedHeight' has a wrong offset!");
static_assert(offsetof(UTslSpectatorPawnMovement, MaxFreeMoveSpeedHeight) == 0x0001B8, "Member 'UTslSpectatorPawnMovement::MaxFreeMoveSpeedHeight' has a wrong offset!");
static_assert(offsetof(UTslSpectatorPawnMovement, AbsoluteMinZ) == 0x0001BC, "Member 'UTslSpectatorPawnMovement::AbsoluteMinZ' has a wrong offset!");
static_assert(offsetof(UTslSpectatorPawnMovement, AbsoluteMaxZ) == 0x0001C0, "Member 'UTslSpectatorPawnMovement::AbsoluteMaxZ' has a wrong offset!");

// Class TslGame.ReplicationTriggerManager
// 0x0028 (0x03C8 - 0x03A0)
class AReplicationTriggerManager final : public AInfo
{
public:
	TArray<TSubclassOf<class AActor>>             TargetReplicatedActorClasses;                      // 0x03A0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPrivate)
	float                                         TriggerRadius;                                     // 0x03B0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TriggerInterval;                                   // 0x03B4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AReplicationTrigger*>            Triggers;                                          // 0x03B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplicationTriggerManager">();
	}
	static class AReplicationTriggerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReplicationTriggerManager>();
	}
};
static_assert(alignof(AReplicationTriggerManager) == 0x000008, "Wrong alignment on AReplicationTriggerManager");
static_assert(sizeof(AReplicationTriggerManager) == 0x0003C8, "Wrong size on AReplicationTriggerManager");
static_assert(offsetof(AReplicationTriggerManager, TargetReplicatedActorClasses) == 0x0003A0, "Member 'AReplicationTriggerManager::TargetReplicatedActorClasses' has a wrong offset!");
static_assert(offsetof(AReplicationTriggerManager, TriggerRadius) == 0x0003B0, "Member 'AReplicationTriggerManager::TriggerRadius' has a wrong offset!");
static_assert(offsetof(AReplicationTriggerManager, TriggerInterval) == 0x0003B4, "Member 'AReplicationTriggerManager::TriggerInterval' has a wrong offset!");
static_assert(offsetof(AReplicationTriggerManager, Triggers) == 0x0003B8, "Member 'AReplicationTriggerManager::Triggers' has a wrong offset!");

// Class TslGame.RewardData
// 0x0028 (0x0050 - 0x0028)
class URewardData final : public UDataAsset
{
public:
	float                                         DefaultScoreMultiplierByDamage;                    // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultScoreMultiplierByKill;                      // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 ScoreByReverseRanking;                             // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 ScoreMultiplierByRanking;                          // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RewardData">();
	}
	static class URewardData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URewardData>();
	}
};
static_assert(alignof(URewardData) == 0x000008, "Wrong alignment on URewardData");
static_assert(sizeof(URewardData) == 0x000050, "Wrong size on URewardData");
static_assert(offsetof(URewardData, DefaultScoreMultiplierByDamage) == 0x000028, "Member 'URewardData::DefaultScoreMultiplierByDamage' has a wrong offset!");
static_assert(offsetof(URewardData, DefaultScoreMultiplierByKill) == 0x00002C, "Member 'URewardData::DefaultScoreMultiplierByKill' has a wrong offset!");
static_assert(offsetof(URewardData, ScoreByReverseRanking) == 0x000030, "Member 'URewardData::ScoreByReverseRanking' has a wrong offset!");
static_assert(offsetof(URewardData, ScoreMultiplierByRanking) == 0x000040, "Member 'URewardData::ScoreMultiplierByRanking' has a wrong offset!");

// Class TslGame.TslSingleton
// 0x00F0 (0x0118 - 0x0028)
class UTslSingleton final : public UObject
{
public:
	uint8                                         Pad_28[0xF0];                                      // 0x0028(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslSingleton">();
	}
	static class UTslSingleton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslSingleton>();
	}
};
static_assert(alignof(UTslSingleton) == 0x000008, "Wrong alignment on UTslSingleton");
static_assert(sizeof(UTslSingleton) == 0x000118, "Wrong size on UTslSingleton");

// Class TslGame.SceneInteractionComponent
// 0x0110 (0x0410 - 0x0300)
class USceneInteractionComponent : public USceneComponent
{
public:
	uint8                                         Pad_300[0x10];                                     // 0x0300(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxInteractableDistance;                           // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   InteractionVerb;                                   // 0x0318(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   InteractiveObjectName;                             // 0x0330(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bUseTraceCheck;                                    // 0x0348(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_349[0x7];                                      // 0x0349(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCastConfig                            CastConfig;                                        // 0x0350(0x0030)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_380[0x8];                                      // 0x0380(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnInteractBy;                                      // 0x0388(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ClientOnInteractBy;                                // 0x0398(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A8[0x68];                                     // 0x03A8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AllowInteractBy(const class ATslCharacter* Character) const;
	class FText GetInteractionVerb() const;
	class FText GetInteractiveObjectName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SceneInteractionComponent">();
	}
	static class USceneInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USceneInteractionComponent>();
	}
};
static_assert(alignof(USceneInteractionComponent) == 0x000008, "Wrong alignment on USceneInteractionComponent");
static_assert(sizeof(USceneInteractionComponent) == 0x000410, "Wrong size on USceneInteractionComponent");
static_assert(offsetof(USceneInteractionComponent, MaxInteractableDistance) == 0x000310, "Member 'USceneInteractionComponent::MaxInteractableDistance' has a wrong offset!");
static_assert(offsetof(USceneInteractionComponent, InteractionVerb) == 0x000318, "Member 'USceneInteractionComponent::InteractionVerb' has a wrong offset!");
static_assert(offsetof(USceneInteractionComponent, InteractiveObjectName) == 0x000330, "Member 'USceneInteractionComponent::InteractiveObjectName' has a wrong offset!");
static_assert(offsetof(USceneInteractionComponent, bUseTraceCheck) == 0x000348, "Member 'USceneInteractionComponent::bUseTraceCheck' has a wrong offset!");
static_assert(offsetof(USceneInteractionComponent, CastConfig) == 0x000350, "Member 'USceneInteractionComponent::CastConfig' has a wrong offset!");
static_assert(offsetof(USceneInteractionComponent, OnInteractBy) == 0x000388, "Member 'USceneInteractionComponent::OnInteractBy' has a wrong offset!");
static_assert(offsetof(USceneInteractionComponent, ClientOnInteractBy) == 0x000398, "Member 'USceneInteractionComponent::ClientOnInteractBy' has a wrong offset!");

// Class TslGame.DoorInteractionComponent
// 0x01F0 (0x0600 - 0x0410)
class UDoorInteractionComponent final : public USceneInteractionComponent
{
public:
	uint8                                         Pad_410[0x8];                                      // 0x0410(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EDoorState                                    DoorState;                                         // 0x0418(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bReverseRotation : 1;                              // 0x0419(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIgnoreParentValidityCheck : 1;                    // 0x0419(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_41A[0x2];                                      // 0x041A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SoundOffset;                                       // 0x041C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UDoorDataAsset*                         DoorDataAsset;                                     // 0x0428(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_430[0x1C0];                                    // 0x0430(0x01C0)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkComponent*                           AkAudioComponent;                                  // 0x05F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F8[0x8];                                      // 0x05F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AllowInteract(const class ATslCharacter* OtherCharacter);
	void OnRep_DoorState(EDoorState PrevDoorState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoorInteractionComponent">();
	}
	static class UDoorInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDoorInteractionComponent>();
	}
};
static_assert(alignof(UDoorInteractionComponent) == 0x000008, "Wrong alignment on UDoorInteractionComponent");
static_assert(sizeof(UDoorInteractionComponent) == 0x000600, "Wrong size on UDoorInteractionComponent");
static_assert(offsetof(UDoorInteractionComponent, DoorState) == 0x000418, "Member 'UDoorInteractionComponent::DoorState' has a wrong offset!");
static_assert(offsetof(UDoorInteractionComponent, SoundOffset) == 0x00041C, "Member 'UDoorInteractionComponent::SoundOffset' has a wrong offset!");
static_assert(offsetof(UDoorInteractionComponent, DoorDataAsset) == 0x000428, "Member 'UDoorInteractionComponent::DoorDataAsset' has a wrong offset!");
static_assert(offsetof(UDoorInteractionComponent, AkAudioComponent) == 0x0005F0, "Member 'UDoorInteractionComponent::AkAudioComponent' has a wrong offset!");

// Class TslGame.TslGameOption
// 0x0000 (0x0028 - 0x0028)
class UTslGameOption final : public UBlueprintFunctionLibrary
{
public:
	static void ApplyAutoQualitySetting();
	static void ApplyGameUserSettings(bool bCheckForCommandLineOverrides);
	static void ApplyMouseSensitivity();
	static ETslInputModes CastTslInputModeFromName(const class FName& InputModeName);
	static TArray<class FString> CultureNames();
	static TArray<struct FCustomizableActionName> CustomizableActionNames();
	static TArray<struct FCustomizableAxisName> CustomizableAxisName();
	static TArray<struct FCustomizableCategoryData> CustomizableCategoryData();
	static TArray<struct FCustomizableMouseSensitiveName> CustomizableMouseSensitiveNames();
	static struct FTslInputKey GetActionKey(class FName ActionName, bool bGamepad, bool bDefault, bool bWantAnyKey, EKeyBindingSlot eKeySlot);
	static TArray<struct FTslInputKey> GetActionKeys(class FName ActionName, bool bDefault);
	static TArray<struct FQualityLevelInfo> GetAutoQualityLevels(int32 WorkScale, float CPUMultiplier, float GPUMultiplier);
	static TArray<class FText> GetAvailableProviderDisplayNames();
	static TArray<class FString> GetAvailableProviderNames();
	static struct FTslInputKey GetAxisKey(class FName AxisName, float Scale, bool bGamepad, bool bDefault, bool bWantAnyKey, EKeyBindingSlot eKeySlot);
	static TArray<struct FTslInputKey> GetAxisKeys(class FName AxisName, float Scale, bool bDefault);
	static float GetBGMSoundVolume();
	static TArray<struct FColorBlindType> GetColorBlindTypes();
	static float GetConvertedMouseSensitivity(class FName InMouseSensitiveName);
	static TArray<struct FPresetColor> GetCrosshairColors();
	static EColorBlindType GetCurrentColorBlindKey();
	static class FString GetCurrentCrosshairColorStr();
	static class FString GetCurrentCultureName();
	static class FString GetCurrentProvider();
	static class FString GetDefaultCultureName();
	static ETslInputModes GetDefaultInputModeSetting(EInputModeSettingActions eAction);
	static float GetEffectSoundVolume();
	static EUiShowType GetFppEquipableItemIconShowType();
	static EUiShowType GetFppWeaponIconShowType();
	static float GetFpsCameraFov();
	static EWindowMode GetFullScreenMode();
	static float GetGamma();
	static TArray<struct FKeyInputModeName> GetKeyInputModeNames();
	static class FText GetKeyName(const struct FTslInputKey& Key);
	static float GetMasterSoundVolume();
	static TArray<struct FUiType> GetMiniMapTypes();
	static float GetMouseSensitivity(class FName InMouseSensitiveName);
	static class FString GetNativeLanguage(const class FString& InCultureName);
	static int32 GetOverallScalabilityLevel();
	static int32 GetQualityLevel(EQualityType Quality);
	static struct FScreenResolution GetScreenResolution();
	static float GetScreenScale();
	static int32 GetSelectMiniMapTypeIndex();
	static TArray<struct FSurportQualityLevel> GetSupportedQualityLevels();
	static TArray<struct FScreenResolution> GetSupportedScreenResolutions();
	static EUiShowType GetTpsWeaponIconShowType();
	static ETslInputModes GetTslInputMode(EInputModeSettingActions eAction);
	static float GetUISoundVolume();
	static bool GetUseCharacterCapture();
	static bool GetUseGlobalVoice();
	static bool GetUsePushToTalk();
	static bool GetUseTeamVoice();
	static int32 GetVoiceInputVolume();
	static int32 GetVoiceOutputVolume();
	static int32 GetWorldMapZoomSpeedLevel();
	static bool IsBGMSoundMute();
	static bool IsDefaultFunctionalityEnabled(EGameplayFunctionalities eAction);
	static bool IsDoubleTapSupported(EInputModeSettingActions eAction);
	static bool IsEffectSoundMute();
	static bool IsEnabledMotionBlur();
	static bool IsFunctionalityEnabled(EGameplayFunctionalities eAction);
	static bool IsGamepadKey(const struct FTslInputKey& Key);
	static bool IsInvertMouse();
	static bool IsKeyUsed(const struct FTslInputKey& Key);
	static bool IsKeyValid(const struct FTslInputKey& Key);
	static bool IsMasterSoundMute();
	static bool IsModifierKey(const struct FTslInputKey& Key);
	static bool IsMouseWheelInput(const struct FTslInputKey& InInputedKey);
	static bool IsUISoundMute();
	static bool IsVoiceInputMute();
	static bool IsVoiceOutputMute();
	static bool IsVSyncEnabled();
	static TArray<class FName> NotDuplicateCategoryNames(class FName CatecoryName);
	static void SetActionKey(const class FName& ActionName, const struct FTslInputKey& NewKey, EKeyBindingSlot InKeyBindingSlot, bool bGamepad);
	static void SetActionKeys(const class FName& ActionName, const TArray<struct FTslInputKey>& NewKeys);
	static void SetActionKeysToDefault(const class FName& ActionName);
	static void SetAxisKey(const class FName& AxisName, float Scale, const struct FTslInputKey& NewKey, EKeyBindingSlot InKeyBindingSlot, bool bGamepad);
	static void SetAxisKeys(const class FName& AxisName, float Scale, const TArray<struct FTslInputKey>& NewKeys);
	static void SetAxisKeysToDefault(const class FName& AxisName, float Scale);
	static void SetBGMSoundMute(bool bIsMute);
	static void SetBGMSoundVolume(float Volume);
	static void SetCurrentColorBlindKey(EColorBlindType ColorBlindKey);
	static void SetCurrentColorBlindKeyByInt(int32 ColorBlindKey);
	static void SetCurrentCrosshairColorString(const class FString& CrosshairColorStr);
	static void SetCurrentCultureName(const class FString& InCultureName);
	static void SetCurrentProvider(const class FString& ProviderName);
	static void SetEffectSoundMute(bool bIsMute);
	static void SetEffectSoundVolume(float Volume);
	static void SetEnableFunctionality(EGameplayFunctionalities eAction, bool bValue);
	static void SetEquipableIteIconShow(bool bNewShow);
	static void SetFppEquipableItemIconShowType(EUiShowType NewShowType);
	static void SetFppWeaponIconShowType(EUiShowType NewShowType);
	static void SetFpsCameraFov(float NewFovValue);
	static void SetFpsWeaponSlotShow(bool bNewShow);
	static void SetFullScreen(EWindowMode InFullscreenMode);
	static void SetGamma(float Gamma);
	static void SetInputKey_Internal(TArray<struct FTslInputKey>* OutKeyList, const struct FTslInputKey& NewKey, EKeyBindingSlot InKeyBindingSlot, bool bGamepad);
	static void SetInvertMouse(bool bInvert);
	static void SetMasterSoundMute(bool bIsMute);
	static void SetMasterSoundVolume(float Volume);
	static void SetMotionBlur(bool bEnabled);
	static void SetMouseSensitivity(class FName InMouseSensitiveName, float InMouseSensitivity);
	static void SetOverallScalabilityLevel(int32 Value);
	static void SetQualityLevel(EQualityType Quality, int32 QualityLevel);
	static void SetScreenResoultion(const struct FScreenResolution& ScreenResolution);
	static void SetScreenScale(float Value);
	static void SetSelectMinimapTypeIndex(int32 Index_0);
	static void SetTpsWeaponIconShowType(EUiShowType NewShowType);
	static void SetTslInputMode(EInputModeSettingActions eAction, ETslInputModes eTslInputMode);
	static void SetUISoundMute(bool bIsMute);
	static void SetUISoundVolume(float Volume);
	static void SetUseCharacterCapture(bool bUseCharacterCapture);
	static void SetUseGlobalVoice(bool bUse);
	static void SetUsePushToTalk(bool bUse);
	static void SetUseTeamVoice(bool bUse);
	static void SetVoiceInputMute(bool bIsMute);
	static void SetVoiceInputVolume(int32 Volume);
	static void SetVoiceOutputMute(bool bIsMute);
	static void SetVoiceOutputVolume(int32 Volume);
	static void SetVSyncEnabled(bool bEnable);
	static void SetWorldMapZoomLevel(int32 NewZoomLevel);
	static class FText WheelAxisNameToWheelActionName(const struct FTslInputKey& Key, float InAxisScale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslGameOption">();
	}
	static class UTslGameOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslGameOption>();
	}
};
static_assert(alignof(UTslGameOption) == 0x000008, "Wrong alignment on UTslGameOption");
static_assert(sizeof(UTslGameOption) == 0x000028, "Wrong size on UTslGameOption");

// Class TslGame.DroppedItemInteractionComponent
// 0x0060 (0x0470 - 0x0410)
class UDroppedItemInteractionComponent final : public USceneInteractionComponent
{
public:
	uint8                                         Pad_410[0x38];                                     // 0x0410(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UItem*                                  Item;                                              // 0x0448(0x0008)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_450[0x8];                                      // 0x0450(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAsyncStaticMeshComponent*              StaticMeshComponent;                               // 0x0458(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_460[0x10];                                     // 0x0460(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Item();

	bool AllowInteractBy(const class ATslCharacter* Character) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DroppedItemInteractionComponent">();
	}
	static class UDroppedItemInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDroppedItemInteractionComponent>();
	}
};
static_assert(alignof(UDroppedItemInteractionComponent) == 0x000008, "Wrong alignment on UDroppedItemInteractionComponent");
static_assert(sizeof(UDroppedItemInteractionComponent) == 0x000470, "Wrong size on UDroppedItemInteractionComponent");
static_assert(offsetof(UDroppedItemInteractionComponent, Item) == 0x000448, "Member 'UDroppedItemInteractionComponent::Item' has a wrong offset!");
static_assert(offsetof(UDroppedItemInteractionComponent, StaticMeshComponent) == 0x000458, "Member 'UDroppedItemInteractionComponent::StaticMeshComponent' has a wrong offset!");

// Class TslGame.VehicleSeatInteractionComponent
// 0x00C0 (0x04D0 - 0x0410)
class UVehicleSeatInteractionComponent : public USceneInteractionComponent
{
public:
	class ATslCharacter*                          Rider;                                             // 0x0410(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_418[0xC];                                      // 0x0418(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SeatIndex;                                         // 0x0424(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ERiderType                                    RiderType;                                         // 0x0428(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_429[0x7];                                      // 0x0429(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LeaveSocketName;                                   // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ViewPitchMin;                                      // 0x0438(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ViewPitchMax;                                      // 0x043C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ViewYawMin;                                        // 0x0440(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ViewYawMax;                                        // 0x0444(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            CurvePitchMax;                                     // 0x0448(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            CurvePitchMin;                                     // 0x0450(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   FirstPersonCameraName;                             // 0x0458(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ThirdPersonCameraName;                             // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EVehicleAnimType                              SeatAnimationType;                                 // 0x0468(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_469[0x7];                                      // 0x0469(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        SeatBlendspaceAiming;                              // 0x0470(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlendSpaceBase*                        SeatBlendspaceFPPAiming;                           // 0x0478(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequenceBase*                      SeatAnimationIdle;                                 // 0x0480(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAimOffsetBlendSpace*                   SeatIdleAO;                                        // 0x0488(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlendSpaceBase*                        TransitionOutBlendspace;                           // 0x0490(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlendSpaceBase*                        TransitionInBlendspace;                            // 0x0498(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRestricWeaponUse;                                 // 0x04A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A1[0x7];                                      // 0x04A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EWeaponClass>                          AllowedWeaponClasses;                              // 0x04A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bCanOnlyFireWhileAiming;                           // 0x04B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseEntryVelocityRestriction;                      // 0x04B9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4BA[0x2];                                      // 0x04BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxVelocityForEntry;                               // 0x04BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InteractionBlockDuration;                          // 0x04C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C4[0xC];                                      // 0x04C4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AllowInteractDelegate(const class ATslCharacter* OtherCharacter);
	float GetMaxPitchByYaw(float CurrentYaw);
	float GetMinPitchByYaw(float CurrentYaw);
	void OnInteractDelegate(class ATslCharacter* OtherCharacter);
	void OnRep_Rider();

	class FText GetAdditionalMessage(const class ATslCharacter* Character) const;
	bool GetCanFireOnlyWhileAimed() const;
	class ATslCharacter* GetRider() const;
	class UBlendSpaceBase* GetSeatAimingBlendspace() const;
	class UBlendSpaceBase* GetSeatAimingFPPBlendspace() const;
	class UAnimSequenceBase* GetSeatIdleAnimation() const;
	class UAimOffsetBlendSpace* GetSeatIdleAO() const;
	class UBlendSpaceBase* GetTransitionInBlendspace() const;
	class UBlendSpaceBase* GetTransitionOutBlendspace() const;
	EVehicleAnimType GetVehicleAnimType() const;
	TScriptInterface<class ITslVehicleInterface> GetVehicleInterface() const;
	class APawn* GetVehiclePawn() const;
	class UTslVehicleSeatComponent* GetVehicleSeatComponent() const;
	bool IsEntryAllowedByVelocity() const;
	bool IsWeaponClassAllowed(EWeaponClass InClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleSeatInteractionComponent">();
	}
	static class UVehicleSeatInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleSeatInteractionComponent>();
	}
};
static_assert(alignof(UVehicleSeatInteractionComponent) == 0x000008, "Wrong alignment on UVehicleSeatInteractionComponent");
static_assert(sizeof(UVehicleSeatInteractionComponent) == 0x0004D0, "Wrong size on UVehicleSeatInteractionComponent");
static_assert(offsetof(UVehicleSeatInteractionComponent, Rider) == 0x000410, "Member 'UVehicleSeatInteractionComponent::Rider' has a wrong offset!");
static_assert(offsetof(UVehicleSeatInteractionComponent, SeatIndex) == 0x000424, "Member 'UVehicleSeatInteractionComponent::SeatIndex' has a wrong offset!");
static_assert(offsetof(UVehicleSeatInteractionComponent, RiderType) == 0x000428, "Member 'UVehicleSeatInteractionComponent::RiderType' has a wrong offset!");
static_assert(offsetof(UVehicleSeatInteractionComponent, LeaveSocketName) == 0x000430, "Member 'UVehicleSeatInteractionComponent::LeaveSocketName' has a wrong offset!");
static_assert(offsetof(UVehicleSeatInteractionComponent, ViewPitchMin) == 0x000438, "Member 'UVehicleSeatInteractionComponent::ViewPitchMin' has a wrong offset!");
static_assert(offsetof(UVehicleSeatInteractionComponent, ViewPitchMax) == 0x00043C, "Member 'UVehicleSeatInteractionComponent::ViewPitchMax' has a wrong offset!");
static_assert(offsetof(UVehicleSeatInteractionComponent, ViewYawMin) == 0x000440, "Member 'UVehicleSeatInteractionComponent::ViewYawMin' has a wrong offset!");
static_assert(offsetof(UVehicleSeatInteractionComponent, ViewYawMax) == 0x000444, "Member 'UVehicleSeatInteractionComponent::ViewYawMax' has a wrong offset!");
static_assert(offsetof(UVehicleSeatInteractionComponent, CurvePitchMax) == 0x000448, "Member 'UVehicleSeatInteractionComponent::CurvePitchMax' has a wrong offset!");
static_assert(offsetof(UVehicleSeatInteractionComponent, CurvePitchMin) == 0x000450, "Member 'UVehicleSeatInteractionComponent::CurvePitchMin' has a wrong offset!");
static_assert(offsetof(UVehicleSeatInteractionComponent, FirstPersonCameraName) == 0x000458, "Member 'UVehicleSeatInteractionComponent::FirstPersonCameraName' has a wrong offset!");
static_assert(offsetof(UVehicleSeatInteractionComponent, ThirdPersonCameraName) == 0x000460, "Member 'UVehicleSeatInteractionComponent::ThirdPersonCameraName' has a wrong offset!");
static_assert(offsetof(UVehicleSeatInteractionComponent, SeatAnimationType) == 0x000468, "Member 'UVehicleSeatInteractionComponent::SeatAnimationType' has a wrong offset!");
static_assert(offsetof(UVehicleSeatInteractionComponent, SeatBlendspaceAiming) == 0x000470, "Member 'UVehicleSeatInteractionComponent::SeatBlendspaceAiming' has a wrong offset!");
static_assert(offsetof(UVehicleSeatInteractionComponent, SeatBlendspaceFPPAiming) == 0x000478, "Member 'UVehicleSeatInteractionComponent::SeatBlendspaceFPPAiming' has a wrong offset!");
static_assert(offsetof(UVehicleSeatInteractionComponent, SeatAnimationIdle) == 0x000480, "Member 'UVehicleSeatInteractionComponent::SeatAnimationIdle' has a wrong offset!");
static_assert(offsetof(UVehicleSeatInteractionComponent, SeatIdleAO) == 0x000488, "Member 'UVehicleSeatInteractionComponent::SeatIdleAO' has a wrong offset!");
static_assert(offsetof(UVehicleSeatInteractionComponent, TransitionOutBlendspace) == 0x000490, "Member 'UVehicleSeatInteractionComponent::TransitionOutBlendspace' has a wrong offset!");
static_assert(offsetof(UVehicleSeatInteractionComponent, TransitionInBlendspace) == 0x000498, "Member 'UVehicleSeatInteractionComponent::TransitionInBlendspace' has a wrong offset!");
static_assert(offsetof(UVehicleSeatInteractionComponent, bRestricWeaponUse) == 0x0004A0, "Member 'UVehicleSeatInteractionComponent::bRestricWeaponUse' has a wrong offset!");
static_assert(offsetof(UVehicleSeatInteractionComponent, AllowedWeaponClasses) == 0x0004A8, "Member 'UVehicleSeatInteractionComponent::AllowedWeaponClasses' has a wrong offset!");
static_assert(offsetof(UVehicleSeatInteractionComponent, bCanOnlyFireWhileAiming) == 0x0004B8, "Member 'UVehicleSeatInteractionComponent::bCanOnlyFireWhileAiming' has a wrong offset!");
static_assert(offsetof(UVehicleSeatInteractionComponent, bUseEntryVelocityRestriction) == 0x0004B9, "Member 'UVehicleSeatInteractionComponent::bUseEntryVelocityRestriction' has a wrong offset!");
static_assert(offsetof(UVehicleSeatInteractionComponent, MaxVelocityForEntry) == 0x0004BC, "Member 'UVehicleSeatInteractionComponent::MaxVelocityForEntry' has a wrong offset!");
static_assert(offsetof(UVehicleSeatInteractionComponent, InteractionBlockDuration) == 0x0004C0, "Member 'UVehicleSeatInteractionComponent::InteractionBlockDuration' has a wrong offset!");

// Class TslGame.TslGunAnimInstance
// 0x00D8 (0x0570 - 0x0498)
class UTslGunAnimInstance final : public UAnimInstance
{
public:
	UMulticastDelegateProperty_                   WeaponFire;                                        // 0x0498(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   WeaponFireCycle;                                   // 0x04A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   TriggerOn;                                         // 0x04B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   TriggerOff;                                        // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Reload1;                                           // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Reload2;                                           // 0x04E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ReloadByOneStart;                                  // 0x04F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ReloadByOneSingle;                                 // 0x0508(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ReloadByOneEnd;                                    // 0x0518(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   WeaponCharge;                                      // 0x0528(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   FireSelect;                                        // 0x0538(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   CancelReload;                                      // 0x0548(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   Name_FireMode_Semi;                                // 0x0558(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_FireMode_Burst;                               // 0x0560(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name_FireMode_Fullauto;                            // 0x0568(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void HandleFiremodeMontage(class UAnimMontage* FireModeMontage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslGunAnimInstance">();
	}
	static class UTslGunAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslGunAnimInstance>();
	}
};
static_assert(alignof(UTslGunAnimInstance) == 0x000008, "Wrong alignment on UTslGunAnimInstance");
static_assert(sizeof(UTslGunAnimInstance) == 0x000570, "Wrong size on UTslGunAnimInstance");
static_assert(offsetof(UTslGunAnimInstance, WeaponFire) == 0x000498, "Member 'UTslGunAnimInstance::WeaponFire' has a wrong offset!");
static_assert(offsetof(UTslGunAnimInstance, WeaponFireCycle) == 0x0004A8, "Member 'UTslGunAnimInstance::WeaponFireCycle' has a wrong offset!");
static_assert(offsetof(UTslGunAnimInstance, TriggerOn) == 0x0004B8, "Member 'UTslGunAnimInstance::TriggerOn' has a wrong offset!");
static_assert(offsetof(UTslGunAnimInstance, TriggerOff) == 0x0004C8, "Member 'UTslGunAnimInstance::TriggerOff' has a wrong offset!");
static_assert(offsetof(UTslGunAnimInstance, Reload1) == 0x0004D8, "Member 'UTslGunAnimInstance::Reload1' has a wrong offset!");
static_assert(offsetof(UTslGunAnimInstance, Reload2) == 0x0004E8, "Member 'UTslGunAnimInstance::Reload2' has a wrong offset!");
static_assert(offsetof(UTslGunAnimInstance, ReloadByOneStart) == 0x0004F8, "Member 'UTslGunAnimInstance::ReloadByOneStart' has a wrong offset!");
static_assert(offsetof(UTslGunAnimInstance, ReloadByOneSingle) == 0x000508, "Member 'UTslGunAnimInstance::ReloadByOneSingle' has a wrong offset!");
static_assert(offsetof(UTslGunAnimInstance, ReloadByOneEnd) == 0x000518, "Member 'UTslGunAnimInstance::ReloadByOneEnd' has a wrong offset!");
static_assert(offsetof(UTslGunAnimInstance, WeaponCharge) == 0x000528, "Member 'UTslGunAnimInstance::WeaponCharge' has a wrong offset!");
static_assert(offsetof(UTslGunAnimInstance, FireSelect) == 0x000538, "Member 'UTslGunAnimInstance::FireSelect' has a wrong offset!");
static_assert(offsetof(UTslGunAnimInstance, CancelReload) == 0x000548, "Member 'UTslGunAnimInstance::CancelReload' has a wrong offset!");
static_assert(offsetof(UTslGunAnimInstance, Name_FireMode_Semi) == 0x000558, "Member 'UTslGunAnimInstance::Name_FireMode_Semi' has a wrong offset!");
static_assert(offsetof(UTslGunAnimInstance, Name_FireMode_Burst) == 0x000560, "Member 'UTslGunAnimInstance::Name_FireMode_Burst' has a wrong offset!");
static_assert(offsetof(UTslGunAnimInstance, Name_FireMode_Fullauto) == 0x000568, "Member 'UTslGunAnimInstance::Name_FireMode_Fullauto' has a wrong offset!");

// Class TslGame.MotorbikeVehicleSeatInteraction
// 0x0000 (0x04D0 - 0x04D0)
class UMotorbikeVehicleSeatInteraction final : public UVehicleSeatInteractionComponent
{
public:
	void HandleFlipAndKickstand();

	bool IsEntryAllowed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MotorbikeVehicleSeatInteraction">();
	}
	static class UMotorbikeVehicleSeatInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMotorbikeVehicleSeatInteraction>();
	}
};
static_assert(alignof(UMotorbikeVehicleSeatInteraction) == 0x000008, "Wrong alignment on UMotorbikeVehicleSeatInteraction");
static_assert(sizeof(UMotorbikeVehicleSeatInteraction) == 0x0004D0, "Wrong size on UMotorbikeVehicleSeatInteraction");

// Class TslGame.ParachuteVehicleSeatInteraction
// 0x0000 (0x04D0 - 0x04D0)
class UParachuteVehicleSeatInteraction final : public UVehicleSeatInteractionComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParachuteVehicleSeatInteraction">();
	}
	static class UParachuteVehicleSeatInteraction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParachuteVehicleSeatInteraction>();
	}
};
static_assert(alignof(UParachuteVehicleSeatInteraction) == 0x000008, "Wrong alignment on UParachuteVehicleSeatInteraction");
static_assert(sizeof(UParachuteVehicleSeatInteraction) == 0x0004D0, "Wrong size on UParachuteVehicleSeatInteraction");

// Class TslGame.SimpleInterpolationMovement
// 0x00A0 (0x0220 - 0x0180)
class USimpleInterpolationMovement : public UPawnMovementComponent
{
public:
	uint8                                         Pad_180[0x18];                                     // 0x0180(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocationInterpTime;                                // 0x0198(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_19C[0x38];                                     // 0x019C(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationInterpTime;                                // 0x01D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D8[0x38];                                     // 0x01D8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseOnlyYawRotation;                               // 0x0210(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseSweepMove;                                     // 0x0211(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseSafeInterpolation;                             // 0x0212(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_213[0x1];                                      // 0x0213(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForceMoveTime;                                     // 0x0214(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_218[0x8];                                      // 0x0218(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleInterpolationMovement">();
	}
	static class USimpleInterpolationMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleInterpolationMovement>();
	}
};
static_assert(alignof(USimpleInterpolationMovement) == 0x000008, "Wrong alignment on USimpleInterpolationMovement");
static_assert(sizeof(USimpleInterpolationMovement) == 0x000220, "Wrong size on USimpleInterpolationMovement");
static_assert(offsetof(USimpleInterpolationMovement, LocationInterpTime) == 0x000198, "Member 'USimpleInterpolationMovement::LocationInterpTime' has a wrong offset!");
static_assert(offsetof(USimpleInterpolationMovement, RotationInterpTime) == 0x0001D4, "Member 'USimpleInterpolationMovement::RotationInterpTime' has a wrong offset!");
static_assert(offsetof(USimpleInterpolationMovement, bUseOnlyYawRotation) == 0x000210, "Member 'USimpleInterpolationMovement::bUseOnlyYawRotation' has a wrong offset!");
static_assert(offsetof(USimpleInterpolationMovement, bUseSweepMove) == 0x000211, "Member 'USimpleInterpolationMovement::bUseSweepMove' has a wrong offset!");
static_assert(offsetof(USimpleInterpolationMovement, bUseSafeInterpolation) == 0x000212, "Member 'USimpleInterpolationMovement::bUseSafeInterpolation' has a wrong offset!");
static_assert(offsetof(USimpleInterpolationMovement, ForceMoveTime) == 0x000214, "Member 'USimpleInterpolationMovement::ForceMoveTime' has a wrong offset!");

// Class TslGame.TslGameViewportClient
// 0x0060 (0x04F0 - 0x0490)
class UTslGameViewportClient final : public UGameViewportClient
{
public:
	uint8                                         Pad_490[0x60];                                     // 0x0490(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslGameViewportClient">();
	}
	static class UTslGameViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslGameViewportClient>();
	}
};
static_assert(alignof(UTslGameViewportClient) == 0x000008, "Wrong alignment on UTslGameViewportClient");
static_assert(sizeof(UTslGameViewportClient) == 0x0004F0, "Wrong size on UTslGameViewportClient");

// Class TslGame.FreeFallMovement
// 0x0050 (0x0270 - 0x0220)
class UFreeFallMovement final : public USimpleInterpolationMovement
{
public:
	float                                         MinPitch;                                          // 0x0220(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxPitch;                                          // 0x0224(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxLateralSpeed;                                   // 0x0228(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LateralAcceleration;                               // 0x022C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LateralDeceleration;                               // 0x0230(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LateralBrakeDeceleration;                          // 0x0234(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         VerticalAcceleration;                              // 0x0238(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         VerticalDeceleration;                              // 0x023C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TerminalSpeed;                                     // 0x0240(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinAdditiveTerminalSpeed;                          // 0x0244(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxAdditiveTerminalSpeed;                          // 0x0248(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotationYawRate;                                   // 0x024C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_250[0x10];                                     // 0x0250(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InputUpdateTime;                                   // 0x0260(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_264[0xC];                                      // 0x0264(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ServerUpdateInput(const float InForwardInput, const float InRightInput, const float InDesiredPitchRotation, const float InDesiredYawRotation);

	float GetForwardInput() const;
	float GetRightInput() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FreeFallMovement">();
	}
	static class UFreeFallMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFreeFallMovement>();
	}
};
static_assert(alignof(UFreeFallMovement) == 0x000008, "Wrong alignment on UFreeFallMovement");
static_assert(sizeof(UFreeFallMovement) == 0x000270, "Wrong size on UFreeFallMovement");
static_assert(offsetof(UFreeFallMovement, MinPitch) == 0x000220, "Member 'UFreeFallMovement::MinPitch' has a wrong offset!");
static_assert(offsetof(UFreeFallMovement, MaxPitch) == 0x000224, "Member 'UFreeFallMovement::MaxPitch' has a wrong offset!");
static_assert(offsetof(UFreeFallMovement, MaxLateralSpeed) == 0x000228, "Member 'UFreeFallMovement::MaxLateralSpeed' has a wrong offset!");
static_assert(offsetof(UFreeFallMovement, LateralAcceleration) == 0x00022C, "Member 'UFreeFallMovement::LateralAcceleration' has a wrong offset!");
static_assert(offsetof(UFreeFallMovement, LateralDeceleration) == 0x000230, "Member 'UFreeFallMovement::LateralDeceleration' has a wrong offset!");
static_assert(offsetof(UFreeFallMovement, LateralBrakeDeceleration) == 0x000234, "Member 'UFreeFallMovement::LateralBrakeDeceleration' has a wrong offset!");
static_assert(offsetof(UFreeFallMovement, VerticalAcceleration) == 0x000238, "Member 'UFreeFallMovement::VerticalAcceleration' has a wrong offset!");
static_assert(offsetof(UFreeFallMovement, VerticalDeceleration) == 0x00023C, "Member 'UFreeFallMovement::VerticalDeceleration' has a wrong offset!");
static_assert(offsetof(UFreeFallMovement, TerminalSpeed) == 0x000240, "Member 'UFreeFallMovement::TerminalSpeed' has a wrong offset!");
static_assert(offsetof(UFreeFallMovement, MinAdditiveTerminalSpeed) == 0x000244, "Member 'UFreeFallMovement::MinAdditiveTerminalSpeed' has a wrong offset!");
static_assert(offsetof(UFreeFallMovement, MaxAdditiveTerminalSpeed) == 0x000248, "Member 'UFreeFallMovement::MaxAdditiveTerminalSpeed' has a wrong offset!");
static_assert(offsetof(UFreeFallMovement, RotationYawRate) == 0x00024C, "Member 'UFreeFallMovement::RotationYawRate' has a wrong offset!");
static_assert(offsetof(UFreeFallMovement, InputUpdateTime) == 0x000260, "Member 'UFreeFallMovement::InputUpdateTime' has a wrong offset!");

// Class TslGame.ParachuteVehicleMovement
// 0x0100 (0x0320 - 0x0220)
class UParachuteVehicleMovement final : public USimpleInterpolationMovement
{
public:
	uint8                                         Pad_220[0x4];                                      // 0x0220(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSpeed;                                          // 0x0224(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Acceleration;                                      // 0x0228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Deceleration;                                      // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxRotationYawRate;                                // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotationYawAcceleration;                           // 0x0234(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotationYawDeceleration;                           // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TerminalVelocity;                                  // 0x023C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DecreaseTerminalVelocity;                          // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_244[0x8];                                      // 0x0244(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationYawReplicated;                             // 0x024C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotationPitchReplicated;                           // 0x0250(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InputUpdateTime;                                   // 0x0254(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_258[0x2C];                                     // 0x0258(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ParachuteDeployCoefficient;                        // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         YawSpeed;                                          // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxForwardPitch;                                   // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxBackwardPitch;                                  // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ForceForwardScale;                                 // 0x0294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ForceForwardStaticSpeed;                           // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         VelocityLERPSpeedMin;                              // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         VelocityLERPSpeedMax;                              // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         VelocityLERPValueMin;                              // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         VelocityLERPValueMax;                              // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DampingPitchMin;                                   // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DampingPitchMax;                                   // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DampingValueMin;                                   // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DampingValueMax;                                   // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ForceDownAngleMin;                                 // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ForceDownAngleMax;                                 // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ForceGravityMax;                                   // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ForceGravitySpeedMin;                              // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ForceGravitySpeedMax;                              // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ForceGravityValueMin;                              // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ForceGravityValueMax;                              // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RollSpeedMin;                                      // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RollSpeedMax;                                      // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RollAngleMin;                                      // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RollAngleMax;                                      // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RollInterpSpeed;                                   // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FinalVelocitySpeedMin;                             // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FinalVelocitySpeedMax;                             // 0x02F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FinalVelocityDampingMin;                           // 0x02F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FinalVelocityDampingMax;                           // 0x02F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2FC[0x4];                                      // 0x02FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceSphereRadius;                                 // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                TraceSphereOffset;                                 // 0x0304(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         GroundTraceStart;                                  // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GroundTraceEnd;                                    // 0x0314(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GroundTraceDampingMin;                             // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GroundTraceDampingMax;                             // 0x031C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ServerUpdateInput(float InForwardInput, float InRotationInput);

	struct FRotator GetClientRotation() const;
	float GetForwardInput() const;
	float GetRotationInput() const;
	float GetRotationYawRate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParachuteVehicleMovement">();
	}
	static class UParachuteVehicleMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParachuteVehicleMovement>();
	}
};
static_assert(alignof(UParachuteVehicleMovement) == 0x000008, "Wrong alignment on UParachuteVehicleMovement");
static_assert(sizeof(UParachuteVehicleMovement) == 0x000320, "Wrong size on UParachuteVehicleMovement");
static_assert(offsetof(UParachuteVehicleMovement, MaxSpeed) == 0x000224, "Member 'UParachuteVehicleMovement::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, Acceleration) == 0x000228, "Member 'UParachuteVehicleMovement::Acceleration' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, Deceleration) == 0x00022C, "Member 'UParachuteVehicleMovement::Deceleration' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, MaxRotationYawRate) == 0x000230, "Member 'UParachuteVehicleMovement::MaxRotationYawRate' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, RotationYawAcceleration) == 0x000234, "Member 'UParachuteVehicleMovement::RotationYawAcceleration' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, RotationYawDeceleration) == 0x000238, "Member 'UParachuteVehicleMovement::RotationYawDeceleration' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, TerminalVelocity) == 0x00023C, "Member 'UParachuteVehicleMovement::TerminalVelocity' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, DecreaseTerminalVelocity) == 0x000240, "Member 'UParachuteVehicleMovement::DecreaseTerminalVelocity' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, RotationYawReplicated) == 0x00024C, "Member 'UParachuteVehicleMovement::RotationYawReplicated' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, RotationPitchReplicated) == 0x000250, "Member 'UParachuteVehicleMovement::RotationPitchReplicated' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, InputUpdateTime) == 0x000254, "Member 'UParachuteVehicleMovement::InputUpdateTime' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, ParachuteDeployCoefficient) == 0x000284, "Member 'UParachuteVehicleMovement::ParachuteDeployCoefficient' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, YawSpeed) == 0x000288, "Member 'UParachuteVehicleMovement::YawSpeed' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, MaxForwardPitch) == 0x00028C, "Member 'UParachuteVehicleMovement::MaxForwardPitch' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, MaxBackwardPitch) == 0x000290, "Member 'UParachuteVehicleMovement::MaxBackwardPitch' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, ForceForwardScale) == 0x000294, "Member 'UParachuteVehicleMovement::ForceForwardScale' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, ForceForwardStaticSpeed) == 0x000298, "Member 'UParachuteVehicleMovement::ForceForwardStaticSpeed' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, VelocityLERPSpeedMin) == 0x00029C, "Member 'UParachuteVehicleMovement::VelocityLERPSpeedMin' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, VelocityLERPSpeedMax) == 0x0002A0, "Member 'UParachuteVehicleMovement::VelocityLERPSpeedMax' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, VelocityLERPValueMin) == 0x0002A4, "Member 'UParachuteVehicleMovement::VelocityLERPValueMin' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, VelocityLERPValueMax) == 0x0002A8, "Member 'UParachuteVehicleMovement::VelocityLERPValueMax' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, DampingPitchMin) == 0x0002AC, "Member 'UParachuteVehicleMovement::DampingPitchMin' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, DampingPitchMax) == 0x0002B0, "Member 'UParachuteVehicleMovement::DampingPitchMax' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, DampingValueMin) == 0x0002B4, "Member 'UParachuteVehicleMovement::DampingValueMin' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, DampingValueMax) == 0x0002B8, "Member 'UParachuteVehicleMovement::DampingValueMax' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, ForceDownAngleMin) == 0x0002BC, "Member 'UParachuteVehicleMovement::ForceDownAngleMin' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, ForceDownAngleMax) == 0x0002C0, "Member 'UParachuteVehicleMovement::ForceDownAngleMax' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, ForceGravityMax) == 0x0002C4, "Member 'UParachuteVehicleMovement::ForceGravityMax' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, ForceGravitySpeedMin) == 0x0002C8, "Member 'UParachuteVehicleMovement::ForceGravitySpeedMin' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, ForceGravitySpeedMax) == 0x0002CC, "Member 'UParachuteVehicleMovement::ForceGravitySpeedMax' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, ForceGravityValueMin) == 0x0002D0, "Member 'UParachuteVehicleMovement::ForceGravityValueMin' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, ForceGravityValueMax) == 0x0002D4, "Member 'UParachuteVehicleMovement::ForceGravityValueMax' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, RollSpeedMin) == 0x0002D8, "Member 'UParachuteVehicleMovement::RollSpeedMin' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, RollSpeedMax) == 0x0002DC, "Member 'UParachuteVehicleMovement::RollSpeedMax' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, RollAngleMin) == 0x0002E0, "Member 'UParachuteVehicleMovement::RollAngleMin' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, RollAngleMax) == 0x0002E4, "Member 'UParachuteVehicleMovement::RollAngleMax' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, RollInterpSpeed) == 0x0002E8, "Member 'UParachuteVehicleMovement::RollInterpSpeed' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, FinalVelocitySpeedMin) == 0x0002EC, "Member 'UParachuteVehicleMovement::FinalVelocitySpeedMin' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, FinalVelocitySpeedMax) == 0x0002F0, "Member 'UParachuteVehicleMovement::FinalVelocitySpeedMax' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, FinalVelocityDampingMin) == 0x0002F4, "Member 'UParachuteVehicleMovement::FinalVelocityDampingMin' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, FinalVelocityDampingMax) == 0x0002F8, "Member 'UParachuteVehicleMovement::FinalVelocityDampingMax' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, TraceSphereRadius) == 0x000300, "Member 'UParachuteVehicleMovement::TraceSphereRadius' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, TraceSphereOffset) == 0x000304, "Member 'UParachuteVehicleMovement::TraceSphereOffset' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, GroundTraceStart) == 0x000310, "Member 'UParachuteVehicleMovement::GroundTraceStart' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, GroundTraceEnd) == 0x000314, "Member 'UParachuteVehicleMovement::GroundTraceEnd' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, GroundTraceDampingMin) == 0x000318, "Member 'UParachuteVehicleMovement::GroundTraceDampingMin' has a wrong offset!");
static_assert(offsetof(UParachuteVehicleMovement, GroundTraceDampingMax) == 0x00031C, "Member 'UParachuteVehicleMovement::GroundTraceDampingMax' has a wrong offset!");

// Class TslGame.TslAircraftVehicleMovement
// 0x0008 (0x0228 - 0x0220)
class UTslAircraftVehicleMovement final : public USimpleInterpolationMovement
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslAircraftVehicleMovement">();
	}
	static class UTslAircraftVehicleMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslAircraftVehicleMovement>();
	}
};
static_assert(alignof(UTslAircraftVehicleMovement) == 0x000008, "Wrong alignment on UTslAircraftVehicleMovement");
static_assert(sizeof(UTslAircraftVehicleMovement) == 0x000228, "Wrong size on UTslAircraftVehicleMovement");

// Class TslGame.TslImpactEffect
// 0x0250 (0x05F0 - 0x03A0)
class ATslImpactEffect final : public AActor
{
public:
	class UParticleSystem*                        DefaultFX;                                         // 0x03A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ConcreteFX;                                        // 0x03A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        DirtFX;                                            // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        WaterFX;                                           // 0x03B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        MetalFX;                                           // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        WoodFX;                                            // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        GlassFX;                                           // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        GrassFX;                                           // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        FleshFX;                                           // 0x03E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AkSound;                                           // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDecalEffectDataSet                    DecalEffectDataSet;                                // 0x03F0(0x0168)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FHitResult                             SurfaceHit;                                        // 0x0558(0x0088)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               ParticleCom;                                       // 0x05E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           AKCom;                                             // 0x05E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslImpactEffect">();
	}
	static class ATslImpactEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslImpactEffect>();
	}
};
static_assert(alignof(ATslImpactEffect) == 0x000008, "Wrong alignment on ATslImpactEffect");
static_assert(sizeof(ATslImpactEffect) == 0x0005F0, "Wrong size on ATslImpactEffect");
static_assert(offsetof(ATslImpactEffect, DefaultFX) == 0x0003A0, "Member 'ATslImpactEffect::DefaultFX' has a wrong offset!");
static_assert(offsetof(ATslImpactEffect, ConcreteFX) == 0x0003A8, "Member 'ATslImpactEffect::ConcreteFX' has a wrong offset!");
static_assert(offsetof(ATslImpactEffect, DirtFX) == 0x0003B0, "Member 'ATslImpactEffect::DirtFX' has a wrong offset!");
static_assert(offsetof(ATslImpactEffect, WaterFX) == 0x0003B8, "Member 'ATslImpactEffect::WaterFX' has a wrong offset!");
static_assert(offsetof(ATslImpactEffect, MetalFX) == 0x0003C0, "Member 'ATslImpactEffect::MetalFX' has a wrong offset!");
static_assert(offsetof(ATslImpactEffect, WoodFX) == 0x0003C8, "Member 'ATslImpactEffect::WoodFX' has a wrong offset!");
static_assert(offsetof(ATslImpactEffect, GlassFX) == 0x0003D0, "Member 'ATslImpactEffect::GlassFX' has a wrong offset!");
static_assert(offsetof(ATslImpactEffect, GrassFX) == 0x0003D8, "Member 'ATslImpactEffect::GrassFX' has a wrong offset!");
static_assert(offsetof(ATslImpactEffect, FleshFX) == 0x0003E0, "Member 'ATslImpactEffect::FleshFX' has a wrong offset!");
static_assert(offsetof(ATslImpactEffect, AkSound) == 0x0003E8, "Member 'ATslImpactEffect::AkSound' has a wrong offset!");
static_assert(offsetof(ATslImpactEffect, DecalEffectDataSet) == 0x0003F0, "Member 'ATslImpactEffect::DecalEffectDataSet' has a wrong offset!");
static_assert(offsetof(ATslImpactEffect, SurfaceHit) == 0x000558, "Member 'ATslImpactEffect::SurfaceHit' has a wrong offset!");
static_assert(offsetof(ATslImpactEffect, ParticleCom) == 0x0005E0, "Member 'ATslImpactEffect::ParticleCom' has a wrong offset!");
static_assert(offsetof(ATslImpactEffect, AKCom) == 0x0005E8, "Member 'ATslImpactEffect::AKCom' has a wrong offset!");

// Class TslGame.SpringArmInVehicleComponent
// 0x0008 (0x0390 - 0x0388)
class USpringArmInVehicleComponent final : public USpringArmComponent
{
public:
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpringArmInVehicleComponent">();
	}
	static class USpringArmInVehicleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpringArmInVehicleComponent>();
	}
};
static_assert(alignof(USpringArmInVehicleComponent) == 0x000008, "Wrong alignment on USpringArmInVehicleComponent");
static_assert(sizeof(USpringArmInVehicleComponent) == 0x000390, "Wrong size on USpringArmInVehicleComponent");

// Class TslGame.StanceComponent
// 0x0080 (0x0178 - 0x00F8)
class UStanceComponent final : public UActorComponent
{
public:
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FStanceTransitionData                  StanceTransitionData;                              // 0x0100(0x0060)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	EStanceMode                                   CurrentStance;                                     // 0x0160(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x17];                                     // 0x0161(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientInitByReconnection(EStanceMode InitStance);
	void OnRep_CurrentStance();
	void ServerChangeStance(EStanceMode ToStance);
	void ServerForceInitStance();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StanceComponent">();
	}
	static class UStanceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStanceComponent>();
	}
};
static_assert(alignof(UStanceComponent) == 0x000008, "Wrong alignment on UStanceComponent");
static_assert(sizeof(UStanceComponent) == 0x000178, "Wrong size on UStanceComponent");
static_assert(offsetof(UStanceComponent, StanceTransitionData) == 0x000100, "Member 'UStanceComponent::StanceTransitionData' has a wrong offset!");
static_assert(offsetof(UStanceComponent, CurrentStance) == 0x000160, "Member 'UStanceComponent::CurrentStance' has a wrong offset!");

// Class TslGame.TslInstancedGlassWindowComponent
// 0x0110 (0x0AF0 - 0x09E0)
class UTslInstancedGlassWindowComponent final : public UGridInstancedStaticMeshComponent
{
public:
	uint8                                         Pad_9E0[0x8];                                      // 0x09E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDestructibleMesh*                      DestructibleMesh;                                  // 0x09E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestroyDelayAfterDestructed;                       // 0x09F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9F4[0x4];                                      // 0x09F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          DestructSound;                                     // 0x09F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bReplicatedOnClient : 1;                           // 0x0A00(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_A01[0x7];                                      // 0x0A01(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 DestroyedInstances;                                // 0x0A08(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 PendingDestroyInstances;                           // 0x0A18(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A28[0xC8];                                     // 0x0A28(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientNotifyHit(bool bBlockingHit, const struct FVector_NetQuantize& Location, const struct FVector_NetQuantizeNormal& ImpactNormal, int32 InstanceIndex);
	void OnRep_Destroyed();
	void OnRep_PendingDestroy();
	void OnRep_ReplicatedOnClient(bool bLastReplicatedOnClient);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslInstancedGlassWindowComponent">();
	}
	static class UTslInstancedGlassWindowComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslInstancedGlassWindowComponent>();
	}
};
static_assert(alignof(UTslInstancedGlassWindowComponent) == 0x000010, "Wrong alignment on UTslInstancedGlassWindowComponent");
static_assert(sizeof(UTslInstancedGlassWindowComponent) == 0x000AF0, "Wrong size on UTslInstancedGlassWindowComponent");
static_assert(offsetof(UTslInstancedGlassWindowComponent, DestructibleMesh) == 0x0009E8, "Member 'UTslInstancedGlassWindowComponent::DestructibleMesh' has a wrong offset!");
static_assert(offsetof(UTslInstancedGlassWindowComponent, DestroyDelayAfterDestructed) == 0x0009F0, "Member 'UTslInstancedGlassWindowComponent::DestroyDelayAfterDestructed' has a wrong offset!");
static_assert(offsetof(UTslInstancedGlassWindowComponent, DestructSound) == 0x0009F8, "Member 'UTslInstancedGlassWindowComponent::DestructSound' has a wrong offset!");
static_assert(offsetof(UTslInstancedGlassWindowComponent, DestroyedInstances) == 0x000A08, "Member 'UTslInstancedGlassWindowComponent::DestroyedInstances' has a wrong offset!");
static_assert(offsetof(UTslInstancedGlassWindowComponent, PendingDestroyInstances) == 0x000A18, "Member 'UTslInstancedGlassWindowComponent::PendingDestroyInstances' has a wrong offset!");

// Class TslGame.TslPlayerStart
// 0x0028 (0x03F8 - 0x03D0)
class ATslPlayerStart final : public APlayerStart
{
public:
	EMatchStartType                               MatchStartType;                                    // 0x03D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D1[0x3];                                      // 0x03D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartRadius;                                       // 0x03D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRandomRotation;                                   // 0x03D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D9[0x7];                                      // 0x03D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AStartActivationVolume*>         ActivationVolumes;                                 // 0x03E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F0[0x8];                                      // 0x03F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetRandomStartLocation() const;
	float GetRandomStartYawRotation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslPlayerStart">();
	}
	static class ATslPlayerStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslPlayerStart>();
	}
};
static_assert(alignof(ATslPlayerStart) == 0x000008, "Wrong alignment on ATslPlayerStart");
static_assert(sizeof(ATslPlayerStart) == 0x0003F8, "Wrong size on ATslPlayerStart");
static_assert(offsetof(ATslPlayerStart, MatchStartType) == 0x0003D0, "Member 'ATslPlayerStart::MatchStartType' has a wrong offset!");
static_assert(offsetof(ATslPlayerStart, StartRadius) == 0x0003D4, "Member 'ATslPlayerStart::StartRadius' has a wrong offset!");
static_assert(offsetof(ATslPlayerStart, bRandomRotation) == 0x0003D8, "Member 'ATslPlayerStart::bRandomRotation' has a wrong offset!");
static_assert(offsetof(ATslPlayerStart, ActivationVolumes) == 0x0003E0, "Member 'ATslPlayerStart::ActivationVolumes' has a wrong offset!");

// Class TslGame.StartActivationVolume
// 0x0008 (0x03E0 - 0x03D8)
class AStartActivationVolume : public AVolume
{
public:
	uint8                                         Pad_3D8[0x8];                                      // 0x03D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StartActivationVolume">();
	}
	static class AStartActivationVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStartActivationVolume>();
	}
};
static_assert(alignof(AStartActivationVolume) == 0x000008, "Wrong alignment on AStartActivationVolume");
static_assert(sizeof(AStartActivationVolume) == 0x0003E0, "Wrong size on AStartActivationVolume");

// Class TslGame.ThingActivationVolume
// 0x0000 (0x03E0 - 0x03E0)
class AThingActivationVolume final : public AStartActivationVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThingActivationVolume">();
	}
	static class AThingActivationVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThingActivationVolume>();
	}
};
static_assert(alignof(AThingActivationVolume) == 0x000008, "Wrong alignment on AThingActivationVolume");
static_assert(sizeof(AThingActivationVolume) == 0x0003E0, "Wrong size on AThingActivationVolume");

// Class TslGame.InventoryFacade
// 0x0020 (0x03C8 - 0x03A8)
class AInventoryFacade final : public ASubActor
{
public:
	TArray<EEquipSlotID>                          AutoSwapEquipSlotID;                               // 0x03A8(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	class AInventory*                             Inventory;                                         // 0x03B8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AEquipment*                             Equipment;                                         // 0x03C0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class AEquipment* GetEquipment();
	class AInventory* GetInventory();
	void GiveItem_Admin(TSubclassOf<class UItem> ItemClass);

	class ATslCharacter* GetOwnerCharacter() const;
	bool HasItemByClass(TSubclassOf<class UItem> ItemClass) const;
	bool IsAutoSwappable(EEquipSlotID SlotID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryFacade">();
	}
	static class AInventoryFacade* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInventoryFacade>();
	}
};
static_assert(alignof(AInventoryFacade) == 0x000008, "Wrong alignment on AInventoryFacade");
static_assert(sizeof(AInventoryFacade) == 0x0003C8, "Wrong size on AInventoryFacade");
static_assert(offsetof(AInventoryFacade, AutoSwapEquipSlotID) == 0x0003A8, "Member 'AInventoryFacade::AutoSwapEquipSlotID' has a wrong offset!");
static_assert(offsetof(AInventoryFacade, Inventory) == 0x0003B8, "Member 'AInventoryFacade::Inventory' has a wrong offset!");
static_assert(offsetof(AInventoryFacade, Equipment) == 0x0003C0, "Member 'AInventoryFacade::Equipment' has a wrong offset!");

// Class TslGame.Equipment
// 0x0050 (0x0428 - 0x03D8)
class AEquipment final : public AItemSlotContainer
{
public:
	UMulticastDelegateProperty_                   OnEquipmentUpdated;                                // 0x03D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E8[0x30];                                     // 0x03E8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UEquipableItem*>                 Items;                                             // 0x0418(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)

public:
	void DetachItem(const struct FEquipPosition& EquipPosition, class FName ItemClassForVerify, EWeaponAttachmentSlotID SlotID, bool bSoundPlay);
	void DropAttachedItem(const struct FEquipPosition& EquipPosition, class FName ItemClassForVerify, EWeaponAttachmentSlotID SlotID, bool bSoundPlay);
	void DropItem(const struct FEquipPosition& Position, class FName ItemClassForVerify, bool bIsForce, bool bSoundPlay);
	bool EquipItem(const struct FEquipPosition& Position, class UEquipableItem* Item, bool bCheckViaCanEquipTo, bool bSoundPlay);
	void Items_RepNotify();
	void PrimaryWeaponSwap(const struct FEquipPosition& EquipPosition, const class FString& Options);
	bool TryEquipItem(class UItem* Item, bool bSoundPlay);
	void UnequipItem(const struct FEquipPosition& Position, class FName ItemClassForVerify, bool bSoundPlay);
	void WeaponAttachmentSwap(const struct FEquipPosition& SourceWeapon, const struct FEquipPosition& TargetWeapon, class FName ItemClassForVerify, EWeaponAttachmentSlotID AttachmentSlotID, bool bSoundPlay);

	int32 EquipPositionToWeaponIndex(const struct FEquipPosition& Position) const;
	int32 FindAttachableWeaponIndex(class UAttachableItem* AttachableItem, const class FString& Options) const;
	struct FEquipPosition FindEquipableWeaponPosition(class UEquipableItem* EquipableItem, const class FString& Options) const;
	struct FEquipPosition FindEquipPosition(EEquipSlotID SlotID, bool bOnlyFree) const;
	struct FEquipPosition FindPosition(class UItem* Item) const;
	class AInventoryFacade* GetInventoryFacade() const;
	class UEquipableItem* GetItem(const struct FEquipPosition& Position) const;
	int32 GetItemCountByClass(TSubclassOf<class UItem> ItemClass) const;
	class ATslCharacter* GetOwnerCharacter() const;
	bool IsAttachableToWeapon(int32 WeaponIndex, class UAttachableItem* AttachableItem, bool bOnlyFree) const;
	bool IsSwapablePrimaryWeapon(const struct FEquipPosition& EquipPosition, const class FString& Options) const;
	struct FEquipPosition WeaponIndexToEquipPosition(int32 WeaponIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Equipment">();
	}
	static class AEquipment* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEquipment>();
	}
};
static_assert(alignof(AEquipment) == 0x000008, "Wrong alignment on AEquipment");
static_assert(sizeof(AEquipment) == 0x000428, "Wrong size on AEquipment");
static_assert(offsetof(AEquipment, OnEquipmentUpdated) == 0x0003D8, "Member 'AEquipment::OnEquipmentUpdated' has a wrong offset!");
static_assert(offsetof(AEquipment, Items) == 0x000418, "Member 'AEquipment::Items' has a wrong offset!");

// Class TslGame.Inventory
// 0x0028 (0x0400 - 0x03D8)
class AInventory final : public AItemSlotContainer
{
public:
	UMulticastDelegateProperty_                   OnInventoryUpdated;                                // 0x03D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UItem*>                          Items;                                             // 0x03E8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	float                                         MaxSpace;                                          // 0x03F8(0x0004)(Edit, Net, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3FC[0x4];                                      // 0x03FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttachItem(int32 Index_0, class FName ItemClassForVerify, const struct FEquipPosition& EquipPosition, bool bSoundPlay);
	void AttachOrDropItem(int32 Index_0, class FName ItemClassForVerify, bool bSoundPlay);
	void ClientBroadcastNoBagSpaceEvent();
	bool ConsumeItemByClass(TSubclassOf<class UItem> ItemClass, int32 Count);
	void DropItem(int32 Index_0, class FName ItemClassForVerify, const class FString& Options, bool bSoundPlay);
	void EquipItem(int32 Index_0, class FName ItemClassForVerify, bool bSoundPlay);
	void EquipOrDropItem(int32 Index_0, class FName ItemClassForVerify, bool bSoundPlay);
	class UItem* FindItem(TSubclassOf<class UItem> ItemClass);
	class UItem* FindItemHasMinStack(TSubclassOf<class UItem> ItemClass);
	void Items_RepNotify();
	void OnFinishUseCast(class UObject* CastObject);
	void UseItem(int32 Index_0, class FName ItemClassForVerify);

	int32 FindItemIndex(class UItem* Item) const;
	int32 GetAdditionalMaxCount(class UItem* Item) const;
	TArray<struct FInventoryItem> GetAllItems() const;
	TArray<struct FInventoryItem> GetAllItemsByType(TSubclassOf<class UItem> ItemSuperClass) const;
	float GetCurrentSpace() const;
	class AInventoryFacade* GetInventoryFacade() const;
	int32 GetItemCount() const;
	int32 GetItemCountByClass(TSubclassOf<class UItem> ItemClass) const;
	float GetMaxSpace() const;
	class ATslCharacter* GetOwnerCharacter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Inventory">();
	}
	static class AInventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInventory>();
	}
};
static_assert(alignof(AInventory) == 0x000008, "Wrong alignment on AInventory");
static_assert(sizeof(AInventory) == 0x000400, "Wrong size on AInventory");
static_assert(offsetof(AInventory, OnInventoryUpdated) == 0x0003D8, "Member 'AInventory::OnInventoryUpdated' has a wrong offset!");
static_assert(offsetof(AInventory, Items) == 0x0003E8, "Member 'AInventory::Items' has a wrong offset!");
static_assert(offsetof(AInventory, MaxSpace) == 0x0003F8, "Member 'AInventory::MaxSpace' has a wrong offset!");

// Class TslGame.ItemExplorerProxy
// 0x0020 (0x0428 - 0x0408)
class AItemExplorerProxy final : public AItemExplorer
{
public:
	TDelegate<void()>                             OnChangeItemExplorerProxy;                         // 0x0408(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_418[0x10];                                     // 0x0418(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Pop();
	void PropagateCreateAndShowContextMenuWidget(TScriptInterface<class ISlotContainerInterface> Param);
	void PropagateDestroyContextMenuWidget();
	void PropagateUpdateItemList();

	bool IsBaseExplorer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemExplorerProxy">();
	}
	static class AItemExplorerProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemExplorerProxy>();
	}
};
static_assert(alignof(AItemExplorerProxy) == 0x000008, "Wrong alignment on AItemExplorerProxy");
static_assert(sizeof(AItemExplorerProxy) == 0x000428, "Wrong size on AItemExplorerProxy");
static_assert(offsetof(AItemExplorerProxy, OnChangeItemExplorerProxy) == 0x000408, "Member 'AItemExplorerProxy::OnChangeItemExplorerProxy' has a wrong offset!");

// Class TslGame.CarePackageItem
// 0x00B0 (0x05B0 - 0x0500)
class ACarePackageItem final : public AItemPackage
{
public:
	TSubclassOf<class AActor>                     ParachuteClass;                                    // 0x0500(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               SmokeFxClass;                                      // 0x0508(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               SmokeAirFxClass;                                   // 0x0510(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               LightFxClass;                                      // 0x0518(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SmokeTime;                                         // 0x0520(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimitFallSpeed;                                    // 0x0524(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SmokeSocket;                                       // 0x0528(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SmokeAirSocket;                                    // 0x0530(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LightSocket;                                       // 0x0538(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParachuteSocket;                                   // 0x0540(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          LandSoundAk;                                       // 0x0548(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFalling;                                        // 0x0550(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPickupedItem;                                   // 0x0551(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHideIconOnMap;                                  // 0x0552(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTranslucentIconOnMap;                           // 0x0553(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_554[0x4];                                      // 0x0554(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ATslParticle*                           SmokeFx;                                           // 0x0558(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATslParticle*                           SmokeAirFx;                                        // 0x0560(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATslParticle*                           LightFx;                                           // 0x0568(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 Parachute;                                         // 0x0570(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_578[0x8];                                      // 0x0578(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USimpleInterpolationMovement*           MovementComponent;                                 // 0x0580(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBuoyancyForceComponent*                BuoyancyForceComponent;                            // 0x0588(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkComponent*                           AkComponent;                                       // 0x0590(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_598[0x18];                                     // 0x0598(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsFalling() const;
	bool IsPickupedItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CarePackageItem">();
	}
	static class ACarePackageItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACarePackageItem>();
	}
};
static_assert(alignof(ACarePackageItem) == 0x000008, "Wrong alignment on ACarePackageItem");
static_assert(sizeof(ACarePackageItem) == 0x0005B0, "Wrong size on ACarePackageItem");
static_assert(offsetof(ACarePackageItem, ParachuteClass) == 0x000500, "Member 'ACarePackageItem::ParachuteClass' has a wrong offset!");
static_assert(offsetof(ACarePackageItem, SmokeFxClass) == 0x000508, "Member 'ACarePackageItem::SmokeFxClass' has a wrong offset!");
static_assert(offsetof(ACarePackageItem, SmokeAirFxClass) == 0x000510, "Member 'ACarePackageItem::SmokeAirFxClass' has a wrong offset!");
static_assert(offsetof(ACarePackageItem, LightFxClass) == 0x000518, "Member 'ACarePackageItem::LightFxClass' has a wrong offset!");
static_assert(offsetof(ACarePackageItem, SmokeTime) == 0x000520, "Member 'ACarePackageItem::SmokeTime' has a wrong offset!");
static_assert(offsetof(ACarePackageItem, LimitFallSpeed) == 0x000524, "Member 'ACarePackageItem::LimitFallSpeed' has a wrong offset!");
static_assert(offsetof(ACarePackageItem, SmokeSocket) == 0x000528, "Member 'ACarePackageItem::SmokeSocket' has a wrong offset!");
static_assert(offsetof(ACarePackageItem, SmokeAirSocket) == 0x000530, "Member 'ACarePackageItem::SmokeAirSocket' has a wrong offset!");
static_assert(offsetof(ACarePackageItem, LightSocket) == 0x000538, "Member 'ACarePackageItem::LightSocket' has a wrong offset!");
static_assert(offsetof(ACarePackageItem, ParachuteSocket) == 0x000540, "Member 'ACarePackageItem::ParachuteSocket' has a wrong offset!");
static_assert(offsetof(ACarePackageItem, LandSoundAk) == 0x000548, "Member 'ACarePackageItem::LandSoundAk' has a wrong offset!");
static_assert(offsetof(ACarePackageItem, bIsFalling) == 0x000550, "Member 'ACarePackageItem::bIsFalling' has a wrong offset!");
static_assert(offsetof(ACarePackageItem, bIsPickupedItem) == 0x000551, "Member 'ACarePackageItem::bIsPickupedItem' has a wrong offset!");
static_assert(offsetof(ACarePackageItem, bIsHideIconOnMap) == 0x000552, "Member 'ACarePackageItem::bIsHideIconOnMap' has a wrong offset!");
static_assert(offsetof(ACarePackageItem, bIsTranslucentIconOnMap) == 0x000553, "Member 'ACarePackageItem::bIsTranslucentIconOnMap' has a wrong offset!");
static_assert(offsetof(ACarePackageItem, SmokeFx) == 0x000558, "Member 'ACarePackageItem::SmokeFx' has a wrong offset!");
static_assert(offsetof(ACarePackageItem, SmokeAirFx) == 0x000560, "Member 'ACarePackageItem::SmokeAirFx' has a wrong offset!");
static_assert(offsetof(ACarePackageItem, LightFx) == 0x000568, "Member 'ACarePackageItem::LightFx' has a wrong offset!");
static_assert(offsetof(ACarePackageItem, Parachute) == 0x000570, "Member 'ACarePackageItem::Parachute' has a wrong offset!");
static_assert(offsetof(ACarePackageItem, MovementComponent) == 0x000580, "Member 'ACarePackageItem::MovementComponent' has a wrong offset!");
static_assert(offsetof(ACarePackageItem, BuoyancyForceComponent) == 0x000588, "Member 'ACarePackageItem::BuoyancyForceComponent' has a wrong offset!");
static_assert(offsetof(ACarePackageItem, AkComponent) == 0x000590, "Member 'ACarePackageItem::AkComponent' has a wrong offset!");

// Class TslGame.TslPhysicsVolume
// 0x0028 (0x0410 - 0x03E8)
class ATslPhysicsVolume final : public APhysicsVolume
{
public:
	class AOceanManager*                          OceanManager;                                      // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ATslParticle>               DefaultWaterSplash;                                // 0x03F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ATslParticle>               VehicleWaterSplash;                                // 0x03F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_400[0x10];                                     // 0x0400(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslPhysicsVolume">();
	}
	static class ATslPhysicsVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslPhysicsVolume>();
	}
};
static_assert(alignof(ATslPhysicsVolume) == 0x000008, "Wrong alignment on ATslPhysicsVolume");
static_assert(sizeof(ATslPhysicsVolume) == 0x000410, "Wrong size on ATslPhysicsVolume");
static_assert(offsetof(ATslPhysicsVolume, OceanManager) == 0x0003E8, "Member 'ATslPhysicsVolume::OceanManager' has a wrong offset!");
static_assert(offsetof(ATslPhysicsVolume, DefaultWaterSplash) == 0x0003F0, "Member 'ATslPhysicsVolume::DefaultWaterSplash' has a wrong offset!");
static_assert(offsetof(ATslPhysicsVolume, VehicleWaterSplash) == 0x0003F8, "Member 'ATslPhysicsVolume::VehicleWaterSplash' has a wrong offset!");

// Class TslGame.FloorSnapItemPackage
// 0x0018 (0x0518 - 0x0500)
class AFloorSnapItemPackage : public AItemPackage
{
public:
	float                                         RayLength;                                         // 0x0500(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseWaterSurface;                                  // 0x0504(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_505[0x3];                                      // 0x0505(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaterSurfaceThreshold;                             // 0x0508(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50C[0x4];                                      // 0x050C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBuoyancyForceComponent*                BuoyancyForceComponent;                            // 0x0510(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FloorSnapItemPackage">();
	}
	static class AFloorSnapItemPackage* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFloorSnapItemPackage>();
	}
};
static_assert(alignof(AFloorSnapItemPackage) == 0x000008, "Wrong alignment on AFloorSnapItemPackage");
static_assert(sizeof(AFloorSnapItemPackage) == 0x000518, "Wrong size on AFloorSnapItemPackage");
static_assert(offsetof(AFloorSnapItemPackage, RayLength) == 0x000500, "Member 'AFloorSnapItemPackage::RayLength' has a wrong offset!");
static_assert(offsetof(AFloorSnapItemPackage, bUseWaterSurface) == 0x000504, "Member 'AFloorSnapItemPackage::bUseWaterSurface' has a wrong offset!");
static_assert(offsetof(AFloorSnapItemPackage, WaterSurfaceThreshold) == 0x000508, "Member 'AFloorSnapItemPackage::WaterSurfaceThreshold' has a wrong offset!");
static_assert(offsetof(AFloorSnapItemPackage, BuoyancyForceComponent) == 0x000510, "Member 'AFloorSnapItemPackage::BuoyancyForceComponent' has a wrong offset!");

// Class TslGame.NearbyInteractiveItemExplorer
// 0x0010 (0x0418 - 0x0408)
class ANearbyInteractiveItemExplorer final : public AItemExplorer
{
public:
	TArray<TWeakObjectPtr<class UObject>>         ExplorableItems;                                   // 0x0408(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NearbyInteractiveItemExplorer">();
	}
	static class ANearbyInteractiveItemExplorer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANearbyInteractiveItemExplorer>();
	}
};
static_assert(alignof(ANearbyInteractiveItemExplorer) == 0x000008, "Wrong alignment on ANearbyInteractiveItemExplorer");
static_assert(sizeof(ANearbyInteractiveItemExplorer) == 0x000418, "Wrong size on ANearbyInteractiveItemExplorer");
static_assert(offsetof(ANearbyInteractiveItemExplorer, ExplorableItems) == 0x000408, "Member 'ANearbyInteractiveItemExplorer::ExplorableItems' has a wrong offset!");

// Class TslGame.ThingSpawnProcessor
// 0x0010 (0x0038 - 0x0028)
class UThingSpawnProcessor : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThingSpawnProcessor">();
	}
	static class UThingSpawnProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThingSpawnProcessor>();
	}
};
static_assert(alignof(UThingSpawnProcessor) == 0x000008, "Wrong alignment on UThingSpawnProcessor");
static_assert(sizeof(UThingSpawnProcessor) == 0x000038, "Wrong size on UThingSpawnProcessor");

// Class TslGame.SubThingSpawnProcessor
// 0x0000 (0x0028 - 0x0028)
class USubThingSpawnProcessor : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubThingSpawnProcessor">();
	}
	static class USubThingSpawnProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubThingSpawnProcessor>();
	}
};
static_assert(alignof(USubThingSpawnProcessor) == 0x000008, "Wrong alignment on USubThingSpawnProcessor");
static_assert(sizeof(USubThingSpawnProcessor) == 0x000028, "Wrong size on USubThingSpawnProcessor");

// Class TslGame.CombinedThingSpawnProcessor
// 0x0020 (0x0058 - 0x0038)
class UCombinedThingSpawnProcessor final : public UThingSpawnProcessor
{
public:
	TArray<TSubclassOf<class USubThingSpawnProcessor>> SubProcessorClasses;                               // 0x0038(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class USubThingSpawnProcessor*>        SubProcessors;                                     // 0x0048(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CombinedThingSpawnProcessor">();
	}
	static class UCombinedThingSpawnProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCombinedThingSpawnProcessor>();
	}
};
static_assert(alignof(UCombinedThingSpawnProcessor) == 0x000008, "Wrong alignment on UCombinedThingSpawnProcessor");
static_assert(sizeof(UCombinedThingSpawnProcessor) == 0x000058, "Wrong size on UCombinedThingSpawnProcessor");
static_assert(offsetof(UCombinedThingSpawnProcessor, SubProcessorClasses) == 0x000038, "Member 'UCombinedThingSpawnProcessor::SubProcessorClasses' has a wrong offset!");
static_assert(offsetof(UCombinedThingSpawnProcessor, SubProcessors) == 0x000048, "Member 'UCombinedThingSpawnProcessor::SubProcessors' has a wrong offset!");

// Class TslGame.PackageSubThingSpawnProcessor
// 0x03D0 (0x03F8 - 0x0028)
class UPackageSubThingSpawnProcessor final : public USubThingSpawnProcessor
{
public:
	class UDataTable*                             RawItemSpawnDataTable;                             // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             RawItemSpawnTogetherDataTable;                     // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FPackageSpotGroupProperty>      RawSpotGroupProperties;                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x3B0];                                     // 0x0048(0x03B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PackageSubThingSpawnProcessor">();
	}
	static class UPackageSubThingSpawnProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPackageSubThingSpawnProcessor>();
	}
};
static_assert(alignof(UPackageSubThingSpawnProcessor) == 0x000008, "Wrong alignment on UPackageSubThingSpawnProcessor");
static_assert(sizeof(UPackageSubThingSpawnProcessor) == 0x0003F8, "Wrong size on UPackageSubThingSpawnProcessor");
static_assert(offsetof(UPackageSubThingSpawnProcessor, RawItemSpawnDataTable) == 0x000028, "Member 'UPackageSubThingSpawnProcessor::RawItemSpawnDataTable' has a wrong offset!");
static_assert(offsetof(UPackageSubThingSpawnProcessor, RawItemSpawnTogetherDataTable) == 0x000030, "Member 'UPackageSubThingSpawnProcessor::RawItemSpawnTogetherDataTable' has a wrong offset!");
static_assert(offsetof(UPackageSubThingSpawnProcessor, RawSpotGroupProperties) == 0x000038, "Member 'UPackageSubThingSpawnProcessor::RawSpotGroupProperties' has a wrong offset!");

// Class TslGame.TslPawnInputBindingComponent
// 0x0020 (0x0118 - 0x00F8)
class UTslPawnInputBindingComponent final : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   OnOwnerPossessed;                                  // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnOwnerUnPossessed;                                // 0x0108(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)

public:
	void NotifyOwnerPossessed(class ATslPlayerController* InController);
	void NotifyOwnerUnPossessed(class ATslPlayerController* InController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslPawnInputBindingComponent">();
	}
	static class UTslPawnInputBindingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslPawnInputBindingComponent>();
	}
};
static_assert(alignof(UTslPawnInputBindingComponent) == 0x000008, "Wrong alignment on UTslPawnInputBindingComponent");
static_assert(sizeof(UTslPawnInputBindingComponent) == 0x000118, "Wrong size on UTslPawnInputBindingComponent");
static_assert(offsetof(UTslPawnInputBindingComponent, OnOwnerPossessed) == 0x0000F8, "Member 'UTslPawnInputBindingComponent::OnOwnerPossessed' has a wrong offset!");
static_assert(offsetof(UTslPawnInputBindingComponent, OnOwnerUnPossessed) == 0x000108, "Member 'UTslPawnInputBindingComponent::OnOwnerUnPossessed' has a wrong offset!");

// Class TslGame.VehicleSubThingSpawnProcessor
// 0x03F0 (0x0418 - 0x0028)
class UVehicleSubThingSpawnProcessor final : public USubThingSpawnProcessor
{
public:
	TArray<struct FVehicleSpotGroupProperty>      RawSpotGroupProperties;                            // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             RawVehicleSpawnDataTable;                          // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpawnZOffsetFromFloor;                             // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44[0x3D4];                                     // 0x0044(0x03D4)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleSubThingSpawnProcessor">();
	}
	static class UVehicleSubThingSpawnProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleSubThingSpawnProcessor>();
	}
};
static_assert(alignof(UVehicleSubThingSpawnProcessor) == 0x000008, "Wrong alignment on UVehicleSubThingSpawnProcessor");
static_assert(sizeof(UVehicleSubThingSpawnProcessor) == 0x000418, "Wrong size on UVehicleSubThingSpawnProcessor");
static_assert(offsetof(UVehicleSubThingSpawnProcessor, RawSpotGroupProperties) == 0x000028, "Member 'UVehicleSubThingSpawnProcessor::RawSpotGroupProperties' has a wrong offset!");
static_assert(offsetof(UVehicleSubThingSpawnProcessor, RawVehicleSpawnDataTable) == 0x000038, "Member 'UVehicleSubThingSpawnProcessor::RawVehicleSpawnDataTable' has a wrong offset!");
static_assert(offsetof(UVehicleSubThingSpawnProcessor, SpawnZOffsetFromFloor) == 0x000040, "Member 'UVehicleSubThingSpawnProcessor::SpawnZOffsetFromFloor' has a wrong offset!");

// Class TslGame.Team
// 0x0068 (0x0408 - 0x03A0)
class ATeam final : public AActor
{
public:
	struct FVector_NetQuantize100                 PlayerLocation;                                    // 0x03A0(0x000C)(Net, Transient, NativeAccessSpecifierPrivate)
	struct FRotator                               PlayerRotation;                                    // 0x03AC(0x000C)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	class FString                                 PlayerName;                                        // 0x03B8(0x0010)(Net, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Health;                                            // 0x03C8(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         HealthMax;                                         // 0x03C9(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         GroggyHealth;                                      // 0x03CA(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         GroggyHealthMax;                                   // 0x03CB(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              MapMarkerPosition;                                 // 0x03CC(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         bIsDying : 1;                                      // 0x03D4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bIsGroggying : 1;                                  // 0x03D4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bQuitter : 1;                                      // 0x03D4(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bShowMapMarker : 1;                                // 0x03D4(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Net, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	ETeamVehicleType                              TeamVehicleType;                                   // 0x03D5(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D6[0x2];                                      // 0x03D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BoostGauge;                                        // 0x03D8(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int8                                          MemberNumber;                                      // 0x03DC(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3DD[0x3];                                      // 0x03DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class ATslCharacter*                          TslCharacter;                                      // 0x03E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E8[0x10];                                     // 0x03E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UniqueId;                                          // 0x03F8(0x0010)(Net, ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnRep_Dying(bool bLastDying);
	void ServerSetMapMarkerPosition(const struct FVector2D& NewMapMarkerPosition);
	void ServerSetShowMapMarker(bool bNewShowMapMarker);

	float GetGroggyHealth() const;
	float GetGroggyHealthMax() const;
	float GetHealth() const;
	float GetHealthMax() const;
	struct FVector2D GetMapMarkerPosition() const;
	int32 GetMemberNumber() const;
	struct FVector GetPlayerLocation() const;
	class FString GetPlayerName() const;
	struct FRotator GetPlayerRotation() const;
	class FString GetPlayerUniqueId() const;
	ETeamVehicleType GetRideVehicle() const;
	class ATslCharacter* GetTslCharacter() const;
	bool IsDying() const;
	bool IsGroggying() const;
	bool IsQuitter() const;
	bool IsShowMapMarker() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Team">();
	}
	static class ATeam* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATeam>();
	}
};
static_assert(alignof(ATeam) == 0x000008, "Wrong alignment on ATeam");
static_assert(sizeof(ATeam) == 0x000408, "Wrong size on ATeam");
static_assert(offsetof(ATeam, PlayerLocation) == 0x0003A0, "Member 'ATeam::PlayerLocation' has a wrong offset!");
static_assert(offsetof(ATeam, PlayerRotation) == 0x0003AC, "Member 'ATeam::PlayerRotation' has a wrong offset!");
static_assert(offsetof(ATeam, PlayerName) == 0x0003B8, "Member 'ATeam::PlayerName' has a wrong offset!");
static_assert(offsetof(ATeam, Health) == 0x0003C8, "Member 'ATeam::Health' has a wrong offset!");
static_assert(offsetof(ATeam, HealthMax) == 0x0003C9, "Member 'ATeam::HealthMax' has a wrong offset!");
static_assert(offsetof(ATeam, GroggyHealth) == 0x0003CA, "Member 'ATeam::GroggyHealth' has a wrong offset!");
static_assert(offsetof(ATeam, GroggyHealthMax) == 0x0003CB, "Member 'ATeam::GroggyHealthMax' has a wrong offset!");
static_assert(offsetof(ATeam, MapMarkerPosition) == 0x0003CC, "Member 'ATeam::MapMarkerPosition' has a wrong offset!");
static_assert(offsetof(ATeam, TeamVehicleType) == 0x0003D5, "Member 'ATeam::TeamVehicleType' has a wrong offset!");
static_assert(offsetof(ATeam, BoostGauge) == 0x0003D8, "Member 'ATeam::BoostGauge' has a wrong offset!");
static_assert(offsetof(ATeam, MemberNumber) == 0x0003DC, "Member 'ATeam::MemberNumber' has a wrong offset!");
static_assert(offsetof(ATeam, TslCharacter) == 0x0003E0, "Member 'ATeam::TslCharacter' has a wrong offset!");
static_assert(offsetof(ATeam, UniqueId) == 0x0003F8, "Member 'ATeam::UniqueId' has a wrong offset!");

// Class TslGame.TslProjectile
// 0x0130 (0x04D0 - 0x03A0)
class ATslProjectile : public AActor
{
public:
	uint8                                         Pad_3A0[0x8];                                      // 0x03A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UProjectileMovementComponent*           MovementComp;                                      // 0x03A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       CollisionComp;                                     // 0x03B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UParticleSystemComponent*               ParticleComp;                                      // 0x03B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   MeshComp;                                          // 0x03C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPhysicsConstraintComponent*            MeshConstraint;                                    // 0x03C8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                MeshInitialRotationRate;                           // 0x03D0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bSyncServerAndClientRotation;                      // 0x03DC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3DD[0xF];                                      // 0x03DD(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          HideMeshAtExplosion;                               // 0x03EC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          ExplosionInWater;                                  // 0x03ED(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EProjectileExplosionRotationType              ExplosionRotationType;                             // 0x03EE(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3EF[0x1];                                      // 0x03EF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ParticleToMeshAttachPointName;                     // 0x03F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F8[0x8];                                      // 0x03F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATslExplosionEffect>        ExplosionTemplate;                                 // 0x0400(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ATslExplosionEffect>        ExplosionTemplateInAir;                            // 0x0408(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ATslExplosionEffect>        ExplosionTemplateInWater;                          // 0x0410(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          ImpactSound;                                       // 0x0418(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           AkComp;                                            // 0x0420(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EProjectileExplodeState                       ExplodeState;                                      // 0x0430(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bActiveParticle : 1;                               // 0x0431(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDoTick : 1;                                       // 0x0431(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_432[0x2];                                      // 0x0432(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ClientMeshRotation;                                // 0x0434(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               ServerMeshRotation;                                // 0x0440(0x000C)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         VelocityStopStepDistance;                          // 0x044C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LastStepLocation;                                  // 0x0450(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         StepBuffer;                                        // 0x045C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FinalInterpSpeed;                                  // 0x0460(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bConstantInterpStep;                               // 0x0464(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_465[0x3];                                      // 0x0465(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VelocityCheckTimerTick;                            // 0x0468(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_46C[0x4];                                      // 0x046C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FProjectileData                        ProjectileConfig;                                  // 0x0470(0x0030)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A0[0x30];                                     // 0x04A0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckVelocityForStart();
	void ExplodeBP(const struct FVector& Location, const struct FRotator& Rotation, const struct FHitResult& Impact, float Radius);
	void OnHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnImpact(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity);
	void OnRep_ActiveParticle();
	void OnRep_ClientActivate();
	void OnRep_Exploded();
	void SetMeshRotationFromServer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslProjectile">();
	}
	static class ATslProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslProjectile>();
	}
};
static_assert(alignof(ATslProjectile) == 0x000008, "Wrong alignment on ATslProjectile");
static_assert(sizeof(ATslProjectile) == 0x0004D0, "Wrong size on ATslProjectile");
static_assert(offsetof(ATslProjectile, MovementComp) == 0x0003A8, "Member 'ATslProjectile::MovementComp' has a wrong offset!");
static_assert(offsetof(ATslProjectile, CollisionComp) == 0x0003B0, "Member 'ATslProjectile::CollisionComp' has a wrong offset!");
static_assert(offsetof(ATslProjectile, ParticleComp) == 0x0003B8, "Member 'ATslProjectile::ParticleComp' has a wrong offset!");
static_assert(offsetof(ATslProjectile, MeshComp) == 0x0003C0, "Member 'ATslProjectile::MeshComp' has a wrong offset!");
static_assert(offsetof(ATslProjectile, MeshConstraint) == 0x0003C8, "Member 'ATslProjectile::MeshConstraint' has a wrong offset!");
static_assert(offsetof(ATslProjectile, MeshInitialRotationRate) == 0x0003D0, "Member 'ATslProjectile::MeshInitialRotationRate' has a wrong offset!");
static_assert(offsetof(ATslProjectile, bSyncServerAndClientRotation) == 0x0003DC, "Member 'ATslProjectile::bSyncServerAndClientRotation' has a wrong offset!");
static_assert(offsetof(ATslProjectile, HideMeshAtExplosion) == 0x0003EC, "Member 'ATslProjectile::HideMeshAtExplosion' has a wrong offset!");
static_assert(offsetof(ATslProjectile, ExplosionInWater) == 0x0003ED, "Member 'ATslProjectile::ExplosionInWater' has a wrong offset!");
static_assert(offsetof(ATslProjectile, ExplosionRotationType) == 0x0003EE, "Member 'ATslProjectile::ExplosionRotationType' has a wrong offset!");
static_assert(offsetof(ATslProjectile, ParticleToMeshAttachPointName) == 0x0003F0, "Member 'ATslProjectile::ParticleToMeshAttachPointName' has a wrong offset!");
static_assert(offsetof(ATslProjectile, ExplosionTemplate) == 0x000400, "Member 'ATslProjectile::ExplosionTemplate' has a wrong offset!");
static_assert(offsetof(ATslProjectile, ExplosionTemplateInAir) == 0x000408, "Member 'ATslProjectile::ExplosionTemplateInAir' has a wrong offset!");
static_assert(offsetof(ATslProjectile, ExplosionTemplateInWater) == 0x000410, "Member 'ATslProjectile::ExplosionTemplateInWater' has a wrong offset!");
static_assert(offsetof(ATslProjectile, ImpactSound) == 0x000418, "Member 'ATslProjectile::ImpactSound' has a wrong offset!");
static_assert(offsetof(ATslProjectile, AkComp) == 0x000420, "Member 'ATslProjectile::AkComp' has a wrong offset!");
static_assert(offsetof(ATslProjectile, ExplodeState) == 0x000430, "Member 'ATslProjectile::ExplodeState' has a wrong offset!");
static_assert(offsetof(ATslProjectile, ClientMeshRotation) == 0x000434, "Member 'ATslProjectile::ClientMeshRotation' has a wrong offset!");
static_assert(offsetof(ATslProjectile, ServerMeshRotation) == 0x000440, "Member 'ATslProjectile::ServerMeshRotation' has a wrong offset!");
static_assert(offsetof(ATslProjectile, VelocityStopStepDistance) == 0x00044C, "Member 'ATslProjectile::VelocityStopStepDistance' has a wrong offset!");
static_assert(offsetof(ATslProjectile, LastStepLocation) == 0x000450, "Member 'ATslProjectile::LastStepLocation' has a wrong offset!");
static_assert(offsetof(ATslProjectile, StepBuffer) == 0x00045C, "Member 'ATslProjectile::StepBuffer' has a wrong offset!");
static_assert(offsetof(ATslProjectile, FinalInterpSpeed) == 0x000460, "Member 'ATslProjectile::FinalInterpSpeed' has a wrong offset!");
static_assert(offsetof(ATslProjectile, bConstantInterpStep) == 0x000464, "Member 'ATslProjectile::bConstantInterpStep' has a wrong offset!");
static_assert(offsetof(ATslProjectile, VelocityCheckTimerTick) == 0x000468, "Member 'ATslProjectile::VelocityCheckTimerTick' has a wrong offset!");
static_assert(offsetof(ATslProjectile, ProjectileConfig) == 0x000470, "Member 'ATslProjectile::ProjectileConfig' has a wrong offset!");

// Class TslGame.TslProjectileMolotov
// 0x0050 (0x0520 - 0x04D0)
class ATslProjectileMolotov final : public ATslProjectile
{
public:
	EMolotovSimulationType                        MolotovSimulation;                                 // 0x04D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D1[0x7];                                      // 0x04D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATslDamageFieldContainer>   DamageFieldContainerTemplate;                      // 0x04D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ATslDamageFieldContainer>   DamageFieldContainerInWallTemplate;                // 0x04E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ATslDamageField>            DamageFieldTemplate;                               // 0x04E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ATslDamageField>            DamageFieldTemplateInWall;                         // 0x04F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ATslProjectileMolotov>      FragmentProjectileClass;                           // 0x04F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ImpactMaxCount;                                    // 0x0500(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_504[0x1C];                                     // 0x0504(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslProjectileMolotov">();
	}
	static class ATslProjectileMolotov* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslProjectileMolotov>();
	}
};
static_assert(alignof(ATslProjectileMolotov) == 0x000008, "Wrong alignment on ATslProjectileMolotov");
static_assert(sizeof(ATslProjectileMolotov) == 0x000520, "Wrong size on ATslProjectileMolotov");
static_assert(offsetof(ATslProjectileMolotov, MolotovSimulation) == 0x0004D0, "Member 'ATslProjectileMolotov::MolotovSimulation' has a wrong offset!");
static_assert(offsetof(ATslProjectileMolotov, DamageFieldContainerTemplate) == 0x0004D8, "Member 'ATslProjectileMolotov::DamageFieldContainerTemplate' has a wrong offset!");
static_assert(offsetof(ATslProjectileMolotov, DamageFieldContainerInWallTemplate) == 0x0004E0, "Member 'ATslProjectileMolotov::DamageFieldContainerInWallTemplate' has a wrong offset!");
static_assert(offsetof(ATslProjectileMolotov, DamageFieldTemplate) == 0x0004E8, "Member 'ATslProjectileMolotov::DamageFieldTemplate' has a wrong offset!");
static_assert(offsetof(ATslProjectileMolotov, DamageFieldTemplateInWall) == 0x0004F0, "Member 'ATslProjectileMolotov::DamageFieldTemplateInWall' has a wrong offset!");
static_assert(offsetof(ATslProjectileMolotov, FragmentProjectileClass) == 0x0004F8, "Member 'ATslProjectileMolotov::FragmentProjectileClass' has a wrong offset!");
static_assert(offsetof(ATslProjectileMolotov, ImpactMaxCount) == 0x000500, "Member 'ATslProjectileMolotov::ImpactMaxCount' has a wrong offset!");

// Class TslGame.ThingHolder
// 0x00A0 (0x0440 - 0x03A0)
class AThingHolder final : public AActor
{
public:
	uint8                                         Pad_3A0[0xA0];                                     // 0x03A0(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThingHolder">();
	}
	static class AThingHolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThingHolder>();
	}
};
static_assert(alignof(AThingHolder) == 0x000008, "Wrong alignment on AThingHolder");
static_assert(sizeof(AThingHolder) == 0x000440, "Wrong size on AThingHolder");

// Class TslGame.ThingSpot
// 0x0008 (0x03A8 - 0x03A0)
class AThingSpot final : public AActor
{
public:
	class UThingSpotComponent*                    SpotComponent;                                     // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThingSpot">();
	}
	static class AThingSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThingSpot>();
	}
};
static_assert(alignof(AThingSpot) == 0x000008, "Wrong alignment on AThingSpot");
static_assert(sizeof(AThingSpot) == 0x0003A8, "Wrong size on AThingSpot");
static_assert(offsetof(AThingSpot, SpotComponent) == 0x0003A0, "Member 'AThingSpot::SpotComponent' has a wrong offset!");

// Class TslGame.TslPlayerCameraManager
// 0x0020 (0x1A80 - 0x1A60)
class ATslPlayerCameraManager final : public APlayerCameraManager
{
public:
	uint8                                         Pad_1A60[0x20];                                    // 0x1A60(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslPlayerCameraManager">();
	}
	static class ATslPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslPlayerCameraManager>();
	}
};
static_assert(alignof(ATslPlayerCameraManager) == 0x000010, "Wrong alignment on ATslPlayerCameraManager");
static_assert(sizeof(ATslPlayerCameraManager) == 0x001A80, "Wrong size on ATslPlayerCameraManager");

// Class TslGame.ThingSpotComponent
// 0x0010 (0x0310 - 0x0300)
class UThingSpotComponent final : public USceneComponent
{
public:
	EThingSpotGroupType                           SpotGroupType;                                     // 0x0300(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_301[0x3];                                      // 0x0301(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              RandomRotatorRange;                                // 0x0304(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThingSpotComponent">();
	}
	static class UThingSpotComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThingSpotComponent>();
	}
};
static_assert(alignof(UThingSpotComponent) == 0x000008, "Wrong alignment on UThingSpotComponent");
static_assert(sizeof(UThingSpotComponent) == 0x000310, "Wrong size on UThingSpotComponent");
static_assert(offsetof(UThingSpotComponent, SpotGroupType) == 0x000300, "Member 'UThingSpotComponent::SpotGroupType' has a wrong offset!");
static_assert(offsetof(UThingSpotComponent, RandomRotatorRange) == 0x000304, "Member 'UThingSpotComponent::RandomRotatorRange' has a wrong offset!");

// Class TslGame.TslAccessoryComponent
// 0x0040 (0x0340 - 0x0300)
class UTslAccessoryComponent final : public USceneComponent
{
public:
	struct FTransform                             InitialTransformAttachmentScene;                   // 0x0300(0x0030)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_330[0x10];                                     // 0x0330(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitSetupComponent(bool bSimulatePhysics);
	void SetPhysicsSimulation(bool bSimulatePhysics);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslAccessoryComponent">();
	}
	static class UTslAccessoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslAccessoryComponent>();
	}
};
static_assert(alignof(UTslAccessoryComponent) == 0x000010, "Wrong alignment on UTslAccessoryComponent");
static_assert(sizeof(UTslAccessoryComponent) == 0x000340, "Wrong size on UTslAccessoryComponent");
static_assert(offsetof(UTslAccessoryComponent, InitialTransformAttachmentScene) == 0x000300, "Member 'UTslAccessoryComponent::InitialTransformAttachmentScene' has a wrong offset!");

// Class TslGame.TslParticle
// 0x0058 (0x03F8 - 0x03A0)
class ATslParticle : public AActor
{
public:
	bool                                          bAutoDestroyOnParticleFinish;                      // 0x03A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoPlaySound;                                    // 0x03A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A2[0x6];                                      // 0x03A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FParticleParameter>             DefaultParameters;                                 // 0x03A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EAttachParent                                 AttachParentType;                                  // 0x03B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B9[0x7];                                      // 0x03B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachSocketName;                                  // 0x03C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               AttachLocationRule;                                // 0x03C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               AttachRotationRule;                                // 0x03C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               AttachScaleRule;                                   // 0x03CA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3CB[0x5];                                      // 0x03CB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               ParticleSystem;                                    // 0x03D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           AkSound;                                           // 0x03D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E0[0x18];                                     // 0x03E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static float GetEmitterGlobalSpawnRateScale();

	void AttachToParent();
	void ForceSpawn(int32 emitterIndex, const struct FVector& InLocation);
	void OnParameterUpdated();
	void OnParticleCollide(class FName EventName, float EmitterTime, int32 ParticleTime, const struct FVector& Location, const struct FVector& Velocity, const struct FVector& Direction, const struct FVector& Normal, class FName BoneName, class UPhysicalMaterial* PhysMat);
	void OnParticleFinish(class UParticleSystemComponent* PSystem);
	void SetParticleParameter(const class FString& Name_0, float Value, bool bEnableRTPC);

	float GetParticleParamter(const class FString& Name_0, float DefaultValue) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslParticle">();
	}
	static class ATslParticle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslParticle>();
	}
};
static_assert(alignof(ATslParticle) == 0x000008, "Wrong alignment on ATslParticle");
static_assert(sizeof(ATslParticle) == 0x0003F8, "Wrong size on ATslParticle");
static_assert(offsetof(ATslParticle, bAutoDestroyOnParticleFinish) == 0x0003A0, "Member 'ATslParticle::bAutoDestroyOnParticleFinish' has a wrong offset!");
static_assert(offsetof(ATslParticle, bAutoPlaySound) == 0x0003A1, "Member 'ATslParticle::bAutoPlaySound' has a wrong offset!");
static_assert(offsetof(ATslParticle, DefaultParameters) == 0x0003A8, "Member 'ATslParticle::DefaultParameters' has a wrong offset!");
static_assert(offsetof(ATslParticle, AttachParentType) == 0x0003B8, "Member 'ATslParticle::AttachParentType' has a wrong offset!");
static_assert(offsetof(ATslParticle, AttachSocketName) == 0x0003C0, "Member 'ATslParticle::AttachSocketName' has a wrong offset!");
static_assert(offsetof(ATslParticle, AttachLocationRule) == 0x0003C8, "Member 'ATslParticle::AttachLocationRule' has a wrong offset!");
static_assert(offsetof(ATslParticle, AttachRotationRule) == 0x0003C9, "Member 'ATslParticle::AttachRotationRule' has a wrong offset!");
static_assert(offsetof(ATslParticle, AttachScaleRule) == 0x0003CA, "Member 'ATslParticle::AttachScaleRule' has a wrong offset!");
static_assert(offsetof(ATslParticle, ParticleSystem) == 0x0003D0, "Member 'ATslParticle::ParticleSystem' has a wrong offset!");
static_assert(offsetof(ATslParticle, AkSound) == 0x0003D8, "Member 'ATslParticle::AkSound' has a wrong offset!");

// Class TslGame.TslParticleEnvironment
// 0x0020 (0x0418 - 0x03F8)
class ATslParticleEnvironment final : public ATslParticle
{
public:
	uint8                                         Pad_3F8[0x10];                                     // 0x03F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoParticleActivateDistance;                      // 0x0408(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoPlayDistance;                                  // 0x040C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_410[0x8];                                      // 0x0410(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslParticleEnvironment">();
	}
	static class ATslParticleEnvironment* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslParticleEnvironment>();
	}
};
static_assert(alignof(ATslParticleEnvironment) == 0x000008, "Wrong alignment on ATslParticleEnvironment");
static_assert(sizeof(ATslParticleEnvironment) == 0x000418, "Wrong size on ATslParticleEnvironment");
static_assert(offsetof(ATslParticleEnvironment, AutoParticleActivateDistance) == 0x000408, "Member 'ATslParticleEnvironment::AutoParticleActivateDistance' has a wrong offset!");
static_assert(offsetof(ATslParticleEnvironment, AutoPlayDistance) == 0x00040C, "Member 'ATslParticleEnvironment::AutoPlayDistance' has a wrong offset!");

// Class TslGame.TslAchievement
// 0x0018 (0x03B8 - 0x03A0)
class ATslAchievement final : public AActor
{
public:
	uint8                                         Pad_3A0[0x18];                                     // 0x03A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslAchievement">();
	}
	static class ATslAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslAchievement>();
	}
};
static_assert(alignof(ATslAchievement) == 0x000008, "Wrong alignment on ATslAchievement");
static_assert(sizeof(ATslAchievement) == 0x0003B8, "Wrong size on ATslAchievement");

// Class TslGame.TslAIController
// 0x0020 (0x04B8 - 0x0498)
class ATslAIController final : public AAIController
{
public:
	class UBlackboardComponent*                   BlackboardComp;                                    // 0x0498(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBehaviorTreeComponent*                 BehaviorComp;                                      // 0x04A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A8[0x10];                                     // 0x04A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FindClosestEnemy();
	bool FindClosestEnemyWithLOS(class ATslCharacter* ExcludeEnemy);
	void ShootEnemy();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslAIController">();
	}
	static class ATslAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslAIController>();
	}
};
static_assert(alignof(ATslAIController) == 0x000008, "Wrong alignment on ATslAIController");
static_assert(sizeof(ATslAIController) == 0x0004B8, "Wrong size on ATslAIController");
static_assert(offsetof(ATslAIController, BlackboardComp) == 0x000498, "Member 'ATslAIController::BlackboardComp' has a wrong offset!");
static_assert(offsetof(ATslAIController, BehaviorComp) == 0x0004A0, "Member 'ATslAIController::BehaviorComp' has a wrong offset!");

// Class TslGame.TslWeapon_Projectile
// 0x0008 (0x0A00 - 0x09F8)
class ATslWeapon_Projectile final : public ATslWeapon_Gun
{
public:
	struct FProjectileWeaponData                  ProjectileConfig;                                  // 0x09F8(0x0008)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void ServerFireProjectile(const struct FVector& Origin, const struct FVector_NetQuantizeNormal& ShootDir);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslWeapon_Projectile">();
	}
	static class ATslWeapon_Projectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslWeapon_Projectile>();
	}
};
static_assert(alignof(ATslWeapon_Projectile) == 0x000008, "Wrong alignment on ATslWeapon_Projectile");
static_assert(sizeof(ATslWeapon_Projectile) == 0x000A00, "Wrong size on ATslWeapon_Projectile");
static_assert(offsetof(ATslWeapon_Projectile, ProjectileConfig) == 0x0009F8, "Member 'ATslWeapon_Projectile::ProjectileConfig' has a wrong offset!");

// Class TslGame.TslAircraftVehicle
// 0x0090 (0x0490 - 0x0400)
class ATslAircraftVehicle : public APawn
{
public:
	TArray<struct FAircraftParticle>              AircraftParticles;                                 // 0x0400(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class ATslParticle*>                   AttachedParticles;                                 // 0x0410(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x0420(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTslAircraftVehicleMovement*            MovementComponent;                                 // 0x0428(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USplineComponent*                       SplineComponent;                                   // 0x0430(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_438[0x48];                                     // 0x0438(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TotalFlyingTime;                                   // 0x0480(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_484[0xC];                                      // 0x0484(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslAircraftVehicle">();
	}
	static class ATslAircraftVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslAircraftVehicle>();
	}
};
static_assert(alignof(ATslAircraftVehicle) == 0x000008, "Wrong alignment on ATslAircraftVehicle");
static_assert(sizeof(ATslAircraftVehicle) == 0x000490, "Wrong size on ATslAircraftVehicle");
static_assert(offsetof(ATslAircraftVehicle, AircraftParticles) == 0x000400, "Member 'ATslAircraftVehicle::AircraftParticles' has a wrong offset!");
static_assert(offsetof(ATslAircraftVehicle, AttachedParticles) == 0x000410, "Member 'ATslAircraftVehicle::AttachedParticles' has a wrong offset!");
static_assert(offsetof(ATslAircraftVehicle, MeshComponent) == 0x000420, "Member 'ATslAircraftVehicle::MeshComponent' has a wrong offset!");
static_assert(offsetof(ATslAircraftVehicle, MovementComponent) == 0x000428, "Member 'ATslAircraftVehicle::MovementComponent' has a wrong offset!");
static_assert(offsetof(ATslAircraftVehicle, SplineComponent) == 0x000430, "Member 'ATslAircraftVehicle::SplineComponent' has a wrong offset!");
static_assert(offsetof(ATslAircraftVehicle, TotalFlyingTime) == 0x000480, "Member 'ATslAircraftVehicle::TotalFlyingTime' has a wrong offset!");

// Class TslGame.AircraftCarePackage
// 0x0048 (0x04D8 - 0x0490)
class AAircraftCarePackage final : public ATslAircraftVehicle
{
public:
	TSubclassOf<class UGeneralItemSpawner>        CarePackageItemSpawnerClass;                       // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ACarePackageItem>           CarePackageItemClass;                              // 0x0498(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FDropCarePackageTableData>      DropCarePackageTableData;                          // 0x04A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	class UGeneralItemSpawner*                    CarePackageItemSpawner;                            // 0x04B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B8[0x20];                                     // 0x04B8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsPlayInEditor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AircraftCarePackage">();
	}
	static class AAircraftCarePackage* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAircraftCarePackage>();
	}
};
static_assert(alignof(AAircraftCarePackage) == 0x000008, "Wrong alignment on AAircraftCarePackage");
static_assert(sizeof(AAircraftCarePackage) == 0x0004D8, "Wrong size on AAircraftCarePackage");
static_assert(offsetof(AAircraftCarePackage, CarePackageItemSpawnerClass) == 0x000490, "Member 'AAircraftCarePackage::CarePackageItemSpawnerClass' has a wrong offset!");
static_assert(offsetof(AAircraftCarePackage, CarePackageItemClass) == 0x000498, "Member 'AAircraftCarePackage::CarePackageItemClass' has a wrong offset!");
static_assert(offsetof(AAircraftCarePackage, DropCarePackageTableData) == 0x0004A0, "Member 'AAircraftCarePackage::DropCarePackageTableData' has a wrong offset!");
static_assert(offsetof(AAircraftCarePackage, CarePackageItemSpawner) == 0x0004B0, "Member 'AAircraftCarePackage::CarePackageItemSpawner' has a wrong offset!");

// Class TslGame.TransportAircraftVehicle
// 0x0078 (0x0508 - 0x0490)
class ATransportAircraftVehicle final : public ATslAircraftVehicle
{
public:
	uint8                                         Pad_490[0x28];                                     // 0x0490(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          RideSound;                                         // 0x04B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          LeaveSound;                                        // 0x04C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           AkSoundCom;                                        // 0x04C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTslVehicleSeatComponent*               VehicleSeatComponent;                              // 0x04D0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UParachuteItem>             ParachuteItem;                                     // 0x04D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractionComponent*                  InteractionComponent;                              // 0x04E0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsEnteredAtEjectionArea;                          // 0x04E8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4E9[0x3];                                      // 0x04E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EjectPredictionTime;                               // 0x04EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxEjectSpeed;                                     // 0x04F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4F4[0x14];                                     // 0x04F4(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AllowInteractBy(const class ATslCharacter* Character);
	void EjectAll();
	void EnterAtEjectionArea();
	void OnInteractBy(class ATslCharacter* Character);
	void OnLeave(class ATslCharacter* Rider, class UVehicleSeatInteractionComponent* Seat);
	void OnLocalPlayerLeave();
	void OnLocalPlayerRide();
	void OnRide(class ATslCharacter* Rider, class UVehicleSeatInteractionComponent* Seat);

	bool IsInEjectionArea() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TransportAircraftVehicle">();
	}
	static class ATransportAircraftVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATransportAircraftVehicle>();
	}
};
static_assert(alignof(ATransportAircraftVehicle) == 0x000008, "Wrong alignment on ATransportAircraftVehicle");
static_assert(sizeof(ATransportAircraftVehicle) == 0x000508, "Wrong size on ATransportAircraftVehicle");
static_assert(offsetof(ATransportAircraftVehicle, RideSound) == 0x0004B8, "Member 'ATransportAircraftVehicle::RideSound' has a wrong offset!");
static_assert(offsetof(ATransportAircraftVehicle, LeaveSound) == 0x0004C0, "Member 'ATransportAircraftVehicle::LeaveSound' has a wrong offset!");
static_assert(offsetof(ATransportAircraftVehicle, AkSoundCom) == 0x0004C8, "Member 'ATransportAircraftVehicle::AkSoundCom' has a wrong offset!");
static_assert(offsetof(ATransportAircraftVehicle, VehicleSeatComponent) == 0x0004D0, "Member 'ATransportAircraftVehicle::VehicleSeatComponent' has a wrong offset!");
static_assert(offsetof(ATransportAircraftVehicle, ParachuteItem) == 0x0004D8, "Member 'ATransportAircraftVehicle::ParachuteItem' has a wrong offset!");
static_assert(offsetof(ATransportAircraftVehicle, InteractionComponent) == 0x0004E0, "Member 'ATransportAircraftVehicle::InteractionComponent' has a wrong offset!");
static_assert(offsetof(ATransportAircraftVehicle, bIsEnteredAtEjectionArea) == 0x0004E8, "Member 'ATransportAircraftVehicle::bIsEnteredAtEjectionArea' has a wrong offset!");
static_assert(offsetof(ATransportAircraftVehicle, EjectPredictionTime) == 0x0004EC, "Member 'ATransportAircraftVehicle::EjectPredictionTime' has a wrong offset!");
static_assert(offsetof(ATransportAircraftVehicle, MaxEjectSpeed) == 0x0004F0, "Member 'ATransportAircraftVehicle::MaxEjectSpeed' has a wrong offset!");

// Class TslGame.TslWheeledVehicle
// 0x02C0 (0x06D0 - 0x0410)
class ATslWheeledVehicle : public AWheeledVehicle
{
public:
	uint8                                         Pad_410[0x10];                                     // 0x0410(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           TimerHandle_Horn;                                  // 0x0420(0x0008)(Protected, NativeAccessSpecifierProtected)
	float                                         LongHornStartingTime;                              // 0x0428(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrHornKeyPressedTime;                            // 0x042C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_430[0x4];                                      // 0x0430(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHornPlayInfo                          HornPlayInfo;                                      // 0x0434(0x0008)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_43C[0x4];                                      // 0x043C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHornSoundInfo                         HornSounds_Local;                                  // 0x0440(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FHornSoundInfo                         HornSounds_Remote;                                 // 0x0450(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_460[0x10];                                     // 0x0460(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       ActivationTrigger;                                 // 0x0470(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Health;                                            // 0x0478(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealthMax;                                         // 0x047C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Fuel;                                              // 0x0480(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FuelMax;                                           // 0x0484(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStabilizeActive;                                  // 0x0488(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_489[0x3];                                      // 0x0489(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AirControlPitchInput;                              // 0x048C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpeedKPH;                                          // 0x0490(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrottleInput;                                     // 0x0494(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RPM;                                               // 0x0498(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Brake;                                             // 0x049C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LatMax;                                            // 0x04A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LongSum;                                           // 0x04A4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaterDepthMax;                                     // 0x04A8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SurfaceMax;                                        // 0x04AC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SuspensionMax;                                     // 0x04B0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FlatTireCount;                                     // 0x04B4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDirtySpeedKPH : 1;                                // 0x04B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDirtyThrottleInput : 1;                           // 0x04B8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDirtyRPM : 1;                                     // 0x04B8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDirtyWaterDepthMax : 1;                           // 0x04B8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDirtyBrake : 1;                                   // 0x04B8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDetectedStartup : 1;                              // 0x04B8(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDetectedBraking : 1;                              // 0x04B8(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_4B9[0x7];                                      // 0x04B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 WheelsLatSlip;                                     // 0x04C0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 WheelsLongSlip;                                    // 0x04D0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 WheelsSuspensionOffset;                            // 0x04E0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UPhysicalMaterial*>              WheelsContactSurface;                              // 0x04F0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UPhysicalMaterial*>              TestWheelsContactSurface_prev;                     // 0x0500(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 WheelsSuspensionMaxDrop;                           // 0x0510(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<float>                                 WheelsSuspensionMaxRaise;                          // 0x0520(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          NullSound;                                         // 0x0530(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTslImpactSoundInfo                    ImpactSound;                                       // 0x0538(0x0060)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTslImpactSoundInfo                    LandingSound;                                      // 0x0598(0x0060)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          StartupSound;                                      // 0x05F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          BreakSound;                                        // 0x0600(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          StopSound;                                         // 0x0608(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          CharacterHitSound;                                 // 0x0610(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bWantsToBoosting : 1;                              // 0x0618(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_619[0x3];                                      // 0x0619(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TorqueMultiplierForBoosting;                       // 0x061C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_620[0x8];                                      // 0x0620(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTslVehicleHitComponent*                VehicleHitComponent;                               // 0x0628(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTslVehicleCommonComponent*             VehicleCommonComponent;                            // 0x0630(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTslVehicleSeatComponent*               VehicleSeatComponent;                              // 0x0638(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTslVehicleEffectComponent*             VehicleEffectComponent;                            // 0x0640(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTslVehicleSyncComponent*               VehicleSyncComponent;                              // 0x0648(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTslVehicleTempComponent*               VehicleTempComponent;                              // 0x0650(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTslPawnInputBindingComponent*          TslPawnInputBindingComponent;                      // 0x0658(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           AudioComEngine;                                    // 0x0660(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBuoyancyForceComponent*                BuoyancyForceComponent;                            // 0x0668(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SinkPoint;                                         // 0x0670(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ATslBuff>                   SinkBuffType;                                      // 0x0678(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_680[0x8];                                      // 0x0680(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBuffComponet*                          BuffComponent;                                     // 0x0688(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UActorComponent>>    ComponentsToDestroyOnDedicatedServer;              // 0x0690(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bProcessAutoEject;                                 // 0x06A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6A1[0x3];                                      // 0x06A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoEjectGroundDistance;                           // 0x06A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AutoEjectRoll;                                     // 0x06A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AutoEjectPitch;                                    // 0x06AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AutoEject_RiseRate;                                // 0x06B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AutoEject_FallRate;                                // 0x06B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6B8[0x4];                                      // 0x06B8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRunStabilizeOnEntry;                              // 0x06BC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6BD[0x3];                                      // 0x06BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StabilizeInitialTimer;                             // 0x06C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StablizeCurrentTimer;                              // 0x06C4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SteeringYawBias;                                   // 0x06C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6CC[0x4];                                      // 0x06CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivationTriggerBeginOverlap(class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& OverlapInfo);
	void ActivationTriggerEndOverlap(class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void BindCallbackToHUD(class ATslPlayerController* InController);
	void MulticastCharacterHitEffects(class ATslCharacter* CharacterHit, float HitDamage);
	void MulticastSetInstantHorn(const struct FHornPlayInfo& InHornPlayInfo);
	void OnBlockingWidgetOpened(class UWidget* Widget);
	void OnBreak();
	void OnCharacterHit(class ATslCharacter* HitCharacter, float HitDamage);
	void OnHornEnd();
	void OnHornKeyDown();
	void OnHornKeyUp();
	void OnPostDriverLeave();
	void OnPostDriverRide();
	void OnRep_SetHornPlayInfo();
	void OnRide(class ATslCharacter* Rider, class UVehicleSeatInteractionComponent* Seat);
	void OnVehicleEjected();
	void PlayHorn(bool bIsLocalPlay, EHornSoundType InHornSoundType);
	void PlayInstantHorn();
	void ServerSetBoosting(bool bNewBoosting);
	void ServerSetHorn(const struct FHornPlayInfo& InHornPlayInfo);
	void SetAirControlPitchInput(float InInput);
	void TickHorn(float DeltaSeconds);
	void UnBindCallbackToHUD(class ATslPlayerController* InController);
	void UpdateBasicInfoCaching();
	void UpdateWheelCaching();
	void UpdateWheelSound();

	float GetAirControlPitchInput() const;
	class UBuffComponet* GetBuffComponent() const;
	float GetCurrentWaterSurfaceZ() const;
	float GetSteeringInput() const;
	class UTslWheeledVehicleMovement* GetTslVehicleMovement() const;
	bool IsBoosting() const;
	bool IsEnabledOptimizeTick() const;
	bool IsInWaterVolume() const;
	bool IsStabilizeOverrideEnabled() const;
	bool IsStablizeOverrideActive() const;
	bool IsSunken() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslWheeledVehicle">();
	}
	static class ATslWheeledVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslWheeledVehicle>();
	}
};
static_assert(alignof(ATslWheeledVehicle) == 0x000008, "Wrong alignment on ATslWheeledVehicle");
static_assert(sizeof(ATslWheeledVehicle) == 0x0006D0, "Wrong size on ATslWheeledVehicle");
static_assert(offsetof(ATslWheeledVehicle, TimerHandle_Horn) == 0x000420, "Member 'ATslWheeledVehicle::TimerHandle_Horn' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, LongHornStartingTime) == 0x000428, "Member 'ATslWheeledVehicle::LongHornStartingTime' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, CurrHornKeyPressedTime) == 0x00042C, "Member 'ATslWheeledVehicle::CurrHornKeyPressedTime' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, HornPlayInfo) == 0x000434, "Member 'ATslWheeledVehicle::HornPlayInfo' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, HornSounds_Local) == 0x000440, "Member 'ATslWheeledVehicle::HornSounds_Local' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, HornSounds_Remote) == 0x000450, "Member 'ATslWheeledVehicle::HornSounds_Remote' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, ActivationTrigger) == 0x000470, "Member 'ATslWheeledVehicle::ActivationTrigger' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, Health) == 0x000478, "Member 'ATslWheeledVehicle::Health' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, HealthMax) == 0x00047C, "Member 'ATslWheeledVehicle::HealthMax' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, Fuel) == 0x000480, "Member 'ATslWheeledVehicle::Fuel' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, FuelMax) == 0x000484, "Member 'ATslWheeledVehicle::FuelMax' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, bStabilizeActive) == 0x000488, "Member 'ATslWheeledVehicle::bStabilizeActive' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, AirControlPitchInput) == 0x00048C, "Member 'ATslWheeledVehicle::AirControlPitchInput' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, SpeedKPH) == 0x000490, "Member 'ATslWheeledVehicle::SpeedKPH' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, ThrottleInput) == 0x000494, "Member 'ATslWheeledVehicle::ThrottleInput' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, RPM) == 0x000498, "Member 'ATslWheeledVehicle::RPM' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, Brake) == 0x00049C, "Member 'ATslWheeledVehicle::Brake' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, LatMax) == 0x0004A0, "Member 'ATslWheeledVehicle::LatMax' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, LongSum) == 0x0004A4, "Member 'ATslWheeledVehicle::LongSum' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, WaterDepthMax) == 0x0004A8, "Member 'ATslWheeledVehicle::WaterDepthMax' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, SurfaceMax) == 0x0004AC, "Member 'ATslWheeledVehicle::SurfaceMax' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, SuspensionMax) == 0x0004B0, "Member 'ATslWheeledVehicle::SuspensionMax' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, FlatTireCount) == 0x0004B4, "Member 'ATslWheeledVehicle::FlatTireCount' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, WheelsLatSlip) == 0x0004C0, "Member 'ATslWheeledVehicle::WheelsLatSlip' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, WheelsLongSlip) == 0x0004D0, "Member 'ATslWheeledVehicle::WheelsLongSlip' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, WheelsSuspensionOffset) == 0x0004E0, "Member 'ATslWheeledVehicle::WheelsSuspensionOffset' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, WheelsContactSurface) == 0x0004F0, "Member 'ATslWheeledVehicle::WheelsContactSurface' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, TestWheelsContactSurface_prev) == 0x000500, "Member 'ATslWheeledVehicle::TestWheelsContactSurface_prev' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, WheelsSuspensionMaxDrop) == 0x000510, "Member 'ATslWheeledVehicle::WheelsSuspensionMaxDrop' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, WheelsSuspensionMaxRaise) == 0x000520, "Member 'ATslWheeledVehicle::WheelsSuspensionMaxRaise' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, NullSound) == 0x000530, "Member 'ATslWheeledVehicle::NullSound' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, ImpactSound) == 0x000538, "Member 'ATslWheeledVehicle::ImpactSound' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, LandingSound) == 0x000598, "Member 'ATslWheeledVehicle::LandingSound' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, StartupSound) == 0x0005F8, "Member 'ATslWheeledVehicle::StartupSound' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, BreakSound) == 0x000600, "Member 'ATslWheeledVehicle::BreakSound' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, StopSound) == 0x000608, "Member 'ATslWheeledVehicle::StopSound' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, CharacterHitSound) == 0x000610, "Member 'ATslWheeledVehicle::CharacterHitSound' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, TorqueMultiplierForBoosting) == 0x00061C, "Member 'ATslWheeledVehicle::TorqueMultiplierForBoosting' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, VehicleHitComponent) == 0x000628, "Member 'ATslWheeledVehicle::VehicleHitComponent' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, VehicleCommonComponent) == 0x000630, "Member 'ATslWheeledVehicle::VehicleCommonComponent' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, VehicleSeatComponent) == 0x000638, "Member 'ATslWheeledVehicle::VehicleSeatComponent' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, VehicleEffectComponent) == 0x000640, "Member 'ATslWheeledVehicle::VehicleEffectComponent' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, VehicleSyncComponent) == 0x000648, "Member 'ATslWheeledVehicle::VehicleSyncComponent' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, VehicleTempComponent) == 0x000650, "Member 'ATslWheeledVehicle::VehicleTempComponent' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, TslPawnInputBindingComponent) == 0x000658, "Member 'ATslWheeledVehicle::TslPawnInputBindingComponent' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, AudioComEngine) == 0x000660, "Member 'ATslWheeledVehicle::AudioComEngine' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, BuoyancyForceComponent) == 0x000668, "Member 'ATslWheeledVehicle::BuoyancyForceComponent' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, SinkPoint) == 0x000670, "Member 'ATslWheeledVehicle::SinkPoint' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, SinkBuffType) == 0x000678, "Member 'ATslWheeledVehicle::SinkBuffType' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, BuffComponent) == 0x000688, "Member 'ATslWheeledVehicle::BuffComponent' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, ComponentsToDestroyOnDedicatedServer) == 0x000690, "Member 'ATslWheeledVehicle::ComponentsToDestroyOnDedicatedServer' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, bProcessAutoEject) == 0x0006A0, "Member 'ATslWheeledVehicle::bProcessAutoEject' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, AutoEjectGroundDistance) == 0x0006A4, "Member 'ATslWheeledVehicle::AutoEjectGroundDistance' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, AutoEjectRoll) == 0x0006A8, "Member 'ATslWheeledVehicle::AutoEjectRoll' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, AutoEjectPitch) == 0x0006AC, "Member 'ATslWheeledVehicle::AutoEjectPitch' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, AutoEject_RiseRate) == 0x0006B0, "Member 'ATslWheeledVehicle::AutoEject_RiseRate' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, AutoEject_FallRate) == 0x0006B4, "Member 'ATslWheeledVehicle::AutoEject_FallRate' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, bRunStabilizeOnEntry) == 0x0006BC, "Member 'ATslWheeledVehicle::bRunStabilizeOnEntry' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, StabilizeInitialTimer) == 0x0006C0, "Member 'ATslWheeledVehicle::StabilizeInitialTimer' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, StablizeCurrentTimer) == 0x0006C4, "Member 'ATslWheeledVehicle::StablizeCurrentTimer' has a wrong offset!");
static_assert(offsetof(ATslWheeledVehicle, SteeringYawBias) == 0x0006C8, "Member 'ATslWheeledVehicle::SteeringYawBias' has a wrong offset!");

// Class TslGame.TslFloatingVehicle
// 0x0098 (0x0498 - 0x0400)
class ATslFloatingVehicle : public APawn
{
public:
	uint8                                         Pad_400[0x10];                                     // 0x0400(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 MeshComponent;                                     // 0x0410(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBuoyancyForceComponent*                BuoyancyForceComponent;                            // 0x0418(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTslFloatingVehicleMovement*            MovementComponent;                                 // 0x0420(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTslVehicleHitComponent*                VehicleHitComponent;                               // 0x0428(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTslVehicleCommonComponent*             VehicleCommonComponent;                            // 0x0430(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTslVehicleSeatComponent*               VehicleSeatComponent;                              // 0x0438(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTslVehicleEffectComponent*             VehicleEffectComponent;                            // 0x0440(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTslVehicleSyncComponent*               VehicleSyncComponent;                              // 0x0448(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTslVehicleTempComponent*               VehicleTempComponent;                              // 0x0450(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTslPawnInputBindingComponent*          TslPawnInputBindingComponent;                      // 0x0458(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkComponent*                           AudioComEngine;                                    // 0x0460(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UActorComponent>>    ComponentsToDestroyOnDedicatedServer;              // 0x0468(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	class FName                                   VehicleEnginePoint;                                // 0x0478(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         VehicleEngineRadius;                               // 0x0480(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Health;                                            // 0x0484(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HealthMax;                                         // 0x0488(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Fuel;                                              // 0x048C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FuelMax;                                           // 0x0490(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_494[0x4];                                      // 0x0494(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetSteerYawAngle() const;
	struct FVector GetVehicleAcceleration() const;
	float GetVehicleEngineImmersionDepth() const;
	bool IsBoosting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslFloatingVehicle">();
	}
	static class ATslFloatingVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslFloatingVehicle>();
	}
};
static_assert(alignof(ATslFloatingVehicle) == 0x000008, "Wrong alignment on ATslFloatingVehicle");
static_assert(sizeof(ATslFloatingVehicle) == 0x000498, "Wrong size on ATslFloatingVehicle");
static_assert(offsetof(ATslFloatingVehicle, MeshComponent) == 0x000410, "Member 'ATslFloatingVehicle::MeshComponent' has a wrong offset!");
static_assert(offsetof(ATslFloatingVehicle, BuoyancyForceComponent) == 0x000418, "Member 'ATslFloatingVehicle::BuoyancyForceComponent' has a wrong offset!");
static_assert(offsetof(ATslFloatingVehicle, MovementComponent) == 0x000420, "Member 'ATslFloatingVehicle::MovementComponent' has a wrong offset!");
static_assert(offsetof(ATslFloatingVehicle, VehicleHitComponent) == 0x000428, "Member 'ATslFloatingVehicle::VehicleHitComponent' has a wrong offset!");
static_assert(offsetof(ATslFloatingVehicle, VehicleCommonComponent) == 0x000430, "Member 'ATslFloatingVehicle::VehicleCommonComponent' has a wrong offset!");
static_assert(offsetof(ATslFloatingVehicle, VehicleSeatComponent) == 0x000438, "Member 'ATslFloatingVehicle::VehicleSeatComponent' has a wrong offset!");
static_assert(offsetof(ATslFloatingVehicle, VehicleEffectComponent) == 0x000440, "Member 'ATslFloatingVehicle::VehicleEffectComponent' has a wrong offset!");
static_assert(offsetof(ATslFloatingVehicle, VehicleSyncComponent) == 0x000448, "Member 'ATslFloatingVehicle::VehicleSyncComponent' has a wrong offset!");
static_assert(offsetof(ATslFloatingVehicle, VehicleTempComponent) == 0x000450, "Member 'ATslFloatingVehicle::VehicleTempComponent' has a wrong offset!");
static_assert(offsetof(ATslFloatingVehicle, TslPawnInputBindingComponent) == 0x000458, "Member 'ATslFloatingVehicle::TslPawnInputBindingComponent' has a wrong offset!");
static_assert(offsetof(ATslFloatingVehicle, AudioComEngine) == 0x000460, "Member 'ATslFloatingVehicle::AudioComEngine' has a wrong offset!");
static_assert(offsetof(ATslFloatingVehicle, ComponentsToDestroyOnDedicatedServer) == 0x000468, "Member 'ATslFloatingVehicle::ComponentsToDestroyOnDedicatedServer' has a wrong offset!");
static_assert(offsetof(ATslFloatingVehicle, VehicleEnginePoint) == 0x000478, "Member 'ATslFloatingVehicle::VehicleEnginePoint' has a wrong offset!");
static_assert(offsetof(ATslFloatingVehicle, VehicleEngineRadius) == 0x000480, "Member 'ATslFloatingVehicle::VehicleEngineRadius' has a wrong offset!");
static_assert(offsetof(ATslFloatingVehicle, Health) == 0x000484, "Member 'ATslFloatingVehicle::Health' has a wrong offset!");
static_assert(offsetof(ATslFloatingVehicle, HealthMax) == 0x000488, "Member 'ATslFloatingVehicle::HealthMax' has a wrong offset!");
static_assert(offsetof(ATslFloatingVehicle, Fuel) == 0x00048C, "Member 'ATslFloatingVehicle::Fuel' has a wrong offset!");
static_assert(offsetof(ATslFloatingVehicle, FuelMax) == 0x000490, "Member 'ATslFloatingVehicle::FuelMax' has a wrong offset!");

// Class TslGame.TslReplayData
// 0x0000 (0x0028 - 0x0028)
class UTslReplayData final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslReplayData">();
	}
	static class UTslReplayData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslReplayData>();
	}
};
static_assert(alignof(UTslReplayData) == 0x000008, "Wrong alignment on UTslReplayData");
static_assert(sizeof(UTslReplayData) == 0x000028, "Wrong size on UTslReplayData");

// Class TslGame.TslWheeledVehicleMovement
// 0x0018 (0x0438 - 0x0420)
class UTslWheeledVehicleMovement final : public UWheeledVehicleMovementComponent4W
{
public:
	TArray<float>                                 WheelHealthPercentages;                            // 0x0420(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_430[0x8];                                      // 0x0430(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientPunctureTire(int32 WheelIndex);
	void OnBreak();
	void OnDriverLeave();
	void OnDriverRide();
	void ServerUpdateAdditionalState(int32 TargetGear);
	void SetSimulateVehicle(bool bSimulate);

	float GetBrakeInput() const;
	float GetHandbrakeInput() const;
	float GetSteeringInput() const;
	float GetSteeringInputClamped() const;
	float GetThrottleInput() const;
	struct FWheelContactData GetWheelContactData(int32 Index_0, float MinVelocity, float MinSkid, float MinSpin, float SuspOffsetForContact) const;
	class UPhysicalMaterial* GetWheelContactSurfaceMaterial(int32 Index_0) const;
	EWheelContactType GetWheelContactType(int32 Index_0, float MinVelocity, float MinSkid, float MinSpin, float SuspOffsetForContact) const;
	TArray<float> GetWheelHealthPercentages() const;
	float GetWheelRotationSpeed(int32 Index_0) const;
	float GetWheelSuspensionMaxDrop(int32 Index_0) const;
	float GetWheelSuspensionMaxRaise(int32 Index_0) const;
	float GetWheelWaterDepth(int32 Index_0) const;
	bool IsSimulatingVehicle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslWheeledVehicleMovement">();
	}
	static class UTslWheeledVehicleMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslWheeledVehicleMovement>();
	}
};
static_assert(alignof(UTslWheeledVehicleMovement) == 0x000008, "Wrong alignment on UTslWheeledVehicleMovement");
static_assert(sizeof(UTslWheeledVehicleMovement) == 0x000438, "Wrong size on UTslWheeledVehicleMovement");
static_assert(offsetof(UTslWheeledVehicleMovement, WheelHealthPercentages) == 0x000420, "Member 'UTslWheeledVehicleMovement::WheelHealthPercentages' has a wrong offset!");

// Class TslGame.TslFloatingVehicleMovement
// 0x0040 (0x01C0 - 0x0180)
class UTslFloatingVehicleMovement final : public UPawnMovementComponent
{
public:
	float                                         MaxAcceleration;                                   // 0x0180(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Acceleration;                                      // 0x0184(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StartAccelerationRate;                             // 0x0188(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StopAccelerationRate;                              // 0x018C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxRotationYawAngle;                               // 0x0190(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotationYawAngle;                                  // 0x0194(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotationYawRate;                                   // 0x0198(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_19C[0x4];                                      // 0x019C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DirectionalAccelerationCurve;                      // 0x01A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BoostModifier;                                     // 0x01A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsBoosting;                                       // 0x01AC(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1AD[0x3];                                      // 0x01AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForwardInput;                                      // 0x01B0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotationInput;                                     // 0x01B4(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B8[0x4];                                      // 0x01B8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitCharacterDuration;                              // 0x01BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnDriverLeave();
	void ServerUpdateInput(float InForwardInput, float InRotationInput, bool bInIsBoosting);

	float GetAcceleration() const;
	struct FVector GetCalculatedAcceleration() const;
	float GetMaxAcceleration() const;
	float GetMaxRotationYawAngle() const;
	float GetRotationYawAngle() const;
	bool IsBoosting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslFloatingVehicleMovement">();
	}
	static class UTslFloatingVehicleMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslFloatingVehicleMovement>();
	}
};
static_assert(alignof(UTslFloatingVehicleMovement) == 0x000008, "Wrong alignment on UTslFloatingVehicleMovement");
static_assert(sizeof(UTslFloatingVehicleMovement) == 0x0001C0, "Wrong size on UTslFloatingVehicleMovement");
static_assert(offsetof(UTslFloatingVehicleMovement, MaxAcceleration) == 0x000180, "Member 'UTslFloatingVehicleMovement::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(UTslFloatingVehicleMovement, Acceleration) == 0x000184, "Member 'UTslFloatingVehicleMovement::Acceleration' has a wrong offset!");
static_assert(offsetof(UTslFloatingVehicleMovement, StartAccelerationRate) == 0x000188, "Member 'UTslFloatingVehicleMovement::StartAccelerationRate' has a wrong offset!");
static_assert(offsetof(UTslFloatingVehicleMovement, StopAccelerationRate) == 0x00018C, "Member 'UTslFloatingVehicleMovement::StopAccelerationRate' has a wrong offset!");
static_assert(offsetof(UTslFloatingVehicleMovement, MaxRotationYawAngle) == 0x000190, "Member 'UTslFloatingVehicleMovement::MaxRotationYawAngle' has a wrong offset!");
static_assert(offsetof(UTslFloatingVehicleMovement, RotationYawAngle) == 0x000194, "Member 'UTslFloatingVehicleMovement::RotationYawAngle' has a wrong offset!");
static_assert(offsetof(UTslFloatingVehicleMovement, RotationYawRate) == 0x000198, "Member 'UTslFloatingVehicleMovement::RotationYawRate' has a wrong offset!");
static_assert(offsetof(UTslFloatingVehicleMovement, DirectionalAccelerationCurve) == 0x0001A0, "Member 'UTslFloatingVehicleMovement::DirectionalAccelerationCurve' has a wrong offset!");
static_assert(offsetof(UTslFloatingVehicleMovement, BoostModifier) == 0x0001A8, "Member 'UTslFloatingVehicleMovement::BoostModifier' has a wrong offset!");
static_assert(offsetof(UTslFloatingVehicleMovement, bIsBoosting) == 0x0001AC, "Member 'UTslFloatingVehicleMovement::bIsBoosting' has a wrong offset!");
static_assert(offsetof(UTslFloatingVehicleMovement, ForwardInput) == 0x0001B0, "Member 'UTslFloatingVehicleMovement::ForwardInput' has a wrong offset!");
static_assert(offsetof(UTslFloatingVehicleMovement, RotationInput) == 0x0001B4, "Member 'UTslFloatingVehicleMovement::RotationInput' has a wrong offset!");
static_assert(offsetof(UTslFloatingVehicleMovement, HitCharacterDuration) == 0x0001BC, "Member 'UTslFloatingVehicleMovement::HitCharacterDuration' has a wrong offset!");

// Class TslGame.TslCharacterMovement
// 0x0220 (0x0970 - 0x0750)
class UTslCharacterMovement final : public UCharacterMovementComponent
{
public:
	uint8                                         Pad_750[0x8];                                      // 0x0750(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxProneSpeed;                                     // 0x0758(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxGroggySpeed;                                    // 0x075C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpedHalfHeight;                                  // 0x0760(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedToJumpModifier;                               // 0x0764(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinJumpZVelocity;                                  // 0x0768(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxJumpZVelocity;                                  // 0x076C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandingJumpDecreaseModifier;                       // 0x0770(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoveryWalkSpeedRatePerSec;                       // 0x0774(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinWalkSpeedModifier;                              // 0x0778(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkSpeedModifierUnit;                             // 0x077C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinStandingJumpXYSpeed;                            // 0x0780(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedInWaterModifier;                              // 0x0784(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EVaultAnimType, class UVaultingData*>    VaultingDataMap;                                   // 0x0788(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         HeightFor200;                                      // 0x07D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HeightFor160;                                      // 0x07DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HeightFor120;                                      // 0x07E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HeightFor90;                                       // 0x07E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SizeForNarrow;                                     // 0x07E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SizeForSlide;                                      // 0x07EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityForMobile;                                 // 0x07F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlobalVaultScale;                                  // 0x07F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VaultCancelDTScalar;                               // 0x07F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinVelocityForStaticVaultCheck;                    // 0x07FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVaultingTask                          CurrentVaultingTask;                               // 0x0800(0x0040)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UVaultingData*                          CurrentVaultingData;                               // 0x0840(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         V_Timer_CP;                                        // 0x0848(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimMultiplierPreApex;                             // 0x084C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimMultiplierPostApex;                            // 0x0850(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVaulting_CP;                                    // 0x0854(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_855[0x3];                                      // 0x0855(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                CharacterRelLocation;                              // 0x0858(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LastVaultLocation;                                 // 0x0864(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                AveragedVelocity;                                  // 0x0870(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LastVaultTime;                                     // 0x087C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VaultCancelAnimSpeed;                              // 0x0880(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWantsToCancelVault;                               // 0x0884(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_885[0x3B];                                     // 0x0885(0x003B)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSwimAcceleration;                               // 0x08C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxZSpeedOutOfWaterModifier;                       // 0x08C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               MaxSwimmingRotationRate;                           // 0x08C8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               SwimmingRotationAcceleration;                      // 0x08D4(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         MaxZSpeedOutOfWaterModifierForStandingSwimming;    // 0x08E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WaveRidingModifier;                                // 0x08E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WaveRidingSmoothingFactor;                         // 0x08E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WaveRidingModifierUnderWater;                      // 0x08EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StayingUnderWaterDepthBand;                        // 0x08F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8F4[0x4];                                      // 0x08F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxUnderwaterSwimSpeed;                            // 0x08F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxUnderwaterSwimAcceleration;                     // 0x08FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BrakingDecelerationUnderwaterSwimming;             // 0x0900(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               MaxUnderwaterSwimmingRotationRate;                 // 0x0904(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               UnderwaterSwimmingRotationAcceleration;            // 0x0910(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         MinimumHighAltitude;                               // 0x091C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_920[0x4];                                      // 0x0920(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxFallLateralSpeedAtHighAltitude;                 // 0x0924(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TerminalVelocityAtHighAltitude;                    // 0x0928(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DecreaseTerminalVelocityAtHighAltitude;            // 0x092C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxFallAccelerationAtHighAltitude;                 // 0x0930(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FRotator                               FallRotationRateAtHighAltitude;                    // 0x0934(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         AirControlAtHighAltitude;                          // 0x0940(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AirControlBoostMultiplierAtHighAltitude;           // 0x0944(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AirControlBoostVelocityThresholdAtHighAltitude;    // 0x0948(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_94C[0x4];                                      // 0x094C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                FallingDamageType;                                 // 0x0950(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            EjectDamageCurve;                                  // 0x0958(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FallingDamageMinZCut;                              // 0x0960(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FallingDamageVDampingZ;                            // 0x0964(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FallingDamageFactor;                               // 0x0968(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_96C[0x4];                                      // 0x096C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartVaultingTask(const struct FVaultingTask& InVaultTask);

	bool EndCurrentTaskToFall() const;
	EVaultAnimType EvaluateVaultAnimType(int32 FirstRow, int32 ApexAdditiveStepCounter, float AverageCellCount, bool bForceVault, bool bForceClimb, float CharVelocity) const;
	EVaultAnimType GetCurrentVaultType() const;
	float GetGlobalVaultingSpeedMultiplier() const;
	class UVaultingData* GetVaultingDataFromAnim(EVaultAnimType InVaultType) const;
	float GetVTimer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslCharacterMovement">();
	}
	static class UTslCharacterMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslCharacterMovement>();
	}
};
static_assert(alignof(UTslCharacterMovement) == 0x000010, "Wrong alignment on UTslCharacterMovement");
static_assert(sizeof(UTslCharacterMovement) == 0x000970, "Wrong size on UTslCharacterMovement");
static_assert(offsetof(UTslCharacterMovement, MaxProneSpeed) == 0x000758, "Member 'UTslCharacterMovement::MaxProneSpeed' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, MaxGroggySpeed) == 0x00075C, "Member 'UTslCharacterMovement::MaxGroggySpeed' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, JumpedHalfHeight) == 0x000760, "Member 'UTslCharacterMovement::JumpedHalfHeight' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, SpeedToJumpModifier) == 0x000764, "Member 'UTslCharacterMovement::SpeedToJumpModifier' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, MinJumpZVelocity) == 0x000768, "Member 'UTslCharacterMovement::MinJumpZVelocity' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, MaxJumpZVelocity) == 0x00076C, "Member 'UTslCharacterMovement::MaxJumpZVelocity' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, LandingJumpDecreaseModifier) == 0x000770, "Member 'UTslCharacterMovement::LandingJumpDecreaseModifier' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, RecoveryWalkSpeedRatePerSec) == 0x000774, "Member 'UTslCharacterMovement::RecoveryWalkSpeedRatePerSec' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, MinWalkSpeedModifier) == 0x000778, "Member 'UTslCharacterMovement::MinWalkSpeedModifier' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, WalkSpeedModifierUnit) == 0x00077C, "Member 'UTslCharacterMovement::WalkSpeedModifierUnit' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, MinStandingJumpXYSpeed) == 0x000780, "Member 'UTslCharacterMovement::MinStandingJumpXYSpeed' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, SpeedInWaterModifier) == 0x000784, "Member 'UTslCharacterMovement::SpeedInWaterModifier' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, VaultingDataMap) == 0x000788, "Member 'UTslCharacterMovement::VaultingDataMap' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, HeightFor200) == 0x0007D8, "Member 'UTslCharacterMovement::HeightFor200' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, HeightFor160) == 0x0007DC, "Member 'UTslCharacterMovement::HeightFor160' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, HeightFor120) == 0x0007E0, "Member 'UTslCharacterMovement::HeightFor120' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, HeightFor90) == 0x0007E4, "Member 'UTslCharacterMovement::HeightFor90' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, SizeForNarrow) == 0x0007E8, "Member 'UTslCharacterMovement::SizeForNarrow' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, SizeForSlide) == 0x0007EC, "Member 'UTslCharacterMovement::SizeForSlide' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, VelocityForMobile) == 0x0007F0, "Member 'UTslCharacterMovement::VelocityForMobile' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, GlobalVaultScale) == 0x0007F4, "Member 'UTslCharacterMovement::GlobalVaultScale' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, VaultCancelDTScalar) == 0x0007F8, "Member 'UTslCharacterMovement::VaultCancelDTScalar' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, MinVelocityForStaticVaultCheck) == 0x0007FC, "Member 'UTslCharacterMovement::MinVelocityForStaticVaultCheck' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, CurrentVaultingTask) == 0x000800, "Member 'UTslCharacterMovement::CurrentVaultingTask' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, CurrentVaultingData) == 0x000840, "Member 'UTslCharacterMovement::CurrentVaultingData' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, V_Timer_CP) == 0x000848, "Member 'UTslCharacterMovement::V_Timer_CP' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, AnimMultiplierPreApex) == 0x00084C, "Member 'UTslCharacterMovement::AnimMultiplierPreApex' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, AnimMultiplierPostApex) == 0x000850, "Member 'UTslCharacterMovement::AnimMultiplierPostApex' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, bIsVaulting_CP) == 0x000854, "Member 'UTslCharacterMovement::bIsVaulting_CP' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, CharacterRelLocation) == 0x000858, "Member 'UTslCharacterMovement::CharacterRelLocation' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, LastVaultLocation) == 0x000864, "Member 'UTslCharacterMovement::LastVaultLocation' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, AveragedVelocity) == 0x000870, "Member 'UTslCharacterMovement::AveragedVelocity' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, LastVaultTime) == 0x00087C, "Member 'UTslCharacterMovement::LastVaultTime' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, VaultCancelAnimSpeed) == 0x000880, "Member 'UTslCharacterMovement::VaultCancelAnimSpeed' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, bWantsToCancelVault) == 0x000884, "Member 'UTslCharacterMovement::bWantsToCancelVault' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, MaxSwimAcceleration) == 0x0008C0, "Member 'UTslCharacterMovement::MaxSwimAcceleration' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, MaxZSpeedOutOfWaterModifier) == 0x0008C4, "Member 'UTslCharacterMovement::MaxZSpeedOutOfWaterModifier' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, MaxSwimmingRotationRate) == 0x0008C8, "Member 'UTslCharacterMovement::MaxSwimmingRotationRate' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, SwimmingRotationAcceleration) == 0x0008D4, "Member 'UTslCharacterMovement::SwimmingRotationAcceleration' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, MaxZSpeedOutOfWaterModifierForStandingSwimming) == 0x0008E0, "Member 'UTslCharacterMovement::MaxZSpeedOutOfWaterModifierForStandingSwimming' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, WaveRidingModifier) == 0x0008E4, "Member 'UTslCharacterMovement::WaveRidingModifier' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, WaveRidingSmoothingFactor) == 0x0008E8, "Member 'UTslCharacterMovement::WaveRidingSmoothingFactor' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, WaveRidingModifierUnderWater) == 0x0008EC, "Member 'UTslCharacterMovement::WaveRidingModifierUnderWater' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, StayingUnderWaterDepthBand) == 0x0008F0, "Member 'UTslCharacterMovement::StayingUnderWaterDepthBand' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, MaxUnderwaterSwimSpeed) == 0x0008F8, "Member 'UTslCharacterMovement::MaxUnderwaterSwimSpeed' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, MaxUnderwaterSwimAcceleration) == 0x0008FC, "Member 'UTslCharacterMovement::MaxUnderwaterSwimAcceleration' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, BrakingDecelerationUnderwaterSwimming) == 0x000900, "Member 'UTslCharacterMovement::BrakingDecelerationUnderwaterSwimming' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, MaxUnderwaterSwimmingRotationRate) == 0x000904, "Member 'UTslCharacterMovement::MaxUnderwaterSwimmingRotationRate' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, UnderwaterSwimmingRotationAcceleration) == 0x000910, "Member 'UTslCharacterMovement::UnderwaterSwimmingRotationAcceleration' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, MinimumHighAltitude) == 0x00091C, "Member 'UTslCharacterMovement::MinimumHighAltitude' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, MaxFallLateralSpeedAtHighAltitude) == 0x000924, "Member 'UTslCharacterMovement::MaxFallLateralSpeedAtHighAltitude' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, TerminalVelocityAtHighAltitude) == 0x000928, "Member 'UTslCharacterMovement::TerminalVelocityAtHighAltitude' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, DecreaseTerminalVelocityAtHighAltitude) == 0x00092C, "Member 'UTslCharacterMovement::DecreaseTerminalVelocityAtHighAltitude' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, MaxFallAccelerationAtHighAltitude) == 0x000930, "Member 'UTslCharacterMovement::MaxFallAccelerationAtHighAltitude' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, FallRotationRateAtHighAltitude) == 0x000934, "Member 'UTslCharacterMovement::FallRotationRateAtHighAltitude' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, AirControlAtHighAltitude) == 0x000940, "Member 'UTslCharacterMovement::AirControlAtHighAltitude' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, AirControlBoostMultiplierAtHighAltitude) == 0x000944, "Member 'UTslCharacterMovement::AirControlBoostMultiplierAtHighAltitude' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, AirControlBoostVelocityThresholdAtHighAltitude) == 0x000948, "Member 'UTslCharacterMovement::AirControlBoostVelocityThresholdAtHighAltitude' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, FallingDamageType) == 0x000950, "Member 'UTslCharacterMovement::FallingDamageType' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, EjectDamageCurve) == 0x000958, "Member 'UTslCharacterMovement::EjectDamageCurve' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, FallingDamageMinZCut) == 0x000960, "Member 'UTslCharacterMovement::FallingDamageMinZCut' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, FallingDamageVDampingZ) == 0x000964, "Member 'UTslCharacterMovement::FallingDamageVDampingZ' has a wrong offset!");
static_assert(offsetof(UTslCharacterMovement, FallingDamageFactor) == 0x000968, "Member 'UTslCharacterMovement::FallingDamageFactor' has a wrong offset!");

// Class TslGame.TslVehicleWheel
// 0x0100 (0x0200 - 0x0100)
class UTslVehicleWheel : public UVehicleWheel
{
public:
	float                                         Health;                                            // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealthMax;                                         // 0x0104(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TireBoneName;                                      // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LongSlipSkidThreshold;                             // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LateralSlipSkidThreshold;                          // 0x0114(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpringCompressionLandingThreshold;                 // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bManualSuspensionSoundControl;                     // 0x011C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11D[0x3];                                      // 0x011D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WheelEffectOffset;                                 // 0x0120(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTslWheelEffectType*                    RollEffect;                                        // 0x0130(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTslWheelEffectType*                    SkidAccelEffect;                                   // 0x0138(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTslWheelEffectType*                    SkidEffect;                                        // 0x0140(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ATslParticle>               PuncturedParticleClass;                            // 0x0148(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ATslParticle>               PuncturedSparkParticleClass;                       // 0x0150(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         slipThresholdForPunkSpark;                         // 0x0158(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          LandingSound;                                      // 0x0160(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyForceOnPuncture;                             // 0x0168(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_169[0x3];                                      // 0x0169(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PunctureForce;                                     // 0x016C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PunctureVelocityScalar;                            // 0x0170(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_174[0xC];                                      // 0x0174(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class ATslParticle*                           TslParticleRoll;                                   // 0x0180(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATslParticle*                           TslParticleSkid;                                   // 0x0188(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATslParticle*                           TslParticleAccelSkid;                              // 0x0190(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATslParticle*                           TslParticlePunctureSpark;                          // 0x0198(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A0[0x8];                                      // 0x01A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkComponent*                           AudioCom;                                          // 0x01A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinZVelocityForSuspensionSound;                    // 0x01B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B4[0x3C];                                     // 0x01B4(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TotalSpeedKmPerHour;                               // 0x01F0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Slip;                                              // 0x01F4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          UseRoll;                                           // 0x01F8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          UseSkid;                                           // 0x01F9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          UseAccelSkid;                                      // 0x01FA(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasLastStatus;                                    // 0x01FB(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1FC[0x4];                                      // 0x01FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslVehicleWheel">();
	}
	static class UTslVehicleWheel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslVehicleWheel>();
	}
};
static_assert(alignof(UTslVehicleWheel) == 0x000008, "Wrong alignment on UTslVehicleWheel");
static_assert(sizeof(UTslVehicleWheel) == 0x000200, "Wrong size on UTslVehicleWheel");
static_assert(offsetof(UTslVehicleWheel, Health) == 0x000100, "Member 'UTslVehicleWheel::Health' has a wrong offset!");
static_assert(offsetof(UTslVehicleWheel, HealthMax) == 0x000104, "Member 'UTslVehicleWheel::HealthMax' has a wrong offset!");
static_assert(offsetof(UTslVehicleWheel, TireBoneName) == 0x000108, "Member 'UTslVehicleWheel::TireBoneName' has a wrong offset!");
static_assert(offsetof(UTslVehicleWheel, LongSlipSkidThreshold) == 0x000110, "Member 'UTslVehicleWheel::LongSlipSkidThreshold' has a wrong offset!");
static_assert(offsetof(UTslVehicleWheel, LateralSlipSkidThreshold) == 0x000114, "Member 'UTslVehicleWheel::LateralSlipSkidThreshold' has a wrong offset!");
static_assert(offsetof(UTslVehicleWheel, SpringCompressionLandingThreshold) == 0x000118, "Member 'UTslVehicleWheel::SpringCompressionLandingThreshold' has a wrong offset!");
static_assert(offsetof(UTslVehicleWheel, bManualSuspensionSoundControl) == 0x00011C, "Member 'UTslVehicleWheel::bManualSuspensionSoundControl' has a wrong offset!");
static_assert(offsetof(UTslVehicleWheel, WheelEffectOffset) == 0x000120, "Member 'UTslVehicleWheel::WheelEffectOffset' has a wrong offset!");
static_assert(offsetof(UTslVehicleWheel, RollEffect) == 0x000130, "Member 'UTslVehicleWheel::RollEffect' has a wrong offset!");
static_assert(offsetof(UTslVehicleWheel, SkidAccelEffect) == 0x000138, "Member 'UTslVehicleWheel::SkidAccelEffect' has a wrong offset!");
static_assert(offsetof(UTslVehicleWheel, SkidEffect) == 0x000140, "Member 'UTslVehicleWheel::SkidEffect' has a wrong offset!");
static_assert(offsetof(UTslVehicleWheel, PuncturedParticleClass) == 0x000148, "Member 'UTslVehicleWheel::PuncturedParticleClass' has a wrong offset!");
static_assert(offsetof(UTslVehicleWheel, PuncturedSparkParticleClass) == 0x000150, "Member 'UTslVehicleWheel::PuncturedSparkParticleClass' has a wrong offset!");
static_assert(offsetof(UTslVehicleWheel, slipThresholdForPunkSpark) == 0x000158, "Member 'UTslVehicleWheel::slipThresholdForPunkSpark' has a wrong offset!");
static_assert(offsetof(UTslVehicleWheel, LandingSound) == 0x000160, "Member 'UTslVehicleWheel::LandingSound' has a wrong offset!");
static_assert(offsetof(UTslVehicleWheel, bApplyForceOnPuncture) == 0x000168, "Member 'UTslVehicleWheel::bApplyForceOnPuncture' has a wrong offset!");
static_assert(offsetof(UTslVehicleWheel, PunctureForce) == 0x00016C, "Member 'UTslVehicleWheel::PunctureForce' has a wrong offset!");
static_assert(offsetof(UTslVehicleWheel, PunctureVelocityScalar) == 0x000170, "Member 'UTslVehicleWheel::PunctureVelocityScalar' has a wrong offset!");
static_assert(offsetof(UTslVehicleWheel, TslParticleRoll) == 0x000180, "Member 'UTslVehicleWheel::TslParticleRoll' has a wrong offset!");
static_assert(offsetof(UTslVehicleWheel, TslParticleSkid) == 0x000188, "Member 'UTslVehicleWheel::TslParticleSkid' has a wrong offset!");
static_assert(offsetof(UTslVehicleWheel, TslParticleAccelSkid) == 0x000190, "Member 'UTslVehicleWheel::TslParticleAccelSkid' has a wrong offset!");
static_assert(offsetof(UTslVehicleWheel, TslParticlePunctureSpark) == 0x000198, "Member 'UTslVehicleWheel::TslParticlePunctureSpark' has a wrong offset!");
static_assert(offsetof(UTslVehicleWheel, AudioCom) == 0x0001A8, "Member 'UTslVehicleWheel::AudioCom' has a wrong offset!");
static_assert(offsetof(UTslVehicleWheel, MinZVelocityForSuspensionSound) == 0x0001B0, "Member 'UTslVehicleWheel::MinZVelocityForSuspensionSound' has a wrong offset!");
static_assert(offsetof(UTslVehicleWheel, TotalSpeedKmPerHour) == 0x0001F0, "Member 'UTslVehicleWheel::TotalSpeedKmPerHour' has a wrong offset!");
static_assert(offsetof(UTslVehicleWheel, Slip) == 0x0001F4, "Member 'UTslVehicleWheel::Slip' has a wrong offset!");
static_assert(offsetof(UTslVehicleWheel, UseRoll) == 0x0001F8, "Member 'UTslVehicleWheel::UseRoll' has a wrong offset!");
static_assert(offsetof(UTslVehicleWheel, UseSkid) == 0x0001F9, "Member 'UTslVehicleWheel::UseSkid' has a wrong offset!");
static_assert(offsetof(UTslVehicleWheel, UseAccelSkid) == 0x0001FA, "Member 'UTslVehicleWheel::UseAccelSkid' has a wrong offset!");
static_assert(offsetof(UTslVehicleWheel, bHasLastStatus) == 0x0001FB, "Member 'UTslVehicleWheel::bHasLastStatus' has a wrong offset!");

// Class TslGame.TslAnimInstance
// 0x0898 (0x0D30 - 0x0498)
class UTslAnimInstance final : public UAnimInstance
{
public:
	UMulticastDelegateProperty_                   WeaponFire;                                        // 0x0498(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   WeaponFireCycle;                                   // 0x04A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   EquipPrimary;                                      // 0x04B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   EquipSecondary;                                    // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   EqupiSidearm;                                      // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   EquipMelee;                                        // 0x04E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   EquipThrown;                                       // 0x04F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   UnEquipPrimary;                                    // 0x0508(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   UnEquipSecondary;                                  // 0x0518(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   UnEqupiSidearm;                                    // 0x0528(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   UnEquipMelee;                                      // 0x0538(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   UnEquipThrown;                                     // 0x0548(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ToggleFireMode;                                    // 0x0558(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ReloadTactical;                                    // 0x0568(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ReloadCharge;                                      // 0x0578(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ReloadByOneStart;                                  // 0x0588(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ReloadByOneStop;                                   // 0x0598(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ReloadByOneSingle;                                 // 0x05A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   EquipThrownGrenade;                                // 0x05B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   EquipThrownMolotov;                                // 0x05C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   EquipThrownOther;                                  // 0x05D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ThrowGrenadeReady;                                 // 0x05E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ThrowGrenadeCooking;                               // 0x05F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ThrowGrenadeStart;                                 // 0x0608(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ThrowMolotovReady;                                 // 0x0618(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ThrowMolotovCooking;                               // 0x0628(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ThrowMolotovStart;                                 // 0x0638(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ThrowLow;                                          // 0x0648(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ThrowHigh;                                         // 0x0658(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ThrowPrepare;                                      // 0x0668(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ThrowCooking;                                      // 0x0678(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ThrowStart;                                        // 0x0688(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ThrowDrop;                                         // 0x0698(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   LandHeavy;                                         // 0x06A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   LandExtreme;                                       // 0x06B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ReloadCancel;                                      // 0x06C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   CharacterPickup;                                   // 0x06D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   UnarmedAttack;                                     // 0x06E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   PowerupUsed;                                       // 0x06F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ChangeCharacterAppearance;                         // 0x0708(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnCastCancel;                                      // 0x0718(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnCastFinish;                                      // 0x0728(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_738[0x8];                                      // 0x0738(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ATslCharacter*                          CharacterReference;                                // 0x0740(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimPawnState                                PreEvalPawnState;                                  // 0x0748(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_749[0x3];                                      // 0x0749(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocomotionSpeed_CP;                                // 0x074C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionSpeed2D_CP;                              // 0x0750(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMoving_CP;                                      // 0x0754(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_755[0x3];                                      // 0x0755(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocomotionDirection_CP;                            // 0x0758(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocomotionJumpDirection_CP;                        // 0x075C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanYaw_CP;                                        // 0x0760(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LastAbsoluteDirection_CP;                          // 0x0764(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ControlRotation_CP;                                // 0x0770(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ControlRotationLastMovement_CP;                    // 0x077C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EAnimStance                                   Stance_CP;                                         // 0x0788(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSprintingFast_CP;                               // 0x0789(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78A[0x2];                                      // 0x078A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponGripType_CP;                                 // 0x078C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintAlpha_CP;                                    // 0x0790(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintValue_CP;                                    // 0x0794(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalQuickThrowHigh_CP;                           // 0x0798(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_799[0x3];                                      // 0x0799(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocalThrowModeSwitchAlpha_CP;                      // 0x079C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsJumping_CP;                                     // 0x07A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJumpForward_CP;                                   // 0x07A1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSwimming_CP;                                    // 0x07A2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUnderWater_CP;                                  // 0x07A3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDBNO_CP;                                        // 0x07A4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimStance                                   DBNOEntryStance;                                   // 0x07A5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReviving_CP;                                    // 0x07A6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUpperbody_CP;                                   // 0x07A7(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTransitioning_CP;                               // 0x07A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A9[0x3];                                      // 0x07A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayerID_CP;                                       // 0x07AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AirCraftIDAnim_CP;                                 // 0x07B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEquippingPistol_CP;                             // 0x07B4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B5[0x3];                                      // 0x07B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           PistolEquipMontageRefCP;                           // 0x07B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFlying_CP;                                      // 0x07C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLocalPlayer;                                    // 0x07C1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C2[0x2];                                      // 0x07C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocalPlayerAlpha;                                  // 0x07C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPunching_CP;                                    // 0x07C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C9[0x3];                                      // 0x07C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PunchingAlpha_CP;                                  // 0x07CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimWeaponType                               Weapon_CP;                                         // 0x07D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsArmedWithGun_CP;                                // 0x07D1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsArmedWithThrown_CP;                             // 0x07D2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPreparingThrow_CP;                              // 0x07D3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowableAdditionalAimYaw_CP;                      // 0x07D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CurrentRecoilMontage_CP;                           // 0x07D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace1D*                          GripBlendSpace_CP;                                 // 0x07E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        GripBlendSpaceLH_CP;                               // 0x07E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LHGripIndex_CP;                                    // 0x07F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsReloading_CP;                                   // 0x07F4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7F5[0x3];                                      // 0x07F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HandWeaponOffset_CP;                               // 0x07F8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_804[0xC];                                      // 0x0804(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             WeaponInertia_CP;                                  // 0x0810(0x0030)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ReloadAlpha_CP;                                    // 0x0840(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HandWeaponOffsetAlpha_CP;                          // 0x0844(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinalRecoilAlpha_CP;                               // 0x0848(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84C[0x4];                                      // 0x084C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBlendSpaceBase*                        WeaponLocomotionBlendspace_CP;                     // 0x0850(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        WeaponLocomotionBlendspace_Pistol;                 // 0x0858(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        WeaponLocomotionBlendspace_SMG;                    // 0x0860(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        WeaponLocomotionBlendspace_Rifle;                  // 0x0868(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        WeaponLocomotionBlendspace_Sniper;                 // 0x0870(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        WeaponLocomotionBlendspace_Pistol_FPP;             // 0x0878(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        WeaponLocomotionBlendspace_SMG_FPP;                // 0x0880(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        WeaponLocomotionBlendspace_Rifle_FPP;              // 0x0888(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        WeaponLocomotionBlendspace_Sniper_FPP;             // 0x0890(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponInertiaX_Scalar_CP;                          // 0x0898(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponInertiaY_Scalar_CP;                          // 0x089C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponInertiaX_Clamp_CP;                           // 0x08A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponInertiaY_Clamp_CP;                           // 0x08A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponInertia_InerpSpeed_CP;                       // 0x08A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponInertiaX_Scalar_ADS_CP;                      // 0x08AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponInertiaY_Scalar_ADS_CP;                      // 0x08B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponInertiaX_Clamp_ADS_CP;                       // 0x08B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponInertiaY_Clamp_ADS_CP;                       // 0x08B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponInertia_InerpSpeed_ADS_CP;                   // 0x08BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponInertia_InerpSpeed_YawScalar_CP;             // 0x08C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponInertia_YawToRollScalar_CP;                  // 0x08C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponInertia_YawToRollScalar_ADS_CP;              // 0x08C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponInertiaRoll_Clamp_ADS_CP;                    // 0x08CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponInertiaRoll_Clamp_CP;                        // 0x08D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponInertia_Yaw_CP;                              // 0x08D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponInertia_Pitch_CP;                            // 0x08D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponInertia_Roll_CP;                             // 0x08DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintWeaponLoweringAlpha_CP;                      // 0x08E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilRollValue_CP;                                // 0x08E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilTimer_CP;                                    // 0x08E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilRollRand_CP;                                 // 0x08EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilTimerScale_CP;                               // 0x08F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8F4[0x4];                                      // 0x08F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RecoilRollCurve_CP;                                // 0x08F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponStabilityAlpha_CP;                           // 0x0900(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponStabilityRefSpeed_CP;                        // 0x0904(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAiming_CP;                                      // 0x0908(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsScoping_CP;                                     // 0x0909(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90A[0x2];                                      // 0x090A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponAimState_CP;                                 // 0x090C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintAlphaModifier_CP;                            // 0x0910(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAimingBackward_CP;                              // 0x0914(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_915[0x3];                                      // 0x0915(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Yaw_CP;                                            // 0x0918(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationYaw_CP;                                    // 0x091C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pitch_CP;                                          // 0x0920(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredPitch_CP;                                   // 0x0924(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AimDirectionCardinal_CP;                           // 0x0928(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_929[0x3];                                      // 0x0929(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               AORot_CP;                                          // 0x092C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               AORotBackwards_CP;                                 // 0x0938(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SwimmingPitch_CP;                                  // 0x0944(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponCollisionAlpha_CP;                           // 0x0948(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeaponObstructedHigh_CP;                          // 0x094C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWasFalling_CP;                                    // 0x094D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94E[0x2];                                      // 0x094E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FallingAlpha_CP;                                   // 0x0950(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FallingMap2D;                                      // 0x0954(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              FallingMapZ;                                       // 0x095C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bForceFall_CP;                                     // 0x0964(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_965[0x3];                                      // 0x0965(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           MontageFallingRifle_CP;                            // 0x0968(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageFallingUnarmed_CP;                          // 0x0970(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandingAlpha_CP;                                   // 0x0978(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalForceProne_CP;                               // 0x097C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_97D[0x3];                                      // 0x097D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpHeight_CP;                                     // 0x0980(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallHeight_CP;                                     // 0x0984(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                JumpStartLocation_CP;                              // 0x0988(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                LandPredictionVector_CP;                           // 0x0994(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LeanLeftAlpha_CP;                                  // 0x09A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanRightAlpha_CP;                                 // 0x09A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanTwoSideAlpha_CP;                               // 0x09A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanInterpSpeed_CP;                                // 0x09AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeanInterpSpeedCollisionClamp_CP;                  // 0x09B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLinearLeanInterp;                              // 0x09B4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFreefalling_CP;                                 // 0x09B5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsParachuting_CP;                                 // 0x09B6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9B7[0x1];                                      // 0x09B7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FreefallX_CP;                                      // 0x09B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreefallY_CP;                                      // 0x09BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeFallAlpha_CP;                                  // 0x09C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsParachuteLanding_CP;                            // 0x09C4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsParachuteMoving_CP;                             // 0x09C5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C6[0x2];                                      // 0x09C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Freefall_Yaw_CP;                                   // 0x09C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Freefall_Pitch_CP;                                 // 0x09CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFreelooking_CP;                                 // 0x09D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMeleeAttacking_CP;                              // 0x09D1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalForceRotationHipLeft_CP;                     // 0x09D2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalForceRotationHipRight_CP;                    // 0x09D3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocalForceRotationAimed_CP;                       // 0x09D4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D5[0x3];                                      // 0x09D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationPlayrateAimed_CP;                          // 0x09D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationPlayrateAimedAdditiveSpine_CP;             // 0x09DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LastRotation_CP;                                   // 0x09E0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Freelook_Body_CP;                                  // 0x09EC(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Freelook_Delta_CP;                                 // 0x09F8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         IdleIndex_CP;                                      // 0x0A04(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastIdleIndex_CP;                                  // 0x0A08(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleTimer_CP;                                      // 0x0A0C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleTriggerRandom;                                 // 0x0A10(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleTriggerTimeMin_CP;                             // 0x0A14(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IdleTriggerTimeVariation_CP;                       // 0x0A18(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1C[0x4];                                      // 0x0A1C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SlotPrimary_CP;                                    // 0x0A20(0x0030)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             SlotSecondary_CP;                                  // 0x0A50(0x0030)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             SlotMelee_CP;                                      // 0x0A80(0x0030)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             SlotThrown_CP;                                     // 0x0AB0(0x0030)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                SlotPrimary_Offset_CP;                             // 0x0AE0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                SlotSecondary_Offset_CP;                           // 0x0AEC(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AnimDynamicsStandAlpha_CP;                         // 0x0AF8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDynamicsStandSprintAlpha_CP;                   // 0x0AFC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDynamicsCrouchAlpha_CP;                        // 0x0B00(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimDynamicsProneAlpha_CP;                         // 0x0B04(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EFCoat_CP;                                         // 0x0B08(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bLocalFPP_CP;                                      // 0x0B14(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B15[0x3];                                      // 0x0B15(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocalFPPAlpha_CP;                                  // 0x0B18(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalFPPAlphaVehicleAimAO_CP;                      // 0x0B1C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInAircraft_CP;                                  // 0x0B20(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDriver_CP;                                      // 0x0B21(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSitting_CP;                                     // 0x0B22(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInVehicle_CP;                                   // 0x0B23(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalSteerInput_CP;                                // 0x0B24(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalSteerInputMoto_CP;                            // 0x0B28(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalStopMoto_CP;                                  // 0x0B2C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalThrottleInput_CP;                             // 0x0B30(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               GasThighRot_CP;                                    // 0x0B34(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               GasAnkleRot_CP;                                    // 0x0B40(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4C[0x4];                                      // 0x0B4C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             GasKneeTransformX_CP;                              // 0x0B50(0x0030)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LocalBrakeInput_CP;                                // 0x0B80(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B84[0xC];                                      // 0x0B84(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BrakeKneeTransform_CP;                             // 0x0B90(0x0030)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               BrakeAnkleRot_CP;                                  // 0x0BC0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         BackwardAOAlpha_CP;                                // 0x0BCC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimBlendAlpha_CP;                                  // 0x0BD0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasContact_CP;                                    // 0x0BD4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD5[0x3];                                      // 0x0BD5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GroundContactMoto_CP;                              // 0x0BD8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirControlPitchInput_CP;                           // 0x0BDC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             DriverIK_CP;                                       // 0x0BE0(0x0030)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PassengerIKAlpha_CP;                               // 0x0C10(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DriverSpineLocWS_CP;                               // 0x0C14(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EVehicleAnimType                              VehicleSeatType_CP;                                // 0x0C20(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMotoHasDriver_CP;                                 // 0x0C21(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVaultCanceled;                                    // 0x0C22(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVaulting_CP;                                    // 0x0C23(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VaultTimer_CP;                                     // 0x0C24(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VaultTimerLast_CP;                                 // 0x0C28(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVaultAnimType                                LocalVaultType_CP;                                 // 0x0C2C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2D[0x3];                                      // 0x0C2D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      VaultAnimSequence_CP;                              // 0x0C30(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VaultAnimLength_CP;                                // 0x0C38(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C3C[0x4];                                      // 0x0C3C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            VaultCurve_CP;                                     // 0x0C40(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VaultBlendInTime_CP;                               // 0x0C48(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VaultBlendOutTime_CP;                              // 0x0C4C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndVaultToFall_CP;                                // 0x0C50(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C51[0x3];                                      // 0x0C51(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VaultBlendOutProgressTime_CP;                      // 0x0C54(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VaultBlendOutExactTime_CP;                         // 0x0C58(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECastAnim                                     CurrentCastAnim_CP;                                // 0x0C5C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActiveRagdoll_CP;                               // 0x0C5D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C5E[0x2];                                      // 0x0C5E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponIKLH_CP;                                     // 0x0C60(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponIKRH_CP;                                     // 0x0C64(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MontageIKLH_CP;                                    // 0x0C68(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MontageIKRH_CP;                                    // 0x0C6C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IgnoreWeaponTransform_CP;                          // 0x0C70(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PickupIKAlpha_CP;                                  // 0x0C74(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetIKRH_CP;                                     // 0x0C78(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetIKLH_CP;                                     // 0x0C7C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceLegsFromAnim_CP;                              // 0x0C80(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C84[0x4];                                      // 0x0C84(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ATslWeapon_Gun*                         LastGunCache_CP;                                   // 0x0C88(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATslWheeledVehicle*                     CachedWheeledVehicle_CP;                           // 0x0C90(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATslFloatingVehicle*                    CachedFloatingVehicle_CP;                          // 0x0C98(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        PassengerAimBS_CP;                                 // 0x0CA0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        PassengerTransitionOut_CP;                         // 0x0CA8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        PassengerTransitionIn_CP;                          // 0x0CB0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      PassengerIdle_CP;                                  // 0x0CB8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            CurveAimState_CP;                                  // 0x0CC0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC8[0x8];                                      // 0x0CC8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsLOD1;                                           // 0x0CD0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLOD2;                                           // 0x0CD1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsWearingCoat;                                    // 0x0CD2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD3[0x9];                                      // 0x0CD3(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsParentalControl;                                // 0x0CDC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CDD[0x3];                                      // 0x0CDD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           MontageMeleeAttack1;                               // 0x0CE0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageMeleeAttack2;                               // 0x0CE8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageMeleeAttack3;                               // 0x0CF0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontagePunchingAttack1;                            // 0x0CF8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontagePunchingAttack2;                            // 0x0D00(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontagePunchingAttack3;                            // 0x0D08(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FPPSprintAnimScalar;                               // 0x0D10(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FPP_PrimaryAndSecondaryItemOffset;                 // 0x0D14(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PunchingAlphaOneTarget_CP;                         // 0x0D20(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PunchingAlphaInterpSpeed;                          // 0x0D24(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintWeaponLoweringScalar_CP;                     // 0x0D28(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowStateSwitchInterpSpeed;                       // 0x0D2C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CacheCharacterReference(class ATslCharacter* InCharacter);
	void EvaluateAimOffsets();
	void EvaluateAimStates();
	void EvaluateAnimDynamics();
	void EvaluateCasting();
	void EvaluateCharacterStates();
	void EvaluateCoatExternalForce();
	void EvaluateFallingAndLanding();
	void EvaluateFreefallAndParachute();
	void EvaluateFreelook();
	void EvaluateIdle();
	void EvaluateItemOffsets();
	void EvaluateJumpCamera();
	void EvaluateJumping();
	void EvaluateLeaning();
	void EvaluateLocalPawnStates();
	void EvaluateMeleeAttack();
	void EvaluatePawnStates();
	void EvaluateRecoilRoll();
	void EvaluateRotations();
	void EvaluateSwimming();
	void EvaluateVaulting();
	void EvaluateVehicle();
	void EvaluateWeaponCollision();
	void EvaluateWeaponInertia();
	void EvaluateWeaponStability();
	void EvaluateWeaponStates();
	void HandleADSSocketOffset();
	void HandleAnimCurves();
	void HandleSpeedAndDirection_CP();
	void OnHitReaction(EAnimWeaponType WeaponType, class FName BoneName, const struct FVector& Direction);
	void PreEvaluatePawnState();
	void ProcessCodePaths();
	void RandomizeIdleIndex_CP(bool ExludeLastIndex);
	void ResetIdle();
	void ResetRecoilRoll();
	void SetJumpStartLocation(const struct FVector& NewLocation, float DefaultFallHeight);
	void SetLandPredictionVector(const struct FVector& newLandVector);
	void SetWeaponStatesEvaluationCooldown(float Time);

	float FindPositionFromDistanceCurve(const float& Distance, class UAnimSequenceBase* InAnimSequence) const;
	uint8 HandleCardinalDirection90(float InDirection) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslAnimInstance">();
	}
	static class UTslAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslAnimInstance>();
	}
};
static_assert(alignof(UTslAnimInstance) == 0x000010, "Wrong alignment on UTslAnimInstance");
static_assert(sizeof(UTslAnimInstance) == 0x000D30, "Wrong size on UTslAnimInstance");
static_assert(offsetof(UTslAnimInstance, WeaponFire) == 0x000498, "Member 'UTslAnimInstance::WeaponFire' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponFireCycle) == 0x0004A8, "Member 'UTslAnimInstance::WeaponFireCycle' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, EquipPrimary) == 0x0004B8, "Member 'UTslAnimInstance::EquipPrimary' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, EquipSecondary) == 0x0004C8, "Member 'UTslAnimInstance::EquipSecondary' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, EqupiSidearm) == 0x0004D8, "Member 'UTslAnimInstance::EqupiSidearm' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, EquipMelee) == 0x0004E8, "Member 'UTslAnimInstance::EquipMelee' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, EquipThrown) == 0x0004F8, "Member 'UTslAnimInstance::EquipThrown' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, UnEquipPrimary) == 0x000508, "Member 'UTslAnimInstance::UnEquipPrimary' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, UnEquipSecondary) == 0x000518, "Member 'UTslAnimInstance::UnEquipSecondary' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, UnEqupiSidearm) == 0x000528, "Member 'UTslAnimInstance::UnEqupiSidearm' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, UnEquipMelee) == 0x000538, "Member 'UTslAnimInstance::UnEquipMelee' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, UnEquipThrown) == 0x000548, "Member 'UTslAnimInstance::UnEquipThrown' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, ToggleFireMode) == 0x000558, "Member 'UTslAnimInstance::ToggleFireMode' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, ReloadTactical) == 0x000568, "Member 'UTslAnimInstance::ReloadTactical' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, ReloadCharge) == 0x000578, "Member 'UTslAnimInstance::ReloadCharge' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, ReloadByOneStart) == 0x000588, "Member 'UTslAnimInstance::ReloadByOneStart' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, ReloadByOneStop) == 0x000598, "Member 'UTslAnimInstance::ReloadByOneStop' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, ReloadByOneSingle) == 0x0005A8, "Member 'UTslAnimInstance::ReloadByOneSingle' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, EquipThrownGrenade) == 0x0005B8, "Member 'UTslAnimInstance::EquipThrownGrenade' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, EquipThrownMolotov) == 0x0005C8, "Member 'UTslAnimInstance::EquipThrownMolotov' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, EquipThrownOther) == 0x0005D8, "Member 'UTslAnimInstance::EquipThrownOther' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, ThrowGrenadeReady) == 0x0005E8, "Member 'UTslAnimInstance::ThrowGrenadeReady' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, ThrowGrenadeCooking) == 0x0005F8, "Member 'UTslAnimInstance::ThrowGrenadeCooking' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, ThrowGrenadeStart) == 0x000608, "Member 'UTslAnimInstance::ThrowGrenadeStart' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, ThrowMolotovReady) == 0x000618, "Member 'UTslAnimInstance::ThrowMolotovReady' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, ThrowMolotovCooking) == 0x000628, "Member 'UTslAnimInstance::ThrowMolotovCooking' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, ThrowMolotovStart) == 0x000638, "Member 'UTslAnimInstance::ThrowMolotovStart' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, ThrowLow) == 0x000648, "Member 'UTslAnimInstance::ThrowLow' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, ThrowHigh) == 0x000658, "Member 'UTslAnimInstance::ThrowHigh' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, ThrowPrepare) == 0x000668, "Member 'UTslAnimInstance::ThrowPrepare' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, ThrowCooking) == 0x000678, "Member 'UTslAnimInstance::ThrowCooking' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, ThrowStart) == 0x000688, "Member 'UTslAnimInstance::ThrowStart' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, ThrowDrop) == 0x000698, "Member 'UTslAnimInstance::ThrowDrop' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, LandHeavy) == 0x0006A8, "Member 'UTslAnimInstance::LandHeavy' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, LandExtreme) == 0x0006B8, "Member 'UTslAnimInstance::LandExtreme' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, ReloadCancel) == 0x0006C8, "Member 'UTslAnimInstance::ReloadCancel' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, CharacterPickup) == 0x0006D8, "Member 'UTslAnimInstance::CharacterPickup' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, UnarmedAttack) == 0x0006E8, "Member 'UTslAnimInstance::UnarmedAttack' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, PowerupUsed) == 0x0006F8, "Member 'UTslAnimInstance::PowerupUsed' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, ChangeCharacterAppearance) == 0x000708, "Member 'UTslAnimInstance::ChangeCharacterAppearance' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, OnCastCancel) == 0x000718, "Member 'UTslAnimInstance::OnCastCancel' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, OnCastFinish) == 0x000728, "Member 'UTslAnimInstance::OnCastFinish' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, CharacterReference) == 0x000740, "Member 'UTslAnimInstance::CharacterReference' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, PreEvalPawnState) == 0x000748, "Member 'UTslAnimInstance::PreEvalPawnState' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, LocomotionSpeed_CP) == 0x00074C, "Member 'UTslAnimInstance::LocomotionSpeed_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, LocomotionSpeed2D_CP) == 0x000750, "Member 'UTslAnimInstance::LocomotionSpeed2D_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsMoving_CP) == 0x000754, "Member 'UTslAnimInstance::bIsMoving_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, LocomotionDirection_CP) == 0x000758, "Member 'UTslAnimInstance::LocomotionDirection_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, LocomotionJumpDirection_CP) == 0x00075C, "Member 'UTslAnimInstance::LocomotionJumpDirection_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, LeanYaw_CP) == 0x000760, "Member 'UTslAnimInstance::LeanYaw_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, LastAbsoluteDirection_CP) == 0x000764, "Member 'UTslAnimInstance::LastAbsoluteDirection_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, ControlRotation_CP) == 0x000770, "Member 'UTslAnimInstance::ControlRotation_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, ControlRotationLastMovement_CP) == 0x00077C, "Member 'UTslAnimInstance::ControlRotationLastMovement_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, Stance_CP) == 0x000788, "Member 'UTslAnimInstance::Stance_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsSprintingFast_CP) == 0x000789, "Member 'UTslAnimInstance::bIsSprintingFast_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponGripType_CP) == 0x00078C, "Member 'UTslAnimInstance::WeaponGripType_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, SprintAlpha_CP) == 0x000790, "Member 'UTslAnimInstance::SprintAlpha_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, SprintValue_CP) == 0x000794, "Member 'UTslAnimInstance::SprintValue_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bLocalQuickThrowHigh_CP) == 0x000798, "Member 'UTslAnimInstance::bLocalQuickThrowHigh_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, LocalThrowModeSwitchAlpha_CP) == 0x00079C, "Member 'UTslAnimInstance::LocalThrowModeSwitchAlpha_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsJumping_CP) == 0x0007A0, "Member 'UTslAnimInstance::bIsJumping_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bJumpForward_CP) == 0x0007A1, "Member 'UTslAnimInstance::bJumpForward_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsSwimming_CP) == 0x0007A2, "Member 'UTslAnimInstance::bIsSwimming_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsUnderWater_CP) == 0x0007A3, "Member 'UTslAnimInstance::bIsUnderWater_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsDBNO_CP) == 0x0007A4, "Member 'UTslAnimInstance::bIsDBNO_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, DBNOEntryStance) == 0x0007A5, "Member 'UTslAnimInstance::DBNOEntryStance' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsReviving_CP) == 0x0007A6, "Member 'UTslAnimInstance::bIsReviving_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsUpperbody_CP) == 0x0007A7, "Member 'UTslAnimInstance::bIsUpperbody_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsTransitioning_CP) == 0x0007A8, "Member 'UTslAnimInstance::bIsTransitioning_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, PlayerID_CP) == 0x0007AC, "Member 'UTslAnimInstance::PlayerID_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, AirCraftIDAnim_CP) == 0x0007B0, "Member 'UTslAnimInstance::AirCraftIDAnim_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsEquippingPistol_CP) == 0x0007B4, "Member 'UTslAnimInstance::bIsEquippingPistol_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, PistolEquipMontageRefCP) == 0x0007B8, "Member 'UTslAnimInstance::PistolEquipMontageRefCP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsFlying_CP) == 0x0007C0, "Member 'UTslAnimInstance::bIsFlying_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsLocalPlayer) == 0x0007C1, "Member 'UTslAnimInstance::bIsLocalPlayer' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, LocalPlayerAlpha) == 0x0007C4, "Member 'UTslAnimInstance::LocalPlayerAlpha' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsPunching_CP) == 0x0007C8, "Member 'UTslAnimInstance::bIsPunching_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, PunchingAlpha_CP) == 0x0007CC, "Member 'UTslAnimInstance::PunchingAlpha_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, Weapon_CP) == 0x0007D0, "Member 'UTslAnimInstance::Weapon_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsArmedWithGun_CP) == 0x0007D1, "Member 'UTslAnimInstance::bIsArmedWithGun_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsArmedWithThrown_CP) == 0x0007D2, "Member 'UTslAnimInstance::bIsArmedWithThrown_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsPreparingThrow_CP) == 0x0007D3, "Member 'UTslAnimInstance::bIsPreparingThrow_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, ThrowableAdditionalAimYaw_CP) == 0x0007D4, "Member 'UTslAnimInstance::ThrowableAdditionalAimYaw_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, CurrentRecoilMontage_CP) == 0x0007D8, "Member 'UTslAnimInstance::CurrentRecoilMontage_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, GripBlendSpace_CP) == 0x0007E0, "Member 'UTslAnimInstance::GripBlendSpace_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, GripBlendSpaceLH_CP) == 0x0007E8, "Member 'UTslAnimInstance::GripBlendSpaceLH_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, LHGripIndex_CP) == 0x0007F0, "Member 'UTslAnimInstance::LHGripIndex_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsReloading_CP) == 0x0007F4, "Member 'UTslAnimInstance::bIsReloading_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, HandWeaponOffset_CP) == 0x0007F8, "Member 'UTslAnimInstance::HandWeaponOffset_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponInertia_CP) == 0x000810, "Member 'UTslAnimInstance::WeaponInertia_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, ReloadAlpha_CP) == 0x000840, "Member 'UTslAnimInstance::ReloadAlpha_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, HandWeaponOffsetAlpha_CP) == 0x000844, "Member 'UTslAnimInstance::HandWeaponOffsetAlpha_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, FinalRecoilAlpha_CP) == 0x000848, "Member 'UTslAnimInstance::FinalRecoilAlpha_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponLocomotionBlendspace_CP) == 0x000850, "Member 'UTslAnimInstance::WeaponLocomotionBlendspace_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponLocomotionBlendspace_Pistol) == 0x000858, "Member 'UTslAnimInstance::WeaponLocomotionBlendspace_Pistol' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponLocomotionBlendspace_SMG) == 0x000860, "Member 'UTslAnimInstance::WeaponLocomotionBlendspace_SMG' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponLocomotionBlendspace_Rifle) == 0x000868, "Member 'UTslAnimInstance::WeaponLocomotionBlendspace_Rifle' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponLocomotionBlendspace_Sniper) == 0x000870, "Member 'UTslAnimInstance::WeaponLocomotionBlendspace_Sniper' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponLocomotionBlendspace_Pistol_FPP) == 0x000878, "Member 'UTslAnimInstance::WeaponLocomotionBlendspace_Pistol_FPP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponLocomotionBlendspace_SMG_FPP) == 0x000880, "Member 'UTslAnimInstance::WeaponLocomotionBlendspace_SMG_FPP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponLocomotionBlendspace_Rifle_FPP) == 0x000888, "Member 'UTslAnimInstance::WeaponLocomotionBlendspace_Rifle_FPP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponLocomotionBlendspace_Sniper_FPP) == 0x000890, "Member 'UTslAnimInstance::WeaponLocomotionBlendspace_Sniper_FPP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponInertiaX_Scalar_CP) == 0x000898, "Member 'UTslAnimInstance::WeaponInertiaX_Scalar_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponInertiaY_Scalar_CP) == 0x00089C, "Member 'UTslAnimInstance::WeaponInertiaY_Scalar_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponInertiaX_Clamp_CP) == 0x0008A0, "Member 'UTslAnimInstance::WeaponInertiaX_Clamp_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponInertiaY_Clamp_CP) == 0x0008A4, "Member 'UTslAnimInstance::WeaponInertiaY_Clamp_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponInertia_InerpSpeed_CP) == 0x0008A8, "Member 'UTslAnimInstance::WeaponInertia_InerpSpeed_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponInertiaX_Scalar_ADS_CP) == 0x0008AC, "Member 'UTslAnimInstance::WeaponInertiaX_Scalar_ADS_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponInertiaY_Scalar_ADS_CP) == 0x0008B0, "Member 'UTslAnimInstance::WeaponInertiaY_Scalar_ADS_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponInertiaX_Clamp_ADS_CP) == 0x0008B4, "Member 'UTslAnimInstance::WeaponInertiaX_Clamp_ADS_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponInertiaY_Clamp_ADS_CP) == 0x0008B8, "Member 'UTslAnimInstance::WeaponInertiaY_Clamp_ADS_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponInertia_InerpSpeed_ADS_CP) == 0x0008BC, "Member 'UTslAnimInstance::WeaponInertia_InerpSpeed_ADS_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponInertia_InerpSpeed_YawScalar_CP) == 0x0008C0, "Member 'UTslAnimInstance::WeaponInertia_InerpSpeed_YawScalar_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponInertia_YawToRollScalar_CP) == 0x0008C4, "Member 'UTslAnimInstance::WeaponInertia_YawToRollScalar_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponInertia_YawToRollScalar_ADS_CP) == 0x0008C8, "Member 'UTslAnimInstance::WeaponInertia_YawToRollScalar_ADS_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponInertiaRoll_Clamp_ADS_CP) == 0x0008CC, "Member 'UTslAnimInstance::WeaponInertiaRoll_Clamp_ADS_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponInertiaRoll_Clamp_CP) == 0x0008D0, "Member 'UTslAnimInstance::WeaponInertiaRoll_Clamp_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponInertia_Yaw_CP) == 0x0008D4, "Member 'UTslAnimInstance::WeaponInertia_Yaw_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponInertia_Pitch_CP) == 0x0008D8, "Member 'UTslAnimInstance::WeaponInertia_Pitch_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponInertia_Roll_CP) == 0x0008DC, "Member 'UTslAnimInstance::WeaponInertia_Roll_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, SprintWeaponLoweringAlpha_CP) == 0x0008E0, "Member 'UTslAnimInstance::SprintWeaponLoweringAlpha_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, RecoilRollValue_CP) == 0x0008E4, "Member 'UTslAnimInstance::RecoilRollValue_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, RecoilTimer_CP) == 0x0008E8, "Member 'UTslAnimInstance::RecoilTimer_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, RecoilRollRand_CP) == 0x0008EC, "Member 'UTslAnimInstance::RecoilRollRand_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, RecoilTimerScale_CP) == 0x0008F0, "Member 'UTslAnimInstance::RecoilTimerScale_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, RecoilRollCurve_CP) == 0x0008F8, "Member 'UTslAnimInstance::RecoilRollCurve_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponStabilityAlpha_CP) == 0x000900, "Member 'UTslAnimInstance::WeaponStabilityAlpha_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponStabilityRefSpeed_CP) == 0x000904, "Member 'UTslAnimInstance::WeaponStabilityRefSpeed_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsAiming_CP) == 0x000908, "Member 'UTslAnimInstance::bIsAiming_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsScoping_CP) == 0x000909, "Member 'UTslAnimInstance::bIsScoping_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponAimState_CP) == 0x00090C, "Member 'UTslAnimInstance::WeaponAimState_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, SprintAlphaModifier_CP) == 0x000910, "Member 'UTslAnimInstance::SprintAlphaModifier_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsAimingBackward_CP) == 0x000914, "Member 'UTslAnimInstance::bIsAimingBackward_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, Yaw_CP) == 0x000918, "Member 'UTslAnimInstance::Yaw_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, RotationYaw_CP) == 0x00091C, "Member 'UTslAnimInstance::RotationYaw_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, Pitch_CP) == 0x000920, "Member 'UTslAnimInstance::Pitch_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, DesiredPitch_CP) == 0x000924, "Member 'UTslAnimInstance::DesiredPitch_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, AimDirectionCardinal_CP) == 0x000928, "Member 'UTslAnimInstance::AimDirectionCardinal_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, AORot_CP) == 0x00092C, "Member 'UTslAnimInstance::AORot_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, AORotBackwards_CP) == 0x000938, "Member 'UTslAnimInstance::AORotBackwards_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, SwimmingPitch_CP) == 0x000944, "Member 'UTslAnimInstance::SwimmingPitch_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponCollisionAlpha_CP) == 0x000948, "Member 'UTslAnimInstance::WeaponCollisionAlpha_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bWeaponObstructedHigh_CP) == 0x00094C, "Member 'UTslAnimInstance::bWeaponObstructedHigh_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bWasFalling_CP) == 0x00094D, "Member 'UTslAnimInstance::bWasFalling_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, FallingAlpha_CP) == 0x000950, "Member 'UTslAnimInstance::FallingAlpha_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, FallingMap2D) == 0x000954, "Member 'UTslAnimInstance::FallingMap2D' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, FallingMapZ) == 0x00095C, "Member 'UTslAnimInstance::FallingMapZ' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bForceFall_CP) == 0x000964, "Member 'UTslAnimInstance::bForceFall_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, MontageFallingRifle_CP) == 0x000968, "Member 'UTslAnimInstance::MontageFallingRifle_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, MontageFallingUnarmed_CP) == 0x000970, "Member 'UTslAnimInstance::MontageFallingUnarmed_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, LandingAlpha_CP) == 0x000978, "Member 'UTslAnimInstance::LandingAlpha_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bLocalForceProne_CP) == 0x00097C, "Member 'UTslAnimInstance::bLocalForceProne_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, JumpHeight_CP) == 0x000980, "Member 'UTslAnimInstance::JumpHeight_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, FallHeight_CP) == 0x000984, "Member 'UTslAnimInstance::FallHeight_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, JumpStartLocation_CP) == 0x000988, "Member 'UTslAnimInstance::JumpStartLocation_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, LandPredictionVector_CP) == 0x000994, "Member 'UTslAnimInstance::LandPredictionVector_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, LeanLeftAlpha_CP) == 0x0009A0, "Member 'UTslAnimInstance::LeanLeftAlpha_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, LeanRightAlpha_CP) == 0x0009A4, "Member 'UTslAnimInstance::LeanRightAlpha_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, LeanTwoSideAlpha_CP) == 0x0009A8, "Member 'UTslAnimInstance::LeanTwoSideAlpha_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, LeanInterpSpeed_CP) == 0x0009AC, "Member 'UTslAnimInstance::LeanInterpSpeed_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, LeanInterpSpeedCollisionClamp_CP) == 0x0009B0, "Member 'UTslAnimInstance::LeanInterpSpeedCollisionClamp_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bUseLinearLeanInterp) == 0x0009B4, "Member 'UTslAnimInstance::bUseLinearLeanInterp' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsFreefalling_CP) == 0x0009B5, "Member 'UTslAnimInstance::bIsFreefalling_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsParachuting_CP) == 0x0009B6, "Member 'UTslAnimInstance::bIsParachuting_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, FreefallX_CP) == 0x0009B8, "Member 'UTslAnimInstance::FreefallX_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, FreefallY_CP) == 0x0009BC, "Member 'UTslAnimInstance::FreefallY_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, FreeFallAlpha_CP) == 0x0009C0, "Member 'UTslAnimInstance::FreeFallAlpha_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsParachuteLanding_CP) == 0x0009C4, "Member 'UTslAnimInstance::bIsParachuteLanding_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsParachuteMoving_CP) == 0x0009C5, "Member 'UTslAnimInstance::bIsParachuteMoving_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, Freefall_Yaw_CP) == 0x0009C8, "Member 'UTslAnimInstance::Freefall_Yaw_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, Freefall_Pitch_CP) == 0x0009CC, "Member 'UTslAnimInstance::Freefall_Pitch_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsFreelooking_CP) == 0x0009D0, "Member 'UTslAnimInstance::bIsFreelooking_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsMeleeAttacking_CP) == 0x0009D1, "Member 'UTslAnimInstance::bIsMeleeAttacking_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bLocalForceRotationHipLeft_CP) == 0x0009D2, "Member 'UTslAnimInstance::bLocalForceRotationHipLeft_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bLocalForceRotationHipRight_CP) == 0x0009D3, "Member 'UTslAnimInstance::bLocalForceRotationHipRight_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bLocalForceRotationAimed_CP) == 0x0009D4, "Member 'UTslAnimInstance::bLocalForceRotationAimed_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, RotationPlayrateAimed_CP) == 0x0009D8, "Member 'UTslAnimInstance::RotationPlayrateAimed_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, RotationPlayrateAimedAdditiveSpine_CP) == 0x0009DC, "Member 'UTslAnimInstance::RotationPlayrateAimedAdditiveSpine_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, LastRotation_CP) == 0x0009E0, "Member 'UTslAnimInstance::LastRotation_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, Freelook_Body_CP) == 0x0009EC, "Member 'UTslAnimInstance::Freelook_Body_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, Freelook_Delta_CP) == 0x0009F8, "Member 'UTslAnimInstance::Freelook_Delta_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, IdleIndex_CP) == 0x000A04, "Member 'UTslAnimInstance::IdleIndex_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, LastIdleIndex_CP) == 0x000A08, "Member 'UTslAnimInstance::LastIdleIndex_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, IdleTimer_CP) == 0x000A0C, "Member 'UTslAnimInstance::IdleTimer_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, IdleTriggerRandom) == 0x000A10, "Member 'UTslAnimInstance::IdleTriggerRandom' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, IdleTriggerTimeMin_CP) == 0x000A14, "Member 'UTslAnimInstance::IdleTriggerTimeMin_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, IdleTriggerTimeVariation_CP) == 0x000A18, "Member 'UTslAnimInstance::IdleTriggerTimeVariation_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, SlotPrimary_CP) == 0x000A20, "Member 'UTslAnimInstance::SlotPrimary_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, SlotSecondary_CP) == 0x000A50, "Member 'UTslAnimInstance::SlotSecondary_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, SlotMelee_CP) == 0x000A80, "Member 'UTslAnimInstance::SlotMelee_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, SlotThrown_CP) == 0x000AB0, "Member 'UTslAnimInstance::SlotThrown_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, SlotPrimary_Offset_CP) == 0x000AE0, "Member 'UTslAnimInstance::SlotPrimary_Offset_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, SlotSecondary_Offset_CP) == 0x000AEC, "Member 'UTslAnimInstance::SlotSecondary_Offset_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, AnimDynamicsStandAlpha_CP) == 0x000AF8, "Member 'UTslAnimInstance::AnimDynamicsStandAlpha_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, AnimDynamicsStandSprintAlpha_CP) == 0x000AFC, "Member 'UTslAnimInstance::AnimDynamicsStandSprintAlpha_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, AnimDynamicsCrouchAlpha_CP) == 0x000B00, "Member 'UTslAnimInstance::AnimDynamicsCrouchAlpha_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, AnimDynamicsProneAlpha_CP) == 0x000B04, "Member 'UTslAnimInstance::AnimDynamicsProneAlpha_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, EFCoat_CP) == 0x000B08, "Member 'UTslAnimInstance::EFCoat_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bLocalFPP_CP) == 0x000B14, "Member 'UTslAnimInstance::bLocalFPP_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, LocalFPPAlpha_CP) == 0x000B18, "Member 'UTslAnimInstance::LocalFPPAlpha_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, LocalFPPAlphaVehicleAimAO_CP) == 0x000B1C, "Member 'UTslAnimInstance::LocalFPPAlphaVehicleAimAO_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsInAircraft_CP) == 0x000B20, "Member 'UTslAnimInstance::bIsInAircraft_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsDriver_CP) == 0x000B21, "Member 'UTslAnimInstance::bIsDriver_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsSitting_CP) == 0x000B22, "Member 'UTslAnimInstance::bIsSitting_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsInVehicle_CP) == 0x000B23, "Member 'UTslAnimInstance::bIsInVehicle_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, LocalSteerInput_CP) == 0x000B24, "Member 'UTslAnimInstance::LocalSteerInput_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, LocalSteerInputMoto_CP) == 0x000B28, "Member 'UTslAnimInstance::LocalSteerInputMoto_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, LocalStopMoto_CP) == 0x000B2C, "Member 'UTslAnimInstance::LocalStopMoto_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, LocalThrottleInput_CP) == 0x000B30, "Member 'UTslAnimInstance::LocalThrottleInput_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, GasThighRot_CP) == 0x000B34, "Member 'UTslAnimInstance::GasThighRot_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, GasAnkleRot_CP) == 0x000B40, "Member 'UTslAnimInstance::GasAnkleRot_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, GasKneeTransformX_CP) == 0x000B50, "Member 'UTslAnimInstance::GasKneeTransformX_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, LocalBrakeInput_CP) == 0x000B80, "Member 'UTslAnimInstance::LocalBrakeInput_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, BrakeKneeTransform_CP) == 0x000B90, "Member 'UTslAnimInstance::BrakeKneeTransform_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, BrakeAnkleRot_CP) == 0x000BC0, "Member 'UTslAnimInstance::BrakeAnkleRot_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, BackwardAOAlpha_CP) == 0x000BCC, "Member 'UTslAnimInstance::BackwardAOAlpha_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, AimBlendAlpha_CP) == 0x000BD0, "Member 'UTslAnimInstance::AimBlendAlpha_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bHasContact_CP) == 0x000BD4, "Member 'UTslAnimInstance::bHasContact_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, GroundContactMoto_CP) == 0x000BD8, "Member 'UTslAnimInstance::GroundContactMoto_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, AirControlPitchInput_CP) == 0x000BDC, "Member 'UTslAnimInstance::AirControlPitchInput_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, DriverIK_CP) == 0x000BE0, "Member 'UTslAnimInstance::DriverIK_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, PassengerIKAlpha_CP) == 0x000C10, "Member 'UTslAnimInstance::PassengerIKAlpha_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, DriverSpineLocWS_CP) == 0x000C14, "Member 'UTslAnimInstance::DriverSpineLocWS_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, VehicleSeatType_CP) == 0x000C20, "Member 'UTslAnimInstance::VehicleSeatType_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bMotoHasDriver_CP) == 0x000C21, "Member 'UTslAnimInstance::bMotoHasDriver_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bVaultCanceled) == 0x000C22, "Member 'UTslAnimInstance::bVaultCanceled' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsVaulting_CP) == 0x000C23, "Member 'UTslAnimInstance::bIsVaulting_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, VaultTimer_CP) == 0x000C24, "Member 'UTslAnimInstance::VaultTimer_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, VaultTimerLast_CP) == 0x000C28, "Member 'UTslAnimInstance::VaultTimerLast_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, LocalVaultType_CP) == 0x000C2C, "Member 'UTslAnimInstance::LocalVaultType_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, VaultAnimSequence_CP) == 0x000C30, "Member 'UTslAnimInstance::VaultAnimSequence_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, VaultAnimLength_CP) == 0x000C38, "Member 'UTslAnimInstance::VaultAnimLength_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, VaultCurve_CP) == 0x000C40, "Member 'UTslAnimInstance::VaultCurve_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, VaultBlendInTime_CP) == 0x000C48, "Member 'UTslAnimInstance::VaultBlendInTime_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, VaultBlendOutTime_CP) == 0x000C4C, "Member 'UTslAnimInstance::VaultBlendOutTime_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bEndVaultToFall_CP) == 0x000C50, "Member 'UTslAnimInstance::bEndVaultToFall_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, VaultBlendOutProgressTime_CP) == 0x000C54, "Member 'UTslAnimInstance::VaultBlendOutProgressTime_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, VaultBlendOutExactTime_CP) == 0x000C58, "Member 'UTslAnimInstance::VaultBlendOutExactTime_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, CurrentCastAnim_CP) == 0x000C5C, "Member 'UTslAnimInstance::CurrentCastAnim_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsActiveRagdoll_CP) == 0x000C5D, "Member 'UTslAnimInstance::bIsActiveRagdoll_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponIKLH_CP) == 0x000C60, "Member 'UTslAnimInstance::WeaponIKLH_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, WeaponIKRH_CP) == 0x000C64, "Member 'UTslAnimInstance::WeaponIKRH_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, MontageIKLH_CP) == 0x000C68, "Member 'UTslAnimInstance::MontageIKLH_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, MontageIKRH_CP) == 0x000C6C, "Member 'UTslAnimInstance::MontageIKRH_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, IgnoreWeaponTransform_CP) == 0x000C70, "Member 'UTslAnimInstance::IgnoreWeaponTransform_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, PickupIKAlpha_CP) == 0x000C74, "Member 'UTslAnimInstance::PickupIKAlpha_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, TargetIKRH_CP) == 0x000C78, "Member 'UTslAnimInstance::TargetIKRH_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, TargetIKLH_CP) == 0x000C7C, "Member 'UTslAnimInstance::TargetIKLH_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, ForceLegsFromAnim_CP) == 0x000C80, "Member 'UTslAnimInstance::ForceLegsFromAnim_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, LastGunCache_CP) == 0x000C88, "Member 'UTslAnimInstance::LastGunCache_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, CachedWheeledVehicle_CP) == 0x000C90, "Member 'UTslAnimInstance::CachedWheeledVehicle_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, CachedFloatingVehicle_CP) == 0x000C98, "Member 'UTslAnimInstance::CachedFloatingVehicle_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, PassengerAimBS_CP) == 0x000CA0, "Member 'UTslAnimInstance::PassengerAimBS_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, PassengerTransitionOut_CP) == 0x000CA8, "Member 'UTslAnimInstance::PassengerTransitionOut_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, PassengerTransitionIn_CP) == 0x000CB0, "Member 'UTslAnimInstance::PassengerTransitionIn_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, PassengerIdle_CP) == 0x000CB8, "Member 'UTslAnimInstance::PassengerIdle_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, CurveAimState_CP) == 0x000CC0, "Member 'UTslAnimInstance::CurveAimState_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsLOD1) == 0x000CD0, "Member 'UTslAnimInstance::bIsLOD1' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsLOD2) == 0x000CD1, "Member 'UTslAnimInstance::bIsLOD2' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsWearingCoat) == 0x000CD2, "Member 'UTslAnimInstance::bIsWearingCoat' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, bIsParentalControl) == 0x000CDC, "Member 'UTslAnimInstance::bIsParentalControl' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, MontageMeleeAttack1) == 0x000CE0, "Member 'UTslAnimInstance::MontageMeleeAttack1' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, MontageMeleeAttack2) == 0x000CE8, "Member 'UTslAnimInstance::MontageMeleeAttack2' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, MontageMeleeAttack3) == 0x000CF0, "Member 'UTslAnimInstance::MontageMeleeAttack3' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, MontagePunchingAttack1) == 0x000CF8, "Member 'UTslAnimInstance::MontagePunchingAttack1' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, MontagePunchingAttack2) == 0x000D00, "Member 'UTslAnimInstance::MontagePunchingAttack2' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, MontagePunchingAttack3) == 0x000D08, "Member 'UTslAnimInstance::MontagePunchingAttack3' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, FPPSprintAnimScalar) == 0x000D10, "Member 'UTslAnimInstance::FPPSprintAnimScalar' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, FPP_PrimaryAndSecondaryItemOffset) == 0x000D14, "Member 'UTslAnimInstance::FPP_PrimaryAndSecondaryItemOffset' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, PunchingAlphaOneTarget_CP) == 0x000D20, "Member 'UTslAnimInstance::PunchingAlphaOneTarget_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, PunchingAlphaInterpSpeed) == 0x000D24, "Member 'UTslAnimInstance::PunchingAlphaInterpSpeed' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, SprintWeaponLoweringScalar_CP) == 0x000D28, "Member 'UTslAnimInstance::SprintWeaponLoweringScalar_CP' has a wrong offset!");
static_assert(offsetof(UTslAnimInstance, ThrowStateSwitchInterpSpeed) == 0x000D2C, "Member 'UTslAnimInstance::ThrowStateSwitchInterpSpeed' has a wrong offset!");

// Class TslGame.TslDamageType
// 0x0050 (0x0090 - 0x0040)
class UTslDamageType : public UDamageType
{
public:
	EDamageTypeCategory                           DamageTypeCategory;                                // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCanvasIcon                            KillIcon;                                          // 0x0048(0x0018)(Edit, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   HitForceFeedback;                                  // 0x0060(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   KilledForceFeedback;                               // 0x0068(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bFallDamage : 1;                                   // 0x0070(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDamageRatioInfo>               DamageRatioInfos;                                  // 0x0078(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          HitReaction;                                       // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslDamageType">();
	}
	static class UTslDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslDamageType>();
	}
};
static_assert(alignof(UTslDamageType) == 0x000008, "Wrong alignment on UTslDamageType");
static_assert(sizeof(UTslDamageType) == 0x000090, "Wrong size on UTslDamageType");
static_assert(offsetof(UTslDamageType, DamageTypeCategory) == 0x000040, "Member 'UTslDamageType::DamageTypeCategory' has a wrong offset!");
static_assert(offsetof(UTslDamageType, KillIcon) == 0x000048, "Member 'UTslDamageType::KillIcon' has a wrong offset!");
static_assert(offsetof(UTslDamageType, HitForceFeedback) == 0x000060, "Member 'UTslDamageType::HitForceFeedback' has a wrong offset!");
static_assert(offsetof(UTslDamageType, KilledForceFeedback) == 0x000068, "Member 'UTslDamageType::KilledForceFeedback' has a wrong offset!");
static_assert(offsetof(UTslDamageType, DamageRatioInfos) == 0x000078, "Member 'UTslDamageType::DamageRatioInfos' has a wrong offset!");
static_assert(offsetof(UTslDamageType, HitReaction) == 0x000088, "Member 'UTslDamageType::HitReaction' has a wrong offset!");

// Class TslGame.TslStreamerManager
// 0x0028 (0x03C8 - 0x03A0)
class ATslStreamerManager final : public AActor
{
public:
	uint8                                         Pad_3A0[0x8];                                      // 0x03A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UTslStreamer>>       StreamerClasses;                                   // 0x03A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UTslStreamer*>                   TslStreamers;                                      // 0x03B8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslStreamerManager">();
	}
	static class ATslStreamerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslStreamerManager>();
	}
};
static_assert(alignof(ATslStreamerManager) == 0x000008, "Wrong alignment on ATslStreamerManager");
static_assert(sizeof(ATslStreamerManager) == 0x0003C8, "Wrong size on ATslStreamerManager");
static_assert(offsetof(ATslStreamerManager, StreamerClasses) == 0x0003A8, "Member 'ATslStreamerManager::StreamerClasses' has a wrong offset!");
static_assert(offsetof(ATslStreamerManager, TslStreamers) == 0x0003B8, "Member 'ATslStreamerManager::TslStreamers' has a wrong offset!");

// Class TslGame.TslHUD
// 0x03C0 (0x08D0 - 0x0510)
class ATslHUD : public ATslBaseHUD
{
public:
	UMulticastDelegateProperty_                   OnPossessPawnChange;                               // 0x0510(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDisplaySystemMessage;                            // 0x0520(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDisplayKilledMessage;                            // 0x0530(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnKillCountChanged;                                // 0x0540(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnNotifyHit;                                       // 0x0550(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnTeamPlayerJoin;                                  // 0x0560(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnTeamPlayerRemove;                                // 0x0570(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnNotifyStartBuff;                                 // 0x0580(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnNotifyHealAmount;                                // 0x0590(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnNotifyRestrictingPlayArea;                       // 0x05A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnNotifyNextGasIn;                                 // 0x05B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnNotifyDisplayMessage;                            // 0x05C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnNotifyWeaponChange;                              // 0x05D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnNotifyWeaponUnarm;                               // 0x05E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnNotifyHeal;                                      // 0x05F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnNotifyDropSlotOnOtherContainer;                  // 0x0600(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnNotifyBlockingWidgetOpened;                      // 0x0610(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         BluezoneState;                                     // 0x0620(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGpsReset;                                         // 0x0624(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBluezoneReset;                                    // 0x0625(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayzoneReset;                                    // 0x0626(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_627[0x1];                                      // 0x0627(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GpsResetTimeCheck;                                 // 0x0628(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHighlight;                                     // 0x062C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62D[0x33];                                     // 0x062D(0x0033)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCanvasIcon                            TimePlaceBg;                                       // 0x0660(0x0018)(Protected, NativeAccessSpecifierProtected)
	struct FCanvasIcon                            PrimaryWeapBg;                                     // 0x0678(0x0018)(Protected, NativeAccessSpecifierProtected)
	struct FCanvasIcon                            SecondaryWeapBg;                                   // 0x0690(0x0018)(Protected, NativeAccessSpecifierProtected)
	struct FCanvasIcon                            Crosshair[0x5];                                    // 0x06A8(0x0018)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_720[0x78];                                     // 0x0720(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             HitNotifyTexture;                                  // 0x0798(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             HUDMainTexture;                                    // 0x07A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             HUDAssets02Texture;                                // 0x07A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             LowHealthOverlayTexture;                           // 0x07B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFont*                                  BigFont;                                           // 0x07B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFont*                                  NormalFont;                                        // 0x07C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C8[0x60];                                     // 0x07C8(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UTslSceneCaptureWorld*                  SceneCaptureWorld;                                 // 0x0828(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_830[0x10];                                     // 0x0830(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NextPlayzonePosition;                              // 0x0840(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         NextPlayzoneRadius;                                // 0x084C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CurrentPlayzonePosition;                           // 0x0850(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         CurrentPlayzoneRadius;                             // 0x085C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_860[0x48];                                     // 0x0860(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SceneCapturePackageName;                           // 0x08A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHighlightSession*                      HighlightSession;                                  // 0x08B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8C0[0x10];                                     // 0x08C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GoToLobby();
	void InitCaptureWorld();
	void NotifyDropSlotOnOtherContainer(TScriptInterface<class ISlotContainerInterface> Container, TScriptInterface<class ISlotInterface> Slot, TScriptInterface<class ISlotContainerInterface> OtherContainer);
	void SetHighlightProvider(const class FString& Provider);
	void SpawnActorInSceneCaptureWorld(TSubclassOf<class AActor> ActorClass, const struct FTransform& SpawnTransform, TDelegate<void(class AActor* SpawnedActor)> DelegateToCall);
	void TestGameEvent_Die(bool bGroggy);
	void TestGameEvent_KillOtherPlayer(bool bGroggy);
	void TestGameEvent_MatchEnded();
	void TestKillMessage(const class FString& KillerName, const class FString& VictimName, bool bKillerIsOwner, bool bVictimIsOwner);
	void TestSendImportantMessage(const class FText& Message, float Duration);
	void TestSendSystemMessage(const class FText& Message, float Duration);

	class ATslCharacter* GetPossessCharacter() const;
	class APawn* GetPossessPawn() const;
	bool IsGameEnded() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslHUD">();
	}
	static class ATslHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslHUD>();
	}
};
static_assert(alignof(ATslHUD) == 0x000008, "Wrong alignment on ATslHUD");
static_assert(sizeof(ATslHUD) == 0x0008D0, "Wrong size on ATslHUD");
static_assert(offsetof(ATslHUD, OnPossessPawnChange) == 0x000510, "Member 'ATslHUD::OnPossessPawnChange' has a wrong offset!");
static_assert(offsetof(ATslHUD, OnDisplaySystemMessage) == 0x000520, "Member 'ATslHUD::OnDisplaySystemMessage' has a wrong offset!");
static_assert(offsetof(ATslHUD, OnDisplayKilledMessage) == 0x000530, "Member 'ATslHUD::OnDisplayKilledMessage' has a wrong offset!");
static_assert(offsetof(ATslHUD, OnKillCountChanged) == 0x000540, "Member 'ATslHUD::OnKillCountChanged' has a wrong offset!");
static_assert(offsetof(ATslHUD, OnNotifyHit) == 0x000550, "Member 'ATslHUD::OnNotifyHit' has a wrong offset!");
static_assert(offsetof(ATslHUD, OnTeamPlayerJoin) == 0x000560, "Member 'ATslHUD::OnTeamPlayerJoin' has a wrong offset!");
static_assert(offsetof(ATslHUD, OnTeamPlayerRemove) == 0x000570, "Member 'ATslHUD::OnTeamPlayerRemove' has a wrong offset!");
static_assert(offsetof(ATslHUD, OnNotifyStartBuff) == 0x000580, "Member 'ATslHUD::OnNotifyStartBuff' has a wrong offset!");
static_assert(offsetof(ATslHUD, OnNotifyHealAmount) == 0x000590, "Member 'ATslHUD::OnNotifyHealAmount' has a wrong offset!");
static_assert(offsetof(ATslHUD, OnNotifyRestrictingPlayArea) == 0x0005A0, "Member 'ATslHUD::OnNotifyRestrictingPlayArea' has a wrong offset!");
static_assert(offsetof(ATslHUD, OnNotifyNextGasIn) == 0x0005B0, "Member 'ATslHUD::OnNotifyNextGasIn' has a wrong offset!");
static_assert(offsetof(ATslHUD, OnNotifyDisplayMessage) == 0x0005C0, "Member 'ATslHUD::OnNotifyDisplayMessage' has a wrong offset!");
static_assert(offsetof(ATslHUD, OnNotifyWeaponChange) == 0x0005D0, "Member 'ATslHUD::OnNotifyWeaponChange' has a wrong offset!");
static_assert(offsetof(ATslHUD, OnNotifyWeaponUnarm) == 0x0005E0, "Member 'ATslHUD::OnNotifyWeaponUnarm' has a wrong offset!");
static_assert(offsetof(ATslHUD, OnNotifyHeal) == 0x0005F0, "Member 'ATslHUD::OnNotifyHeal' has a wrong offset!");
static_assert(offsetof(ATslHUD, OnNotifyDropSlotOnOtherContainer) == 0x000600, "Member 'ATslHUD::OnNotifyDropSlotOnOtherContainer' has a wrong offset!");
static_assert(offsetof(ATslHUD, OnNotifyBlockingWidgetOpened) == 0x000610, "Member 'ATslHUD::OnNotifyBlockingWidgetOpened' has a wrong offset!");
static_assert(offsetof(ATslHUD, BluezoneState) == 0x000620, "Member 'ATslHUD::BluezoneState' has a wrong offset!");
static_assert(offsetof(ATslHUD, bGpsReset) == 0x000624, "Member 'ATslHUD::bGpsReset' has a wrong offset!");
static_assert(offsetof(ATslHUD, bBluezoneReset) == 0x000625, "Member 'ATslHUD::bBluezoneReset' has a wrong offset!");
static_assert(offsetof(ATslHUD, bPlayzoneReset) == 0x000626, "Member 'ATslHUD::bPlayzoneReset' has a wrong offset!");
static_assert(offsetof(ATslHUD, GpsResetTimeCheck) == 0x000628, "Member 'ATslHUD::GpsResetTimeCheck' has a wrong offset!");
static_assert(offsetof(ATslHUD, bUseHighlight) == 0x00062C, "Member 'ATslHUD::bUseHighlight' has a wrong offset!");
static_assert(offsetof(ATslHUD, TimePlaceBg) == 0x000660, "Member 'ATslHUD::TimePlaceBg' has a wrong offset!");
static_assert(offsetof(ATslHUD, PrimaryWeapBg) == 0x000678, "Member 'ATslHUD::PrimaryWeapBg' has a wrong offset!");
static_assert(offsetof(ATslHUD, SecondaryWeapBg) == 0x000690, "Member 'ATslHUD::SecondaryWeapBg' has a wrong offset!");
static_assert(offsetof(ATslHUD, Crosshair) == 0x0006A8, "Member 'ATslHUD::Crosshair' has a wrong offset!");
static_assert(offsetof(ATslHUD, HitNotifyTexture) == 0x000798, "Member 'ATslHUD::HitNotifyTexture' has a wrong offset!");
static_assert(offsetof(ATslHUD, HUDMainTexture) == 0x0007A0, "Member 'ATslHUD::HUDMainTexture' has a wrong offset!");
static_assert(offsetof(ATslHUD, HUDAssets02Texture) == 0x0007A8, "Member 'ATslHUD::HUDAssets02Texture' has a wrong offset!");
static_assert(offsetof(ATslHUD, LowHealthOverlayTexture) == 0x0007B0, "Member 'ATslHUD::LowHealthOverlayTexture' has a wrong offset!");
static_assert(offsetof(ATslHUD, BigFont) == 0x0007B8, "Member 'ATslHUD::BigFont' has a wrong offset!");
static_assert(offsetof(ATslHUD, NormalFont) == 0x0007C0, "Member 'ATslHUD::NormalFont' has a wrong offset!");
static_assert(offsetof(ATslHUD, SceneCaptureWorld) == 0x000828, "Member 'ATslHUD::SceneCaptureWorld' has a wrong offset!");
static_assert(offsetof(ATslHUD, NextPlayzonePosition) == 0x000840, "Member 'ATslHUD::NextPlayzonePosition' has a wrong offset!");
static_assert(offsetof(ATslHUD, NextPlayzoneRadius) == 0x00084C, "Member 'ATslHUD::NextPlayzoneRadius' has a wrong offset!");
static_assert(offsetof(ATslHUD, CurrentPlayzonePosition) == 0x000850, "Member 'ATslHUD::CurrentPlayzonePosition' has a wrong offset!");
static_assert(offsetof(ATslHUD, CurrentPlayzoneRadius) == 0x00085C, "Member 'ATslHUD::CurrentPlayzoneRadius' has a wrong offset!");
static_assert(offsetof(ATslHUD, SceneCapturePackageName) == 0x0008A8, "Member 'ATslHUD::SceneCapturePackageName' has a wrong offset!");
static_assert(offsetof(ATslHUD, HighlightSession) == 0x0008B8, "Member 'ATslHUD::HighlightSession' has a wrong offset!");

// Class TslGame.LobbyHUD
// 0x00E0 (0x09B0 - 0x08D0)
class ALobbyHUD : public ATslHUD
{
public:
	UMulticastDelegateProperty_                   OnCreateCharacter;                                 // 0x08D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDestroyCharacter;                                // 0x08E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 StartURL;                                          // 0x08F0(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UCoherentCommonBinder*>          CommonBinders;                                     // 0x0900(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UAkComponent*                           AkSound;                                           // 0x0910(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACameraActor*                           Camera;                                            // 0x0918(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_920[0x20];                                     // 0x0920(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ALobbyCharacter>            LobbyCharacterMaleClass;                           // 0x0940(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ALobbyCharacter>            LobbyCharacterFemaleClass;                         // 0x0948(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_950[0x50];                                     // 0x0950(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FViewTargetTransitionParams            ViewTargetTransitionParams;                        // 0x09A0(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	void ClearAllWidget();
	void SetWidgetForBinding(int32 ViewIndex, class UCoherentUIGTWidget* Widget);

	class ALobbyCharacter* GetLobbyCharacter(int32 SlotIndex) const;
	int32 GetLobbyCharacterNum() const;
	class FString GetStartUrl() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyHUD">();
	}
	static class ALobbyHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALobbyHUD>();
	}
};
static_assert(alignof(ALobbyHUD) == 0x000008, "Wrong alignment on ALobbyHUD");
static_assert(sizeof(ALobbyHUD) == 0x0009B0, "Wrong size on ALobbyHUD");
static_assert(offsetof(ALobbyHUD, OnCreateCharacter) == 0x0008D0, "Member 'ALobbyHUD::OnCreateCharacter' has a wrong offset!");
static_assert(offsetof(ALobbyHUD, OnDestroyCharacter) == 0x0008E0, "Member 'ALobbyHUD::OnDestroyCharacter' has a wrong offset!");
static_assert(offsetof(ALobbyHUD, StartURL) == 0x0008F0, "Member 'ALobbyHUD::StartURL' has a wrong offset!");
static_assert(offsetof(ALobbyHUD, CommonBinders) == 0x000900, "Member 'ALobbyHUD::CommonBinders' has a wrong offset!");
static_assert(offsetof(ALobbyHUD, AkSound) == 0x000910, "Member 'ALobbyHUD::AkSound' has a wrong offset!");
static_assert(offsetof(ALobbyHUD, Camera) == 0x000918, "Member 'ALobbyHUD::Camera' has a wrong offset!");
static_assert(offsetof(ALobbyHUD, LobbyCharacterMaleClass) == 0x000940, "Member 'ALobbyHUD::LobbyCharacterMaleClass' has a wrong offset!");
static_assert(offsetof(ALobbyHUD, LobbyCharacterFemaleClass) == 0x000948, "Member 'ALobbyHUD::LobbyCharacterFemaleClass' has a wrong offset!");
static_assert(offsetof(ALobbyHUD, ViewTargetTransitionParams) == 0x0009A0, "Member 'ALobbyHUD::ViewTargetTransitionParams' has a wrong offset!");

// Class TslGame.TslMotorbikeVehicle
// 0x0198 (0x0868 - 0x06D0)
class ATslMotorbikeVehicle : public ATslWheeledVehicle
{
public:
	bool                                          bUseKickstandStabilize;                            // 0x06D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D1[0x3];                                      // 0x06D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinSuspensionOffsetForContact;                     // 0x06D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStabilizeOnServer;                                // 0x06D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D9[0x3];                                      // 0x06D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KickstandStabilizeDamping;                         // 0x06DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KickstandMaxAngVelocity;                           // 0x06E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultAngularDamping;                             // 0x06E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KickstandStabilizeTorqueScalar;                    // 0x06E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KickstandStabilizeRollScalar;                      // 0x06EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KickstandStabilizeRollMinRange;                    // 0x06F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinVelocityForStabilizeOverride;                   // 0x06F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StabilizeBone_Low;                                 // 0x06F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StabilizeBone_High;                                // 0x0700(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            Curve_Roll;                                        // 0x0708(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            Curve_RollReturn;                                  // 0x0710(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            Curve_Steer;                                       // 0x0718(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            Curve_Yaw;                                         // 0x0720(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            Curve_Torque;                                      // 0x0728(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StabStaticVector;                                  // 0x0730(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                StabStaticVectorKickstand;                         // 0x073C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                StabNoDriverVector;                                // 0x0748(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              StabX_Velocity_In;                                 // 0x0754(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              StabX_Velocity_Out;                                // 0x075C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              StabX_Pitch_In;                                    // 0x0764(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              StabX_Pitch_Out;                                   // 0x076C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              StabZ_Velocity_In;                                 // 0x0774(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              StabZ_Velocity_Out;                                // 0x077C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              StabZ_Roll_In;                                     // 0x0784(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              StabZ_Roll_Out;                                    // 0x078C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              StabZ_Pitch_In;                                    // 0x0794(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              StabZ_Pitch_Out;                                   // 0x079C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              StabTorque_In;                                     // 0x07A4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              StabTorque_Out;                                    // 0x07AC(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         StabTorque_ForceScalar;                            // 0x07B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StabTorque_Pitch_In;                               // 0x07B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              StabTorque_Pitch_Out;                              // 0x07C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseFlipping;                                      // 0x07C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C9[0x3];                                      // 0x07C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FlippingForce;                                     // 0x07CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialFlipTimer;                                  // 0x07D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinVelocityForFlipping;                            // 0x07D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D8[0x4];                                      // 0x07D8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ContactAlpha_RiseRate;                             // 0x07DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ContactAlpha_FallRate;                             // 0x07E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E4[0x4];                                      // 0x07E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            Curve_EngineAudio;                                 // 0x07E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              AirControlF_VelMap;                                // 0x07F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              AirControlB_VelMap;                                // 0x07F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              AirControlL_VelMap;                                // 0x0800(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              AirControlR_VelMap;                                // 0x0808(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              AirControlQ_VelMap;                                // 0x0810(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              AirControlE_VelMap;                                // 0x0818(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AirControl_FB_Torque;                              // 0x0820(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirControl_LR_Torque;                              // 0x0824(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AirControl_QE_Torque;                              // 0x0828(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStabilizeInAir;                                   // 0x082C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82D[0x3];                                      // 0x082D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StabilizeAirPercentage;                            // 0x0830(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_834[0x31];                                     // 0x0834(0x0031)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bKickstandStabilize;                               // 0x0865(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_866[0x2];                                      // 0x0866(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPostDriverLeave();
	void OnPostDriverRide();
	void OnVehicleEjected();
	void ProcessFlipAndStabilize();
	void SetAirControlB(float inFloat);
	void SetAirControlE(float inFloat);
	void SetAirControlF(float inFloat);
	void SetAirControlL(float inFloat);
	void SetAirControlQ(float inFloat);
	void SetAirControlR(float inFloat);

	float GetCOMSteerOffset() const;
	bool HasContact() const;
	bool IsFlippingEnabled() const;
	bool IsKickstandActive() const;
	bool IsUsingActiveStabilize() const;
	bool VehicleHasDriver() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslMotorbikeVehicle">();
	}
	static class ATslMotorbikeVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslMotorbikeVehicle>();
	}
};
static_assert(alignof(ATslMotorbikeVehicle) == 0x000008, "Wrong alignment on ATslMotorbikeVehicle");
static_assert(sizeof(ATslMotorbikeVehicle) == 0x000868, "Wrong size on ATslMotorbikeVehicle");
static_assert(offsetof(ATslMotorbikeVehicle, bUseKickstandStabilize) == 0x0006D0, "Member 'ATslMotorbikeVehicle::bUseKickstandStabilize' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, MinSuspensionOffsetForContact) == 0x0006D4, "Member 'ATslMotorbikeVehicle::MinSuspensionOffsetForContact' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, bStabilizeOnServer) == 0x0006D8, "Member 'ATslMotorbikeVehicle::bStabilizeOnServer' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, KickstandStabilizeDamping) == 0x0006DC, "Member 'ATslMotorbikeVehicle::KickstandStabilizeDamping' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, KickstandMaxAngVelocity) == 0x0006E0, "Member 'ATslMotorbikeVehicle::KickstandMaxAngVelocity' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, DefaultAngularDamping) == 0x0006E4, "Member 'ATslMotorbikeVehicle::DefaultAngularDamping' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, KickstandStabilizeTorqueScalar) == 0x0006E8, "Member 'ATslMotorbikeVehicle::KickstandStabilizeTorqueScalar' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, KickstandStabilizeRollScalar) == 0x0006EC, "Member 'ATslMotorbikeVehicle::KickstandStabilizeRollScalar' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, KickstandStabilizeRollMinRange) == 0x0006F0, "Member 'ATslMotorbikeVehicle::KickstandStabilizeRollMinRange' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, MinVelocityForStabilizeOverride) == 0x0006F4, "Member 'ATslMotorbikeVehicle::MinVelocityForStabilizeOverride' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, StabilizeBone_Low) == 0x0006F8, "Member 'ATslMotorbikeVehicle::StabilizeBone_Low' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, StabilizeBone_High) == 0x000700, "Member 'ATslMotorbikeVehicle::StabilizeBone_High' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, Curve_Roll) == 0x000708, "Member 'ATslMotorbikeVehicle::Curve_Roll' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, Curve_RollReturn) == 0x000710, "Member 'ATslMotorbikeVehicle::Curve_RollReturn' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, Curve_Steer) == 0x000718, "Member 'ATslMotorbikeVehicle::Curve_Steer' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, Curve_Yaw) == 0x000720, "Member 'ATslMotorbikeVehicle::Curve_Yaw' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, Curve_Torque) == 0x000728, "Member 'ATslMotorbikeVehicle::Curve_Torque' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, StabStaticVector) == 0x000730, "Member 'ATslMotorbikeVehicle::StabStaticVector' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, StabStaticVectorKickstand) == 0x00073C, "Member 'ATslMotorbikeVehicle::StabStaticVectorKickstand' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, StabNoDriverVector) == 0x000748, "Member 'ATslMotorbikeVehicle::StabNoDriverVector' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, StabX_Velocity_In) == 0x000754, "Member 'ATslMotorbikeVehicle::StabX_Velocity_In' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, StabX_Velocity_Out) == 0x00075C, "Member 'ATslMotorbikeVehicle::StabX_Velocity_Out' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, StabX_Pitch_In) == 0x000764, "Member 'ATslMotorbikeVehicle::StabX_Pitch_In' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, StabX_Pitch_Out) == 0x00076C, "Member 'ATslMotorbikeVehicle::StabX_Pitch_Out' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, StabZ_Velocity_In) == 0x000774, "Member 'ATslMotorbikeVehicle::StabZ_Velocity_In' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, StabZ_Velocity_Out) == 0x00077C, "Member 'ATslMotorbikeVehicle::StabZ_Velocity_Out' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, StabZ_Roll_In) == 0x000784, "Member 'ATslMotorbikeVehicle::StabZ_Roll_In' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, StabZ_Roll_Out) == 0x00078C, "Member 'ATslMotorbikeVehicle::StabZ_Roll_Out' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, StabZ_Pitch_In) == 0x000794, "Member 'ATslMotorbikeVehicle::StabZ_Pitch_In' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, StabZ_Pitch_Out) == 0x00079C, "Member 'ATslMotorbikeVehicle::StabZ_Pitch_Out' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, StabTorque_In) == 0x0007A4, "Member 'ATslMotorbikeVehicle::StabTorque_In' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, StabTorque_Out) == 0x0007AC, "Member 'ATslMotorbikeVehicle::StabTorque_Out' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, StabTorque_ForceScalar) == 0x0007B4, "Member 'ATslMotorbikeVehicle::StabTorque_ForceScalar' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, StabTorque_Pitch_In) == 0x0007B8, "Member 'ATslMotorbikeVehicle::StabTorque_Pitch_In' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, StabTorque_Pitch_Out) == 0x0007C0, "Member 'ATslMotorbikeVehicle::StabTorque_Pitch_Out' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, bUseFlipping) == 0x0007C8, "Member 'ATslMotorbikeVehicle::bUseFlipping' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, FlippingForce) == 0x0007CC, "Member 'ATslMotorbikeVehicle::FlippingForce' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, InitialFlipTimer) == 0x0007D0, "Member 'ATslMotorbikeVehicle::InitialFlipTimer' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, MinVelocityForFlipping) == 0x0007D4, "Member 'ATslMotorbikeVehicle::MinVelocityForFlipping' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, ContactAlpha_RiseRate) == 0x0007DC, "Member 'ATslMotorbikeVehicle::ContactAlpha_RiseRate' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, ContactAlpha_FallRate) == 0x0007E0, "Member 'ATslMotorbikeVehicle::ContactAlpha_FallRate' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, Curve_EngineAudio) == 0x0007E8, "Member 'ATslMotorbikeVehicle::Curve_EngineAudio' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, AirControlF_VelMap) == 0x0007F0, "Member 'ATslMotorbikeVehicle::AirControlF_VelMap' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, AirControlB_VelMap) == 0x0007F8, "Member 'ATslMotorbikeVehicle::AirControlB_VelMap' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, AirControlL_VelMap) == 0x000800, "Member 'ATslMotorbikeVehicle::AirControlL_VelMap' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, AirControlR_VelMap) == 0x000808, "Member 'ATslMotorbikeVehicle::AirControlR_VelMap' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, AirControlQ_VelMap) == 0x000810, "Member 'ATslMotorbikeVehicle::AirControlQ_VelMap' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, AirControlE_VelMap) == 0x000818, "Member 'ATslMotorbikeVehicle::AirControlE_VelMap' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, AirControl_FB_Torque) == 0x000820, "Member 'ATslMotorbikeVehicle::AirControl_FB_Torque' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, AirControl_LR_Torque) == 0x000824, "Member 'ATslMotorbikeVehicle::AirControl_LR_Torque' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, AirControl_QE_Torque) == 0x000828, "Member 'ATslMotorbikeVehicle::AirControl_QE_Torque' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, bStabilizeInAir) == 0x00082C, "Member 'ATslMotorbikeVehicle::bStabilizeInAir' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, StabilizeAirPercentage) == 0x000830, "Member 'ATslMotorbikeVehicle::StabilizeAirPercentage' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle, bKickstandStabilize) == 0x000865, "Member 'ATslMotorbikeVehicle::bKickstandStabilize' has a wrong offset!");

// Class TslGame.TslMotorbikeVehicle_Sidecar
// 0x0018 (0x0880 - 0x0868)
class ATslMotorbikeVehicle_Sidecar : public ATslMotorbikeVehicle
{
public:
	float                                         Sidecar_COM_Y_Left;                                // 0x0868(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Sidecar_COM_Y_Right;                               // 0x086C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                Sidecar_StabilizerHigh_StaticCOM;                  // 0x0870(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_87C[0x4];                                      // 0x087C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslMotorbikeVehicle_Sidecar">();
	}
	static class ATslMotorbikeVehicle_Sidecar* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslMotorbikeVehicle_Sidecar>();
	}
};
static_assert(alignof(ATslMotorbikeVehicle_Sidecar) == 0x000008, "Wrong alignment on ATslMotorbikeVehicle_Sidecar");
static_assert(sizeof(ATslMotorbikeVehicle_Sidecar) == 0x000880, "Wrong size on ATslMotorbikeVehicle_Sidecar");
static_assert(offsetof(ATslMotorbikeVehicle_Sidecar, Sidecar_COM_Y_Left) == 0x000868, "Member 'ATslMotorbikeVehicle_Sidecar::Sidecar_COM_Y_Left' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle_Sidecar, Sidecar_COM_Y_Right) == 0x00086C, "Member 'ATslMotorbikeVehicle_Sidecar::Sidecar_COM_Y_Right' has a wrong offset!");
static_assert(offsetof(ATslMotorbikeVehicle_Sidecar, Sidecar_StabilizerHigh_StaticCOM) == 0x000870, "Member 'ATslMotorbikeVehicle_Sidecar::Sidecar_StabilizerHigh_StaticCOM' has a wrong offset!");

// Class TslGame.TslEntryPlayerController
// 0x0008 (0x06D8 - 0x06D0)
class ATslEntryPlayerController final : public ATslBasePlayerController
{
public:
	class UVivoxLobbyComponent*                   VivoxComponent;                                    // 0x06D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslEntryPlayerController">();
	}
	static class ATslEntryPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslEntryPlayerController>();
	}
};
static_assert(alignof(ATslEntryPlayerController) == 0x000008, "Wrong alignment on ATslEntryPlayerController");
static_assert(sizeof(ATslEntryPlayerController) == 0x0006D8, "Wrong size on ATslEntryPlayerController");
static_assert(offsetof(ATslEntryPlayerController, VivoxComponent) == 0x0006D0, "Member 'ATslEntryPlayerController::VivoxComponent' has a wrong offset!");

// Class TslGame.PerfBotPlayerController
// 0x0060 (0x0A58 - 0x09F8)
class APerfBotPlayerController final : public ATslPlayerController
{
public:
	int32                                         AmmoClips;                                         // 0x09F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9FC[0x4];                                      // 0x09FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATslWeapon>                 WeaponType;                                        // 0x0A00(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A08[0x50];                                     // 0x0A08(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientQuit();
	void ServerMoveToLocation(const struct FVector& Location);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerfBotPlayerController">();
	}
	static class APerfBotPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<APerfBotPlayerController>();
	}
};
static_assert(alignof(APerfBotPlayerController) == 0x000008, "Wrong alignment on APerfBotPlayerController");
static_assert(sizeof(APerfBotPlayerController) == 0x000A58, "Wrong size on APerfBotPlayerController");
static_assert(offsetof(APerfBotPlayerController, AmmoClips) == 0x0009F8, "Member 'APerfBotPlayerController::AmmoClips' has a wrong offset!");
static_assert(offsetof(APerfBotPlayerController, WeaponType) == 0x000A00, "Member 'APerfBotPlayerController::WeaponType' has a wrong offset!");

// Class TslGame.TslViewTargetTempComponent
// 0x0018 (0x0110 - 0x00F8)
class UTslViewTargetTempComponent final : public UActorComponent
{
public:
	TArray<struct FTempComponentInfo>             ComponentInfos;                                    // 0x00F8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddTempComponent(class USceneComponent* TempComponent);
	void AddTempComponentWithDelegate(class USceneComponent* TempComponent, TDelegate<void(class USceneComponent* NewComponent)> DelegateToCall);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslViewTargetTempComponent">();
	}
	static class UTslViewTargetTempComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslViewTargetTempComponent>();
	}
};
static_assert(alignof(UTslViewTargetTempComponent) == 0x000008, "Wrong alignment on UTslViewTargetTempComponent");
static_assert(sizeof(UTslViewTargetTempComponent) == 0x000110, "Wrong size on UTslViewTargetTempComponent");
static_assert(offsetof(UTslViewTargetTempComponent, ComponentInfos) == 0x0000F8, "Member 'UTslViewTargetTempComponent::ComponentInfos' has a wrong offset!");

// Class TslGame.TslDemoSpectator
// 0x0028 (0x0A20 - 0x09F8)
class ATslDemoSpectator final : public ATslPlayerController
{
public:
	uint8                                         Pad_9F8[0x28];                                     // 0x09F8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslDemoSpectator">();
	}
	static class ATslDemoSpectator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslDemoSpectator>();
	}
};
static_assert(alignof(ATslDemoSpectator) == 0x000008, "Wrong alignment on ATslDemoSpectator");
static_assert(sizeof(ATslDemoSpectator) == 0x000A20, "Wrong size on ATslDemoSpectator");

// Class TslGame.TslPlayerController_Menu
// 0x0000 (0x09F8 - 0x09F8)
class ATslPlayerController_Menu final : public ATslPlayerController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslPlayerController_Menu">();
	}
	static class ATslPlayerController_Menu* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslPlayerController_Menu>();
	}
};
static_assert(alignof(ATslPlayerController_Menu) == 0x000008, "Wrong alignment on ATslPlayerController_Menu");
static_assert(sizeof(ATslPlayerController_Menu) == 0x0009F8, "Wrong size on ATslPlayerController_Menu");

// Class TslGame.TslStreamer
// 0x0020 (0x0048 - 0x0028)
class UTslStreamer : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelChangedInternal();
	void OnOriginShiftedInternal(class UWorld* InWorld, const struct FIntVector& From, const struct FIntVector& To);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslStreamer">();
	}
	static class UTslStreamer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslStreamer>();
	}
};
static_assert(alignof(UTslStreamer) == 0x000008, "Wrong alignment on UTslStreamer");
static_assert(sizeof(UTslStreamer) == 0x000048, "Wrong size on UTslStreamer");

// Class TslGame.LODActorStreamer
// 0x0038 (0x0080 - 0x0048)
class ULODActorStreamer final : public UTslStreamer
{
public:
	bool                                          bEnabled;                                          // 0x0048(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PreLoadDistance;                                   // 0x004C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PerFrameShowCount;                                 // 0x0050(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PerFrameShowCountLimit;                            // 0x0054(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FFloatRange>                    MinDrawDistanceOverride;                           // 0x0058(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x18];                                      // 0x0068(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LODActorStreamer">();
	}
	static class ULODActorStreamer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULODActorStreamer>();
	}
};
static_assert(alignof(ULODActorStreamer) == 0x000008, "Wrong alignment on ULODActorStreamer");
static_assert(sizeof(ULODActorStreamer) == 0x000080, "Wrong size on ULODActorStreamer");
static_assert(offsetof(ULODActorStreamer, bEnabled) == 0x000048, "Member 'ULODActorStreamer::bEnabled' has a wrong offset!");
static_assert(offsetof(ULODActorStreamer, PreLoadDistance) == 0x00004C, "Member 'ULODActorStreamer::PreLoadDistance' has a wrong offset!");
static_assert(offsetof(ULODActorStreamer, PerFrameShowCount) == 0x000050, "Member 'ULODActorStreamer::PerFrameShowCount' has a wrong offset!");
static_assert(offsetof(ULODActorStreamer, PerFrameShowCountLimit) == 0x000054, "Member 'ULODActorStreamer::PerFrameShowCountLimit' has a wrong offset!");
static_assert(offsetof(ULODActorStreamer, MinDrawDistanceOverride) == 0x000058, "Member 'ULODActorStreamer::MinDrawDistanceOverride' has a wrong offset!");

// Class TslGame.TslBotAIController
// 0x0020 (0x04B8 - 0x0498)
class ATslBotAIController final : public AAIController
{
public:
	uint8                                         Pad_498[0x20];                                     // 0x0498(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslBotAIController">();
	}
	static class ATslBotAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslBotAIController>();
	}
};
static_assert(alignof(ATslBotAIController) == 0x000008, "Wrong alignment on ATslBotAIController");
static_assert(sizeof(ATslBotAIController) == 0x0004B8, "Wrong size on ATslBotAIController");

// Class TslGame.CharacterBreathBuff
// 0x0008 (0x0408 - 0x0400)
class ACharacterBreathBuff final : public ATslBuff
{
public:
	float                                         BreathPerTick;                                     // 0x0400(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_404[0x4];                                      // 0x0404(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UCharacterBreathComponent* GetBreathComponent() const;
	class ATslCharacter* GetCharacter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterBreathBuff">();
	}
	static class ACharacterBreathBuff* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharacterBreathBuff>();
	}
};
static_assert(alignof(ACharacterBreathBuff) == 0x000008, "Wrong alignment on ACharacterBreathBuff");
static_assert(sizeof(ACharacterBreathBuff) == 0x000408, "Wrong size on ACharacterBreathBuff");
static_assert(offsetof(ACharacterBreathBuff, BreathPerTick) == 0x000400, "Member 'ACharacterBreathBuff::BreathPerTick' has a wrong offset!");

// Class TslGame.TslThrowableTrajectoryViewComponent
// 0x00D0 (0x0880 - 0x07B0)
class UTslThrowableTrajectoryViewComponent final : public USplineComponent
{
public:
	class UStaticMesh*                            SplineSegmentMesh;                                 // 0x07B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     SplineSegmentMeshMaterial;                         // 0x07B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              SegmentMeshScale;                                  // 0x07C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	class UStaticMesh*                            ImpactMesh;                                        // 0x07C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     ImpactMeshMaterial;                                // 0x07D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                ImpactMeshScale;                                   // 0x07D8(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7E4[0x4];                                      // 0x07E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<EObjectTypeQuery>                        TraceObjectTypes;                                  // 0x07E8(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         PredictionTime;                                    // 0x0838(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DistanceScaleFactor;                               // 0x083C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MaterialParam_NearDepthFadeOrigin;                 // 0x0840(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   MaterialParam_FarDepthFadeOrigin;                  // 0x0848(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SplineGenerationAngThresholdDeg;                   // 0x0850(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_854[0xC];                                      // 0x0854(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   ImpactMeshComponent;                               // 0x0860(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class USplineMeshComponent*>           SplineMeshArray;                                   // 0x0868(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               SplineSegmentMeshMaterialDynamic;                  // 0x0878(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AttachToThrowable(const class ATslWeapon_Throwable* ThrowableIn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslThrowableTrajectoryViewComponent">();
	}
	static class UTslThrowableTrajectoryViewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslThrowableTrajectoryViewComponent>();
	}
};
static_assert(alignof(UTslThrowableTrajectoryViewComponent) == 0x000010, "Wrong alignment on UTslThrowableTrajectoryViewComponent");
static_assert(sizeof(UTslThrowableTrajectoryViewComponent) == 0x000880, "Wrong size on UTslThrowableTrajectoryViewComponent");
static_assert(offsetof(UTslThrowableTrajectoryViewComponent, SplineSegmentMesh) == 0x0007B0, "Member 'UTslThrowableTrajectoryViewComponent::SplineSegmentMesh' has a wrong offset!");
static_assert(offsetof(UTslThrowableTrajectoryViewComponent, SplineSegmentMeshMaterial) == 0x0007B8, "Member 'UTslThrowableTrajectoryViewComponent::SplineSegmentMeshMaterial' has a wrong offset!");
static_assert(offsetof(UTslThrowableTrajectoryViewComponent, SegmentMeshScale) == 0x0007C0, "Member 'UTslThrowableTrajectoryViewComponent::SegmentMeshScale' has a wrong offset!");
static_assert(offsetof(UTslThrowableTrajectoryViewComponent, ImpactMesh) == 0x0007C8, "Member 'UTslThrowableTrajectoryViewComponent::ImpactMesh' has a wrong offset!");
static_assert(offsetof(UTslThrowableTrajectoryViewComponent, ImpactMeshMaterial) == 0x0007D0, "Member 'UTslThrowableTrajectoryViewComponent::ImpactMeshMaterial' has a wrong offset!");
static_assert(offsetof(UTslThrowableTrajectoryViewComponent, ImpactMeshScale) == 0x0007D8, "Member 'UTslThrowableTrajectoryViewComponent::ImpactMeshScale' has a wrong offset!");
static_assert(offsetof(UTslThrowableTrajectoryViewComponent, TraceObjectTypes) == 0x0007E8, "Member 'UTslThrowableTrajectoryViewComponent::TraceObjectTypes' has a wrong offset!");
static_assert(offsetof(UTslThrowableTrajectoryViewComponent, PredictionTime) == 0x000838, "Member 'UTslThrowableTrajectoryViewComponent::PredictionTime' has a wrong offset!");
static_assert(offsetof(UTslThrowableTrajectoryViewComponent, DistanceScaleFactor) == 0x00083C, "Member 'UTslThrowableTrajectoryViewComponent::DistanceScaleFactor' has a wrong offset!");
static_assert(offsetof(UTslThrowableTrajectoryViewComponent, MaterialParam_NearDepthFadeOrigin) == 0x000840, "Member 'UTslThrowableTrajectoryViewComponent::MaterialParam_NearDepthFadeOrigin' has a wrong offset!");
static_assert(offsetof(UTslThrowableTrajectoryViewComponent, MaterialParam_FarDepthFadeOrigin) == 0x000848, "Member 'UTslThrowableTrajectoryViewComponent::MaterialParam_FarDepthFadeOrigin' has a wrong offset!");
static_assert(offsetof(UTslThrowableTrajectoryViewComponent, SplineGenerationAngThresholdDeg) == 0x000850, "Member 'UTslThrowableTrajectoryViewComponent::SplineGenerationAngThresholdDeg' has a wrong offset!");
static_assert(offsetof(UTslThrowableTrajectoryViewComponent, ImpactMeshComponent) == 0x000860, "Member 'UTslThrowableTrajectoryViewComponent::ImpactMeshComponent' has a wrong offset!");
static_assert(offsetof(UTslThrowableTrajectoryViewComponent, SplineMeshArray) == 0x000868, "Member 'UTslThrowableTrajectoryViewComponent::SplineMeshArray' has a wrong offset!");
static_assert(offsetof(UTslThrowableTrajectoryViewComponent, SplineSegmentMeshMaterialDynamic) == 0x000878, "Member 'UTslThrowableTrajectoryViewComponent::SplineSegmentMeshMaterialDynamic' has a wrong offset!");

// Class TslGame.TslBuoyancyForceComponent
// 0x0000 (0x03A0 - 0x03A0)
class UTslBuoyancyForceComponent final : public UBuoyancyForceComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslBuoyancyForceComponent">();
	}
	static class UTslBuoyancyForceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslBuoyancyForceComponent>();
	}
};
static_assert(alignof(UTslBuoyancyForceComponent) == 0x000008, "Wrong alignment on UTslBuoyancyForceComponent");
static_assert(sizeof(UTslBuoyancyForceComponent) == 0x0003A0, "Wrong size on UTslBuoyancyForceComponent");

// Class TslGame.TslCameraComponent
// 0x0010 (0x0870 - 0x0860)
class UTslCameraComponent final : public UCameraComponent
{
public:
	uint8                                         Pad_860[0x10];                                     // 0x0860(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslCameraComponent">();
	}
	static class UTslCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslCameraComponent>();
	}
};
static_assert(alignof(UTslCameraComponent) == 0x000010, "Wrong alignment on UTslCameraComponent");
static_assert(sizeof(UTslCameraComponent) == 0x000870, "Wrong size on UTslCameraComponent");

// Class TslGame.TslCharacterProxy
// 0x0030 (0x07F0 - 0x07C0)
class ATslCharacterProxy : public ACharacter
{
public:
	uint8                                         Pad_7C0[0x8];                                      // 0x07C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UWeaponClone*>                   ArmedWeapons;                                      // 0x07C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UWeaponAnimInfoComponent*               WeaponAnimInfoComponent;                           // 0x07D8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WeaponUpdateIntervalSeconds;                       // 0x07E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7E4[0xC];                                      // 0x07E4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAccessorySlot(class UTslAccessoryComponent* AccessoryComponent, EAccessorySlot Slot);
	void UpdateArmedWeapons();
	void UpdateCharacterAppearance();
	void UpdateEquippedWeapons();

	class UTslAccessoryComponent* GetAccessorySlot(EAccessorySlot Slot) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslCharacterProxy">();
	}
	static class ATslCharacterProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslCharacterProxy>();
	}
};
static_assert(alignof(ATslCharacterProxy) == 0x000010, "Wrong alignment on ATslCharacterProxy");
static_assert(sizeof(ATslCharacterProxy) == 0x0007F0, "Wrong size on ATslCharacterProxy");
static_assert(offsetof(ATslCharacterProxy, ArmedWeapons) == 0x0007C8, "Member 'ATslCharacterProxy::ArmedWeapons' has a wrong offset!");
static_assert(offsetof(ATslCharacterProxy, WeaponAnimInfoComponent) == 0x0007D8, "Member 'ATslCharacterProxy::WeaponAnimInfoComponent' has a wrong offset!");
static_assert(offsetof(ATslCharacterProxy, WeaponUpdateIntervalSeconds) == 0x0007E0, "Member 'ATslCharacterProxy::WeaponUpdateIntervalSeconds' has a wrong offset!");

// Class TslGame.TslUserWidget
// 0x0020 (0x0260 - 0x0240)
class UTslUserWidget : public UUserWidget
{
public:
	class UInputComponent*                        InputComponentAxis;                                // 0x0240(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, DuplicateTransient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATslCharacter*                          CachedTslCharacter;                                // 0x0248(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATslGameState*                          CachedTslGameState;                                // 0x0250(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATslCharacter*                          CachedViewTargetTslCharacter;                      // 0x0258(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ListenForInputAxis(class FName AxisName, float Scale, bool bConsume, TDelegate<void(float Scale)> Callback);
	void StopListeningForAllInputAxises();

	class ATslCharacter* GetCachedCharacter() const;
	class ATslGameState* GetCachedGameState() const;
	class ATslCharacter* GetCachedViewTargetTslCharacter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslUserWidget">();
	}
	static class UTslUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslUserWidget>();
	}
};
static_assert(alignof(UTslUserWidget) == 0x000008, "Wrong alignment on UTslUserWidget");
static_assert(sizeof(UTslUserWidget) == 0x000260, "Wrong size on UTslUserWidget");
static_assert(offsetof(UTslUserWidget, InputComponentAxis) == 0x000240, "Member 'UTslUserWidget::InputComponentAxis' has a wrong offset!");
static_assert(offsetof(UTslUserWidget, CachedTslCharacter) == 0x000248, "Member 'UTslUserWidget::CachedTslCharacter' has a wrong offset!");
static_assert(offsetof(UTslUserWidget, CachedTslGameState) == 0x000250, "Member 'UTslUserWidget::CachedTslGameState' has a wrong offset!");
static_assert(offsetof(UTslUserWidget, CachedViewTargetTslCharacter) == 0x000258, "Member 'UTslUserWidget::CachedViewTargetTslCharacter' has a wrong offset!");

// Class TslGame.UmgBaseWidget
// 0x0018 (0x0278 - 0x0260)
class UUmgBaseWidget : public UTslUserWidget
{
public:
	uint8                                         Pad_260[0x18];                                     // 0x0260(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleMainPrepass(class UWidget* Widget);

	bool IsMouseOn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UmgBaseWidget">();
	}
	static class UUmgBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUmgBaseWidget>();
	}
};
static_assert(alignof(UUmgBaseWidget) == 0x000008, "Wrong alignment on UUmgBaseWidget");
static_assert(sizeof(UUmgBaseWidget) == 0x000278, "Wrong size on UUmgBaseWidget");

// Class TslGame.BluezoneGpsBaseWidget
// 0x0370 (0x05E8 - 0x0278)
class UBluezoneGpsBaseWidget : public UUmgBaseWidget
{
public:
	struct FUmgWidgetBinder_Image                 BluezoneGaugeImageBinder;                          // 0x0278(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_TextBlock             BluezoneTimeTextBinder;                            // 0x02A0(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Image                 PlayerIconImageBinder;                             // 0x02C0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Animation             MovingAnimationBinder;                             // 0x02E8(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FUmgWidgetBinder_Animation>     WarningAnimationList;                              // 0x0308(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FUmgWidgetBinder_Animation>     ReleasingTextAnimationList;                        // 0x0318(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Animation             EnterNextPlayzoneAnimBinder;                       // 0x0328(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Animation             LeaveNextPlayzoneAnimBinder;                       // 0x0348(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Animation             WidgetEmergingAnimBinder;                          // 0x0368(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Animation             WidgetVanishingAminBinder;                         // 0x0388(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   PlayZoneStartParmName;                             // 0x03A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BluezoneEndParamName;                              // 0x03B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ColorMultiplyParmName;                             // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           InNextPlayzoneColorMultiply;                       // 0x03C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FText                                   WarningTimeTextFormat;                             // 0x03D0(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ReleaseTimeText;                                   // 0x03E8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSequence_Float                        BluezoneResetSequence;                             // 0x0400(0x00A0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSequence_Float                        PlayzoneResetSequence;                             // 0x04A0(0x00A0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSequence_Float                        PlayerIconResetSequence;                           // 0x0540(0x00A0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E0[0x8];                                      // 0x05E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnNotifyNextGasIn(const struct FVector& PoisonGasWarningPosition, float PoisonGasWarningRadius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BluezoneGpsBaseWidget">();
	}
	static class UBluezoneGpsBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBluezoneGpsBaseWidget>();
	}
};
static_assert(alignof(UBluezoneGpsBaseWidget) == 0x000008, "Wrong alignment on UBluezoneGpsBaseWidget");
static_assert(sizeof(UBluezoneGpsBaseWidget) == 0x0005E8, "Wrong size on UBluezoneGpsBaseWidget");
static_assert(offsetof(UBluezoneGpsBaseWidget, BluezoneGaugeImageBinder) == 0x000278, "Member 'UBluezoneGpsBaseWidget::BluezoneGaugeImageBinder' has a wrong offset!");
static_assert(offsetof(UBluezoneGpsBaseWidget, BluezoneTimeTextBinder) == 0x0002A0, "Member 'UBluezoneGpsBaseWidget::BluezoneTimeTextBinder' has a wrong offset!");
static_assert(offsetof(UBluezoneGpsBaseWidget, PlayerIconImageBinder) == 0x0002C0, "Member 'UBluezoneGpsBaseWidget::PlayerIconImageBinder' has a wrong offset!");
static_assert(offsetof(UBluezoneGpsBaseWidget, MovingAnimationBinder) == 0x0002E8, "Member 'UBluezoneGpsBaseWidget::MovingAnimationBinder' has a wrong offset!");
static_assert(offsetof(UBluezoneGpsBaseWidget, WarningAnimationList) == 0x000308, "Member 'UBluezoneGpsBaseWidget::WarningAnimationList' has a wrong offset!");
static_assert(offsetof(UBluezoneGpsBaseWidget, ReleasingTextAnimationList) == 0x000318, "Member 'UBluezoneGpsBaseWidget::ReleasingTextAnimationList' has a wrong offset!");
static_assert(offsetof(UBluezoneGpsBaseWidget, EnterNextPlayzoneAnimBinder) == 0x000328, "Member 'UBluezoneGpsBaseWidget::EnterNextPlayzoneAnimBinder' has a wrong offset!");
static_assert(offsetof(UBluezoneGpsBaseWidget, LeaveNextPlayzoneAnimBinder) == 0x000348, "Member 'UBluezoneGpsBaseWidget::LeaveNextPlayzoneAnimBinder' has a wrong offset!");
static_assert(offsetof(UBluezoneGpsBaseWidget, WidgetEmergingAnimBinder) == 0x000368, "Member 'UBluezoneGpsBaseWidget::WidgetEmergingAnimBinder' has a wrong offset!");
static_assert(offsetof(UBluezoneGpsBaseWidget, WidgetVanishingAminBinder) == 0x000388, "Member 'UBluezoneGpsBaseWidget::WidgetVanishingAminBinder' has a wrong offset!");
static_assert(offsetof(UBluezoneGpsBaseWidget, PlayZoneStartParmName) == 0x0003A8, "Member 'UBluezoneGpsBaseWidget::PlayZoneStartParmName' has a wrong offset!");
static_assert(offsetof(UBluezoneGpsBaseWidget, BluezoneEndParamName) == 0x0003B0, "Member 'UBluezoneGpsBaseWidget::BluezoneEndParamName' has a wrong offset!");
static_assert(offsetof(UBluezoneGpsBaseWidget, ColorMultiplyParmName) == 0x0003B8, "Member 'UBluezoneGpsBaseWidget::ColorMultiplyParmName' has a wrong offset!");
static_assert(offsetof(UBluezoneGpsBaseWidget, InNextPlayzoneColorMultiply) == 0x0003C0, "Member 'UBluezoneGpsBaseWidget::InNextPlayzoneColorMultiply' has a wrong offset!");
static_assert(offsetof(UBluezoneGpsBaseWidget, WarningTimeTextFormat) == 0x0003D0, "Member 'UBluezoneGpsBaseWidget::WarningTimeTextFormat' has a wrong offset!");
static_assert(offsetof(UBluezoneGpsBaseWidget, ReleaseTimeText) == 0x0003E8, "Member 'UBluezoneGpsBaseWidget::ReleaseTimeText' has a wrong offset!");
static_assert(offsetof(UBluezoneGpsBaseWidget, BluezoneResetSequence) == 0x000400, "Member 'UBluezoneGpsBaseWidget::BluezoneResetSequence' has a wrong offset!");
static_assert(offsetof(UBluezoneGpsBaseWidget, PlayzoneResetSequence) == 0x0004A0, "Member 'UBluezoneGpsBaseWidget::PlayzoneResetSequence' has a wrong offset!");
static_assert(offsetof(UBluezoneGpsBaseWidget, PlayerIconResetSequence) == 0x000540, "Member 'UBluezoneGpsBaseWidget::PlayerIconResetSequence' has a wrong offset!");

// Class TslGame.TslCharacterSpringArmComponent
// 0x00D8 (0x0460 - 0x0388)
class UTslCharacterSpringArmComponent final : public USpringArmComponent
{
public:
	float                                         IndoorCheckDistance;                               // 0x0388(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         IndoorCheckTime;                                   // 0x038C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_390[0x4];                                      // 0x0390(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                DefaultSocketOffset;                               // 0x0394(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                IndoorSocketOffset;                                // 0x03A0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                LeanLeftDefaultSocketOffsetAddition;               // 0x03AC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                LeanRightDefaultSocketOffsetAddition;              // 0x03B8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                LeftShoulderAimingSocketOffset;                    // 0x03C4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                RightShoulderAimingSocketOffset;                   // 0x03D0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                LeanLeftAimedSocketOffsetAddition;                 // 0x03DC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                LeanRightAimedSocketOffsetAddition;                // 0x03E8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                SprintSocketOffsetAddition;                        // 0x03F4(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         CrouchSocketOffsetZAddition;                       // 0x0400(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CrouchSocketOffsetMovementZAddition;               // 0x0404(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ProneScoketOffsetZAddition;                        // 0x0408(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SocketOffsetInterpSpeed;                           // 0x040C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                DefaultTargetOffset;                               // 0x0410(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                IndoorTargetOffset;                                // 0x041C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FVector                                AimingTargetOffset;                                // 0x0428(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         TargetOffsetInterpSpeed;                           // 0x0434(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DefaultSpringArmLength;                            // 0x0438(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         IndoorSpringArmLength;                             // 0x043C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AimingSpringArmLength;                             // 0x0440(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BlockingCompressOffset;                            // 0x0444(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SpringArmLengthInterpSpeed;                        // 0x0448(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AimingSpringArmLengthInterpSpeed;                  // 0x044C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_450[0x4];                                      // 0x0450(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpringArmRestoreInterpSpeed;                       // 0x0454(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslCharacterSpringArmComponent">();
	}
	static class UTslCharacterSpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslCharacterSpringArmComponent>();
	}
};
static_assert(alignof(UTslCharacterSpringArmComponent) == 0x000008, "Wrong alignment on UTslCharacterSpringArmComponent");
static_assert(sizeof(UTslCharacterSpringArmComponent) == 0x000460, "Wrong size on UTslCharacterSpringArmComponent");
static_assert(offsetof(UTslCharacterSpringArmComponent, IndoorCheckDistance) == 0x000388, "Member 'UTslCharacterSpringArmComponent::IndoorCheckDistance' has a wrong offset!");
static_assert(offsetof(UTslCharacterSpringArmComponent, IndoorCheckTime) == 0x00038C, "Member 'UTslCharacterSpringArmComponent::IndoorCheckTime' has a wrong offset!");
static_assert(offsetof(UTslCharacterSpringArmComponent, DefaultSocketOffset) == 0x000394, "Member 'UTslCharacterSpringArmComponent::DefaultSocketOffset' has a wrong offset!");
static_assert(offsetof(UTslCharacterSpringArmComponent, IndoorSocketOffset) == 0x0003A0, "Member 'UTslCharacterSpringArmComponent::IndoorSocketOffset' has a wrong offset!");
static_assert(offsetof(UTslCharacterSpringArmComponent, LeanLeftDefaultSocketOffsetAddition) == 0x0003AC, "Member 'UTslCharacterSpringArmComponent::LeanLeftDefaultSocketOffsetAddition' has a wrong offset!");
static_assert(offsetof(UTslCharacterSpringArmComponent, LeanRightDefaultSocketOffsetAddition) == 0x0003B8, "Member 'UTslCharacterSpringArmComponent::LeanRightDefaultSocketOffsetAddition' has a wrong offset!");
static_assert(offsetof(UTslCharacterSpringArmComponent, LeftShoulderAimingSocketOffset) == 0x0003C4, "Member 'UTslCharacterSpringArmComponent::LeftShoulderAimingSocketOffset' has a wrong offset!");
static_assert(offsetof(UTslCharacterSpringArmComponent, RightShoulderAimingSocketOffset) == 0x0003D0, "Member 'UTslCharacterSpringArmComponent::RightShoulderAimingSocketOffset' has a wrong offset!");
static_assert(offsetof(UTslCharacterSpringArmComponent, LeanLeftAimedSocketOffsetAddition) == 0x0003DC, "Member 'UTslCharacterSpringArmComponent::LeanLeftAimedSocketOffsetAddition' has a wrong offset!");
static_assert(offsetof(UTslCharacterSpringArmComponent, LeanRightAimedSocketOffsetAddition) == 0x0003E8, "Member 'UTslCharacterSpringArmComponent::LeanRightAimedSocketOffsetAddition' has a wrong offset!");
static_assert(offsetof(UTslCharacterSpringArmComponent, SprintSocketOffsetAddition) == 0x0003F4, "Member 'UTslCharacterSpringArmComponent::SprintSocketOffsetAddition' has a wrong offset!");
static_assert(offsetof(UTslCharacterSpringArmComponent, CrouchSocketOffsetZAddition) == 0x000400, "Member 'UTslCharacterSpringArmComponent::CrouchSocketOffsetZAddition' has a wrong offset!");
static_assert(offsetof(UTslCharacterSpringArmComponent, CrouchSocketOffsetMovementZAddition) == 0x000404, "Member 'UTslCharacterSpringArmComponent::CrouchSocketOffsetMovementZAddition' has a wrong offset!");
static_assert(offsetof(UTslCharacterSpringArmComponent, ProneScoketOffsetZAddition) == 0x000408, "Member 'UTslCharacterSpringArmComponent::ProneScoketOffsetZAddition' has a wrong offset!");
static_assert(offsetof(UTslCharacterSpringArmComponent, SocketOffsetInterpSpeed) == 0x00040C, "Member 'UTslCharacterSpringArmComponent::SocketOffsetInterpSpeed' has a wrong offset!");
static_assert(offsetof(UTslCharacterSpringArmComponent, DefaultTargetOffset) == 0x000410, "Member 'UTslCharacterSpringArmComponent::DefaultTargetOffset' has a wrong offset!");
static_assert(offsetof(UTslCharacterSpringArmComponent, IndoorTargetOffset) == 0x00041C, "Member 'UTslCharacterSpringArmComponent::IndoorTargetOffset' has a wrong offset!");
static_assert(offsetof(UTslCharacterSpringArmComponent, AimingTargetOffset) == 0x000428, "Member 'UTslCharacterSpringArmComponent::AimingTargetOffset' has a wrong offset!");
static_assert(offsetof(UTslCharacterSpringArmComponent, TargetOffsetInterpSpeed) == 0x000434, "Member 'UTslCharacterSpringArmComponent::TargetOffsetInterpSpeed' has a wrong offset!");
static_assert(offsetof(UTslCharacterSpringArmComponent, DefaultSpringArmLength) == 0x000438, "Member 'UTslCharacterSpringArmComponent::DefaultSpringArmLength' has a wrong offset!");
static_assert(offsetof(UTslCharacterSpringArmComponent, IndoorSpringArmLength) == 0x00043C, "Member 'UTslCharacterSpringArmComponent::IndoorSpringArmLength' has a wrong offset!");
static_assert(offsetof(UTslCharacterSpringArmComponent, AimingSpringArmLength) == 0x000440, "Member 'UTslCharacterSpringArmComponent::AimingSpringArmLength' has a wrong offset!");
static_assert(offsetof(UTslCharacterSpringArmComponent, BlockingCompressOffset) == 0x000444, "Member 'UTslCharacterSpringArmComponent::BlockingCompressOffset' has a wrong offset!");
static_assert(offsetof(UTslCharacterSpringArmComponent, SpringArmLengthInterpSpeed) == 0x000448, "Member 'UTslCharacterSpringArmComponent::SpringArmLengthInterpSpeed' has a wrong offset!");
static_assert(offsetof(UTslCharacterSpringArmComponent, AimingSpringArmLengthInterpSpeed) == 0x00044C, "Member 'UTslCharacterSpringArmComponent::AimingSpringArmLengthInterpSpeed' has a wrong offset!");
static_assert(offsetof(UTslCharacterSpringArmComponent, SpringArmRestoreInterpSpeed) == 0x000454, "Member 'UTslCharacterSpringArmComponent::SpringArmRestoreInterpSpeed' has a wrong offset!");

// Class TslGame.TslCharacterValidateLocationComponent
// 0x0028 (0x0120 - 0x00F8)
class UTslCharacterValidateLocationComponent final : public UActorComponent
{
public:
	float                                         ValidLocationCacheInterval;                        // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FC[0x10];                                      // 0x00FC(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InvalidUndergroundCheckInterval;                   // 0x010C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x4];                                      // 0x0110(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InvalidUndergroundCheckLength;                     // 0x0114(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxAdjustRange;                                    // 0x0118(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaxAdjustCount;                                    // 0x011C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslCharacterValidateLocationComponent">();
	}
	static class UTslCharacterValidateLocationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslCharacterValidateLocationComponent>();
	}
};
static_assert(alignof(UTslCharacterValidateLocationComponent) == 0x000008, "Wrong alignment on UTslCharacterValidateLocationComponent");
static_assert(sizeof(UTslCharacterValidateLocationComponent) == 0x000120, "Wrong size on UTslCharacterValidateLocationComponent");
static_assert(offsetof(UTslCharacterValidateLocationComponent, ValidLocationCacheInterval) == 0x0000F8, "Member 'UTslCharacterValidateLocationComponent::ValidLocationCacheInterval' has a wrong offset!");
static_assert(offsetof(UTslCharacterValidateLocationComponent, InvalidUndergroundCheckInterval) == 0x00010C, "Member 'UTslCharacterValidateLocationComponent::InvalidUndergroundCheckInterval' has a wrong offset!");
static_assert(offsetof(UTslCharacterValidateLocationComponent, InvalidUndergroundCheckLength) == 0x000114, "Member 'UTslCharacterValidateLocationComponent::InvalidUndergroundCheckLength' has a wrong offset!");
static_assert(offsetof(UTslCharacterValidateLocationComponent, MaxAdjustRange) == 0x000118, "Member 'UTslCharacterValidateLocationComponent::MaxAdjustRange' has a wrong offset!");
static_assert(offsetof(UTslCharacterValidateLocationComponent, MaxAdjustCount) == 0x00011C, "Member 'UTslCharacterValidateLocationComponent::MaxAdjustCount' has a wrong offset!");

// Class TslGame.FppWeaponSlotHudBaseWidget
// 0x0000 (0x0278 - 0x0278)
class UFppWeaponSlotHudBaseWidget : public UUmgBaseWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FppWeaponSlotHudBaseWidget">();
	}
	static class UFppWeaponSlotHudBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFppWeaponSlotHudBaseWidget>();
	}
};
static_assert(alignof(UFppWeaponSlotHudBaseWidget) == 0x000008, "Wrong alignment on UFppWeaponSlotHudBaseWidget");
static_assert(sizeof(UFppWeaponSlotHudBaseWidget) == 0x000278, "Wrong size on UFppWeaponSlotHudBaseWidget");

// Class TslGame.TslChatWidgetStyle
// 0x0988 (0x09B8 - 0x0030)
class UTslChatWidgetStyle final : public USlateWidgetStyleContainerBase
{
public:
	struct FTslChatStyle                          ChatStyle;                                         // 0x0030(0x0988)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslChatWidgetStyle">();
	}
	static class UTslChatWidgetStyle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslChatWidgetStyle>();
	}
};
static_assert(alignof(UTslChatWidgetStyle) == 0x000008, "Wrong alignment on UTslChatWidgetStyle");
static_assert(sizeof(UTslChatWidgetStyle) == 0x0009B8, "Wrong size on UTslChatWidgetStyle");
static_assert(offsetof(UTslChatWidgetStyle, ChatStyle) == 0x000030, "Member 'UTslChatWidgetStyle::ChatStyle' has a wrong offset!");

// Class TslGame.BlockInputUserWidget
// 0x0030 (0x0290 - 0x0260)
class UBlockInputUserWidget : public UTslUserWidget
{
public:
	bool                                          bWhiteList;                                        // 0x0260(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBlockAction>                   BlockActions;                                      // 0x0268(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class FName>                           BlockAxises;                                       // 0x0278(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	bool                                          bGenerateEventOnOpen;                              // 0x0288(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlockInputUserWidget">();
	}
	static class UBlockInputUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlockInputUserWidget>();
	}
};
static_assert(alignof(UBlockInputUserWidget) == 0x000008, "Wrong alignment on UBlockInputUserWidget");
static_assert(sizeof(UBlockInputUserWidget) == 0x000290, "Wrong size on UBlockInputUserWidget");
static_assert(offsetof(UBlockInputUserWidget, bWhiteList) == 0x000260, "Member 'UBlockInputUserWidget::bWhiteList' has a wrong offset!");
static_assert(offsetof(UBlockInputUserWidget, BlockActions) == 0x000268, "Member 'UBlockInputUserWidget::BlockActions' has a wrong offset!");
static_assert(offsetof(UBlockInputUserWidget, BlockAxises) == 0x000278, "Member 'UBlockInputUserWidget::BlockAxises' has a wrong offset!");
static_assert(offsetof(UBlockInputUserWidget, bGenerateEventOnOpen) == 0x000288, "Member 'UBlockInputUserWidget::bGenerateEventOnOpen' has a wrong offset!");

// Class TslGame.TslCheatManager
// 0x0010 (0x0088 - 0x0078)
class UTslCheatManager final : public UCheatManager
{
public:
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeTeam(int32 NewTeamNumber);
	void Cheat(const class FString& Msg);
	void CopyDebugInfo();
	void CtrlShortCutOnOff(bool OnOff);
	void DelayCrash(float DelaySeconds);
	void DrawVehicleCenterOfMass();
	void DumpDestructibleComponents();
	void DumpReplicatedItems();
	void DumpVoiceDevices();
	void ForceMatchStart();
	void InsertCrashMeCommand();
	void LookAt(float Pitch, float Yaw, float Roll);
	void MoveVehicleOnClient(float X, float Y, float Z);
	void ReturnLookAt();
	void SetClientConnectionTimeout(float TimeoutSeconds);
	void SetSpectatorYawAndPitch(float Yaw, float Pitch, float RevertSmoothSpeed);
	void SetVehicleRepPosCorrection(float LinearDeltaThresholdSq, float LinearInterpAlpha, float LinearRecipFixTime, float BodySpeedThresholdSq);
	void SetVehicleRepRotCorrection(float AngularDeltaThreshold, float AngularInterpAlpha, float AngularRecipFixTime);
	void SpawnBot();
	void TestVoiceAccessToken();
	void ToggleCollisionOfDestructibleComponents();
	void ToggleMatchTimer();
	void ToggleVisibilityOfDestructibleComponents();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslCheatManager">();
	}
	static class UTslCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslCheatManager>();
	}
};
static_assert(alignof(UTslCheatManager) == 0x000008, "Wrong alignment on UTslCheatManager");
static_assert(sizeof(UTslCheatManager) == 0x000088, "Wrong size on UTslCheatManager");

// Class TslGame.TslCoherentWidget
// 0x0018 (0x0470 - 0x0458)
class UTslCoherentWidget final : public UCoherentUIGTWidget
{
public:
	TSubclassOf<class UCoherentWidgetBinder>      WidgetBinderClass;                                 // 0x0458(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCoherentWidgetBinder*                  WidgetBinder;                                      // 0x0460(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_468[0x8];                                      // 0x0468(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GoBack();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslCoherentWidget">();
	}
	static class UTslCoherentWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslCoherentWidget>();
	}
};
static_assert(alignof(UTslCoherentWidget) == 0x000008, "Wrong alignment on UTslCoherentWidget");
static_assert(sizeof(UTslCoherentWidget) == 0x000470, "Wrong size on UTslCoherentWidget");
static_assert(offsetof(UTslCoherentWidget, WidgetBinderClass) == 0x000458, "Member 'UTslCoherentWidget::WidgetBinderClass' has a wrong offset!");
static_assert(offsetof(UTslCoherentWidget, WidgetBinder) == 0x000460, "Member 'UTslCoherentWidget::WidgetBinder' has a wrong offset!");

// Class TslGame.KillCountBaseWidget
// 0x0090 (0x0308 - 0x0278)
class UKillCountBaseWidget : public UUmgBaseWidget
{
public:
	struct FUmgWidgetBinder_TextBlock             KillCountTextBinder;                               // 0x0278(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Animation             KillCountEmergingAnimBinder;                       // 0x0298(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Animation             KillCountVanishingAnimBinder;                      // 0x02B8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Animation             IncreasingAnimBinder;                              // 0x02D8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         IncreasingKillCountDisplayTime;                    // 0x02F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         LastKillCount;                                     // 0x02FC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bLastWantShow;                                     // 0x0300(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_301[0x3];                                      // 0x0301(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IncreasingKillCountDisplayStartTime;               // 0x0304(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnUpdateKillCount(int32 NewKillCount);

	int32 GetLastKillCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillCountBaseWidget">();
	}
	static class UKillCountBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillCountBaseWidget>();
	}
};
static_assert(alignof(UKillCountBaseWidget) == 0x000008, "Wrong alignment on UKillCountBaseWidget");
static_assert(sizeof(UKillCountBaseWidget) == 0x000308, "Wrong size on UKillCountBaseWidget");
static_assert(offsetof(UKillCountBaseWidget, KillCountTextBinder) == 0x000278, "Member 'UKillCountBaseWidget::KillCountTextBinder' has a wrong offset!");
static_assert(offsetof(UKillCountBaseWidget, KillCountEmergingAnimBinder) == 0x000298, "Member 'UKillCountBaseWidget::KillCountEmergingAnimBinder' has a wrong offset!");
static_assert(offsetof(UKillCountBaseWidget, KillCountVanishingAnimBinder) == 0x0002B8, "Member 'UKillCountBaseWidget::KillCountVanishingAnimBinder' has a wrong offset!");
static_assert(offsetof(UKillCountBaseWidget, IncreasingAnimBinder) == 0x0002D8, "Member 'UKillCountBaseWidget::IncreasingAnimBinder' has a wrong offset!");
static_assert(offsetof(UKillCountBaseWidget, IncreasingKillCountDisplayTime) == 0x0002F8, "Member 'UKillCountBaseWidget::IncreasingKillCountDisplayTime' has a wrong offset!");
static_assert(offsetof(UKillCountBaseWidget, LastKillCount) == 0x0002FC, "Member 'UKillCountBaseWidget::LastKillCount' has a wrong offset!");
static_assert(offsetof(UKillCountBaseWidget, bLastWantShow) == 0x000300, "Member 'UKillCountBaseWidget::bLastWantShow' has a wrong offset!");
static_assert(offsetof(UKillCountBaseWidget, IncreasingKillCountDisplayStartTime) == 0x000304, "Member 'UKillCountBaseWidget::IncreasingKillCountDisplayStartTime' has a wrong offset!");

// Class TslGame.TslConsole
// 0x0008 (0x0138 - 0x0130)
class UTslConsole final : public UConsole
{
public:
	uint8                                         Pad_130[0x8];                                      // 0x0130(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslConsole">();
	}
	static class UTslConsole* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslConsole>();
	}
};
static_assert(alignof(UTslConsole) == 0x000008, "Wrong alignment on UTslConsole");
static_assert(sizeof(UTslConsole) == 0x000138, "Wrong size on UTslConsole");

// Class TslGame.TslConsoleSetting
// 0x0090 (0x0100 - 0x0070)
class UTslConsoleSetting final : public UConsoleSettings
{
public:
	TArray<class FString>                         AutoCompleteItemPaths;                             // 0x0070(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         AutoCompleteItemKinds;                             // 0x0080(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         AutoCompleteVehiclePaths;                          // 0x0090(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         AutoCompleteMaleBody;                              // 0x00A0(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         AutoCompleteMaleHair;                              // 0x00B0(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         AutoCompleteMaleFace;                              // 0x00C0(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         AutoCompleteFemaleBody;                            // 0x00D0(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         AutoCompleteFemaleHair;                            // 0x00E0(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         AutoCompleteFemaleFace;                            // 0x00F0(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslConsoleSetting">();
	}
	static class UTslConsoleSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslConsoleSetting>();
	}
};
static_assert(alignof(UTslConsoleSetting) == 0x000008, "Wrong alignment on UTslConsoleSetting");
static_assert(sizeof(UTslConsoleSetting) == 0x000100, "Wrong size on UTslConsoleSetting");
static_assert(offsetof(UTslConsoleSetting, AutoCompleteItemPaths) == 0x000070, "Member 'UTslConsoleSetting::AutoCompleteItemPaths' has a wrong offset!");
static_assert(offsetof(UTslConsoleSetting, AutoCompleteItemKinds) == 0x000080, "Member 'UTslConsoleSetting::AutoCompleteItemKinds' has a wrong offset!");
static_assert(offsetof(UTslConsoleSetting, AutoCompleteVehiclePaths) == 0x000090, "Member 'UTslConsoleSetting::AutoCompleteVehiclePaths' has a wrong offset!");
static_assert(offsetof(UTslConsoleSetting, AutoCompleteMaleBody) == 0x0000A0, "Member 'UTslConsoleSetting::AutoCompleteMaleBody' has a wrong offset!");
static_assert(offsetof(UTslConsoleSetting, AutoCompleteMaleHair) == 0x0000B0, "Member 'UTslConsoleSetting::AutoCompleteMaleHair' has a wrong offset!");
static_assert(offsetof(UTslConsoleSetting, AutoCompleteMaleFace) == 0x0000C0, "Member 'UTslConsoleSetting::AutoCompleteMaleFace' has a wrong offset!");
static_assert(offsetof(UTslConsoleSetting, AutoCompleteFemaleBody) == 0x0000D0, "Member 'UTslConsoleSetting::AutoCompleteFemaleBody' has a wrong offset!");
static_assert(offsetof(UTslConsoleSetting, AutoCompleteFemaleHair) == 0x0000E0, "Member 'UTslConsoleSetting::AutoCompleteFemaleHair' has a wrong offset!");
static_assert(offsetof(UTslConsoleSetting, AutoCompleteFemaleFace) == 0x0000F0, "Member 'UTslConsoleSetting::AutoCompleteFemaleFace' has a wrong offset!");

// Class TslGame.TslCustomizableSkeletalComponent
// 0x0000 (0x03C0 - 0x03C0)
class UTslCustomizableSkeletalComponent final : public UCustomizableSkeletalComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslCustomizableSkeletalComponent">();
	}
	static class UTslCustomizableSkeletalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslCustomizableSkeletalComponent>();
	}
};
static_assert(alignof(UTslCustomizableSkeletalComponent) == 0x000008, "Wrong alignment on UTslCustomizableSkeletalComponent");
static_assert(sizeof(UTslCustomizableSkeletalComponent) == 0x0003C0, "Wrong size on UTslCustomizableSkeletalComponent");

// Class TslGame.TslDamageField
// 0x0038 (0x03D8 - 0x03A0)
class ATslDamageField final : public AActor
{
public:
	uint8                                         Pad_3A0[0x4];                                      // 0x03A0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageRadius;                                      // 0x03A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        DamageFieldFX;                                     // 0x03A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage;                                            // 0x03B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DamageInterval;                                    // 0x03B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x03B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C0[0x10];                                     // 0x03C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATslBuff>                   DebuffTemplate;                                    // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslDamageField">();
	}
	static class ATslDamageField* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslDamageField>();
	}
};
static_assert(alignof(ATslDamageField) == 0x000008, "Wrong alignment on ATslDamageField");
static_assert(sizeof(ATslDamageField) == 0x0003D8, "Wrong size on ATslDamageField");
static_assert(offsetof(ATslDamageField, DamageRadius) == 0x0003A4, "Member 'ATslDamageField::DamageRadius' has a wrong offset!");
static_assert(offsetof(ATslDamageField, DamageFieldFX) == 0x0003A8, "Member 'ATslDamageField::DamageFieldFX' has a wrong offset!");
static_assert(offsetof(ATslDamageField, Damage) == 0x0003B0, "Member 'ATslDamageField::Damage' has a wrong offset!");
static_assert(offsetof(ATslDamageField, DamageInterval) == 0x0003B4, "Member 'ATslDamageField::DamageInterval' has a wrong offset!");
static_assert(offsetof(ATslDamageField, DamageType) == 0x0003B8, "Member 'ATslDamageField::DamageType' has a wrong offset!");
static_assert(offsetof(ATslDamageField, DebuffTemplate) == 0x0003D0, "Member 'ATslDamageField::DebuffTemplate' has a wrong offset!");

// Class TslGame.TslDamageFieldContainer
// 0x0040 (0x03E0 - 0x03A0)
class ATslDamageFieldContainer final : public AActor
{
public:
	uint8                                         Pad_3A0[0x8];                                      // 0x03A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FDamageFieldLayout>             DamageFieldLayouts;                                // 0x03A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B8[0x8];                                      // 0x03B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATslDamageField>            DamageFieldTemplate;                               // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          FlameInWall;                                       // 0x03C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C9[0x3];                                      // 0x03C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FlameMaxCountInWall;                               // 0x03CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FlameDelayInWall;                                  // 0x03D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D4[0xC];                                      // 0x03D4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslDamageFieldContainer">();
	}
	static class ATslDamageFieldContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslDamageFieldContainer>();
	}
};
static_assert(alignof(ATslDamageFieldContainer) == 0x000008, "Wrong alignment on ATslDamageFieldContainer");
static_assert(sizeof(ATslDamageFieldContainer) == 0x0003E0, "Wrong size on ATslDamageFieldContainer");
static_assert(offsetof(ATslDamageFieldContainer, DamageFieldLayouts) == 0x0003A8, "Member 'ATslDamageFieldContainer::DamageFieldLayouts' has a wrong offset!");
static_assert(offsetof(ATslDamageFieldContainer, DamageFieldTemplate) == 0x0003C0, "Member 'ATslDamageFieldContainer::DamageFieldTemplate' has a wrong offset!");
static_assert(offsetof(ATslDamageFieldContainer, FlameInWall) == 0x0003C8, "Member 'ATslDamageFieldContainer::FlameInWall' has a wrong offset!");
static_assert(offsetof(ATslDamageFieldContainer, FlameMaxCountInWall) == 0x0003CC, "Member 'ATslDamageFieldContainer::FlameMaxCountInWall' has a wrong offset!");
static_assert(offsetof(ATslDamageFieldContainer, FlameDelayInWall) == 0x0003D0, "Member 'ATslDamageFieldContainer::FlameDelayInWall' has a wrong offset!");

// Class TslGame.VehicleWheelInfoBaseWidget
// 0x0068 (0x02E0 - 0x0278)
class UVehicleWheelInfoBaseWidget : public UUmgBaseWidget
{
public:
	int32                                         WheelIndex;                                        // 0x0278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUmgWidgetBinder_Image                 WheelImageBinder;                                  // 0x0280(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Image                 PunctureImageBinder;                               // 0x02A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class ATslWheeledVehicle*                     CachedVehiclePawn;                                 // 0x02D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTslWheeledVehicleMovement*             CachedVehicleMovement;                             // 0x02D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleWheelInfoBaseWidget">();
	}
	static class UVehicleWheelInfoBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleWheelInfoBaseWidget>();
	}
};
static_assert(alignof(UVehicleWheelInfoBaseWidget) == 0x000008, "Wrong alignment on UVehicleWheelInfoBaseWidget");
static_assert(sizeof(UVehicleWheelInfoBaseWidget) == 0x0002E0, "Wrong size on UVehicleWheelInfoBaseWidget");
static_assert(offsetof(UVehicleWheelInfoBaseWidget, WheelIndex) == 0x000278, "Member 'UVehicleWheelInfoBaseWidget::WheelIndex' has a wrong offset!");
static_assert(offsetof(UVehicleWheelInfoBaseWidget, WheelImageBinder) == 0x000280, "Member 'UVehicleWheelInfoBaseWidget::WheelImageBinder' has a wrong offset!");
static_assert(offsetof(UVehicleWheelInfoBaseWidget, PunctureImageBinder) == 0x0002A8, "Member 'UVehicleWheelInfoBaseWidget::PunctureImageBinder' has a wrong offset!");
static_assert(offsetof(UVehicleWheelInfoBaseWidget, CachedVehiclePawn) == 0x0002D0, "Member 'UVehicleWheelInfoBaseWidget::CachedVehiclePawn' has a wrong offset!");
static_assert(offsetof(UVehicleWheelInfoBaseWidget, CachedVehicleMovement) == 0x0002D8, "Member 'UVehicleWheelInfoBaseWidget::CachedVehicleMovement' has a wrong offset!");

// Class TslGame.TslDestructibleComponent
// 0x0000 (0x09C0 - 0x09C0)
class UTslDestructibleComponent final : public UDestructibleComponent
{
public:
	void ClientReceiveComponentDamage(float DamageAmount, const struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslDestructibleComponent">();
	}
	static class UTslDestructibleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslDestructibleComponent>();
	}
};
static_assert(alignof(UTslDestructibleComponent) == 0x000010, "Wrong alignment on UTslDestructibleComponent");
static_assert(sizeof(UTslDestructibleComponent) == 0x0009C0, "Wrong size on UTslDestructibleComponent");

// Class TslGame.TslDestructibleContainer
// 0x0008 (0x03A8 - 0x03A0)
class ATslDestructibleContainer final : public AActor
{
public:
	uint8                                         bFlag : 1;                                         // 0x03A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3A1[0x7];                                      // 0x03A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Flag();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslDestructibleContainer">();
	}
	static class ATslDestructibleContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslDestructibleContainer>();
	}
};
static_assert(alignof(ATslDestructibleContainer) == 0x000008, "Wrong alignment on ATslDestructibleContainer");
static_assert(sizeof(ATslDestructibleContainer) == 0x0003A8, "Wrong size on ATslDestructibleContainer");

// Class TslGame.TslDoor
// 0x0290 (0x0640 - 0x03B0)
class ATslDoor final : public AStaticMeshActor
{
public:
	class UStaticMeshComponent*                   DoorMeshComponent;                                 // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           AkSound;                                           // 0x03B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionComponent*                  Interaction;                                       // 0x03C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C8[0x20];                                     // 0x03C8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UDestructibleMesh*                      DoorDestructibleMesh;                              // 0x03E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDoorOpened : 1;                                   // 0x03F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bReverseRotation : 1;                              // 0x03F0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3F1[0x3];                                      // 0x03F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OpenAngle;                                         // 0x03F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          OpenSound;                                         // 0x03F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkAudioEvent*                          CloseSound;                                        // 0x0400(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            OpenCurve;                                         // 0x0408(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OpenCurveDuration;                                 // 0x0410(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_414[0x4];                                      // 0x0414(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CloseCurve;                                        // 0x0418(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CloseCurveDuration;                                // 0x0420(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PointDamageImpulse;                                // 0x0424(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PointDamageRadius;                                 // 0x0428(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BreakingRadius;                                    // 0x042C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BreakingImpulse;                                   // 0x0430(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BreakingMinDamage;                                 // 0x0434(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageAccumulateTimeout;                           // 0x0438(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_43C[0x4];                                      // 0x043C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TopImpactSoketName;                                // 0x0440(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CenterImpactSoketName;                             // 0x0448(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BottomImpactSoketName;                             // 0x0450(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_458[0x1C8];                                    // 0x0458(0x01C8)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDoorBreakingStateLegacy               DoorBreakingState;                                 // 0x0620(0x0001)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_621[0x1F];                                     // 0x0621(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientTakeDamage(float Damage, const struct FVector_NetQuantize& HitLocation, float DamageRadius, float Impulse);
	void OnInteractBy(class ATslCharacter* OtherCharacter);
	void OnRep_DoorBreakingState();
	void OnRep_DoorOpened();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslDoor">();
	}
	static class ATslDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslDoor>();
	}
};
static_assert(alignof(ATslDoor) == 0x000008, "Wrong alignment on ATslDoor");
static_assert(sizeof(ATslDoor) == 0x000640, "Wrong size on ATslDoor");
static_assert(offsetof(ATslDoor, DoorMeshComponent) == 0x0003B0, "Member 'ATslDoor::DoorMeshComponent' has a wrong offset!");
static_assert(offsetof(ATslDoor, AkSound) == 0x0003B8, "Member 'ATslDoor::AkSound' has a wrong offset!");
static_assert(offsetof(ATslDoor, Interaction) == 0x0003C0, "Member 'ATslDoor::Interaction' has a wrong offset!");
static_assert(offsetof(ATslDoor, DoorDestructibleMesh) == 0x0003E8, "Member 'ATslDoor::DoorDestructibleMesh' has a wrong offset!");
static_assert(offsetof(ATslDoor, OpenAngle) == 0x0003F4, "Member 'ATslDoor::OpenAngle' has a wrong offset!");
static_assert(offsetof(ATslDoor, OpenSound) == 0x0003F8, "Member 'ATslDoor::OpenSound' has a wrong offset!");
static_assert(offsetof(ATslDoor, CloseSound) == 0x000400, "Member 'ATslDoor::CloseSound' has a wrong offset!");
static_assert(offsetof(ATslDoor, OpenCurve) == 0x000408, "Member 'ATslDoor::OpenCurve' has a wrong offset!");
static_assert(offsetof(ATslDoor, OpenCurveDuration) == 0x000410, "Member 'ATslDoor::OpenCurveDuration' has a wrong offset!");
static_assert(offsetof(ATslDoor, CloseCurve) == 0x000418, "Member 'ATslDoor::CloseCurve' has a wrong offset!");
static_assert(offsetof(ATslDoor, CloseCurveDuration) == 0x000420, "Member 'ATslDoor::CloseCurveDuration' has a wrong offset!");
static_assert(offsetof(ATslDoor, PointDamageImpulse) == 0x000424, "Member 'ATslDoor::PointDamageImpulse' has a wrong offset!");
static_assert(offsetof(ATslDoor, PointDamageRadius) == 0x000428, "Member 'ATslDoor::PointDamageRadius' has a wrong offset!");
static_assert(offsetof(ATslDoor, BreakingRadius) == 0x00042C, "Member 'ATslDoor::BreakingRadius' has a wrong offset!");
static_assert(offsetof(ATslDoor, BreakingImpulse) == 0x000430, "Member 'ATslDoor::BreakingImpulse' has a wrong offset!");
static_assert(offsetof(ATslDoor, BreakingMinDamage) == 0x000434, "Member 'ATslDoor::BreakingMinDamage' has a wrong offset!");
static_assert(offsetof(ATslDoor, DamageAccumulateTimeout) == 0x000438, "Member 'ATslDoor::DamageAccumulateTimeout' has a wrong offset!");
static_assert(offsetof(ATslDoor, TopImpactSoketName) == 0x000440, "Member 'ATslDoor::TopImpactSoketName' has a wrong offset!");
static_assert(offsetof(ATslDoor, CenterImpactSoketName) == 0x000448, "Member 'ATslDoor::CenterImpactSoketName' has a wrong offset!");
static_assert(offsetof(ATslDoor, BottomImpactSoketName) == 0x000450, "Member 'ATslDoor::BottomImpactSoketName' has a wrong offset!");
static_assert(offsetof(ATslDoor, DoorBreakingState) == 0x000620, "Member 'ATslDoor::DoorBreakingState' has a wrong offset!");

// Class TslGame.TslEngine
// 0x0008 (0x0D50 - 0x0D48)
class UTslEngine final : public UGameEngine
{
public:
	float                                         ESportsServerMaxTickRate;                          // 0x0D48(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrameRateCap;                                      // 0x0D4C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslEngine">();
	}
	static class UTslEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslEngine>();
	}
};
static_assert(alignof(UTslEngine) == 0x000008, "Wrong alignment on UTslEngine");
static_assert(sizeof(UTslEngine) == 0x000D50, "Wrong size on UTslEngine");
static_assert(offsetof(UTslEngine, ESportsServerMaxTickRate) == 0x000D48, "Member 'UTslEngine::ESportsServerMaxTickRate' has a wrong offset!");
static_assert(offsetof(UTslEngine, FrameRateCap) == 0x000D4C, "Member 'UTslEngine::FrameRateCap' has a wrong offset!");

// Class TslGame.TslVehicleReactionInterface
// 0x0000 (0x0028 - 0x0028)
class ITslVehicleReactionInterface final : public IInterface
{
public:
	void OnImpactedByVehicle(const struct FHitResult& Hit, const struct FVector& Velocity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslVehicleReactionInterface">();
	}
	static class ITslVehicleReactionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITslVehicleReactionInterface>();
	}
};
static_assert(alignof(ITslVehicleReactionInterface) == 0x000008, "Wrong alignment on ITslVehicleReactionInterface");
static_assert(sizeof(ITslVehicleReactionInterface) == 0x000028, "Wrong size on ITslVehicleReactionInterface");

// Class TslGame.TslEntryGameMode
// 0x0000 (0x0470 - 0x0470)
class ATslEntryGameMode : public AGameMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslEntryGameMode">();
	}
	static class ATslEntryGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslEntryGameMode>();
	}
};
static_assert(alignof(ATslEntryGameMode) == 0x000008, "Wrong alignment on ATslEntryGameMode");
static_assert(sizeof(ATslEntryGameMode) == 0x000470, "Wrong size on ATslEntryGameMode");

// Class TslGame.TslExplosionEffect
// 0x0228 (0x05C8 - 0x03A0)
class ATslExplosionEffect final : public AActor
{
public:
	class UParticleSystem*                        ExplosionFX;                                       // 0x03A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPointLightComponent*                   ExplosionLight;                                    // 0x03A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ExplosionLightFadeOut;                             // 0x03B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B4[0x4];                                      // 0x03B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          ExplosionSound;                                    // 0x03B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDecalEffectDataSet                    DecalEffectDataSet;                                // 0x03C0(0x0168)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         DecalSpawnDelayTime;                               // 0x0528(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52C[0x4];                                      // 0x052C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SurfaceHit;                                        // 0x0530(0x0088)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B8[0x10];                                     // 0x05B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnParticleCollide(class FName EventName, float EmitterTime, int32 ParticleTime, const struct FVector& Location, const struct FVector& Velocity, const struct FVector& Direction, const struct FVector& Normal, class FName BoneName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslExplosionEffect">();
	}
	static class ATslExplosionEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslExplosionEffect>();
	}
};
static_assert(alignof(ATslExplosionEffect) == 0x000008, "Wrong alignment on ATslExplosionEffect");
static_assert(sizeof(ATslExplosionEffect) == 0x0005C8, "Wrong size on ATslExplosionEffect");
static_assert(offsetof(ATslExplosionEffect, ExplosionFX) == 0x0003A0, "Member 'ATslExplosionEffect::ExplosionFX' has a wrong offset!");
static_assert(offsetof(ATslExplosionEffect, ExplosionLight) == 0x0003A8, "Member 'ATslExplosionEffect::ExplosionLight' has a wrong offset!");
static_assert(offsetof(ATslExplosionEffect, ExplosionLightFadeOut) == 0x0003B0, "Member 'ATslExplosionEffect::ExplosionLightFadeOut' has a wrong offset!");
static_assert(offsetof(ATslExplosionEffect, ExplosionSound) == 0x0003B8, "Member 'ATslExplosionEffect::ExplosionSound' has a wrong offset!");
static_assert(offsetof(ATslExplosionEffect, DecalEffectDataSet) == 0x0003C0, "Member 'ATslExplosionEffect::DecalEffectDataSet' has a wrong offset!");
static_assert(offsetof(ATslExplosionEffect, DecalSpawnDelayTime) == 0x000528, "Member 'ATslExplosionEffect::DecalSpawnDelayTime' has a wrong offset!");
static_assert(offsetof(ATslExplosionEffect, SurfaceHit) == 0x000530, "Member 'ATslExplosionEffect::SurfaceHit' has a wrong offset!");

// Class TslGame.WeaponSlotBaseWidget
// 0x02F0 (0x0568 - 0x0278)
class UWeaponSlotBaseWidget : public UUmgBaseWidget
{
public:
	uint8                                         bListInSlot : 1;                                   // 0x0278(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_279[0x3];                                      // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         WeaponIndex;                                       // 0x027C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENoReloadGuideType                            ListSlotNoReloadGuideType;                         // 0x0280(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseWeaponIcon : 1;                                // 0x0281(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_282[0x6];                                      // 0x0282(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUmgWidgetBinder_Image                 WeaponIconImageBinder;                             // 0x0288(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_SizeBox               WeaponIconImageSizeBoxBinder;                      // 0x02B0(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         WeaponIconImageSizeBoxHeight;                      // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WeaponIconTextureParmName;                         // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeaponIconColorParmName;                           // 0x02E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           WeaponColor_Normal;                                // 0x02E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           WeaponColor_Unarmed;                               // 0x02F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Animation             ScaleUpAnimBinder;                                 // 0x0308(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Animation             ScaleDownAnimBinder;                               // 0x0328(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FColorBlindColorSet                    WeaponColorSet_NoReload;                           // 0x0348(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         bUseAmmoTextAndIcon : 1;                           // 0x0358(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_359[0x7];                                      // 0x0359(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUmgWidgetBinder_TextBlock             WeaponHandsOnLoadedAmmoCountTextBinder;            // 0x0360(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_TextBlock             WeaponListLoadedAmmoCountTextBinder;               // 0x0380(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Animation             AmmoIncreasingAnimBinder;                          // 0x03A0(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Animation             AmmoDecreasingAnimBinder;                          // 0x03C0(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_TextBlock             WeaponHandsOnUnloadedAmmoCountTextBinder;          // 0x03E0(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Animation             UnloadedAmmoIncreasingAnimBinder;                  // 0x0400(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Animation             UnloadedAmmoDecreasingAnimBinder;                  // 0x0420(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Image                 WeaponHandsOnAmmoIconBinder;                       // 0x0440(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   AmmoTexParamName;                                  // 0x0468(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseWeaponFiringModeTextBinder : 1;                // 0x0470(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_471[0x7];                                      // 0x0471(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUmgWidgetBinder_TextBlock             WeaponFiringModeTextBinder;                        // 0x0478(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         bZeroingDistancebUseText : 1;                      // 0x0498(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_499[0x7];                                      // 0x0499(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUmgWidgetBinder_VerticalBox           ZeroingDistanceBlockBinder;                        // 0x04A0(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_TextBlock             ZeroingdistanceTextBinder;                         // 0x04C0(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Animation             ZeroDistIncreasingAnimBinder;                      // 0x04E0(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Animation             ZeroDistDecreasingAnimBinder;                      // 0x0500(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ZeroingTextFormat;                                 // 0x0520(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   ZeroingNA;                                         // 0x0538(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_550[0x18];                                     // 0x0550(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponSlotBaseWidget">();
	}
	static class UWeaponSlotBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponSlotBaseWidget>();
	}
};
static_assert(alignof(UWeaponSlotBaseWidget) == 0x000008, "Wrong alignment on UWeaponSlotBaseWidget");
static_assert(sizeof(UWeaponSlotBaseWidget) == 0x000568, "Wrong size on UWeaponSlotBaseWidget");
static_assert(offsetof(UWeaponSlotBaseWidget, WeaponIndex) == 0x00027C, "Member 'UWeaponSlotBaseWidget::WeaponIndex' has a wrong offset!");
static_assert(offsetof(UWeaponSlotBaseWidget, ListSlotNoReloadGuideType) == 0x000280, "Member 'UWeaponSlotBaseWidget::ListSlotNoReloadGuideType' has a wrong offset!");
static_assert(offsetof(UWeaponSlotBaseWidget, WeaponIconImageBinder) == 0x000288, "Member 'UWeaponSlotBaseWidget::WeaponIconImageBinder' has a wrong offset!");
static_assert(offsetof(UWeaponSlotBaseWidget, WeaponIconImageSizeBoxBinder) == 0x0002B0, "Member 'UWeaponSlotBaseWidget::WeaponIconImageSizeBoxBinder' has a wrong offset!");
static_assert(offsetof(UWeaponSlotBaseWidget, WeaponIconImageSizeBoxHeight) == 0x0002D0, "Member 'UWeaponSlotBaseWidget::WeaponIconImageSizeBoxHeight' has a wrong offset!");
static_assert(offsetof(UWeaponSlotBaseWidget, WeaponIconTextureParmName) == 0x0002D8, "Member 'UWeaponSlotBaseWidget::WeaponIconTextureParmName' has a wrong offset!");
static_assert(offsetof(UWeaponSlotBaseWidget, WeaponIconColorParmName) == 0x0002E0, "Member 'UWeaponSlotBaseWidget::WeaponIconColorParmName' has a wrong offset!");
static_assert(offsetof(UWeaponSlotBaseWidget, WeaponColor_Normal) == 0x0002E8, "Member 'UWeaponSlotBaseWidget::WeaponColor_Normal' has a wrong offset!");
static_assert(offsetof(UWeaponSlotBaseWidget, WeaponColor_Unarmed) == 0x0002F8, "Member 'UWeaponSlotBaseWidget::WeaponColor_Unarmed' has a wrong offset!");
static_assert(offsetof(UWeaponSlotBaseWidget, ScaleUpAnimBinder) == 0x000308, "Member 'UWeaponSlotBaseWidget::ScaleUpAnimBinder' has a wrong offset!");
static_assert(offsetof(UWeaponSlotBaseWidget, ScaleDownAnimBinder) == 0x000328, "Member 'UWeaponSlotBaseWidget::ScaleDownAnimBinder' has a wrong offset!");
static_assert(offsetof(UWeaponSlotBaseWidget, WeaponColorSet_NoReload) == 0x000348, "Member 'UWeaponSlotBaseWidget::WeaponColorSet_NoReload' has a wrong offset!");
static_assert(offsetof(UWeaponSlotBaseWidget, WeaponHandsOnLoadedAmmoCountTextBinder) == 0x000360, "Member 'UWeaponSlotBaseWidget::WeaponHandsOnLoadedAmmoCountTextBinder' has a wrong offset!");
static_assert(offsetof(UWeaponSlotBaseWidget, WeaponListLoadedAmmoCountTextBinder) == 0x000380, "Member 'UWeaponSlotBaseWidget::WeaponListLoadedAmmoCountTextBinder' has a wrong offset!");
static_assert(offsetof(UWeaponSlotBaseWidget, AmmoIncreasingAnimBinder) == 0x0003A0, "Member 'UWeaponSlotBaseWidget::AmmoIncreasingAnimBinder' has a wrong offset!");
static_assert(offsetof(UWeaponSlotBaseWidget, AmmoDecreasingAnimBinder) == 0x0003C0, "Member 'UWeaponSlotBaseWidget::AmmoDecreasingAnimBinder' has a wrong offset!");
static_assert(offsetof(UWeaponSlotBaseWidget, WeaponHandsOnUnloadedAmmoCountTextBinder) == 0x0003E0, "Member 'UWeaponSlotBaseWidget::WeaponHandsOnUnloadedAmmoCountTextBinder' has a wrong offset!");
static_assert(offsetof(UWeaponSlotBaseWidget, UnloadedAmmoIncreasingAnimBinder) == 0x000400, "Member 'UWeaponSlotBaseWidget::UnloadedAmmoIncreasingAnimBinder' has a wrong offset!");
static_assert(offsetof(UWeaponSlotBaseWidget, UnloadedAmmoDecreasingAnimBinder) == 0x000420, "Member 'UWeaponSlotBaseWidget::UnloadedAmmoDecreasingAnimBinder' has a wrong offset!");
static_assert(offsetof(UWeaponSlotBaseWidget, WeaponHandsOnAmmoIconBinder) == 0x000440, "Member 'UWeaponSlotBaseWidget::WeaponHandsOnAmmoIconBinder' has a wrong offset!");
static_assert(offsetof(UWeaponSlotBaseWidget, AmmoTexParamName) == 0x000468, "Member 'UWeaponSlotBaseWidget::AmmoTexParamName' has a wrong offset!");
static_assert(offsetof(UWeaponSlotBaseWidget, WeaponFiringModeTextBinder) == 0x000478, "Member 'UWeaponSlotBaseWidget::WeaponFiringModeTextBinder' has a wrong offset!");
static_assert(offsetof(UWeaponSlotBaseWidget, ZeroingDistanceBlockBinder) == 0x0004A0, "Member 'UWeaponSlotBaseWidget::ZeroingDistanceBlockBinder' has a wrong offset!");
static_assert(offsetof(UWeaponSlotBaseWidget, ZeroingdistanceTextBinder) == 0x0004C0, "Member 'UWeaponSlotBaseWidget::ZeroingdistanceTextBinder' has a wrong offset!");
static_assert(offsetof(UWeaponSlotBaseWidget, ZeroDistIncreasingAnimBinder) == 0x0004E0, "Member 'UWeaponSlotBaseWidget::ZeroDistIncreasingAnimBinder' has a wrong offset!");
static_assert(offsetof(UWeaponSlotBaseWidget, ZeroDistDecreasingAnimBinder) == 0x000500, "Member 'UWeaponSlotBaseWidget::ZeroDistDecreasingAnimBinder' has a wrong offset!");
static_assert(offsetof(UWeaponSlotBaseWidget, ZeroingTextFormat) == 0x000520, "Member 'UWeaponSlotBaseWidget::ZeroingTextFormat' has a wrong offset!");
static_assert(offsetof(UWeaponSlotBaseWidget, ZeroingNA) == 0x000538, "Member 'UWeaponSlotBaseWidget::ZeroingNA' has a wrong offset!");

// Class TslGame.TslExplosionReactionInterface
// 0x0000 (0x0028 - 0x0028)
class ITslExplosionReactionInterface final : public IInterface
{
public:
	void OnExplode(float DamageAmout, const struct FVector& Origin, const TArray<struct FHitResult>& ComponentHits, class AController* EventInstigator, class AActor* DamageCauser);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslExplosionReactionInterface">();
	}
	static class ITslExplosionReactionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITslExplosionReactionInterface>();
	}
};
static_assert(alignof(ITslExplosionReactionInterface) == 0x000008, "Wrong alignment on ITslExplosionReactionInterface");
static_assert(sizeof(ITslExplosionReactionInterface) == 0x000028, "Wrong size on ITslExplosionReactionInterface");

// Class TslGame.TslFence
// 0x0098 (0x0438 - 0x03A0)
class ATslFence : public AActor
{
public:
	class USplineComponent*                       SplineComponent;                                   // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETslFenceSelector                             BeginSelector;                                     // 0x03A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A9[0x7];                                      // 0x03A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            BeginMesh1;                                        // 0x03B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            BeginMesh2;                                        // 0x03B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            BeginMesh3;                                        // 0x03C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            BeginMesh4;                                        // 0x03C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETslFenceSelector                             EndSelector;                                       // 0x03D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D1[0x7];                                      // 0x03D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            EndMesh1;                                          // 0x03D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            EndMesh2;                                          // 0x03E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            EndMesh3;                                          // 0x03E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            EndMesh4;                                          // 0x03F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseRandomForMiddle;                               // 0x03F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F9[0x3];                                      // 0x03F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnitLengthForMiddle;                               // 0x03FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UnitSpacingForMiddle;                              // 0x0400(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PivotOffsetForMiddle;                              // 0x0404(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRandomStream                          RandomStreamForMiddle;                             // 0x0408(0x0008)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UStaticMesh*                            MiddleMesh1;                                       // 0x0410(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            MiddleMesh2;                                       // 0x0418(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            MiddleMesh3;                                       // 0x0420(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMesh*                            MiddleMesh4;                                       // 0x0428(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCollisionProfileName                  FenceCollisionProfile;                             // 0x0430(0x0008)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	class USplineComponent* GetSplineComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslFence">();
	}
	static class ATslFence* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslFence>();
	}
};
static_assert(alignof(ATslFence) == 0x000008, "Wrong alignment on ATslFence");
static_assert(sizeof(ATslFence) == 0x000438, "Wrong size on ATslFence");
static_assert(offsetof(ATslFence, SplineComponent) == 0x0003A0, "Member 'ATslFence::SplineComponent' has a wrong offset!");
static_assert(offsetof(ATslFence, BeginSelector) == 0x0003A8, "Member 'ATslFence::BeginSelector' has a wrong offset!");
static_assert(offsetof(ATslFence, BeginMesh1) == 0x0003B0, "Member 'ATslFence::BeginMesh1' has a wrong offset!");
static_assert(offsetof(ATslFence, BeginMesh2) == 0x0003B8, "Member 'ATslFence::BeginMesh2' has a wrong offset!");
static_assert(offsetof(ATslFence, BeginMesh3) == 0x0003C0, "Member 'ATslFence::BeginMesh3' has a wrong offset!");
static_assert(offsetof(ATslFence, BeginMesh4) == 0x0003C8, "Member 'ATslFence::BeginMesh4' has a wrong offset!");
static_assert(offsetof(ATslFence, EndSelector) == 0x0003D0, "Member 'ATslFence::EndSelector' has a wrong offset!");
static_assert(offsetof(ATslFence, EndMesh1) == 0x0003D8, "Member 'ATslFence::EndMesh1' has a wrong offset!");
static_assert(offsetof(ATslFence, EndMesh2) == 0x0003E0, "Member 'ATslFence::EndMesh2' has a wrong offset!");
static_assert(offsetof(ATslFence, EndMesh3) == 0x0003E8, "Member 'ATslFence::EndMesh3' has a wrong offset!");
static_assert(offsetof(ATslFence, EndMesh4) == 0x0003F0, "Member 'ATslFence::EndMesh4' has a wrong offset!");
static_assert(offsetof(ATslFence, bUseRandomForMiddle) == 0x0003F8, "Member 'ATslFence::bUseRandomForMiddle' has a wrong offset!");
static_assert(offsetof(ATslFence, UnitLengthForMiddle) == 0x0003FC, "Member 'ATslFence::UnitLengthForMiddle' has a wrong offset!");
static_assert(offsetof(ATslFence, UnitSpacingForMiddle) == 0x000400, "Member 'ATslFence::UnitSpacingForMiddle' has a wrong offset!");
static_assert(offsetof(ATslFence, PivotOffsetForMiddle) == 0x000404, "Member 'ATslFence::PivotOffsetForMiddle' has a wrong offset!");
static_assert(offsetof(ATslFence, RandomStreamForMiddle) == 0x000408, "Member 'ATslFence::RandomStreamForMiddle' has a wrong offset!");
static_assert(offsetof(ATslFence, MiddleMesh1) == 0x000410, "Member 'ATslFence::MiddleMesh1' has a wrong offset!");
static_assert(offsetof(ATslFence, MiddleMesh2) == 0x000418, "Member 'ATslFence::MiddleMesh2' has a wrong offset!");
static_assert(offsetof(ATslFence, MiddleMesh3) == 0x000420, "Member 'ATslFence::MiddleMesh3' has a wrong offset!");
static_assert(offsetof(ATslFence, MiddleMesh4) == 0x000428, "Member 'ATslFence::MiddleMesh4' has a wrong offset!");
static_assert(offsetof(ATslFence, FenceCollisionProfile) == 0x000430, "Member 'ATslFence::FenceCollisionProfile' has a wrong offset!");

// Class TslGame.TslTeamWidget
// 0x0038 (0x02B0 - 0x0278)
class UTslTeamWidget : public UUmgBaseWidget
{
public:
	TArray<class UTeamMarkWidget*>                TeamMarkWidgets;                                   // 0x0278(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UTeamMarkWidget>            TeamMarkWidgetClass;                               // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_CanvasPanel           TeamMarkerLayerBinder;                             // 0x0290(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslTeamWidget">();
	}
	static class UTslTeamWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslTeamWidget>();
	}
};
static_assert(alignof(UTslTeamWidget) == 0x000008, "Wrong alignment on UTslTeamWidget");
static_assert(sizeof(UTslTeamWidget) == 0x0002B0, "Wrong size on UTslTeamWidget");
static_assert(offsetof(UTslTeamWidget, TeamMarkWidgets) == 0x000278, "Member 'UTslTeamWidget::TeamMarkWidgets' has a wrong offset!");
static_assert(offsetof(UTslTeamWidget, TeamMarkWidgetClass) == 0x000288, "Member 'UTslTeamWidget::TeamMarkWidgetClass' has a wrong offset!");
static_assert(offsetof(UTslTeamWidget, TeamMarkerLayerBinder) == 0x000290, "Member 'UTslTeamWidget::TeamMarkerLayerBinder' has a wrong offset!");

// Class TslGame.TslReactionData
// 0x0040 (0x0068 - 0x0028)
class UTslReactionData final : public UDataAsset
{
public:
	float                                         DestroyDelay;                                      // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVehicleReactionData                   VehicleReactionData;                               // 0x002C(0x000C)(Edit, NativeAccessSpecifierPublic)
	struct FRadialDamageReactionData              RadialDamageReactionData;                          // 0x0038(0x000C)(Edit, NativeAccessSpecifierPublic)
	struct FPointDamageReactionData               PointDamageReactionData;                           // 0x0044(0x0010)(Edit, NativeAccessSpecifierPublic)
	int32                                         DependancyCountBySibling;                          // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          PhysicsReactionSoundAk;                            // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          DestructibleReactionSoundAk;                       // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslReactionData">();
	}
	static class UTslReactionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslReactionData>();
	}
};
static_assert(alignof(UTslReactionData) == 0x000008, "Wrong alignment on UTslReactionData");
static_assert(sizeof(UTslReactionData) == 0x000068, "Wrong size on UTslReactionData");
static_assert(offsetof(UTslReactionData, DestroyDelay) == 0x000028, "Member 'UTslReactionData::DestroyDelay' has a wrong offset!");
static_assert(offsetof(UTslReactionData, VehicleReactionData) == 0x00002C, "Member 'UTslReactionData::VehicleReactionData' has a wrong offset!");
static_assert(offsetof(UTslReactionData, RadialDamageReactionData) == 0x000038, "Member 'UTslReactionData::RadialDamageReactionData' has a wrong offset!");
static_assert(offsetof(UTslReactionData, PointDamageReactionData) == 0x000044, "Member 'UTslReactionData::PointDamageReactionData' has a wrong offset!");
static_assert(offsetof(UTslReactionData, DependancyCountBySibling) == 0x000054, "Member 'UTslReactionData::DependancyCountBySibling' has a wrong offset!");
static_assert(offsetof(UTslReactionData, PhysicsReactionSoundAk) == 0x000058, "Member 'UTslReactionData::PhysicsReactionSoundAk' has a wrong offset!");
static_assert(offsetof(UTslReactionData, DestructibleReactionSoundAk) == 0x000060, "Member 'UTslReactionData::DestructibleReactionSoundAk' has a wrong offset!");

// Class TslGame.TslReactionComponent
// 0x0040 (0x0850 - 0x0810)
class UTslReactionComponent final : public UStaticMeshComponent
{
public:
	uint8                                         bPendingDestroy : 1;                               // 0x0808(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_809[0x7];                                      // 0x0809(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTslReactionData*                       ReactionData;                                      // 0x0810(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDestructibleMesh*                      ReactionDM;                                        // 0x0818(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_820[0x30];                                     // 0x0820(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_ReactByPointDamage(float DamageAmount, const struct FVector& Impact, const struct FVector& ImpulseDir);
	void Client_ReactByRadialDamage(float DamageAmount, const struct FVector& Origin, const struct FVector& Impact, const struct FVector& ImpulseDir, float OuterRadius);
	void Client_ReactByVehicle(const struct FVector& Impact, const struct FVector& ImpulseDir, const struct FVector& Velocity);
	void OnRep_PendingDestroy();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslReactionComponent">();
	}
	static class UTslReactionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslReactionComponent>();
	}
};
static_assert(alignof(UTslReactionComponent) == 0x000010, "Wrong alignment on UTslReactionComponent");
static_assert(sizeof(UTslReactionComponent) == 0x000850, "Wrong size on UTslReactionComponent");
static_assert(offsetof(UTslReactionComponent, ReactionData) == 0x000810, "Member 'UTslReactionComponent::ReactionData' has a wrong offset!");
static_assert(offsetof(UTslReactionComponent, ReactionDM) == 0x000818, "Member 'UTslReactionComponent::ReactionDM' has a wrong offset!");

// Class TslGame.TslVehicleEffectComponent
// 0x0310 (0x0408 - 0x00F8)
class UTslVehicleEffectComponent final : public UActorComponent
{
public:
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshComponent*                         MeshComponent;                                     // 0x0100(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAkComponent*                           EngineSoundComponent;                              // 0x0108(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVehicleEffectInfo                     VehicleEffectInfo;                                 // 0x0110(0x00F0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class ATslParticle*                           MufflerEffect;                                     // 0x0200(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATslParticle*                           Muffler2Effect;                                    // 0x0208(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATslParticle*                           BoostEffect;                                       // 0x0210(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATslParticle*                           Boost2Effect;                                      // 0x0218(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATslParticle*                           DamagedEffect;                                     // 0x0220(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATslParticle*                           ExplosionEffect;                                   // 0x0228(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATslParticle*                           FrontTrailEffect;                                  // 0x0230(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATslParticle*                           RearTrailEffect;                                   // 0x0238(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATslParticle*                           ThrusterEffect;                                    // 0x0240(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATslParticle*                           Thruster2Effect;                                   // 0x0248(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATslParticle*                           FrontFoamLeftEffect;                               // 0x0250(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATslParticle*                           FrontFoamRightEffect;                              // 0x0258(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_260[0x1C];                                     // 0x0260(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TrailSpeedThreshold;                               // 0x027C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FrontFoamSpawnThreshold;                           // 0x0280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bRPMOverride;                                      // 0x0284(0x0001)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_285[0x13];                                     // 0x0285(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ESurfaceEffect, class UVehicleSurfaceAudioData*> SurfaceAudioMap;                                   // 0x0298(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseNewSurfaceAudio;                               // 0x02E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 MeasuredWheelIndices;                              // 0x02F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<int32>                                 MeasuredWheelIndicesSlip;                          // 0x0300(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         SuspenionOffsetForContact;                         // 0x0310(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurfaceActivationValue;                            // 0x0314(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SurfaceDeactivationValue;                          // 0x0318(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DT_Multiplier;                                     // 0x031C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinVelocityForSurfaceCheck;                        // 0x0320(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSlip;                                           // 0x0324(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinSpin;                                           // 0x0328(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VelocityInterpSpeed;                               // 0x032C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlipInterpSpeed;                                   // 0x0330(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpinInterpSpeed;                                   // 0x0334(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugVisualizedMeasuredWheels;                    // 0x0338(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_339[0x77];                                     // 0x0339(0x0077)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class UMaterialInterface*>        DestroyedMaterialMap;                              // 0x03B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         ApplyDestroyedMaterialDelay;                       // 0x0400(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_404[0x4];                                      // 0x0404(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyDestoyedMaterialWithDelay();
	void OnDeath(float KillingDamage, const struct FDamageEvent& DamageEvent, class ATslPlayerState* PlayerInstigator, class AActor* DamageCauser);
	void OnDestroyedImpactEffect(class AActor* DestroyedActor);
	void OnHealthChange(float CurrentHealth, float LastHealth, float HealthMax, bool bIsDying);
	void OnHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void SetEngineSoundRTPC(const class FString& RTPC, float Value);
	void SetVehicleMaterialsToDestroyed();

	class UAkComponent* GetEngineSoundComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslVehicleEffectComponent">();
	}
	static class UTslVehicleEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslVehicleEffectComponent>();
	}
};
static_assert(alignof(UTslVehicleEffectComponent) == 0x000008, "Wrong alignment on UTslVehicleEffectComponent");
static_assert(sizeof(UTslVehicleEffectComponent) == 0x000408, "Wrong size on UTslVehicleEffectComponent");
static_assert(offsetof(UTslVehicleEffectComponent, MeshComponent) == 0x000100, "Member 'UTslVehicleEffectComponent::MeshComponent' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, EngineSoundComponent) == 0x000108, "Member 'UTslVehicleEffectComponent::EngineSoundComponent' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, VehicleEffectInfo) == 0x000110, "Member 'UTslVehicleEffectComponent::VehicleEffectInfo' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, MufflerEffect) == 0x000200, "Member 'UTslVehicleEffectComponent::MufflerEffect' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, Muffler2Effect) == 0x000208, "Member 'UTslVehicleEffectComponent::Muffler2Effect' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, BoostEffect) == 0x000210, "Member 'UTslVehicleEffectComponent::BoostEffect' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, Boost2Effect) == 0x000218, "Member 'UTslVehicleEffectComponent::Boost2Effect' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, DamagedEffect) == 0x000220, "Member 'UTslVehicleEffectComponent::DamagedEffect' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, ExplosionEffect) == 0x000228, "Member 'UTslVehicleEffectComponent::ExplosionEffect' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, FrontTrailEffect) == 0x000230, "Member 'UTslVehicleEffectComponent::FrontTrailEffect' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, RearTrailEffect) == 0x000238, "Member 'UTslVehicleEffectComponent::RearTrailEffect' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, ThrusterEffect) == 0x000240, "Member 'UTslVehicleEffectComponent::ThrusterEffect' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, Thruster2Effect) == 0x000248, "Member 'UTslVehicleEffectComponent::Thruster2Effect' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, FrontFoamLeftEffect) == 0x000250, "Member 'UTslVehicleEffectComponent::FrontFoamLeftEffect' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, FrontFoamRightEffect) == 0x000258, "Member 'UTslVehicleEffectComponent::FrontFoamRightEffect' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, TrailSpeedThreshold) == 0x00027C, "Member 'UTslVehicleEffectComponent::TrailSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, FrontFoamSpawnThreshold) == 0x000280, "Member 'UTslVehicleEffectComponent::FrontFoamSpawnThreshold' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, bRPMOverride) == 0x000284, "Member 'UTslVehicleEffectComponent::bRPMOverride' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, SurfaceAudioMap) == 0x000298, "Member 'UTslVehicleEffectComponent::SurfaceAudioMap' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, bUseNewSurfaceAudio) == 0x0002E8, "Member 'UTslVehicleEffectComponent::bUseNewSurfaceAudio' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, MeasuredWheelIndices) == 0x0002F0, "Member 'UTslVehicleEffectComponent::MeasuredWheelIndices' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, MeasuredWheelIndicesSlip) == 0x000300, "Member 'UTslVehicleEffectComponent::MeasuredWheelIndicesSlip' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, SuspenionOffsetForContact) == 0x000310, "Member 'UTslVehicleEffectComponent::SuspenionOffsetForContact' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, SurfaceActivationValue) == 0x000314, "Member 'UTslVehicleEffectComponent::SurfaceActivationValue' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, SurfaceDeactivationValue) == 0x000318, "Member 'UTslVehicleEffectComponent::SurfaceDeactivationValue' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, DT_Multiplier) == 0x00031C, "Member 'UTslVehicleEffectComponent::DT_Multiplier' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, MinVelocityForSurfaceCheck) == 0x000320, "Member 'UTslVehicleEffectComponent::MinVelocityForSurfaceCheck' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, MinSlip) == 0x000324, "Member 'UTslVehicleEffectComponent::MinSlip' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, MinSpin) == 0x000328, "Member 'UTslVehicleEffectComponent::MinSpin' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, VelocityInterpSpeed) == 0x00032C, "Member 'UTslVehicleEffectComponent::VelocityInterpSpeed' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, SlipInterpSpeed) == 0x000330, "Member 'UTslVehicleEffectComponent::SlipInterpSpeed' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, SpinInterpSpeed) == 0x000334, "Member 'UTslVehicleEffectComponent::SpinInterpSpeed' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, bDebugVisualizedMeasuredWheels) == 0x000338, "Member 'UTslVehicleEffectComponent::bDebugVisualizedMeasuredWheels' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, DestroyedMaterialMap) == 0x0003B0, "Member 'UTslVehicleEffectComponent::DestroyedMaterialMap' has a wrong offset!");
static_assert(offsetof(UTslVehicleEffectComponent, ApplyDestroyedMaterialDelay) == 0x000400, "Member 'UTslVehicleEffectComponent::ApplyDestroyedMaterialDelay' has a wrong offset!");

// Class TslGame.TslBreakableFence
// 0x0068 (0x04A0 - 0x0438)
class ATslBreakableFence final : public ATslFence
{
public:
	class UTslReactionData*                       ReactionData;                                      // 0x0438(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleMesh*                      BeginDestuctible1;                                 // 0x0440(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleMesh*                      BeginDestuctible2;                                 // 0x0448(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleMesh*                      BeginDestuctible3;                                 // 0x0450(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleMesh*                      BeginDestuctible4;                                 // 0x0458(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleMesh*                      EndDestuctible1;                                   // 0x0460(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleMesh*                      EndDestuctible2;                                   // 0x0468(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleMesh*                      EndDestuctible3;                                   // 0x0470(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleMesh*                      EndDestuctible4;                                   // 0x0478(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleMesh*                      MiddleDestuctible1;                                // 0x0480(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleMesh*                      MiddleDestuctible2;                                // 0x0488(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleMesh*                      MiddleDestuctible3;                                // 0x0490(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDestructibleMesh*                      MiddleDestuctible4;                                // 0x0498(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslBreakableFence">();
	}
	static class ATslBreakableFence* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslBreakableFence>();
	}
};
static_assert(alignof(ATslBreakableFence) == 0x000008, "Wrong alignment on ATslBreakableFence");
static_assert(sizeof(ATslBreakableFence) == 0x0004A0, "Wrong size on ATslBreakableFence");
static_assert(offsetof(ATslBreakableFence, ReactionData) == 0x000438, "Member 'ATslBreakableFence::ReactionData' has a wrong offset!");
static_assert(offsetof(ATslBreakableFence, BeginDestuctible1) == 0x000440, "Member 'ATslBreakableFence::BeginDestuctible1' has a wrong offset!");
static_assert(offsetof(ATslBreakableFence, BeginDestuctible2) == 0x000448, "Member 'ATslBreakableFence::BeginDestuctible2' has a wrong offset!");
static_assert(offsetof(ATslBreakableFence, BeginDestuctible3) == 0x000450, "Member 'ATslBreakableFence::BeginDestuctible3' has a wrong offset!");
static_assert(offsetof(ATslBreakableFence, BeginDestuctible4) == 0x000458, "Member 'ATslBreakableFence::BeginDestuctible4' has a wrong offset!");
static_assert(offsetof(ATslBreakableFence, EndDestuctible1) == 0x000460, "Member 'ATslBreakableFence::EndDestuctible1' has a wrong offset!");
static_assert(offsetof(ATslBreakableFence, EndDestuctible2) == 0x000468, "Member 'ATslBreakableFence::EndDestuctible2' has a wrong offset!");
static_assert(offsetof(ATslBreakableFence, EndDestuctible3) == 0x000470, "Member 'ATslBreakableFence::EndDestuctible3' has a wrong offset!");
static_assert(offsetof(ATslBreakableFence, EndDestuctible4) == 0x000478, "Member 'ATslBreakableFence::EndDestuctible4' has a wrong offset!");
static_assert(offsetof(ATslBreakableFence, MiddleDestuctible1) == 0x000480, "Member 'ATslBreakableFence::MiddleDestuctible1' has a wrong offset!");
static_assert(offsetof(ATslBreakableFence, MiddleDestuctible2) == 0x000488, "Member 'ATslBreakableFence::MiddleDestuctible2' has a wrong offset!");
static_assert(offsetof(ATslBreakableFence, MiddleDestuctible3) == 0x000490, "Member 'ATslBreakableFence::MiddleDestuctible3' has a wrong offset!");
static_assert(offsetof(ATslBreakableFence, MiddleDestuctible4) == 0x000498, "Member 'ATslBreakableFence::MiddleDestuctible4' has a wrong offset!");

// Class TslGame.TslStaticFence
// 0x0000 (0x0438 - 0x0438)
class ATslStaticFence final : public ATslFence
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslStaticFence">();
	}
	static class ATslStaticFence* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslStaticFence>();
	}
};
static_assert(alignof(ATslStaticFence) == 0x000008, "Wrong alignment on ATslStaticFence");
static_assert(sizeof(ATslStaticFence) == 0x000438, "Wrong size on ATslStaticFence");

// Class TslGame.TslWebPopupInterface
// 0x0000 (0x0028 - 0x0028)
class ITslWebPopupInterface final : public IInterface
{
public:
	void ShowWebPopup(const struct FWebPopupParam& Param);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslWebPopupInterface">();
	}
	static class ITslWebPopupInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITslWebPopupInterface>();
	}
};
static_assert(alignof(ITslWebPopupInterface) == 0x000008, "Wrong alignment on ITslWebPopupInterface");
static_assert(sizeof(ITslWebPopupInterface) == 0x000028, "Wrong size on ITslWebPopupInterface");

// Class TslGame.TslFocusableWidgetInterface
// 0x0000 (0x0028 - 0x0028)
class ITslFocusableWidgetInterface final : public IInterface
{
public:
	bool Down();
	bool InputA();
	bool InputB();
	bool InputLB();
	bool InputLT();
	bool InputRB();
	bool InputRT();
	bool InputX();
	bool InputY();
	bool Left();
	bool Right();
	bool SetFocus(bool NewFocus);
	bool Up();

	class UUserWidget* GetDownWidget() const;
	class UUserWidget* GetFocusingChildWidget() const;
	class UUserWidget* GetLeftWidget() const;
	class UUserWidget* GetRightWidget() const;
	class UUserWidget* GetUpWidget() const;
	bool IsFocus() const;
	bool IsFocusable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslFocusableWidgetInterface">();
	}
	static class ITslFocusableWidgetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITslFocusableWidgetInterface>();
	}
};
static_assert(alignof(ITslFocusableWidgetInterface) == 0x000008, "Wrong alignment on ITslFocusableWidgetInterface");
static_assert(sizeof(ITslFocusableWidgetInterface) == 0x000028, "Wrong size on ITslFocusableWidgetInterface");

// Class TslGame.TslGame_Menu
// 0x0000 (0x0470 - 0x0470)
class ATslGame_Menu final : public AGameMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslGame_Menu">();
	}
	static class ATslGame_Menu* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslGame_Menu>();
	}
};
static_assert(alignof(ATslGame_Menu) == 0x000008, "Wrong alignment on ATslGame_Menu");
static_assert(sizeof(ATslGame_Menu) == 0x000470, "Wrong size on ATslGame_Menu");

// Class TslGame.TslVehicleSyncComponent
// 0x0050 (0x0148 - 0x00F8)
class UTslVehicleSyncComponent final : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   OnSyncHit;                                         // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x4];                                      // 0x0108(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinCorrectionInterval;                             // 0x010C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x4];                                      // 0x0110(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SendingToServerIntervalAtClient;                   // 0x0114(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x8];                                      // 0x0118(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SendingReliableHitToServerIntervalAtClient;        // 0x0120(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AllowedMaxDistanceSqAtServer;                      // 0x0128(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StationaryCorrectionIntervalAtClient;              // 0x012C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x4];                                      // 0x0130(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StationaryCorrectionSpeedThresholdSq;              // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StationaryCorrectionThresholdDistanceSq;           // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13C[0xC];                                      // 0x013C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDriverRide();
	void OnHitAtClient(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnHitAtServer(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void SendClientHitToServerReliably(int32 InCorrectionId, const struct FVector_NetQuantize100& ClientLocation, const struct FVector_NetQuantize100& ClientLinearVelocity, const struct FVector_NetQuantizeNormal& ClientRotator, const struct FVector_NetQuantize100& ClientAngularVelocity, const struct FVector_NetQuantize100& NormalImpulse, const struct FHitResult& Hit);
	void SendClientHitToServerUnreliably(int32 InCorrectionId, const struct FVector_NetQuantize100& ClientLocation, const struct FVector_NetQuantize100& ClientLinearVelocity, const struct FVector_NetQuantizeNormal& ClientRotator, const struct FVector_NetQuantize100& ClientAngularVelocity, const struct FVector_NetQuantize100& NormalImpulse, const struct FHitResult& Hit);
	void SendClientMoveToServerReliably(int32 InCorrectionId, const struct FVector_NetQuantize100& ClientLocation, const struct FVector_NetQuantize100& ClientLinearVelocity, const struct FVector_NetQuantizeNormal& ClientRotator, const struct FVector_NetQuantize100& ClientAngularVelocity);
	void SendClientMoveToServerUnreliably(int32 InCorrectionId, const struct FVector_NetQuantize100& ClientLocation, const struct FVector_NetQuantize100& ClientLinearVelocity, const struct FVector_NetQuantizeNormal& ClientRotator, const struct FVector_NetQuantize100& ClientAngularVelocity);
	void SendServerMoveToClient(int32 InCorrectionId, const struct FVector_NetQuantize100& ServerLocation, const struct FVector_NetQuantize100& ServerLinearVelocity, const struct FVector_NetQuantizeNormal& ServerRotator, const struct FVector_NetQuantize100& ServerAngularVelocity, bool bIsSnap);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslVehicleSyncComponent">();
	}
	static class UTslVehicleSyncComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslVehicleSyncComponent>();
	}
};
static_assert(alignof(UTslVehicleSyncComponent) == 0x000008, "Wrong alignment on UTslVehicleSyncComponent");
static_assert(sizeof(UTslVehicleSyncComponent) == 0x000148, "Wrong size on UTslVehicleSyncComponent");
static_assert(offsetof(UTslVehicleSyncComponent, OnSyncHit) == 0x0000F8, "Member 'UTslVehicleSyncComponent::OnSyncHit' has a wrong offset!");
static_assert(offsetof(UTslVehicleSyncComponent, MinCorrectionInterval) == 0x00010C, "Member 'UTslVehicleSyncComponent::MinCorrectionInterval' has a wrong offset!");
static_assert(offsetof(UTslVehicleSyncComponent, SendingToServerIntervalAtClient) == 0x000114, "Member 'UTslVehicleSyncComponent::SendingToServerIntervalAtClient' has a wrong offset!");
static_assert(offsetof(UTslVehicleSyncComponent, SendingReliableHitToServerIntervalAtClient) == 0x000120, "Member 'UTslVehicleSyncComponent::SendingReliableHitToServerIntervalAtClient' has a wrong offset!");
static_assert(offsetof(UTslVehicleSyncComponent, AllowedMaxDistanceSqAtServer) == 0x000128, "Member 'UTslVehicleSyncComponent::AllowedMaxDistanceSqAtServer' has a wrong offset!");
static_assert(offsetof(UTslVehicleSyncComponent, StationaryCorrectionIntervalAtClient) == 0x00012C, "Member 'UTslVehicleSyncComponent::StationaryCorrectionIntervalAtClient' has a wrong offset!");
static_assert(offsetof(UTslVehicleSyncComponent, StationaryCorrectionSpeedThresholdSq) == 0x000134, "Member 'UTslVehicleSyncComponent::StationaryCorrectionSpeedThresholdSq' has a wrong offset!");
static_assert(offsetof(UTslVehicleSyncComponent, StationaryCorrectionThresholdDistanceSq) == 0x000138, "Member 'UTslVehicleSyncComponent::StationaryCorrectionThresholdDistanceSq' has a wrong offset!");

// Class TslGame.TslSettings
// 0x0378 (0x03A0 - 0x0028)
class UTslSettings final : public UObject
{
public:
	float                                         RepDistance_Item;                                  // 0x0028(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepDistance_Character;                             // 0x002C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepDistance_Weapon;                                // 0x0030(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepDistance_Vehicle;                               // 0x0034(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepDistance_Parachute;                             // 0x0038(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepDistance_Door;                                  // 0x003C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepDistance_Window;                                // 0x0040(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepFrequency_Character;                            // 0x0044(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepFrequency_WheeledVehicle;                       // 0x0048(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepFrequency_FloatingVehicle;                      // 0x004C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepFrequency_Parachute;                            // 0x0050(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepFrequency_Aircraft;                             // 0x0054(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepFrequency_CarePackage;                          // 0x0058(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepVehicle_SpawnDistance;                          // 0x005C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RepVehicle_UnspawnDistance;                        // 0x0060(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigidBodyErrorCorrection              RepVehicle_PhysicErrorCorrection;                  // 0x0064(0x001C)(Edit, Config, NativeAccessSpecifierPublic)
	float                                         CharacterCorrection_MaxSpeed;                      // 0x0080(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterCorrection_MaxSpeedPositionError;         // 0x0084(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterCorrection_ZeroSpeedPositionError;        // 0x0088(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBattlEyeEnabled;                                  // 0x008C(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBattlEyeEnabledInPIE;                             // 0x008D(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E[0x2];                                       // 0x008E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BattlEyeReliablePacketIntervalOnClient;            // 0x0090(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattlEyeReliablePacketIntervalOnServer;            // 0x0094(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChineseLicensing;                                 // 0x0098(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKoreanRating;                                     // 0x0099(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x2];                                       // 0x009A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GameStateLogInterval;                              // 0x009C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerStatLogInterval;                             // 0x00A0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterPositionLogInterval;                      // 0x00A4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestructibleComponentMaxDrawDistance;              // 0x00A8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATslCharacter>              CharacterClassToPlay;                              // 0x00B0(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBoneBinding>                   BoneMapping;                                       // 0x00B8(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AWheeledVehicle>>    TestVehicleClasses;                                // 0x00C8(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ATslFloatingVehicle>> TestFloatingVehicleClasses;                        // 0x00D8(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         StoppedWheeledVehicleSpeedThreshold;               // 0x00E8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StoppedFloatingVehicleSpeedThreshold;              // 0x00EC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastDriverDuration;                                // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractableDistanceToleranceOnDedicatedServer;    // 0x00F4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractableDistance_ItemDefault;                  // 0x00F8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractableSpeed_ItemDefault;                     // 0x00FC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInteractionCollisionData              InteractionCollisionForFPS;                        // 0x0100(0x0014)(Edit, Config, NativeAccessSpecifierPublic)
	struct FInteractionCollisionData              InteractionCollisionForTPS;                        // 0x0114(0x0014)(Edit, Config, NativeAccessSpecifierPublic)
	bool                                          bPreventFinishMatchInPIE;                          // 0x0128(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableInitialItemDonator;                         // 0x0129(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12A[0x2];                                      // 0x012A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InventoryMaxSpaceDefault;                          // 0x012C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               ErrorIconTexture;                                  // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               LoadingIconTexture;                                // 0x0138(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        AssetsForPackageIntegrity;                         // 0x0140(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         UICrosshairDistance;                               // 0x0150(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UICrosshairInterpSpeed;                            // 0x0154(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UICrosshairDisableDistance;                        // 0x0158(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GameTimeMultiplier;                                // 0x015C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AimOffsetRayCast;                                  // 0x0160(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x3];                                      // 0x0161(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MeleeWeaponPitchMin;                               // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeleeWeaponPitchMax;                               // 0x0168(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableThrowLagCompensation;                        // 0x016C(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FullRecoilRecovery;                                // 0x016D(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16E[0x2];                                      // 0x016E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLevelLoadingBoostParameters           LevelLoadingBoostParameters;                       // 0x0170(0x0010)(Edit, Config, NativeAccessSpecifierPublic)
	TArray<struct FNearClippingValue>             NearClippingValues;                                // 0x0180(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FCustomizableCategoryData>      CustomizableCategoryData;                          // 0x0190(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FCustomizableActionName>        CustomizableActionNames;                           // 0x01A0(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FCustomizableAxisName>          CustomizableAxisNames;                             // 0x01B0(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FCustomizableMouseSensitiveName> CustomizableMouseSensitiveNames;                   // 0x01C0(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FSurportQualityLevel>           SupportedQualityLevels;                            // 0x01D0(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FScreenResolution>              SupportedScreenResolutions;                        // 0x01E0(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	struct FStringAssetReference                  MouseSensitivityCurve;                             // 0x01F0(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	struct FStringAssetReference                  GammaCurve;                                        // 0x0200(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FString>                         CultureNames;                                      // 0x0210(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FColorBlindType>                ColorBlindTypes;                                   // 0x0220(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FPresetColor>                   CrosshairColors;                                   // 0x0230(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FKeyInputModeName>              KeyInputModeNames;                                 // 0x0240(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FUiType>                        MiniMapTypeList;                                   // 0x0250(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	float                                         MinimumScreenResolutionRatio;                      // 0x0260(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScreenResolution                      MinimumScreenResolution;                           // 0x0264(0x0008)(Edit, Config, NativeAccessSpecifierPublic)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FColorBlindColorSet>            OverrideMarkerColors;                              // 0x0270(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	float                                         PunchClientHitLeeway_Attacker;                     // 0x0280(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PunchClientHitLeeway_Victim;                       // 0x0284(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClientSideHitLeeway;                               // 0x0288(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LogClientSideHitLeeway;                            // 0x028C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClientSideOriginDistanceLeeway;                    // 0x0290(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelDistanceLeeway;                              // 0x0294(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AllowedHitLag;                                     // 0x0298(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LogMinHitLag;                                      // 0x029C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FOverrideScalability>           OverrideScalabilities;                             // 0x02A0(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	float                                         FakeDoorBlockMaxY;                                 // 0x02B0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FReportCauseData>               ReportCauses;                                      // 0x02B8(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FSubjectToReport>               SubjectToReport;                                   // 0x02C8(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	float                                         FreelookRecoveryInterpSpeed;                       // 0x02D8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, float>                      GamepadSensitiveMultiplier;                        // 0x02E0(0x0050)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	bool                                          bIsESports;                                        // 0x0330(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_331[0x57];                                     // 0x0331(0x0057)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            LoadedMouseSensitivityCurve;                       // 0x0388(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            LoadedGammaCurve;                                  // 0x0390(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 CharacterStudioRenderTarget;                       // 0x0398(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UTslSettings* GetTslSettings();

	class UTextureRenderTarget2D* GetCharacterStudioRenderTarget();
	void SetCharacterStudioRenderTarget(class UTextureRenderTarget2D* rt);

	bool IsESports() const;
	const bool IsForChineseLicensing() const;
	const bool IsForKoreanRating() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslSettings">();
	}
	static class UTslSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslSettings>();
	}
};
static_assert(alignof(UTslSettings) == 0x000008, "Wrong alignment on UTslSettings");
static_assert(sizeof(UTslSettings) == 0x0003A0, "Wrong size on UTslSettings");
static_assert(offsetof(UTslSettings, RepDistance_Item) == 0x000028, "Member 'UTslSettings::RepDistance_Item' has a wrong offset!");
static_assert(offsetof(UTslSettings, RepDistance_Character) == 0x00002C, "Member 'UTslSettings::RepDistance_Character' has a wrong offset!");
static_assert(offsetof(UTslSettings, RepDistance_Weapon) == 0x000030, "Member 'UTslSettings::RepDistance_Weapon' has a wrong offset!");
static_assert(offsetof(UTslSettings, RepDistance_Vehicle) == 0x000034, "Member 'UTslSettings::RepDistance_Vehicle' has a wrong offset!");
static_assert(offsetof(UTslSettings, RepDistance_Parachute) == 0x000038, "Member 'UTslSettings::RepDistance_Parachute' has a wrong offset!");
static_assert(offsetof(UTslSettings, RepDistance_Door) == 0x00003C, "Member 'UTslSettings::RepDistance_Door' has a wrong offset!");
static_assert(offsetof(UTslSettings, RepDistance_Window) == 0x000040, "Member 'UTslSettings::RepDistance_Window' has a wrong offset!");
static_assert(offsetof(UTslSettings, RepFrequency_Character) == 0x000044, "Member 'UTslSettings::RepFrequency_Character' has a wrong offset!");
static_assert(offsetof(UTslSettings, RepFrequency_WheeledVehicle) == 0x000048, "Member 'UTslSettings::RepFrequency_WheeledVehicle' has a wrong offset!");
static_assert(offsetof(UTslSettings, RepFrequency_FloatingVehicle) == 0x00004C, "Member 'UTslSettings::RepFrequency_FloatingVehicle' has a wrong offset!");
static_assert(offsetof(UTslSettings, RepFrequency_Parachute) == 0x000050, "Member 'UTslSettings::RepFrequency_Parachute' has a wrong offset!");
static_assert(offsetof(UTslSettings, RepFrequency_Aircraft) == 0x000054, "Member 'UTslSettings::RepFrequency_Aircraft' has a wrong offset!");
static_assert(offsetof(UTslSettings, RepFrequency_CarePackage) == 0x000058, "Member 'UTslSettings::RepFrequency_CarePackage' has a wrong offset!");
static_assert(offsetof(UTslSettings, RepVehicle_SpawnDistance) == 0x00005C, "Member 'UTslSettings::RepVehicle_SpawnDistance' has a wrong offset!");
static_assert(offsetof(UTslSettings, RepVehicle_UnspawnDistance) == 0x000060, "Member 'UTslSettings::RepVehicle_UnspawnDistance' has a wrong offset!");
static_assert(offsetof(UTslSettings, RepVehicle_PhysicErrorCorrection) == 0x000064, "Member 'UTslSettings::RepVehicle_PhysicErrorCorrection' has a wrong offset!");
static_assert(offsetof(UTslSettings, CharacterCorrection_MaxSpeed) == 0x000080, "Member 'UTslSettings::CharacterCorrection_MaxSpeed' has a wrong offset!");
static_assert(offsetof(UTslSettings, CharacterCorrection_MaxSpeedPositionError) == 0x000084, "Member 'UTslSettings::CharacterCorrection_MaxSpeedPositionError' has a wrong offset!");
static_assert(offsetof(UTslSettings, CharacterCorrection_ZeroSpeedPositionError) == 0x000088, "Member 'UTslSettings::CharacterCorrection_ZeroSpeedPositionError' has a wrong offset!");
static_assert(offsetof(UTslSettings, bBattlEyeEnabled) == 0x00008C, "Member 'UTslSettings::bBattlEyeEnabled' has a wrong offset!");
static_assert(offsetof(UTslSettings, bBattlEyeEnabledInPIE) == 0x00008D, "Member 'UTslSettings::bBattlEyeEnabledInPIE' has a wrong offset!");
static_assert(offsetof(UTslSettings, BattlEyeReliablePacketIntervalOnClient) == 0x000090, "Member 'UTslSettings::BattlEyeReliablePacketIntervalOnClient' has a wrong offset!");
static_assert(offsetof(UTslSettings, BattlEyeReliablePacketIntervalOnServer) == 0x000094, "Member 'UTslSettings::BattlEyeReliablePacketIntervalOnServer' has a wrong offset!");
static_assert(offsetof(UTslSettings, bChineseLicensing) == 0x000098, "Member 'UTslSettings::bChineseLicensing' has a wrong offset!");
static_assert(offsetof(UTslSettings, bKoreanRating) == 0x000099, "Member 'UTslSettings::bKoreanRating' has a wrong offset!");
static_assert(offsetof(UTslSettings, GameStateLogInterval) == 0x00009C, "Member 'UTslSettings::GameStateLogInterval' has a wrong offset!");
static_assert(offsetof(UTslSettings, ServerStatLogInterval) == 0x0000A0, "Member 'UTslSettings::ServerStatLogInterval' has a wrong offset!");
static_assert(offsetof(UTslSettings, CharacterPositionLogInterval) == 0x0000A4, "Member 'UTslSettings::CharacterPositionLogInterval' has a wrong offset!");
static_assert(offsetof(UTslSettings, DestructibleComponentMaxDrawDistance) == 0x0000A8, "Member 'UTslSettings::DestructibleComponentMaxDrawDistance' has a wrong offset!");
static_assert(offsetof(UTslSettings, CharacterClassToPlay) == 0x0000B0, "Member 'UTslSettings::CharacterClassToPlay' has a wrong offset!");
static_assert(offsetof(UTslSettings, BoneMapping) == 0x0000B8, "Member 'UTslSettings::BoneMapping' has a wrong offset!");
static_assert(offsetof(UTslSettings, TestVehicleClasses) == 0x0000C8, "Member 'UTslSettings::TestVehicleClasses' has a wrong offset!");
static_assert(offsetof(UTslSettings, TestFloatingVehicleClasses) == 0x0000D8, "Member 'UTslSettings::TestFloatingVehicleClasses' has a wrong offset!");
static_assert(offsetof(UTslSettings, StoppedWheeledVehicleSpeedThreshold) == 0x0000E8, "Member 'UTslSettings::StoppedWheeledVehicleSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UTslSettings, StoppedFloatingVehicleSpeedThreshold) == 0x0000EC, "Member 'UTslSettings::StoppedFloatingVehicleSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UTslSettings, LastDriverDuration) == 0x0000F0, "Member 'UTslSettings::LastDriverDuration' has a wrong offset!");
static_assert(offsetof(UTslSettings, InteractableDistanceToleranceOnDedicatedServer) == 0x0000F4, "Member 'UTslSettings::InteractableDistanceToleranceOnDedicatedServer' has a wrong offset!");
static_assert(offsetof(UTslSettings, InteractableDistance_ItemDefault) == 0x0000F8, "Member 'UTslSettings::InteractableDistance_ItemDefault' has a wrong offset!");
static_assert(offsetof(UTslSettings, InteractableSpeed_ItemDefault) == 0x0000FC, "Member 'UTslSettings::InteractableSpeed_ItemDefault' has a wrong offset!");
static_assert(offsetof(UTslSettings, InteractionCollisionForFPS) == 0x000100, "Member 'UTslSettings::InteractionCollisionForFPS' has a wrong offset!");
static_assert(offsetof(UTslSettings, InteractionCollisionForTPS) == 0x000114, "Member 'UTslSettings::InteractionCollisionForTPS' has a wrong offset!");
static_assert(offsetof(UTslSettings, bPreventFinishMatchInPIE) == 0x000128, "Member 'UTslSettings::bPreventFinishMatchInPIE' has a wrong offset!");
static_assert(offsetof(UTslSettings, bEnableInitialItemDonator) == 0x000129, "Member 'UTslSettings::bEnableInitialItemDonator' has a wrong offset!");
static_assert(offsetof(UTslSettings, InventoryMaxSpaceDefault) == 0x00012C, "Member 'UTslSettings::InventoryMaxSpaceDefault' has a wrong offset!");
static_assert(offsetof(UTslSettings, ErrorIconTexture) == 0x000130, "Member 'UTslSettings::ErrorIconTexture' has a wrong offset!");
static_assert(offsetof(UTslSettings, LoadingIconTexture) == 0x000138, "Member 'UTslSettings::LoadingIconTexture' has a wrong offset!");
static_assert(offsetof(UTslSettings, AssetsForPackageIntegrity) == 0x000140, "Member 'UTslSettings::AssetsForPackageIntegrity' has a wrong offset!");
static_assert(offsetof(UTslSettings, UICrosshairDistance) == 0x000150, "Member 'UTslSettings::UICrosshairDistance' has a wrong offset!");
static_assert(offsetof(UTslSettings, UICrosshairInterpSpeed) == 0x000154, "Member 'UTslSettings::UICrosshairInterpSpeed' has a wrong offset!");
static_assert(offsetof(UTslSettings, UICrosshairDisableDistance) == 0x000158, "Member 'UTslSettings::UICrosshairDisableDistance' has a wrong offset!");
static_assert(offsetof(UTslSettings, GameTimeMultiplier) == 0x00015C, "Member 'UTslSettings::GameTimeMultiplier' has a wrong offset!");
static_assert(offsetof(UTslSettings, AimOffsetRayCast) == 0x000160, "Member 'UTslSettings::AimOffsetRayCast' has a wrong offset!");
static_assert(offsetof(UTslSettings, MeleeWeaponPitchMin) == 0x000164, "Member 'UTslSettings::MeleeWeaponPitchMin' has a wrong offset!");
static_assert(offsetof(UTslSettings, MeleeWeaponPitchMax) == 0x000168, "Member 'UTslSettings::MeleeWeaponPitchMax' has a wrong offset!");
static_assert(offsetof(UTslSettings, EnableThrowLagCompensation) == 0x00016C, "Member 'UTslSettings::EnableThrowLagCompensation' has a wrong offset!");
static_assert(offsetof(UTslSettings, FullRecoilRecovery) == 0x00016D, "Member 'UTslSettings::FullRecoilRecovery' has a wrong offset!");
static_assert(offsetof(UTslSettings, LevelLoadingBoostParameters) == 0x000170, "Member 'UTslSettings::LevelLoadingBoostParameters' has a wrong offset!");
static_assert(offsetof(UTslSettings, NearClippingValues) == 0x000180, "Member 'UTslSettings::NearClippingValues' has a wrong offset!");
static_assert(offsetof(UTslSettings, CustomizableCategoryData) == 0x000190, "Member 'UTslSettings::CustomizableCategoryData' has a wrong offset!");
static_assert(offsetof(UTslSettings, CustomizableActionNames) == 0x0001A0, "Member 'UTslSettings::CustomizableActionNames' has a wrong offset!");
static_assert(offsetof(UTslSettings, CustomizableAxisNames) == 0x0001B0, "Member 'UTslSettings::CustomizableAxisNames' has a wrong offset!");
static_assert(offsetof(UTslSettings, CustomizableMouseSensitiveNames) == 0x0001C0, "Member 'UTslSettings::CustomizableMouseSensitiveNames' has a wrong offset!");
static_assert(offsetof(UTslSettings, SupportedQualityLevels) == 0x0001D0, "Member 'UTslSettings::SupportedQualityLevels' has a wrong offset!");
static_assert(offsetof(UTslSettings, SupportedScreenResolutions) == 0x0001E0, "Member 'UTslSettings::SupportedScreenResolutions' has a wrong offset!");
static_assert(offsetof(UTslSettings, MouseSensitivityCurve) == 0x0001F0, "Member 'UTslSettings::MouseSensitivityCurve' has a wrong offset!");
static_assert(offsetof(UTslSettings, GammaCurve) == 0x000200, "Member 'UTslSettings::GammaCurve' has a wrong offset!");
static_assert(offsetof(UTslSettings, CultureNames) == 0x000210, "Member 'UTslSettings::CultureNames' has a wrong offset!");
static_assert(offsetof(UTslSettings, ColorBlindTypes) == 0x000220, "Member 'UTslSettings::ColorBlindTypes' has a wrong offset!");
static_assert(offsetof(UTslSettings, CrosshairColors) == 0x000230, "Member 'UTslSettings::CrosshairColors' has a wrong offset!");
static_assert(offsetof(UTslSettings, KeyInputModeNames) == 0x000240, "Member 'UTslSettings::KeyInputModeNames' has a wrong offset!");
static_assert(offsetof(UTslSettings, MiniMapTypeList) == 0x000250, "Member 'UTslSettings::MiniMapTypeList' has a wrong offset!");
static_assert(offsetof(UTslSettings, MinimumScreenResolutionRatio) == 0x000260, "Member 'UTslSettings::MinimumScreenResolutionRatio' has a wrong offset!");
static_assert(offsetof(UTslSettings, MinimumScreenResolution) == 0x000264, "Member 'UTslSettings::MinimumScreenResolution' has a wrong offset!");
static_assert(offsetof(UTslSettings, OverrideMarkerColors) == 0x000270, "Member 'UTslSettings::OverrideMarkerColors' has a wrong offset!");
static_assert(offsetof(UTslSettings, PunchClientHitLeeway_Attacker) == 0x000280, "Member 'UTslSettings::PunchClientHitLeeway_Attacker' has a wrong offset!");
static_assert(offsetof(UTslSettings, PunchClientHitLeeway_Victim) == 0x000284, "Member 'UTslSettings::PunchClientHitLeeway_Victim' has a wrong offset!");
static_assert(offsetof(UTslSettings, ClientSideHitLeeway) == 0x000288, "Member 'UTslSettings::ClientSideHitLeeway' has a wrong offset!");
static_assert(offsetof(UTslSettings, LogClientSideHitLeeway) == 0x00028C, "Member 'UTslSettings::LogClientSideHitLeeway' has a wrong offset!");
static_assert(offsetof(UTslSettings, ClientSideOriginDistanceLeeway) == 0x000290, "Member 'UTslSettings::ClientSideOriginDistanceLeeway' has a wrong offset!");
static_assert(offsetof(UTslSettings, TravelDistanceLeeway) == 0x000294, "Member 'UTslSettings::TravelDistanceLeeway' has a wrong offset!");
static_assert(offsetof(UTslSettings, AllowedHitLag) == 0x000298, "Member 'UTslSettings::AllowedHitLag' has a wrong offset!");
static_assert(offsetof(UTslSettings, LogMinHitLag) == 0x00029C, "Member 'UTslSettings::LogMinHitLag' has a wrong offset!");
static_assert(offsetof(UTslSettings, OverrideScalabilities) == 0x0002A0, "Member 'UTslSettings::OverrideScalabilities' has a wrong offset!");
static_assert(offsetof(UTslSettings, FakeDoorBlockMaxY) == 0x0002B0, "Member 'UTslSettings::FakeDoorBlockMaxY' has a wrong offset!");
static_assert(offsetof(UTslSettings, ReportCauses) == 0x0002B8, "Member 'UTslSettings::ReportCauses' has a wrong offset!");
static_assert(offsetof(UTslSettings, SubjectToReport) == 0x0002C8, "Member 'UTslSettings::SubjectToReport' has a wrong offset!");
static_assert(offsetof(UTslSettings, FreelookRecoveryInterpSpeed) == 0x0002D8, "Member 'UTslSettings::FreelookRecoveryInterpSpeed' has a wrong offset!");
static_assert(offsetof(UTslSettings, GamepadSensitiveMultiplier) == 0x0002E0, "Member 'UTslSettings::GamepadSensitiveMultiplier' has a wrong offset!");
static_assert(offsetof(UTslSettings, bIsESports) == 0x000330, "Member 'UTslSettings::bIsESports' has a wrong offset!");
static_assert(offsetof(UTslSettings, LoadedMouseSensitivityCurve) == 0x000388, "Member 'UTslSettings::LoadedMouseSensitivityCurve' has a wrong offset!");
static_assert(offsetof(UTslSettings, LoadedGammaCurve) == 0x000390, "Member 'UTslSettings::LoadedGammaCurve' has a wrong offset!");
static_assert(offsetof(UTslSettings, CharacterStudioRenderTarget) == 0x000398, "Member 'UTslSettings::CharacterStudioRenderTarget' has a wrong offset!");

// Class TslGame.TslVehicleCommonComponent
// 0x00B0 (0x01A8 - 0x00F8)
class UTslVehicleCommonComponent final : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   OnBreak;                                           // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnRepair;                                          // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDeath;                                           // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnHealthChange;                                    // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFuelChange;                                      // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   SimpleBodyBoneName;                                // 0x0148(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           ComplexBodyBoneNames;                              // 0x0150(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FName                                   MainComplexBodyBoneName;                           // 0x0160(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ComplexCollisionProfileName;                       // 0x0168(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bIsDying : 1;                                      // 0x0170(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, Net, EditConst, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         bIsBroken : 1;                                     // 0x0170(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, Net, EditConst, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_171[0x3];                                      // 0x0171(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Health;                                            // 0x0174(0x0004)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HealthMax;                                         // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Fuel;                                              // 0x017C(0x0004)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FuelMax;                                           // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_184[0x4];                                      // 0x0184(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UTslDamageType>             VehicleExplosionDamageType;                        // 0x0188(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<EDamageTypeCategory>                   CharacterDamageIgnores;                            // 0x0190(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                VehicleUI;                                         // 0x01A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddVehicleFuel(float Delta);
	void Break();
	void OnRep_Broken();
	void OnRep_Dying();
	void OnRep_Fuel(float LastFuel);
	void OnRep_Health(float LastHealth);
	void Repair();
	void SetVehicleFuel(float NewFuel);
	void SetVehicleFuelPercent(float Percent);
	void SetVehicleHealth(float NewHealth);

	bool CanIgnoreCharacterDamage(EDamageTypeCategory DamageTypeCategory) const;
	float GetVehicleBaseFuel() const;
	float GetVehicleBaseHealth() const;
	float GetVehicleFuel() const;
	float GetVehicleFuelPercent() const;
	float GetVehicleHealth() const;
	float GetVehicleHealthPercent() const;
	TSubclassOf<class UUserWidget> GetVehicleUI() const;
	bool IsBroken() const;
	bool IsDying() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslVehicleCommonComponent">();
	}
	static class UTslVehicleCommonComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslVehicleCommonComponent>();
	}
};
static_assert(alignof(UTslVehicleCommonComponent) == 0x000008, "Wrong alignment on UTslVehicleCommonComponent");
static_assert(sizeof(UTslVehicleCommonComponent) == 0x0001A8, "Wrong size on UTslVehicleCommonComponent");
static_assert(offsetof(UTslVehicleCommonComponent, OnBreak) == 0x0000F8, "Member 'UTslVehicleCommonComponent::OnBreak' has a wrong offset!");
static_assert(offsetof(UTslVehicleCommonComponent, OnRepair) == 0x000108, "Member 'UTslVehicleCommonComponent::OnRepair' has a wrong offset!");
static_assert(offsetof(UTslVehicleCommonComponent, OnDeath) == 0x000118, "Member 'UTslVehicleCommonComponent::OnDeath' has a wrong offset!");
static_assert(offsetof(UTslVehicleCommonComponent, OnHealthChange) == 0x000128, "Member 'UTslVehicleCommonComponent::OnHealthChange' has a wrong offset!");
static_assert(offsetof(UTslVehicleCommonComponent, OnFuelChange) == 0x000138, "Member 'UTslVehicleCommonComponent::OnFuelChange' has a wrong offset!");
static_assert(offsetof(UTslVehicleCommonComponent, SimpleBodyBoneName) == 0x000148, "Member 'UTslVehicleCommonComponent::SimpleBodyBoneName' has a wrong offset!");
static_assert(offsetof(UTslVehicleCommonComponent, ComplexBodyBoneNames) == 0x000150, "Member 'UTslVehicleCommonComponent::ComplexBodyBoneNames' has a wrong offset!");
static_assert(offsetof(UTslVehicleCommonComponent, MainComplexBodyBoneName) == 0x000160, "Member 'UTslVehicleCommonComponent::MainComplexBodyBoneName' has a wrong offset!");
static_assert(offsetof(UTslVehicleCommonComponent, ComplexCollisionProfileName) == 0x000168, "Member 'UTslVehicleCommonComponent::ComplexCollisionProfileName' has a wrong offset!");
static_assert(offsetof(UTslVehicleCommonComponent, Health) == 0x000174, "Member 'UTslVehicleCommonComponent::Health' has a wrong offset!");
static_assert(offsetof(UTslVehicleCommonComponent, HealthMax) == 0x000178, "Member 'UTslVehicleCommonComponent::HealthMax' has a wrong offset!");
static_assert(offsetof(UTslVehicleCommonComponent, Fuel) == 0x00017C, "Member 'UTslVehicleCommonComponent::Fuel' has a wrong offset!");
static_assert(offsetof(UTslVehicleCommonComponent, FuelMax) == 0x000180, "Member 'UTslVehicleCommonComponent::FuelMax' has a wrong offset!");
static_assert(offsetof(UTslVehicleCommonComponent, VehicleExplosionDamageType) == 0x000188, "Member 'UTslVehicleCommonComponent::VehicleExplosionDamageType' has a wrong offset!");
static_assert(offsetof(UTslVehicleCommonComponent, CharacterDamageIgnores) == 0x000190, "Member 'UTslVehicleCommonComponent::CharacterDamageIgnores' has a wrong offset!");
static_assert(offsetof(UTslVehicleCommonComponent, VehicleUI) == 0x0001A0, "Member 'UTslVehicleCommonComponent::VehicleUI' has a wrong offset!");

// Class TslGame.TslGameInstance
// 0x0480 (0x0570 - 0x00F0)
class UTslGameInstance final : public UGameInstance
{
public:
	class FString                                 WelcomeScreenMap;                                  // 0x00F0(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseLobbyWidget;                                   // 0x0100(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_101[0x3];                                      // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LobbyWidgetZOrder;                                 // 0x0104(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULobbyLink*                             LobbyLink;                                         // 0x0108(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVivoxManager*                          VivoxManager;                                      // 0x0110(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTslStartParameter                     StartParamter;                                     // 0x0118(0x0080)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_198[0x180];                                    // 0x0198(0x0180)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ULobbyWidget>               LobbyWidgetClass;                                  // 0x0318(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_320[0x120];                                    // 0x0320(0x0120)(Fixing Size After Last Property [ Dumper-7 ])
	class ULobbyWidget*                           LobbyWidget;                                       // 0x0440(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_448[0x68];                                     // 0x0448(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FReplayKillEventItem>           ReplayKillEventItems;                              // 0x04B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEnumerateReplayKillEventsDone;                   // 0x04C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D0[0x10];                                     // 0x04D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FReplayItem>                    ReplayItemList;                                    // 0x04E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F0[0x38];                                     // 0x04F0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnGetReplayListDone;                               // 0x0528(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnGotoTimelineDone;                                // 0x0538(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnRecordStarted;                                   // 0x0548(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_558[0x8];                                      // 0x0558(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGameEventObserver*                     GameEventObserver;                                 // 0x0560(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_568[0x8];                                      // 0x0568(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnumerateReplayKillEvents();
	int32 GetNumTotalReplays();
	float GetReplayCurrentTime();
	void GetReplayList();
	void GetReplayListByRegionOrLocal(const class FString& RegionOrLocal, int32 PageIndex, int32 PageSize);
	void GetReplayListLocal(int32 PageIndex, int32 PageSize);
	float GetReplayTotalTime();
	bool IsLive();
	bool IsPaused();
	bool IsRecording();
	bool IsReplaying();
	bool Pause();
	void PlayReplayBP(const class FString& SessionOrFriendlyName);
	void PlayReplayBPByRegionOrLocal(const class FString& RegionOrLocal, const class FString& SessionOrFriendlyName);
	void ReplayJump(float TimelinePercentage);
	void SetReplayTimeSpeed(float TimeSpeed);
	void ShowLoadingScreen();
	bool UnPause();

	class FName GetCurrentGameState() const;
	class UGameEventObserver* GetGameEventObserver() const;
	const struct FTslStartParameter GetStartParameter() const;
	class FString GetStartParameterStringValue(const class FString& Key, const class FString& NotFoundValue) const;
	bool UseLobbyWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslGameInstance">();
	}
	static class UTslGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslGameInstance>();
	}
};
static_assert(alignof(UTslGameInstance) == 0x000008, "Wrong alignment on UTslGameInstance");
static_assert(sizeof(UTslGameInstance) == 0x000570, "Wrong size on UTslGameInstance");
static_assert(offsetof(UTslGameInstance, WelcomeScreenMap) == 0x0000F0, "Member 'UTslGameInstance::WelcomeScreenMap' has a wrong offset!");
static_assert(offsetof(UTslGameInstance, bUseLobbyWidget) == 0x000100, "Member 'UTslGameInstance::bUseLobbyWidget' has a wrong offset!");
static_assert(offsetof(UTslGameInstance, LobbyWidgetZOrder) == 0x000104, "Member 'UTslGameInstance::LobbyWidgetZOrder' has a wrong offset!");
static_assert(offsetof(UTslGameInstance, LobbyLink) == 0x000108, "Member 'UTslGameInstance::LobbyLink' has a wrong offset!");
static_assert(offsetof(UTslGameInstance, VivoxManager) == 0x000110, "Member 'UTslGameInstance::VivoxManager' has a wrong offset!");
static_assert(offsetof(UTslGameInstance, StartParamter) == 0x000118, "Member 'UTslGameInstance::StartParamter' has a wrong offset!");
static_assert(offsetof(UTslGameInstance, LobbyWidgetClass) == 0x000318, "Member 'UTslGameInstance::LobbyWidgetClass' has a wrong offset!");
static_assert(offsetof(UTslGameInstance, LobbyWidget) == 0x000440, "Member 'UTslGameInstance::LobbyWidget' has a wrong offset!");
static_assert(offsetof(UTslGameInstance, ReplayKillEventItems) == 0x0004B0, "Member 'UTslGameInstance::ReplayKillEventItems' has a wrong offset!");
static_assert(offsetof(UTslGameInstance, OnEnumerateReplayKillEventsDone) == 0x0004C0, "Member 'UTslGameInstance::OnEnumerateReplayKillEventsDone' has a wrong offset!");
static_assert(offsetof(UTslGameInstance, ReplayItemList) == 0x0004E0, "Member 'UTslGameInstance::ReplayItemList' has a wrong offset!");
static_assert(offsetof(UTslGameInstance, OnGetReplayListDone) == 0x000528, "Member 'UTslGameInstance::OnGetReplayListDone' has a wrong offset!");
static_assert(offsetof(UTslGameInstance, OnGotoTimelineDone) == 0x000538, "Member 'UTslGameInstance::OnGotoTimelineDone' has a wrong offset!");
static_assert(offsetof(UTslGameInstance, OnRecordStarted) == 0x000548, "Member 'UTslGameInstance::OnRecordStarted' has a wrong offset!");
static_assert(offsetof(UTslGameInstance, GameEventObserver) == 0x000560, "Member 'UTslGameInstance::GameEventObserver' has a wrong offset!");

// Class TslGame.TslGameMode
// 0x0338 (0x07A8 - 0x0470)
class ATslGameMode final : public AGameMode
{
public:
	TSubclassOf<class APawn>                      MalePawnClass;                                     // 0x0470(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APlayerController>          PerfBotPlayerControllerClass;                      // 0x0478(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AModeController>            ModeControllerClass;                               // 0x0480(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AModeController>>    AdditionalModeControllerClasses;                   // 0x0488(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoClear, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class UGeneralItemSpawner>        InitialItemDonatorClass;                           // 0x0498(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMatchPreparerClass>            MatchPreparerClasses;                              // 0x04A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EMatchStartType                               MatchStartType;                                    // 0x04B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraViewBehaviour                          CameraViewBehaviour;                               // 0x04B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PlayerRespawn;                                     // 0x04B2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B3[0x1];                                      // 0x04B3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PostMatchWaitingTime;                              // 0x04B4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CustomGamePostMatchWaitingTime;                    // 0x04B8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ESportsPostMatchWaitingTime;                       // 0x04BC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ServerQuitAfterLeavingMapTime;                     // 0x04C0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinPlayers;                                        // 0x04C4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PlayerSpawnTryMaxCount;                            // 0x04C8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnablePerfBotInPIE;                               // 0x04CC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnablePerfBotLogin;                               // 0x04CD(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPerfBotSpawnToRandomPosition;                   // 0x04CE(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanRestartPerfBot;                                // 0x04CF(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableObserverInPIE;                              // 0x04D0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsBattleRoyale;                                    // 0x04D1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartPlayerAtMatchStart;                          // 0x04D2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldSpawnAtStartSpot;                           // 0x04D3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D4[0x1];                                      // 0x04D4(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsCustomGame;                                     // 0x04D5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanAllSpectate;                                   // 0x04D6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D7[0x1];                                      // 0x04D7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCustomGameUpdateCharacterInfo         CustomGameUpdateCharacterInfo;                     // 0x04D8(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, Config, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4EC[0x4];                                      // 0x04EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLimitCustomStringParameter>    LimitCustomStringParameters;                       // 0x04F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	float                                         MultiplierBlueZone;                                // 0x0500(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlueZoneCentralizationFactor;                      // 0x0504(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MultiplierCarePackage;                             // 0x0508(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRedZoneCustomOption                   RedZoneCustomOption;                               // 0x050C(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, Config, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBlueZoneCustomOption>          BlueZoneCustomOptions;                             // 0x0528(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	int32                                         WarmupTime;                                        // 0x0538(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         EditorTestTeamMemberCount;                         // 0x053C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FString, class URewardData*>       RewardDataMap;                                     // 0x0540(0x0050)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class URewardData*                            RewardData;                                        // 0x0590(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATslPlayerState*                        WinnerPlayerState;                                 // 0x0598(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WinnerTeam;                                        // 0x05A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A4[0x4];                                      // 0x05A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UItemSpawnProcessor>        ItemSpawnProcessorClass;                           // 0x05A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UThingSpawnProcessor>       ThingSpawnProcessorClass;                          // 0x05B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UItem>                      BasicBeltItemClassForNoBelt;                       // 0x05B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C0[0x8];                                      // 0x05C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemSpawnProcessor*                    ItemSpawnProcessor;                                // 0x05C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UThingSpawnProcessor*                   ThingSpawnProcessor;                               // 0x05D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGeneralItemSpawner*                    InitialItemDonator;                                // 0x05D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMatchPreparer*                         MatchPreparer;                                     // 0x05E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AModeController*                        ModeController;                                    // 0x05E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ADroppedItemGridManager*                DroppedItemGridManager;                            // 0x05F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AModeController*>                AdditinalModeControllers;                          // 0x05F8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_608[0x98];                                     // 0x0608(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class APlayerState*>      JoinedUserPlayerStateMap;                          // 0x06A0(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FTeams>                         Teams;                                             // 0x06F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_700[0xA8];                                     // 0x0700(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BenchmarkFinished();
	void BroadcastGameModeEvent(class FName EventName, const class FString& Parameter);
	class ATslCharacter* FindCharacterByPlayerState(const class APlayerState* State);
	void FinishMatch();
	void GetAllPawns(TArray<class APawn*>* OutPawns);
	class UItemSpawnProcessor* GetItemSpawnProcessor();
	class UThingSpawnProcessor* GetThingSpawnProcessor();
	void NotifyNextGasInToAll(const struct FVector& PoisonGasWarningPosition, float PoisonGasWarningRadius);
	void NotifyRestrictingPlayAreaToAll();
	void SendSystemMessageToAll(ESystemMessageType MessageType, const class FText& Message, float MessageDuration);

	bool CanDealDamage(const class ATslPlayerState* DamageInstigator, const class ATslPlayerState* DamagedPlayer) const;
	class ULobbyLink* GetLobbyLink() const;
	class UVivoxManager* GetVivoxManager() const;
	bool IsPlayInEditor() const;
	bool IsPreventFinishMatch() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslGameMode">();
	}
	static class ATslGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslGameMode>();
	}
};
static_assert(alignof(ATslGameMode) == 0x000008, "Wrong alignment on ATslGameMode");
static_assert(sizeof(ATslGameMode) == 0x0007A8, "Wrong size on ATslGameMode");
static_assert(offsetof(ATslGameMode, MalePawnClass) == 0x000470, "Member 'ATslGameMode::MalePawnClass' has a wrong offset!");
static_assert(offsetof(ATslGameMode, PerfBotPlayerControllerClass) == 0x000478, "Member 'ATslGameMode::PerfBotPlayerControllerClass' has a wrong offset!");
static_assert(offsetof(ATslGameMode, ModeControllerClass) == 0x000480, "Member 'ATslGameMode::ModeControllerClass' has a wrong offset!");
static_assert(offsetof(ATslGameMode, AdditionalModeControllerClasses) == 0x000488, "Member 'ATslGameMode::AdditionalModeControllerClasses' has a wrong offset!");
static_assert(offsetof(ATslGameMode, InitialItemDonatorClass) == 0x000498, "Member 'ATslGameMode::InitialItemDonatorClass' has a wrong offset!");
static_assert(offsetof(ATslGameMode, MatchPreparerClasses) == 0x0004A0, "Member 'ATslGameMode::MatchPreparerClasses' has a wrong offset!");
static_assert(offsetof(ATslGameMode, MatchStartType) == 0x0004B0, "Member 'ATslGameMode::MatchStartType' has a wrong offset!");
static_assert(offsetof(ATslGameMode, CameraViewBehaviour) == 0x0004B1, "Member 'ATslGameMode::CameraViewBehaviour' has a wrong offset!");
static_assert(offsetof(ATslGameMode, PlayerRespawn) == 0x0004B2, "Member 'ATslGameMode::PlayerRespawn' has a wrong offset!");
static_assert(offsetof(ATslGameMode, PostMatchWaitingTime) == 0x0004B4, "Member 'ATslGameMode::PostMatchWaitingTime' has a wrong offset!");
static_assert(offsetof(ATslGameMode, CustomGamePostMatchWaitingTime) == 0x0004B8, "Member 'ATslGameMode::CustomGamePostMatchWaitingTime' has a wrong offset!");
static_assert(offsetof(ATslGameMode, ESportsPostMatchWaitingTime) == 0x0004BC, "Member 'ATslGameMode::ESportsPostMatchWaitingTime' has a wrong offset!");
static_assert(offsetof(ATslGameMode, ServerQuitAfterLeavingMapTime) == 0x0004C0, "Member 'ATslGameMode::ServerQuitAfterLeavingMapTime' has a wrong offset!");
static_assert(offsetof(ATslGameMode, MinPlayers) == 0x0004C4, "Member 'ATslGameMode::MinPlayers' has a wrong offset!");
static_assert(offsetof(ATslGameMode, PlayerSpawnTryMaxCount) == 0x0004C8, "Member 'ATslGameMode::PlayerSpawnTryMaxCount' has a wrong offset!");
static_assert(offsetof(ATslGameMode, bEnablePerfBotInPIE) == 0x0004CC, "Member 'ATslGameMode::bEnablePerfBotInPIE' has a wrong offset!");
static_assert(offsetof(ATslGameMode, bEnablePerfBotLogin) == 0x0004CD, "Member 'ATslGameMode::bEnablePerfBotLogin' has a wrong offset!");
static_assert(offsetof(ATslGameMode, bIsPerfBotSpawnToRandomPosition) == 0x0004CE, "Member 'ATslGameMode::bIsPerfBotSpawnToRandomPosition' has a wrong offset!");
static_assert(offsetof(ATslGameMode, bCanRestartPerfBot) == 0x0004CF, "Member 'ATslGameMode::bCanRestartPerfBot' has a wrong offset!");
static_assert(offsetof(ATslGameMode, bEnableObserverInPIE) == 0x0004D0, "Member 'ATslGameMode::bEnableObserverInPIE' has a wrong offset!");
static_assert(offsetof(ATslGameMode, IsBattleRoyale) == 0x0004D1, "Member 'ATslGameMode::IsBattleRoyale' has a wrong offset!");
static_assert(offsetof(ATslGameMode, bStartPlayerAtMatchStart) == 0x0004D2, "Member 'ATslGameMode::bStartPlayerAtMatchStart' has a wrong offset!");
static_assert(offsetof(ATslGameMode, bShouldSpawnAtStartSpot) == 0x0004D3, "Member 'ATslGameMode::bShouldSpawnAtStartSpot' has a wrong offset!");
static_assert(offsetof(ATslGameMode, bIsCustomGame) == 0x0004D5, "Member 'ATslGameMode::bIsCustomGame' has a wrong offset!");
static_assert(offsetof(ATslGameMode, bCanAllSpectate) == 0x0004D6, "Member 'ATslGameMode::bCanAllSpectate' has a wrong offset!");
static_assert(offsetof(ATslGameMode, CustomGameUpdateCharacterInfo) == 0x0004D8, "Member 'ATslGameMode::CustomGameUpdateCharacterInfo' has a wrong offset!");
static_assert(offsetof(ATslGameMode, LimitCustomStringParameters) == 0x0004F0, "Member 'ATslGameMode::LimitCustomStringParameters' has a wrong offset!");
static_assert(offsetof(ATslGameMode, MultiplierBlueZone) == 0x000500, "Member 'ATslGameMode::MultiplierBlueZone' has a wrong offset!");
static_assert(offsetof(ATslGameMode, BlueZoneCentralizationFactor) == 0x000504, "Member 'ATslGameMode::BlueZoneCentralizationFactor' has a wrong offset!");
static_assert(offsetof(ATslGameMode, MultiplierCarePackage) == 0x000508, "Member 'ATslGameMode::MultiplierCarePackage' has a wrong offset!");
static_assert(offsetof(ATslGameMode, RedZoneCustomOption) == 0x00050C, "Member 'ATslGameMode::RedZoneCustomOption' has a wrong offset!");
static_assert(offsetof(ATslGameMode, BlueZoneCustomOptions) == 0x000528, "Member 'ATslGameMode::BlueZoneCustomOptions' has a wrong offset!");
static_assert(offsetof(ATslGameMode, WarmupTime) == 0x000538, "Member 'ATslGameMode::WarmupTime' has a wrong offset!");
static_assert(offsetof(ATslGameMode, EditorTestTeamMemberCount) == 0x00053C, "Member 'ATslGameMode::EditorTestTeamMemberCount' has a wrong offset!");
static_assert(offsetof(ATslGameMode, RewardDataMap) == 0x000540, "Member 'ATslGameMode::RewardDataMap' has a wrong offset!");
static_assert(offsetof(ATslGameMode, RewardData) == 0x000590, "Member 'ATslGameMode::RewardData' has a wrong offset!");
static_assert(offsetof(ATslGameMode, WinnerPlayerState) == 0x000598, "Member 'ATslGameMode::WinnerPlayerState' has a wrong offset!");
static_assert(offsetof(ATslGameMode, WinnerTeam) == 0x0005A0, "Member 'ATslGameMode::WinnerTeam' has a wrong offset!");
static_assert(offsetof(ATslGameMode, ItemSpawnProcessorClass) == 0x0005A8, "Member 'ATslGameMode::ItemSpawnProcessorClass' has a wrong offset!");
static_assert(offsetof(ATslGameMode, ThingSpawnProcessorClass) == 0x0005B0, "Member 'ATslGameMode::ThingSpawnProcessorClass' has a wrong offset!");
static_assert(offsetof(ATslGameMode, BasicBeltItemClassForNoBelt) == 0x0005B8, "Member 'ATslGameMode::BasicBeltItemClassForNoBelt' has a wrong offset!");
static_assert(offsetof(ATslGameMode, ItemSpawnProcessor) == 0x0005C8, "Member 'ATslGameMode::ItemSpawnProcessor' has a wrong offset!");
static_assert(offsetof(ATslGameMode, ThingSpawnProcessor) == 0x0005D0, "Member 'ATslGameMode::ThingSpawnProcessor' has a wrong offset!");
static_assert(offsetof(ATslGameMode, InitialItemDonator) == 0x0005D8, "Member 'ATslGameMode::InitialItemDonator' has a wrong offset!");
static_assert(offsetof(ATslGameMode, MatchPreparer) == 0x0005E0, "Member 'ATslGameMode::MatchPreparer' has a wrong offset!");
static_assert(offsetof(ATslGameMode, ModeController) == 0x0005E8, "Member 'ATslGameMode::ModeController' has a wrong offset!");
static_assert(offsetof(ATslGameMode, DroppedItemGridManager) == 0x0005F0, "Member 'ATslGameMode::DroppedItemGridManager' has a wrong offset!");
static_assert(offsetof(ATslGameMode, AdditinalModeControllers) == 0x0005F8, "Member 'ATslGameMode::AdditinalModeControllers' has a wrong offset!");
static_assert(offsetof(ATslGameMode, JoinedUserPlayerStateMap) == 0x0006A0, "Member 'ATslGameMode::JoinedUserPlayerStateMap' has a wrong offset!");
static_assert(offsetof(ATslGameMode, Teams) == 0x0006F0, "Member 'ATslGameMode::Teams' has a wrong offset!");

// Class TslGame.TslGameState
// 0x00B0 (0x04B0 - 0x0400)
class ATslGameState : public AGameState
{
public:
	class FString                                 MatchId;                                           // 0x0400(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchShortGuid;                                    // 0x0410(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumTeams;                                          // 0x0420(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RemainingTime;                                     // 0x0424(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTimerPaused;                                      // 0x0428(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_429[0x3];                                      // 0x0429(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumJoinPlayers;                                    // 0x042C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumAlivePlayers;                                   // 0x0430(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumAliveTeams;                                     // 0x0434(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumStartPlayers;                                   // 0x0438(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumStartTeams;                                     // 0x043C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SafetyZonePosition;                                // 0x0440(0x000C)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SafetyZoneRadius;                                  // 0x044C(0x0004)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PoisonGasWarningPosition;                          // 0x0450(0x000C)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PoisonGasWarningRadius;                            // 0x045C(0x0004)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RedZonePosition;                                   // 0x0460(0x000C)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RedZoneRadius;                                     // 0x046C(0x0004)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalReleaseDuration;                              // 0x0470(0x0004)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElapsedReleaseDuration;                            // 0x0474(0x0004)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalWarningDuration;                              // 0x0478(0x0004)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ElapsedWarningDuration;                            // 0x047C(0x0004)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGasRelease;                                     // 0x0480(0x0001)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTeamMatch;                                      // 0x0481(0x0001)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_482[0x2];                                      // 0x0482(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ElapsedGasReleaseDuration;                         // 0x0484(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LerpSafetyZonePosition;                            // 0x0488(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LerpSafetyZoneRadius;                              // 0x0494(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SafetyZoneBeginPosition;                           // 0x0498(0x000C)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SafetyZoneBeginRadius;                             // 0x04A4(0x0004)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ALevelAttribute*                        LevelAttribute;                                    // 0x04A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_GasRelease(bool bLastIsGasRelease);
	void OnRep_MatchShortGuid();
	void OnStartGasRelease(bool InbIsGasRelease);
	void UpdateWorldTimeSecondsDelta(float DeltaSeconds);

	class ALevelAttribute* GetLevelAttribute() const;
	bool IsMatchInProgressBP() const;
	void ShowPlayerStateList() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslGameState">();
	}
	static class ATslGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslGameState>();
	}
};
static_assert(alignof(ATslGameState) == 0x000008, "Wrong alignment on ATslGameState");
static_assert(sizeof(ATslGameState) == 0x0004B0, "Wrong size on ATslGameState");
static_assert(offsetof(ATslGameState, MatchId) == 0x000400, "Member 'ATslGameState::MatchId' has a wrong offset!");
static_assert(offsetof(ATslGameState, MatchShortGuid) == 0x000410, "Member 'ATslGameState::MatchShortGuid' has a wrong offset!");
static_assert(offsetof(ATslGameState, NumTeams) == 0x000420, "Member 'ATslGameState::NumTeams' has a wrong offset!");
static_assert(offsetof(ATslGameState, RemainingTime) == 0x000424, "Member 'ATslGameState::RemainingTime' has a wrong offset!");
static_assert(offsetof(ATslGameState, bTimerPaused) == 0x000428, "Member 'ATslGameState::bTimerPaused' has a wrong offset!");
static_assert(offsetof(ATslGameState, NumJoinPlayers) == 0x00042C, "Member 'ATslGameState::NumJoinPlayers' has a wrong offset!");
static_assert(offsetof(ATslGameState, NumAlivePlayers) == 0x000430, "Member 'ATslGameState::NumAlivePlayers' has a wrong offset!");
static_assert(offsetof(ATslGameState, NumAliveTeams) == 0x000434, "Member 'ATslGameState::NumAliveTeams' has a wrong offset!");
static_assert(offsetof(ATslGameState, NumStartPlayers) == 0x000438, "Member 'ATslGameState::NumStartPlayers' has a wrong offset!");
static_assert(offsetof(ATslGameState, NumStartTeams) == 0x00043C, "Member 'ATslGameState::NumStartTeams' has a wrong offset!");
static_assert(offsetof(ATslGameState, SafetyZonePosition) == 0x000440, "Member 'ATslGameState::SafetyZonePosition' has a wrong offset!");
static_assert(offsetof(ATslGameState, SafetyZoneRadius) == 0x00044C, "Member 'ATslGameState::SafetyZoneRadius' has a wrong offset!");
static_assert(offsetof(ATslGameState, PoisonGasWarningPosition) == 0x000450, "Member 'ATslGameState::PoisonGasWarningPosition' has a wrong offset!");
static_assert(offsetof(ATslGameState, PoisonGasWarningRadius) == 0x00045C, "Member 'ATslGameState::PoisonGasWarningRadius' has a wrong offset!");
static_assert(offsetof(ATslGameState, RedZonePosition) == 0x000460, "Member 'ATslGameState::RedZonePosition' has a wrong offset!");
static_assert(offsetof(ATslGameState, RedZoneRadius) == 0x00046C, "Member 'ATslGameState::RedZoneRadius' has a wrong offset!");
static_assert(offsetof(ATslGameState, TotalReleaseDuration) == 0x000470, "Member 'ATslGameState::TotalReleaseDuration' has a wrong offset!");
static_assert(offsetof(ATslGameState, ElapsedReleaseDuration) == 0x000474, "Member 'ATslGameState::ElapsedReleaseDuration' has a wrong offset!");
static_assert(offsetof(ATslGameState, TotalWarningDuration) == 0x000478, "Member 'ATslGameState::TotalWarningDuration' has a wrong offset!");
static_assert(offsetof(ATslGameState, ElapsedWarningDuration) == 0x00047C, "Member 'ATslGameState::ElapsedWarningDuration' has a wrong offset!");
static_assert(offsetof(ATslGameState, bIsGasRelease) == 0x000480, "Member 'ATslGameState::bIsGasRelease' has a wrong offset!");
static_assert(offsetof(ATslGameState, bIsTeamMatch) == 0x000481, "Member 'ATslGameState::bIsTeamMatch' has a wrong offset!");
static_assert(offsetof(ATslGameState, ElapsedGasReleaseDuration) == 0x000484, "Member 'ATslGameState::ElapsedGasReleaseDuration' has a wrong offset!");
static_assert(offsetof(ATslGameState, LerpSafetyZonePosition) == 0x000488, "Member 'ATslGameState::LerpSafetyZonePosition' has a wrong offset!");
static_assert(offsetof(ATslGameState, LerpSafetyZoneRadius) == 0x000494, "Member 'ATslGameState::LerpSafetyZoneRadius' has a wrong offset!");
static_assert(offsetof(ATslGameState, SafetyZoneBeginPosition) == 0x000498, "Member 'ATslGameState::SafetyZoneBeginPosition' has a wrong offset!");
static_assert(offsetof(ATslGameState, SafetyZoneBeginRadius) == 0x0004A4, "Member 'ATslGameState::SafetyZoneBeginRadius' has a wrong offset!");
static_assert(offsetof(ATslGameState, LevelAttribute) == 0x0004A8, "Member 'ATslGameState::LevelAttribute' has a wrong offset!");

// Class TslGame.TslGameUserSettings
// 0x00F8 (0x01F8 - 0x0100)
class UTslGameUserSettings final : public UGameUserSettings
{
public:
	float                                         ScreenScale;                                       // 0x0100(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Gamma;                                             // 0x0104(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsLanMatch;                                       // 0x0108(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsMasterSoundMute;                                // 0x0109(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10A[0x2];                                      // 0x010A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MasterSoundVolume;                                 // 0x010C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsEffectSoundMute;                                // 0x0110(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EffectSoundVolume;                                 // 0x0114(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsUISoundMute;                                    // 0x0118(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UISoundVolume;                                     // 0x011C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsBGMSoundMute;                                   // 0x0120(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_121[0x3];                                      // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BGMSoundVolume;                                    // 0x0124(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsVoiceInputMute;                                 // 0x0128(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsVoiceOutputMute;                                // 0x0129(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12A[0x2];                                      // 0x012A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VoiceInputVolume;                                  // 0x012C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         VoiceOutputVolume;                                 // 0x0130(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUsePushToTalk;                                    // 0x0134(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseGlobalVoice;                                   // 0x0135(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseTeamVoice;                                     // 0x0136(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSavedGraphicOption;                               // 0x0137(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMotionBlur;                                       // 0x0138(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_139[0x7];                                      // 0x0139(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CultureName;                                       // 0x0140(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FCustomInputSettings                   CustomInputSettins;                                // 0x0150(0x0040)(Config, NativeAccessSpecifierPrivate)
	int32                                         SelectMiniMapIndex;                                // 0x0190(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FpsCamearFov;                                      // 0x0194(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseForceFeedback;                                 // 0x0198(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_199[0x3];                                      // 0x0199(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ColorBlindType;                                    // 0x019C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 CrosshairColorString;                              // 0x01A0(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UItem>>              GearProfile1;                                      // 0x01B0(0x0010)(ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class UItem>>              GearProfile2;                                      // 0x01C0(0x0010)(ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPrivate)
	EUiShowType                                   FppWeaponIconShowType;                             // 0x01D0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EUiShowType                                   TpsWeaponIconShowType;                             // 0x01D1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EUiShowType                                   FppEquipableItemIconShowType;                      // 0x01D2(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseCharacterCapture;                              // 0x01D3(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         WorldMapZoomSpeedLevel;                            // 0x01D4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ETslInputModes                                InputModeCrouch;                                   // 0x01D8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETslInputModes                                InputModeProne;                                    // 0x01D9(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETslInputModes                                InputModeWalk;                                     // 0x01DA(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETslInputModes                                bToggleSprint;                                     // 0x01DB(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETslInputModes                                InputModeHoldRotation;                             // 0x01DC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETslInputModes                                InputModeHoldBreath;                               // 0x01DD(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETslInputModes                                InputModePeek;                                     // 0x01DE(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETslInputModes                                InputModeMap;                                      // 0x01DF(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETslInputModes                                InputModeADS;                                      // 0x01E0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEditorApplyOverrideScalability;                   // 0x01E1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseFreeLookInterp;                                // 0x01E2(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E3[0x5];                                      // 0x01E3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnGameUserSettingApplied;                          // 0x01E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslGameUserSettings">();
	}
	static class UTslGameUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslGameUserSettings>();
	}
};
static_assert(alignof(UTslGameUserSettings) == 0x000008, "Wrong alignment on UTslGameUserSettings");
static_assert(sizeof(UTslGameUserSettings) == 0x0001F8, "Wrong size on UTslGameUserSettings");
static_assert(offsetof(UTslGameUserSettings, ScreenScale) == 0x000100, "Member 'UTslGameUserSettings::ScreenScale' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, Gamma) == 0x000104, "Member 'UTslGameUserSettings::Gamma' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, bIsLanMatch) == 0x000108, "Member 'UTslGameUserSettings::bIsLanMatch' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, bIsMasterSoundMute) == 0x000109, "Member 'UTslGameUserSettings::bIsMasterSoundMute' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, MasterSoundVolume) == 0x00010C, "Member 'UTslGameUserSettings::MasterSoundVolume' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, bIsEffectSoundMute) == 0x000110, "Member 'UTslGameUserSettings::bIsEffectSoundMute' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, EffectSoundVolume) == 0x000114, "Member 'UTslGameUserSettings::EffectSoundVolume' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, bIsUISoundMute) == 0x000118, "Member 'UTslGameUserSettings::bIsUISoundMute' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, UISoundVolume) == 0x00011C, "Member 'UTslGameUserSettings::UISoundVolume' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, bIsBGMSoundMute) == 0x000120, "Member 'UTslGameUserSettings::bIsBGMSoundMute' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, BGMSoundVolume) == 0x000124, "Member 'UTslGameUserSettings::BGMSoundVolume' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, bIsVoiceInputMute) == 0x000128, "Member 'UTslGameUserSettings::bIsVoiceInputMute' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, bIsVoiceOutputMute) == 0x000129, "Member 'UTslGameUserSettings::bIsVoiceOutputMute' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, VoiceInputVolume) == 0x00012C, "Member 'UTslGameUserSettings::VoiceInputVolume' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, VoiceOutputVolume) == 0x000130, "Member 'UTslGameUserSettings::VoiceOutputVolume' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, bUsePushToTalk) == 0x000134, "Member 'UTslGameUserSettings::bUsePushToTalk' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, bUseGlobalVoice) == 0x000135, "Member 'UTslGameUserSettings::bUseGlobalVoice' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, bUseTeamVoice) == 0x000136, "Member 'UTslGameUserSettings::bUseTeamVoice' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, bSavedGraphicOption) == 0x000137, "Member 'UTslGameUserSettings::bSavedGraphicOption' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, bMotionBlur) == 0x000138, "Member 'UTslGameUserSettings::bMotionBlur' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, CultureName) == 0x000140, "Member 'UTslGameUserSettings::CultureName' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, CustomInputSettins) == 0x000150, "Member 'UTslGameUserSettings::CustomInputSettins' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, SelectMiniMapIndex) == 0x000190, "Member 'UTslGameUserSettings::SelectMiniMapIndex' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, FpsCamearFov) == 0x000194, "Member 'UTslGameUserSettings::FpsCamearFov' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, bUseForceFeedback) == 0x000198, "Member 'UTslGameUserSettings::bUseForceFeedback' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, ColorBlindType) == 0x00019C, "Member 'UTslGameUserSettings::ColorBlindType' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, CrosshairColorString) == 0x0001A0, "Member 'UTslGameUserSettings::CrosshairColorString' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, GearProfile1) == 0x0001B0, "Member 'UTslGameUserSettings::GearProfile1' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, GearProfile2) == 0x0001C0, "Member 'UTslGameUserSettings::GearProfile2' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, FppWeaponIconShowType) == 0x0001D0, "Member 'UTslGameUserSettings::FppWeaponIconShowType' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, TpsWeaponIconShowType) == 0x0001D1, "Member 'UTslGameUserSettings::TpsWeaponIconShowType' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, FppEquipableItemIconShowType) == 0x0001D2, "Member 'UTslGameUserSettings::FppEquipableItemIconShowType' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, bUseCharacterCapture) == 0x0001D3, "Member 'UTslGameUserSettings::bUseCharacterCapture' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, WorldMapZoomSpeedLevel) == 0x0001D4, "Member 'UTslGameUserSettings::WorldMapZoomSpeedLevel' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, InputModeCrouch) == 0x0001D8, "Member 'UTslGameUserSettings::InputModeCrouch' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, InputModeProne) == 0x0001D9, "Member 'UTslGameUserSettings::InputModeProne' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, InputModeWalk) == 0x0001DA, "Member 'UTslGameUserSettings::InputModeWalk' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, bToggleSprint) == 0x0001DB, "Member 'UTslGameUserSettings::bToggleSprint' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, InputModeHoldRotation) == 0x0001DC, "Member 'UTslGameUserSettings::InputModeHoldRotation' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, InputModeHoldBreath) == 0x0001DD, "Member 'UTslGameUserSettings::InputModeHoldBreath' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, InputModePeek) == 0x0001DE, "Member 'UTslGameUserSettings::InputModePeek' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, InputModeMap) == 0x0001DF, "Member 'UTslGameUserSettings::InputModeMap' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, InputModeADS) == 0x0001E0, "Member 'UTslGameUserSettings::InputModeADS' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, bEditorApplyOverrideScalability) == 0x0001E1, "Member 'UTslGameUserSettings::bEditorApplyOverrideScalability' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, bUseFreeLookInterp) == 0x0001E2, "Member 'UTslGameUserSettings::bUseFreeLookInterp' has a wrong offset!");
static_assert(offsetof(UTslGameUserSettings, OnGameUserSettingApplied) == 0x0001E8, "Member 'UTslGameUserSettings::OnGameUserSettingApplied' has a wrong offset!");

// Class TslGame.TslGlassWindowComponent
// 0x0030 (0x0840 - 0x0810)
class UTslGlassWindowComponent final : public UStaticMeshComponent
{
public:
	class UDestructibleMesh*                      DestructibleMesh;                                  // 0x0808(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestroyDelayAfterDestructed;                       // 0x0810(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_814[0x4];                                      // 0x0814(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          DestructSound;                                     // 0x0818(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDestructibleComponent*                 DestructibleComponent;                             // 0x0820(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bReplicatedOnClient : 1;                           // 0x0828(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDestroyed : 1;                                    // 0x0828(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_829[0x17];                                     // 0x0829(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientNotifyHit(bool bBlockingHit, const struct FVector_NetQuantize& Location, const struct FVector_NetQuantizeNormal& ImpactNormal);
	void OnRep_Destroyed(bool bLastDestroyed);
	void OnRep_ReplicatedOnClient(bool bLastReplicatedOnClient);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslGlassWindowComponent">();
	}
	static class UTslGlassWindowComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslGlassWindowComponent>();
	}
};
static_assert(alignof(UTslGlassWindowComponent) == 0x000010, "Wrong alignment on UTslGlassWindowComponent");
static_assert(sizeof(UTslGlassWindowComponent) == 0x000840, "Wrong size on UTslGlassWindowComponent");
static_assert(offsetof(UTslGlassWindowComponent, DestructibleMesh) == 0x000808, "Member 'UTslGlassWindowComponent::DestructibleMesh' has a wrong offset!");
static_assert(offsetof(UTslGlassWindowComponent, DestroyDelayAfterDestructed) == 0x000810, "Member 'UTslGlassWindowComponent::DestroyDelayAfterDestructed' has a wrong offset!");
static_assert(offsetof(UTslGlassWindowComponent, DestructSound) == 0x000818, "Member 'UTslGlassWindowComponent::DestructSound' has a wrong offset!");
static_assert(offsetof(UTslGlassWindowComponent, DestructibleComponent) == 0x000820, "Member 'UTslGlassWindowComponent::DestructibleComponent' has a wrong offset!");

// Class TslGame.TslHealthGaugeData
// 0x0020 (0x0048 - 0x0028)
class UTslHealthGaugeData final : public UDataAsset
{
public:
	TArray<struct FHealthColorData>               HealthGaugeColors;                                 // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FFloatInterval                         WarningRage;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UCurveLinearColor*                      GroggyColorCurve;                                  // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	struct FLinearColor GetGaugeColor(float HealthPercent) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslHealthGaugeData">();
	}
	static class UTslHealthGaugeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslHealthGaugeData>();
	}
};
static_assert(alignof(UTslHealthGaugeData) == 0x000008, "Wrong alignment on UTslHealthGaugeData");
static_assert(sizeof(UTslHealthGaugeData) == 0x000048, "Wrong size on UTslHealthGaugeData");
static_assert(offsetof(UTslHealthGaugeData, HealthGaugeColors) == 0x000028, "Member 'UTslHealthGaugeData::HealthGaugeColors' has a wrong offset!");
static_assert(offsetof(UTslHealthGaugeData, WarningRage) == 0x000038, "Member 'UTslHealthGaugeData::WarningRage' has a wrong offset!");
static_assert(offsetof(UTslHealthGaugeData, GroggyColorCurve) == 0x000040, "Member 'UTslHealthGaugeData::GroggyColorCurve' has a wrong offset!");

// Class TslGame.TslInstancedReactionComponent
// 0x01E0 (0x0BC0 - 0x09E0)
class UTslInstancedReactionComponent final : public UGridInstancedStaticMeshComponent
{
public:
	uint8                                         Pad_9E0[0x8];                                      // 0x09E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 PendingDestroyInstances;                           // 0x09E8(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	class UTslReactionData*                       ReactionData;                                      // 0x09F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDestructibleMesh*                      ReactionDM;                                        // 0x0A00(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A08[0x1B8];                                    // 0x0A08(0x01B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Client_ReactByPointDamage(int32 InstanceIndex, float DamageAmount, const struct FVector& Impact, const struct FVector& ImpulseDir);
	void Client_ReactByRadialDamage(int32 InstanceIndex, float DamageAmount, const struct FVector& Origin, const struct FVector& Impact, const struct FVector& ImpulseDir, float OuterRadius);
	void Client_ReactByVehicle(int32 InstanceIndex, const struct FVector& Impact, const struct FVector& ImpulseDir, const struct FVector& Velocity);
	void OnRep_PendingDestroy();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslInstancedReactionComponent">();
	}
	static class UTslInstancedReactionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslInstancedReactionComponent>();
	}
};
static_assert(alignof(UTslInstancedReactionComponent) == 0x000010, "Wrong alignment on UTslInstancedReactionComponent");
static_assert(sizeof(UTslInstancedReactionComponent) == 0x000BC0, "Wrong size on UTslInstancedReactionComponent");
static_assert(offsetof(UTslInstancedReactionComponent, PendingDestroyInstances) == 0x0009E8, "Member 'UTslInstancedReactionComponent::PendingDestroyInstances' has a wrong offset!");
static_assert(offsetof(UTslInstancedReactionComponent, ReactionData) == 0x0009F8, "Member 'UTslInstancedReactionComponent::ReactionData' has a wrong offset!");
static_assert(offsetof(UTslInstancedReactionComponent, ReactionDM) == 0x000A00, "Member 'UTslInstancedReactionComponent::ReactionDM' has a wrong offset!");

// Class TslGame.TslLevelScriptActor
// 0x00A8 (0x0450 - 0x03A8)
class ATslLevelScriptActor final : public ALevelScriptActor
{
public:
	TArray<struct FWeatherLevelInfo>              WeatherLevelInfos;                                 // 0x03A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UMaterialParameterCollection*           GlobalMPC;                                         // 0x03B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SelectedWeatherLevelIndex;                         // 0x03C0(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C4[0x8C];                                     // 0x03C4(0x008C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnumerateReplayLevelEvents();
	void OnRep_SelectedWeatherIndex();
	void RecordWeatherAsCustomEvent();
	void RequestReplayALevelWeatherEvent(const class FString& EventID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslLevelScriptActor">();
	}
	static class ATslLevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslLevelScriptActor>();
	}
};
static_assert(alignof(ATslLevelScriptActor) == 0x000008, "Wrong alignment on ATslLevelScriptActor");
static_assert(sizeof(ATslLevelScriptActor) == 0x000450, "Wrong size on ATslLevelScriptActor");
static_assert(offsetof(ATslLevelScriptActor, WeatherLevelInfos) == 0x0003A8, "Member 'ATslLevelScriptActor::WeatherLevelInfos' has a wrong offset!");
static_assert(offsetof(ATslLevelScriptActor, GlobalMPC) == 0x0003B8, "Member 'ATslLevelScriptActor::GlobalMPC' has a wrong offset!");
static_assert(offsetof(ATslLevelScriptActor, SelectedWeatherLevelIndex) == 0x0003C0, "Member 'ATslLevelScriptActor::SelectedWeatherLevelIndex' has a wrong offset!");

// Class TslGame.TslPersistentUser
// 0x0030 (0x0058 - 0x0028)
class UTslPersistentUser final : public USaveGame
{
public:
	float                                         Gamma;                                             // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AimSensitivity;                                    // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInvertedYAxis;                                    // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScreenScalePercentage;                             // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslPersistentUser">();
	}
	static class UTslPersistentUser* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslPersistentUser>();
	}
};
static_assert(alignof(UTslPersistentUser) == 0x000008, "Wrong alignment on UTslPersistentUser");
static_assert(sizeof(UTslPersistentUser) == 0x000058, "Wrong size on UTslPersistentUser");
static_assert(offsetof(UTslPersistentUser, Gamma) == 0x000028, "Member 'UTslPersistentUser::Gamma' has a wrong offset!");
static_assert(offsetof(UTslPersistentUser, AimSensitivity) == 0x00002C, "Member 'UTslPersistentUser::AimSensitivity' has a wrong offset!");
static_assert(offsetof(UTslPersistentUser, bInvertedYAxis) == 0x000030, "Member 'UTslPersistentUser::bInvertedYAxis' has a wrong offset!");
static_assert(offsetof(UTslPersistentUser, ScreenScalePercentage) == 0x000034, "Member 'UTslPersistentUser::ScreenScalePercentage' has a wrong offset!");

// Class TslGame.TslLocalPlayer
// 0x0008 (0x0198 - 0x0190)
class UTslLocalPlayer final : public ULocalPlayer
{
public:
	class UTslPersistentUser*                     PersistentUser;                                    // 0x0190(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslLocalPlayer">();
	}
	static class UTslLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslLocalPlayer>();
	}
};
static_assert(alignof(UTslLocalPlayer) == 0x000008, "Wrong alignment on UTslLocalPlayer");
static_assert(sizeof(UTslLocalPlayer) == 0x000198, "Wrong size on UTslLocalPlayer");
static_assert(offsetof(UTslLocalPlayer, PersistentUser) == 0x000190, "Member 'UTslLocalPlayer::PersistentUser' has a wrong offset!");

// Class TslGame.TslMenuItemWidgetStyle
// 0x01B8 (0x01E8 - 0x0030)
class UTslMenuItemWidgetStyle final : public USlateWidgetStyleContainerBase
{
public:
	struct FTslMenuItemStyle                      MenuItemStyle;                                     // 0x0030(0x01B8)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslMenuItemWidgetStyle">();
	}
	static class UTslMenuItemWidgetStyle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslMenuItemWidgetStyle>();
	}
};
static_assert(alignof(UTslMenuItemWidgetStyle) == 0x000008, "Wrong alignment on UTslMenuItemWidgetStyle");
static_assert(sizeof(UTslMenuItemWidgetStyle) == 0x0001E8, "Wrong size on UTslMenuItemWidgetStyle");
static_assert(offsetof(UTslMenuItemWidgetStyle, MenuItemStyle) == 0x000030, "Member 'UTslMenuItemWidgetStyle::MenuItemStyle' has a wrong offset!");

// Class TslGame.TslMenuSoundsWidgetStyle
// 0x0038 (0x0068 - 0x0030)
class UTslMenuSoundsWidgetStyle final : public USlateWidgetStyleContainerBase
{
public:
	struct FTslMenuSoundsStyle                    SoundsStyle;                                       // 0x0030(0x0038)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslMenuSoundsWidgetStyle">();
	}
	static class UTslMenuSoundsWidgetStyle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslMenuSoundsWidgetStyle>();
	}
};
static_assert(alignof(UTslMenuSoundsWidgetStyle) == 0x000008, "Wrong alignment on UTslMenuSoundsWidgetStyle");
static_assert(sizeof(UTslMenuSoundsWidgetStyle) == 0x000068, "Wrong size on UTslMenuSoundsWidgetStyle");
static_assert(offsetof(UTslMenuSoundsWidgetStyle, SoundsStyle) == 0x000030, "Member 'UTslMenuSoundsWidgetStyle::SoundsStyle' has a wrong offset!");

// Class TslGame.TslMenuWidgetStyle
// 0x0218 (0x0248 - 0x0030)
class UTslMenuWidgetStyle final : public USlateWidgetStyleContainerBase
{
public:
	struct FTslMenuStyle                          MenuStyle;                                         // 0x0030(0x0218)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslMenuWidgetStyle">();
	}
	static class UTslMenuWidgetStyle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslMenuWidgetStyle>();
	}
};
static_assert(alignof(UTslMenuWidgetStyle) == 0x000008, "Wrong alignment on UTslMenuWidgetStyle");
static_assert(sizeof(UTslMenuWidgetStyle) == 0x000248, "Wrong size on UTslMenuWidgetStyle");
static_assert(offsetof(UTslMenuWidgetStyle, MenuStyle) == 0x000030, "Member 'UTslMenuWidgetStyle::MenuStyle' has a wrong offset!");

// Class TslGame.TslModularBuilding
// 0x0100 (0x04A0 - 0x03A0)
class ATslModularBuilding final : public AActor
{
public:
	uint8                                         Pad_3A0[0x100];                                    // 0x03A0(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAttachmentToTable(const class FString& Keyword, class UStaticMeshComponent* Attachment);
	void AddBuildingModuleToTable(const class FString& Keyword, class UStaticMeshComponent* Building);
	void ClearAttachmentTable();
	void ClearBuildingModuleTable();
	TArray<class UStaticMeshComponent*> GetAttachmentsFromTable(const class FString& Keyword);
	TArray<class UStaticMeshComponent*> GetBuildingModuleFromTable(const class FString& Keyword);
	TArray<class UStaticMeshComponent*> GetMeshOnSapartedFloor(int32 SepartedFloor, const class FString& Keyword);
	void PassSeparatedFloors(const TArray<class UChildActorComponent*>& Floors);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslModularBuilding">();
	}
	static class ATslModularBuilding* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslModularBuilding>();
	}
};
static_assert(alignof(ATslModularBuilding) == 0x000008, "Wrong alignment on ATslModularBuilding");
static_assert(sizeof(ATslModularBuilding) == 0x0004A0, "Wrong size on ATslModularBuilding");

// Class TslGame.TslPassBluezoneArea
// 0x0010 (0x03B0 - 0x03A0)
class ATslPassBluezoneArea final : public AActor
{
public:
	class USphereComponent*                       SphereComponent;                                   // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Radius;                                            // 0x03A8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3AC[0x4];                                      // 0x03AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslPassBluezoneArea">();
	}
	static class ATslPassBluezoneArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslPassBluezoneArea>();
	}
};
static_assert(alignof(ATslPassBluezoneArea) == 0x000008, "Wrong alignment on ATslPassBluezoneArea");
static_assert(sizeof(ATslPassBluezoneArea) == 0x0003B0, "Wrong size on ATslPassBluezoneArea");
static_assert(offsetof(ATslPassBluezoneArea, SphereComponent) == 0x0003A0, "Member 'ATslPassBluezoneArea::SphereComponent' has a wrong offset!");
static_assert(offsetof(ATslPassBluezoneArea, Radius) == 0x0003A8, "Member 'ATslPassBluezoneArea::Radius' has a wrong offset!");

// Class TslGame.TslPlayerState
// 0x01F0 (0x0620 - 0x0430)
class ATslPlayerState final : public APlayerState
{
public:
	int32                                         Ranking;                                           // 0x0430(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bKilled : 1;                                       // 0x0434(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	bool                                          bShowMapMarker;                                    // 0x0435(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_436[0x2];                                      // 0x0436(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              MapMarkerPosition;                                 // 0x0438(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EObserverAuthorityType                        ObserverAuthorityType;                             // 0x0440(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_441[0x3];                                      // 0x0441(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TeamNumber;                                        // 0x0444(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTslPlayerScores                       PlayerScores;                                      // 0x0448(0x000C)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTslPlayerStatistics                   PlayerStatistics;                                  // 0x0454(0x0004)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_458[0xA8];                                     // 0x0458(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FReplicatedEquipableItem>       ReplicatedEquipableItems;                          // 0x0500(0x0010)(Net, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_510[0x1C];                                     // 0x0510(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bQuitter : 1;                                      // 0x052C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_52D[0xDF];                                     // 0x052D(0x00DF)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastHitTime;                                       // 0x060C(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    CurrentAttackedPlayerLocation;                     // 0x0610(0x000C)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	uint8                                         Pad_61C[0x4];                                      // 0x061C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastDeath(class ATslPlayerState* KillerPlayerState, class ATslPlayerState* GroggyPlayerInstigator, const class UDamageType* KillerDamageType, EDamageReason DamageReason, const class FText& DamageCauserName, int32 AlivePlayerNum, int32 AliveTeamNum, bool InbIsStealKilled);
	void InformAboutKill(const class UDamageType* KillerDamageType, class ATslPlayerState* KilledPlayerState);
	void OnRep_LastHitTime();
	void OnRep_PlayerStatistics(const struct FTslPlayerStatistics& OldPlayerStatistics);

	int32 GetKills() const;
	EObserverAuthorityType GetObserverAuthorityType() const;
	float GetPing() const;
	struct FTslPlayerScores GetPlayerScores() const;
	class FString GetShortPlayerName() const;
	int32 GetTeamNum() const;
	bool IsObserver() const;
	bool IsQuitter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslPlayerState">();
	}
	static class ATslPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslPlayerState>();
	}
};
static_assert(alignof(ATslPlayerState) == 0x000008, "Wrong alignment on ATslPlayerState");
static_assert(sizeof(ATslPlayerState) == 0x000620, "Wrong size on ATslPlayerState");
static_assert(offsetof(ATslPlayerState, Ranking) == 0x000430, "Member 'ATslPlayerState::Ranking' has a wrong offset!");
static_assert(offsetof(ATslPlayerState, bShowMapMarker) == 0x000435, "Member 'ATslPlayerState::bShowMapMarker' has a wrong offset!");
static_assert(offsetof(ATslPlayerState, MapMarkerPosition) == 0x000438, "Member 'ATslPlayerState::MapMarkerPosition' has a wrong offset!");
static_assert(offsetof(ATslPlayerState, ObserverAuthorityType) == 0x000440, "Member 'ATslPlayerState::ObserverAuthorityType' has a wrong offset!");
static_assert(offsetof(ATslPlayerState, TeamNumber) == 0x000444, "Member 'ATslPlayerState::TeamNumber' has a wrong offset!");
static_assert(offsetof(ATslPlayerState, PlayerScores) == 0x000448, "Member 'ATslPlayerState::PlayerScores' has a wrong offset!");
static_assert(offsetof(ATslPlayerState, PlayerStatistics) == 0x000454, "Member 'ATslPlayerState::PlayerStatistics' has a wrong offset!");
static_assert(offsetof(ATslPlayerState, ReplicatedEquipableItems) == 0x000500, "Member 'ATslPlayerState::ReplicatedEquipableItems' has a wrong offset!");
static_assert(offsetof(ATslPlayerState, LastHitTime) == 0x00060C, "Member 'ATslPlayerState::LastHitTime' has a wrong offset!");
static_assert(offsetof(ATslPlayerState, CurrentAttackedPlayerLocation) == 0x000610, "Member 'ATslPlayerState::CurrentAttackedPlayerLocation' has a wrong offset!");

// Class TslGame.TslPostProcessEffect
// 0x0048 (0x03E8 - 0x03A0)
class ATslPostProcessEffect : public AActor
{
public:
	TArray<struct FPostProcessMaterial>           PostProcessMaterials;                              // 0x03A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FPostProcessEffectParameter>    DefaultPostProcessEffectParameter;                 // 0x03B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	TArray<struct FPostProcessEffectDynamicMaterialState> PostProcessEffectDynamicMaterialStates;            // 0x03C0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class APostProcessVolume*                     PostProcessVolume;                                 // 0x03D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D8[0x10];                                     // 0x03D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool SetEffectParameter(const class FString& ParameterName, float Value);
	bool SetMaterialBlendWeight(int32 idx, float Value);
	bool SetMaterialParameter(int32 idx, class FName ParameterName, float Value);
	bool SetMaterialVectorParameter(int32 idx, class FName ParameterName, const struct FLinearColor& Value);

	float GetEffectParameter(const class FString& ParameterName, float DefaultValue) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslPostProcessEffect">();
	}
	static class ATslPostProcessEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslPostProcessEffect>();
	}
};
static_assert(alignof(ATslPostProcessEffect) == 0x000008, "Wrong alignment on ATslPostProcessEffect");
static_assert(sizeof(ATslPostProcessEffect) == 0x0003E8, "Wrong size on ATslPostProcessEffect");
static_assert(offsetof(ATslPostProcessEffect, PostProcessMaterials) == 0x0003A0, "Member 'ATslPostProcessEffect::PostProcessMaterials' has a wrong offset!");
static_assert(offsetof(ATslPostProcessEffect, DefaultPostProcessEffectParameter) == 0x0003B0, "Member 'ATslPostProcessEffect::DefaultPostProcessEffectParameter' has a wrong offset!");
static_assert(offsetof(ATslPostProcessEffect, PostProcessEffectDynamicMaterialStates) == 0x0003C0, "Member 'ATslPostProcessEffect::PostProcessEffectDynamicMaterialStates' has a wrong offset!");
static_assert(offsetof(ATslPostProcessEffect, PostProcessVolume) == 0x0003D0, "Member 'ATslPostProcessEffect::PostProcessVolume' has a wrong offset!");

// Class TslGame.TslReactionDoorComponent
// 0x0050 (0x0860 - 0x0810)
class UTslReactionDoorComponent final : public UStaticMeshComponent
{
public:
	uint8                                         Pad_808[0x8];                                      // 0x0808(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTslReactionDoorData*                   ReactionDoorData;                                  // 0x0810(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDestructibleMesh*                      DoorDestructibleMesh;                              // 0x0818(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDoorBreakingState                     DoorBreakingState;                                 // 0x0820(0x0001)(Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_821[0x3F];                                     // 0x0821(0x003F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientTakeDamage(float Damage, const struct FVector_NetQuantize& HitLocation, float DamageRadius, float Impulse);
	void OnRep_DoorBreakingState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslReactionDoorComponent">();
	}
	static class UTslReactionDoorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslReactionDoorComponent>();
	}
};
static_assert(alignof(UTslReactionDoorComponent) == 0x000010, "Wrong alignment on UTslReactionDoorComponent");
static_assert(sizeof(UTslReactionDoorComponent) == 0x000860, "Wrong size on UTslReactionDoorComponent");
static_assert(offsetof(UTslReactionDoorComponent, ReactionDoorData) == 0x000810, "Member 'UTslReactionDoorComponent::ReactionDoorData' has a wrong offset!");
static_assert(offsetof(UTslReactionDoorComponent, DoorDestructibleMesh) == 0x000818, "Member 'UTslReactionDoorComponent::DoorDestructibleMesh' has a wrong offset!");
static_assert(offsetof(UTslReactionDoorComponent, DoorBreakingState) == 0x000820, "Member 'UTslReactionDoorComponent::DoorBreakingState' has a wrong offset!");

// Class TslGame.TslReactionBoxComponent
// 0x0000 (0x0700 - 0x0700)
class UTslReactionBoxComponent final : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslReactionBoxComponent">();
	}
	static class UTslReactionBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslReactionBoxComponent>();
	}
};
static_assert(alignof(UTslReactionBoxComponent) == 0x000010, "Wrong alignment on UTslReactionBoxComponent");
static_assert(sizeof(UTslReactionBoxComponent) == 0x000700, "Wrong size on UTslReactionBoxComponent");

// Class TslGame.TslReactionClientComponent
// 0x0000 (0x0810 - 0x0810)
class UTslReactionClientComponent final : public UStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslReactionClientComponent">();
	}
	static class UTslReactionClientComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslReactionClientComponent>();
	}
};
static_assert(alignof(UTslReactionClientComponent) == 0x000010, "Wrong alignment on UTslReactionClientComponent");
static_assert(sizeof(UTslReactionClientComponent) == 0x000810, "Wrong size on UTslReactionClientComponent");

// Class TslGame.TslSceneCaptureComponent2D
// 0x0010 (0x08E0 - 0x08D0)
class UTslSceneCaptureComponent2D final : public USceneCaptureComponent2D
{
public:
	class UWorld*                                 World;                                             // 0x08D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8D8[0x8];                                      // 0x08D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CaptureScene();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslSceneCaptureComponent2D">();
	}
	static class UTslSceneCaptureComponent2D* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslSceneCaptureComponent2D>();
	}
};
static_assert(alignof(UTslSceneCaptureComponent2D) == 0x000010, "Wrong alignment on UTslSceneCaptureComponent2D");
static_assert(sizeof(UTslSceneCaptureComponent2D) == 0x0008E0, "Wrong size on UTslSceneCaptureComponent2D");
static_assert(offsetof(UTslSceneCaptureComponent2D, World) == 0x0008D0, "Member 'UTslSceneCaptureComponent2D::World' has a wrong offset!");

// Class TslGame.TslSceneCaptureWorld
// 0x0078 (0x00A0 - 0x0028)
class UTslSceneCaptureWorld final : public UObject
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UWorld*                                 World;                                             // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x48];                                      // 0x0058(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DestroyWorld();
	void InitWorld(class UGameInstance* GameInstance, const class FString& SceneCapturePackageName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslSceneCaptureWorld">();
	}
	static class UTslSceneCaptureWorld* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslSceneCaptureWorld>();
	}
};
static_assert(alignof(UTslSceneCaptureWorld) == 0x000008, "Wrong alignment on UTslSceneCaptureWorld");
static_assert(sizeof(UTslSceneCaptureWorld) == 0x0000A0, "Wrong size on UTslSceneCaptureWorld");
static_assert(offsetof(UTslSceneCaptureWorld, World) == 0x000050, "Member 'UTslSceneCaptureWorld::World' has a wrong offset!");

// Class TslGame.TslServerParticle
// 0x0028 (0x03C8 - 0x03A0)
class ATslServerParticle final : public AActor
{
public:
	bool                                          bAutoDestroyOnParticleFinish;                      // 0x03A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoPlaySound;                                    // 0x03A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A2[0x6];                                      // 0x03A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               ParticleSystem;                                    // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAkComponent*                           AkSound;                                           // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B8[0x10];                                     // 0x03B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnParticleFinish(class UParticleSystemComponent* PSystem);
	void StopParticleMulticast();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslServerParticle">();
	}
	static class ATslServerParticle* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslServerParticle>();
	}
};
static_assert(alignof(ATslServerParticle) == 0x000008, "Wrong alignment on ATslServerParticle");
static_assert(sizeof(ATslServerParticle) == 0x0003C8, "Wrong size on ATslServerParticle");
static_assert(offsetof(ATslServerParticle, bAutoDestroyOnParticleFinish) == 0x0003A0, "Member 'ATslServerParticle::bAutoDestroyOnParticleFinish' has a wrong offset!");
static_assert(offsetof(ATslServerParticle, bAutoPlaySound) == 0x0003A1, "Member 'ATslServerParticle::bAutoPlaySound' has a wrong offset!");
static_assert(offsetof(ATslServerParticle, ParticleSystem) == 0x0003A8, "Member 'ATslServerParticle::ParticleSystem' has a wrong offset!");
static_assert(offsetof(ATslServerParticle, AkSound) == 0x0003B0, "Member 'ATslServerParticle::AkSound' has a wrong offset!");

// Class TslGame.TslSpectatorPawn
// 0x0198 (0x05C0 - 0x0428)
class ATslSpectatorPawn final : public ASpectatorPawn
{
public:
	TSubclassOf<class ATslHUD>                    ReplayHUD;                                         // 0x0428(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ALevelAttribute>            LevelAttribute_BattleRoyalRule;                    // 0x0430(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ALevelAttribute>            LevelAttribute_Erangel;                            // 0x0438(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerInfoMinDistance;                             // 0x0440(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerInfoMaxDistance;                             // 0x0444(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpringArmComponent*                    FreeCameraSpringArmComponent;                      // 0x0448(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraComponent*                       FreeCameraComponent;                               // 0x0450(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpringArmComponent*                    ThirdPersonSpringArm;                              // 0x0458(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraComponent*                       ThirdPersonCamera;                                 // 0x0460(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USpringArmInVehicleComponent*           ThirdPersonSpringArmInVehicle;                     // 0x0468(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraComponent*                       ThirdPersonCameraInVehicle;                        // 0x0470(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UArrowComponent*                        AudioListener;                                     // 0x0478(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_480[0x4];                                      // 0x0480(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeathFollowBlendTime;                              // 0x0484(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EViewTargetBlendFunction                      DeathFollowBlendFunc;                              // 0x0488(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_489[0x3];                                      // 0x0489(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeathFollowBlendExp;                               // 0x048C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DeathFollowTime;                                   // 0x0490(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_494[0x4];                                      // 0x0494(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DeathFollowDistance;                               // 0x0498(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49C[0x4];                                      // 0x049C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DeathFollowBone;                                   // 0x04A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A8[0x4];                                      // 0x04A8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocationUpdateIntervalSeconds;                     // 0x04AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B0[0x4];                                      // 0x04B0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FreeCameraBlendTime;                               // 0x04B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EViewTargetBlendFunction                      FreeCameraBlendFunc;                               // 0x04B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B9[0x3];                                      // 0x04B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FreeCameraBlendExp;                                // 0x04BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FreeCameraBlendPitch;                              // 0x04C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LimitMinFreeCamFov;                                // 0x04C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LimitMaxFreeCamFov;                                // 0x04C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4CC[0xC];                                      // 0x04CC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FollowCameraZoomSpeed;                             // 0x04D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ThirdPersonCameraBlendTime;                        // 0x04DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EViewTargetBlendFunction                      ThirdPersonCameraBlendFunc;                        // 0x04E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4E1[0x3];                                      // 0x04E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ThirdPersonCameraBlendExp;                         // 0x04E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LimitTargetArmLength;                              // 0x04E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4EC[0x4];                                      // 0x04EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachSocket;                                      // 0x04F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATslCharacter*                          DeathCharacter;                                    // 0x04F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SpectatableCheckLength;                            // 0x0500(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SpectatableCheckScreenRatio;                       // 0x0504(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_508[0x18];                                     // 0x0508(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATslPostProcessEffect>      OutlineEffectClass;                                // 0x0520(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ATslPostProcessEffect*                  OutlineEffect;                                     // 0x0528(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FSavedObPos>                    ArrObPos;                                          // 0x0530(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	uint8                                         Pad_540[0x70];                                     // 0x0540(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnPlayerInfoDistanceDelegate;                      // 0x05B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void BackupTargetCharacterID();
	void OnPlayerInfoDistanceDown();
	void OnPlayerInfoDistanceDownHold();
	void OnPlayerInfoDistanceUp();
	void OnPlayerInfoDistanceUpHold();
	void OnSaveCharacter(uint8 idx);
	void OnSaveLocation(uint8 idx);
	void OnSetCharacter(uint8 idx);
	void OnSetCharacterSpec(uint8 idx);
	void OnSetFollow();
	void OnSetFree();
	void OnSetLocation(uint8 idx);
	void OnSetSpectator();
	void OnStartFastMove();
	void OnStartSlowMove();
	void OnStopFastMove();
	void OnStopSlowMove();
	void OnSwitchCameraFollow();
	void OnSwitchCameraSpectator();
	void OnThirdPersonActivated(class UActorComponent* InThirdPersonCamera, bool bReset);
	void OnToggleObseverTagWidget();
	void OnToggleShowObseverTagWeapon();
	void OnViewTargetUpdate(class AActor* NewViewTarget);
	void RestoreTargetCharacter();
	void SetFreeCamBattleLocation(const struct FVector& HitterLoc, const struct FVector& AttackedLoc);
	void SetObserverCameraMode(EObserverCameraMode NewCameraMode, class AActor* NewViewTarget, bool IsBlend);
	void SetPlayerCamera(class AActor* NewViewTarget);
	void SetShowPlayerInfoDistance(float Distance);

	EObserverCameraMode GetCameraMode() const;
	class ATslCharacter* GetLastSpectatedCharacter() const;
	bool GetObserverTagShow() const;
	float GetShowPlayerInfoDistance() const;
	class ACarePackageItem* GetSpectableCarePackageItem() const;
	class ATslCharacter* GetSpectatableCharacter() const;
	bool IsObserverTagWeaponShow() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslSpectatorPawn">();
	}
	static class ATslSpectatorPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslSpectatorPawn>();
	}
};
static_assert(alignof(ATslSpectatorPawn) == 0x000008, "Wrong alignment on ATslSpectatorPawn");
static_assert(sizeof(ATslSpectatorPawn) == 0x0005C0, "Wrong size on ATslSpectatorPawn");
static_assert(offsetof(ATslSpectatorPawn, ReplayHUD) == 0x000428, "Member 'ATslSpectatorPawn::ReplayHUD' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, LevelAttribute_BattleRoyalRule) == 0x000430, "Member 'ATslSpectatorPawn::LevelAttribute_BattleRoyalRule' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, LevelAttribute_Erangel) == 0x000438, "Member 'ATslSpectatorPawn::LevelAttribute_Erangel' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, PlayerInfoMinDistance) == 0x000440, "Member 'ATslSpectatorPawn::PlayerInfoMinDistance' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, PlayerInfoMaxDistance) == 0x000444, "Member 'ATslSpectatorPawn::PlayerInfoMaxDistance' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, FreeCameraSpringArmComponent) == 0x000448, "Member 'ATslSpectatorPawn::FreeCameraSpringArmComponent' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, FreeCameraComponent) == 0x000450, "Member 'ATslSpectatorPawn::FreeCameraComponent' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, ThirdPersonSpringArm) == 0x000458, "Member 'ATslSpectatorPawn::ThirdPersonSpringArm' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, ThirdPersonCamera) == 0x000460, "Member 'ATslSpectatorPawn::ThirdPersonCamera' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, ThirdPersonSpringArmInVehicle) == 0x000468, "Member 'ATslSpectatorPawn::ThirdPersonSpringArmInVehicle' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, ThirdPersonCameraInVehicle) == 0x000470, "Member 'ATslSpectatorPawn::ThirdPersonCameraInVehicle' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, AudioListener) == 0x000478, "Member 'ATslSpectatorPawn::AudioListener' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, DeathFollowBlendTime) == 0x000484, "Member 'ATslSpectatorPawn::DeathFollowBlendTime' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, DeathFollowBlendFunc) == 0x000488, "Member 'ATslSpectatorPawn::DeathFollowBlendFunc' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, DeathFollowBlendExp) == 0x00048C, "Member 'ATslSpectatorPawn::DeathFollowBlendExp' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, DeathFollowTime) == 0x000490, "Member 'ATslSpectatorPawn::DeathFollowTime' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, DeathFollowDistance) == 0x000498, "Member 'ATslSpectatorPawn::DeathFollowDistance' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, DeathFollowBone) == 0x0004A0, "Member 'ATslSpectatorPawn::DeathFollowBone' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, LocationUpdateIntervalSeconds) == 0x0004AC, "Member 'ATslSpectatorPawn::LocationUpdateIntervalSeconds' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, FreeCameraBlendTime) == 0x0004B4, "Member 'ATslSpectatorPawn::FreeCameraBlendTime' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, FreeCameraBlendFunc) == 0x0004B8, "Member 'ATslSpectatorPawn::FreeCameraBlendFunc' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, FreeCameraBlendExp) == 0x0004BC, "Member 'ATslSpectatorPawn::FreeCameraBlendExp' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, FreeCameraBlendPitch) == 0x0004C0, "Member 'ATslSpectatorPawn::FreeCameraBlendPitch' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, LimitMinFreeCamFov) == 0x0004C4, "Member 'ATslSpectatorPawn::LimitMinFreeCamFov' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, LimitMaxFreeCamFov) == 0x0004C8, "Member 'ATslSpectatorPawn::LimitMaxFreeCamFov' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, FollowCameraZoomSpeed) == 0x0004D8, "Member 'ATslSpectatorPawn::FollowCameraZoomSpeed' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, ThirdPersonCameraBlendTime) == 0x0004DC, "Member 'ATslSpectatorPawn::ThirdPersonCameraBlendTime' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, ThirdPersonCameraBlendFunc) == 0x0004E0, "Member 'ATslSpectatorPawn::ThirdPersonCameraBlendFunc' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, ThirdPersonCameraBlendExp) == 0x0004E4, "Member 'ATslSpectatorPawn::ThirdPersonCameraBlendExp' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, LimitTargetArmLength) == 0x0004E8, "Member 'ATslSpectatorPawn::LimitTargetArmLength' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, AttachSocket) == 0x0004F0, "Member 'ATslSpectatorPawn::AttachSocket' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, DeathCharacter) == 0x0004F8, "Member 'ATslSpectatorPawn::DeathCharacter' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, SpectatableCheckLength) == 0x000500, "Member 'ATslSpectatorPawn::SpectatableCheckLength' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, SpectatableCheckScreenRatio) == 0x000504, "Member 'ATslSpectatorPawn::SpectatableCheckScreenRatio' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, OutlineEffectClass) == 0x000520, "Member 'ATslSpectatorPawn::OutlineEffectClass' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, OutlineEffect) == 0x000528, "Member 'ATslSpectatorPawn::OutlineEffect' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, ArrObPos) == 0x000530, "Member 'ATslSpectatorPawn::ArrObPos' has a wrong offset!");
static_assert(offsetof(ATslSpectatorPawn, OnPlayerInfoDistanceDelegate) == 0x0005B0, "Member 'ATslSpectatorPawn::OnPlayerInfoDistanceDelegate' has a wrong offset!");

// Class TslGame.TslStatics
// 0x0000 (0x0028 - 0x0028)
class UTslStatics final : public UBlueprintFunctionLibrary
{
public:
	static void ApplyDamage(class AActor* DamagedActor, float BaseDamage, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UDamageType> DamageTypeClass, const struct FAttackId& AttackId);
	static bool ApplyRadialDamage(class UObject* WorldContextObject, float BaseDamage, const struct FVector& Origin, float DamageRadius, TSubclassOf<class UDamageType> DamageTypeClass, const TArray<class AActor*>& IgnoreActors, const struct FAttackId& AttackId, bool bIsTargetDestructible, class AActor* DamageCauser, class AController* InstigatedByController, bool bDoFullDamage, ECollisionChannel DamagePreventionChannel, bool bExplode);
	static bool ApplyRadialDamageWithCurve(class UObject* WorldContextObject, float BaseDamage, const struct FVector& Origin, float DamageRadius, const class UCurveFloat* DamageCurve, TSubclassOf<class UDamageType> DamageTypeClass, const TArray<class AActor*>& IgnoreActors, const struct FAttackId& AttackId, bool bIsTargetDestructible, class AActor* DamageCauser, class AController* InstigatedByController, ECollisionChannel DamagePreventionChannel, bool bExplode);
	static bool ApplyRadialDamageWithFalloff(class UObject* WorldContextObject, float BaseDamage, float MinimumDamage, const struct FVector& Origin, float DamageInnerRadius, float DamageOuterRadius, float DamageFalloff, TSubclassOf<class UDamageType> DamageTypeClass, const TArray<class AActor*>& IgnoreActors, const struct FAttackId& AttackId, bool bIsTargetDestructible, class AActor* DamageCauser, class AController* InstigatedByController, ECollisionChannel DamagePreventionChannel, bool bExplode);
	static int32 ConeVolumeLineTraceMulti(const class UObject* WorldContextObject, TArray<struct FVector>* OutHitPoints, const struct FVector& Origin, int32 SamplingNum, float HalfConeAngle, float RayLength);
	static bool ConeVolumeLineTraceSingle(const class UObject* WorldContextObject, struct FVector* OutHitPoint, const struct FVector& Origin, float HalfConeAngle, float RayLength);
	static struct FVector GetBluezonePosition(class UObject* WorldContextObject);
	static float GetBluezoneRadius(class UObject* WorldContextObject);
	static bool GetConsoleValue(const class FString& ConsloeName, float* OutValueFloat, int32* OutValueInt, class FString* OutValueString);
	static class FString GetFullGameVersion();
	static class FString GetGameVersion();
	static struct FVector GetNextPlayzonePosition(class UObject* WorldContextObject);
	static float GetNextPlayzoneRadius(class UObject* WorldContextObject);
	static struct FVector GetServerLocation(const class UObject* ActorOrComponent);
	static class UPhysicalMaterial* GetSimplePhysicalMaterial(class UPrimitiveComponent* PrimitiveComponent);
	static class ATslCharacter* GetTslCharacter(const class UObject* WorldContextObject);
	static class ATslGameState* GetTslGameState(class UObject* WorldContextObject);
	static class FString GetTslPlatformName();
	static class ATslPlayerController* GetTslPlayerController(const class APawn* Pawn);
	static class UTslVehicleCommonComponent* GetVehicleCommonComponent(class AActor* Actor);
	static class UTslVehicleSeatComponent* GetVehicleSeatComponent(class AActor* Actor);
	static float GetWaterSurfaceHeight(const class APhysicsVolume* PhysicsVolume, const struct FVector& CurLocation);
	static bool IsClientActor(const class AActor* Actor);
	static bool IsEditor();
	static bool IsESports();
	static bool IsForChineseLicensing();
	static bool IsForKoreanRating();
	static bool IsGamepadConnected();
	static bool IsLastInputGamepad(class UObject* WorldContextObject);
	static bool IsMapFullyLoaded(class UWorld* World);
	static bool IsServerActor(const class AActor* Actor);
	static bool IsShipping();
	static bool LineSphereIntersection(struct FVector* Intersection1, struct FVector* Intersection2, const struct FVector& Center, const struct FVector& Origion, const struct FVector& Direction, const float& Radius);
	static struct FVector LocalPositionToServer(class UObject* WorldContextObject, const struct FVector& Local);
	static class FName PhysicalSurfaceToName(EPhysicalSurface Type);
	static class FString PhysicalSurfaceToString(EPhysicalSurface Type);
	static bool PredictProjectilePathBox(const class UObject* WorldContextObject, struct FHitResult* OutHit, TArray<struct FVector>* OutPathPositions, struct FVector* OutLastTraceDestination, const struct FVector& StartPos, const struct FVector& LaunchVelocity, bool bTracePath, const struct FVector& ProjectileBox, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, float DrawDebugTime, float SimFrequency, float MaxSimTime, float OverrideGravityZ);
	static bool PredictProjectilePathCapsule(const class UObject* WorldContextObject, struct FHitResult* OutHit, TArray<struct FVector>* OutPathPositions, struct FVector* OutLastTraceDestination, const struct FVector& StartPos, const struct FVector& LaunchVelocity, bool bTracePath, const struct FVector& ProjectileBox, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, float DrawDebugTime, float SimFrequency, float MaxSimTime, float OverrideGravityZ);
	static struct FVector ProjectPointsToHighFloor(const class UObject* WorldContextObject, const struct FVector& Origin, bool* bOutHit, float AroundLength, float RayLength);
	static struct FVector ProjectPointToFloor(const class UObject* WorldContextObject, const struct FVector& Origin, bool* bOutHit, float Length);
	static void ReleaseMouseCaptureFromPlayerController(class APlayerController* PlayerController);
	static float SafeDivide_FloatFloat(float A, float B, float DivideByZeroValue);
	static int32 SafeDivide_IntInt(int32 A, int32 B, int32 DivideByZeroValue);
	static struct FVector ServerPositionToLocal(class UObject* WorldContextObject, const struct FVector& Server);
	static void SetAnimationAkRTPC(class ACharacter* Character, const class FString& RTPCName, float RTPCValue);
	static void SetAnimationAkSwitch(class ACharacter* Character, const class FString& SwitchGroup, const class FString& SwitchState);
	static void SetWorldOrigin(const class APlayerController* Controller);
	static void SetWorldOriginByDistance(const class APlayerController* Controller, float XYDistanceToShift);
	static void UseHighPrecisionMouseMovement(class APlayerController* PlayerController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslStatics">();
	}
	static class UTslStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslStatics>();
	}
};
static_assert(alignof(UTslStatics) == 0x000008, "Wrong alignment on UTslStatics");
static_assert(sizeof(UTslStatics) == 0x000028, "Wrong size on UTslStatics");

// Class TslGame.FoliageCollisionStreamer
// 0x0068 (0x00B0 - 0x0048)
class UFoliageCollisionStreamer final : public UTslStreamer
{
public:
	bool                                          bEnabled;                                          // 0x0048(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDistance;                                       // 0x004C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxQueryDistance;                                  // 0x0050(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxSimulationDistance;                             // 0x0054(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseOnlyQueryAndPhysics;                           // 0x0058(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59[0x57];                                      // 0x0059(0x0057)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FoliageCollisionStreamer">();
	}
	static class UFoliageCollisionStreamer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFoliageCollisionStreamer>();
	}
};
static_assert(alignof(UFoliageCollisionStreamer) == 0x000008, "Wrong alignment on UFoliageCollisionStreamer");
static_assert(sizeof(UFoliageCollisionStreamer) == 0x0000B0, "Wrong size on UFoliageCollisionStreamer");
static_assert(offsetof(UFoliageCollisionStreamer, bEnabled) == 0x000048, "Member 'UFoliageCollisionStreamer::bEnabled' has a wrong offset!");
static_assert(offsetof(UFoliageCollisionStreamer, MinDistance) == 0x00004C, "Member 'UFoliageCollisionStreamer::MinDistance' has a wrong offset!");
static_assert(offsetof(UFoliageCollisionStreamer, MaxQueryDistance) == 0x000050, "Member 'UFoliageCollisionStreamer::MaxQueryDistance' has a wrong offset!");
static_assert(offsetof(UFoliageCollisionStreamer, MaxSimulationDistance) == 0x000054, "Member 'UFoliageCollisionStreamer::MaxSimulationDistance' has a wrong offset!");
static_assert(offsetof(UFoliageCollisionStreamer, bUseOnlyQueryAndPhysics) == 0x000058, "Member 'UFoliageCollisionStreamer::bUseOnlyQueryAndPhysics' has a wrong offset!");

// Class TslGame.ParticleEnvrionmentStreamer
// 0x0018 (0x0060 - 0x0048)
class UParticleEnvrionmentStreamer final : public UTslStreamer
{
public:
	bool                                          bEnabled;                                          // 0x0048(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ToleranceDeactiveDistance;                         // 0x004C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleEnvrionmentStreamer">();
	}
	static class UParticleEnvrionmentStreamer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleEnvrionmentStreamer>();
	}
};
static_assert(alignof(UParticleEnvrionmentStreamer) == 0x000008, "Wrong alignment on UParticleEnvrionmentStreamer");
static_assert(sizeof(UParticleEnvrionmentStreamer) == 0x000060, "Wrong size on UParticleEnvrionmentStreamer");
static_assert(offsetof(UParticleEnvrionmentStreamer, bEnabled) == 0x000048, "Member 'UParticleEnvrionmentStreamer::bEnabled' has a wrong offset!");
static_assert(offsetof(UParticleEnvrionmentStreamer, ToleranceDeactiveDistance) == 0x00004C, "Member 'UParticleEnvrionmentStreamer::ToleranceDeactiveDistance' has a wrong offset!");

// Class TslGame.CharacterStanceBaseWidget
// 0x0030 (0x02A8 - 0x0278)
class UCharacterStanceBaseWidget : public UUmgBaseWidget
{
public:
	struct FUmgWidgetBinder_Image                 StanceIconImageBinder;                             // 0x0278(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FName                                   IconStateParamName;                                // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterStanceBaseWidget">();
	}
	static class UCharacterStanceBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterStanceBaseWidget>();
	}
};
static_assert(alignof(UCharacterStanceBaseWidget) == 0x000008, "Wrong alignment on UCharacterStanceBaseWidget");
static_assert(sizeof(UCharacterStanceBaseWidget) == 0x0002A8, "Wrong size on UCharacterStanceBaseWidget");
static_assert(offsetof(UCharacterStanceBaseWidget, StanceIconImageBinder) == 0x000278, "Member 'UCharacterStanceBaseWidget::StanceIconImageBinder' has a wrong offset!");
static_assert(offsetof(UCharacterStanceBaseWidget, IconStateParamName) == 0x0002A0, "Member 'UCharacterStanceBaseWidget::IconStateParamName' has a wrong offset!");

// Class TslGame.EquipableItemIconBaseWidget
// 0x00B0 (0x0328 - 0x0278)
class UEquipableItemIconBaseWidget : public UUmgBaseWidget
{
public:
	EEquipSlotID                                  EquipSlotID;                                       // 0x0278(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDurabilityColorSet                    DurabilityColorSet;                                // 0x0280(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         bUseWrning : 1;                                    // 0x0290(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_291[0x3];                                      // 0x0291(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatInterval                         WarningRange;                                      // 0x0294(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, NativeAccessSpecifierPublic)
	EEquipableItemIconVisibility                  IconVisibilityType;                                // 0x029C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29D[0x3];                                      // 0x029D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUmgWidgetBinder_Image                 IconImageBinder;                                   // 0x02A0(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   IconTexParamName;                                  // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IconColorParamName;                                // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DefaultColor;                                      // 0x02D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Animation             WarningAnimBinder;                                 // 0x02E8(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Animation             NoBagSpaceAnimBinder;                              // 0x0308(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	void OnNoBagSpaceEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquipableItemIconBaseWidget">();
	}
	static class UEquipableItemIconBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEquipableItemIconBaseWidget>();
	}
};
static_assert(alignof(UEquipableItemIconBaseWidget) == 0x000008, "Wrong alignment on UEquipableItemIconBaseWidget");
static_assert(sizeof(UEquipableItemIconBaseWidget) == 0x000328, "Wrong size on UEquipableItemIconBaseWidget");
static_assert(offsetof(UEquipableItemIconBaseWidget, EquipSlotID) == 0x000278, "Member 'UEquipableItemIconBaseWidget::EquipSlotID' has a wrong offset!");
static_assert(offsetof(UEquipableItemIconBaseWidget, DurabilityColorSet) == 0x000280, "Member 'UEquipableItemIconBaseWidget::DurabilityColorSet' has a wrong offset!");
static_assert(offsetof(UEquipableItemIconBaseWidget, WarningRange) == 0x000294, "Member 'UEquipableItemIconBaseWidget::WarningRange' has a wrong offset!");
static_assert(offsetof(UEquipableItemIconBaseWidget, IconVisibilityType) == 0x00029C, "Member 'UEquipableItemIconBaseWidget::IconVisibilityType' has a wrong offset!");
static_assert(offsetof(UEquipableItemIconBaseWidget, IconImageBinder) == 0x0002A0, "Member 'UEquipableItemIconBaseWidget::IconImageBinder' has a wrong offset!");
static_assert(offsetof(UEquipableItemIconBaseWidget, IconTexParamName) == 0x0002C8, "Member 'UEquipableItemIconBaseWidget::IconTexParamName' has a wrong offset!");
static_assert(offsetof(UEquipableItemIconBaseWidget, IconColorParamName) == 0x0002D0, "Member 'UEquipableItemIconBaseWidget::IconColorParamName' has a wrong offset!");
static_assert(offsetof(UEquipableItemIconBaseWidget, DefaultColor) == 0x0002D8, "Member 'UEquipableItemIconBaseWidget::DefaultColor' has a wrong offset!");
static_assert(offsetof(UEquipableItemIconBaseWidget, WarningAnimBinder) == 0x0002E8, "Member 'UEquipableItemIconBaseWidget::WarningAnimBinder' has a wrong offset!");
static_assert(offsetof(UEquipableItemIconBaseWidget, NoBagSpaceAnimBinder) == 0x000308, "Member 'UEquipableItemIconBaseWidget::NoBagSpaceAnimBinder' has a wrong offset!");

// Class TslGame.EquipableItemIconHudBaseWidget
// 0x0000 (0x0278 - 0x0278)
class UEquipableItemIconHudBaseWidget : public UUmgBaseWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquipableItemIconHudBaseWidget">();
	}
	static class UEquipableItemIconHudBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEquipableItemIconHudBaseWidget>();
	}
};
static_assert(alignof(UEquipableItemIconHudBaseWidget) == 0x000008, "Wrong alignment on UEquipableItemIconHudBaseWidget");
static_assert(sizeof(UEquipableItemIconHudBaseWidget) == 0x000278, "Wrong size on UEquipableItemIconHudBaseWidget");

// Class TslGame.InteractionBaseWidget
// 0x01B8 (0x0430 - 0x0278)
class UInteractionBaseWidget : public UUmgBaseWidget
{
public:
	struct FUmgWidgetBinder_Border                MainLayer;                                         // 0x0278(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_TextBlock             InteractionMessageTextBinder;                      // 0x0298(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Border                InteractionMessageTextBgBinder;                    // 0x02B8(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_TextBlock             AdditionalTextBinder;                              // 0x02D8(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Image                 SuitableWeaponImageBinder;                         // 0x02F8(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         SuitableWeaponImageHeight;                         // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUmgWidgetBinder_Image                 KeyImageBinder;                                    // 0x0328(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_TextBlock             InteractionKeyTextBinder;                          // 0x0350(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Animation             AdditionalMessageBlinkingBinder;                   // 0x0370(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Animation             AdditionalMessageNormalBinder;                     // 0x0390(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Animation             ShowAnimationBinder;                               // 0x03B0(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Animation             HiddenAnimationBinder;                             // 0x03D0(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_WidgetSwitcher        InteractionInputMethodSwitcherBinder;              // 0x03F0(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class FName                                   InteractionKeyName;                                // 0x0410(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_418[0x18];                                     // 0x0418(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionBaseWidget">();
	}
	static class UInteractionBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionBaseWidget>();
	}
};
static_assert(alignof(UInteractionBaseWidget) == 0x000008, "Wrong alignment on UInteractionBaseWidget");
static_assert(sizeof(UInteractionBaseWidget) == 0x000430, "Wrong size on UInteractionBaseWidget");
static_assert(offsetof(UInteractionBaseWidget, MainLayer) == 0x000278, "Member 'UInteractionBaseWidget::MainLayer' has a wrong offset!");
static_assert(offsetof(UInteractionBaseWidget, InteractionMessageTextBinder) == 0x000298, "Member 'UInteractionBaseWidget::InteractionMessageTextBinder' has a wrong offset!");
static_assert(offsetof(UInteractionBaseWidget, InteractionMessageTextBgBinder) == 0x0002B8, "Member 'UInteractionBaseWidget::InteractionMessageTextBgBinder' has a wrong offset!");
static_assert(offsetof(UInteractionBaseWidget, AdditionalTextBinder) == 0x0002D8, "Member 'UInteractionBaseWidget::AdditionalTextBinder' has a wrong offset!");
static_assert(offsetof(UInteractionBaseWidget, SuitableWeaponImageBinder) == 0x0002F8, "Member 'UInteractionBaseWidget::SuitableWeaponImageBinder' has a wrong offset!");
static_assert(offsetof(UInteractionBaseWidget, SuitableWeaponImageHeight) == 0x000320, "Member 'UInteractionBaseWidget::SuitableWeaponImageHeight' has a wrong offset!");
static_assert(offsetof(UInteractionBaseWidget, KeyImageBinder) == 0x000328, "Member 'UInteractionBaseWidget::KeyImageBinder' has a wrong offset!");
static_assert(offsetof(UInteractionBaseWidget, InteractionKeyTextBinder) == 0x000350, "Member 'UInteractionBaseWidget::InteractionKeyTextBinder' has a wrong offset!");
static_assert(offsetof(UInteractionBaseWidget, AdditionalMessageBlinkingBinder) == 0x000370, "Member 'UInteractionBaseWidget::AdditionalMessageBlinkingBinder' has a wrong offset!");
static_assert(offsetof(UInteractionBaseWidget, AdditionalMessageNormalBinder) == 0x000390, "Member 'UInteractionBaseWidget::AdditionalMessageNormalBinder' has a wrong offset!");
static_assert(offsetof(UInteractionBaseWidget, ShowAnimationBinder) == 0x0003B0, "Member 'UInteractionBaseWidget::ShowAnimationBinder' has a wrong offset!");
static_assert(offsetof(UInteractionBaseWidget, HiddenAnimationBinder) == 0x0003D0, "Member 'UInteractionBaseWidget::HiddenAnimationBinder' has a wrong offset!");
static_assert(offsetof(UInteractionBaseWidget, InteractionInputMethodSwitcherBinder) == 0x0003F0, "Member 'UInteractionBaseWidget::InteractionInputMethodSwitcherBinder' has a wrong offset!");
static_assert(offsetof(UInteractionBaseWidget, InteractionKeyName) == 0x000410, "Member 'UInteractionBaseWidget::InteractionKeyName' has a wrong offset!");

// Class TslGame.LifeGaugeBaseWidget
// 0x0120 (0x0398 - 0x0278)
class ULifeGaugeBaseWidget : public UUmgBaseWidget
{
public:
	class UTslHealthGaugeData*                    LifeGaugeColorData;                                // 0x0278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Image                 LifeGaugeImageBinder;                              // 0x0280(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   LifeGaugeRatioValueParamName;                      // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LifeGaugeColorParamName;                           // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Image                 HealAmountImageBinder;                             // 0x02B8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Overlay               HitEffectLayer;                                    // 0x02E0(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   HealAmountRatioValueParamName;                     // 0x0300(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HealAmountRatioSartParamName;                      // 0x0308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HealAmountRatioEndParamName;                       // 0x0310(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HealAmountColorParamName;                          // 0x0318(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            HealEffectTimeCurve;                               // 0x0320(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                HitEffectClass;                                    // 0x0328(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCastableItem>              Item_Heal_FirstAid;                                // 0x0330(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCastableItem>              Item_Heal_MedKit;                                  // 0x0338(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Animation             WarningAnimationBinder;                            // 0x0340(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Animation             GroggyAnimationBinder;                             // 0x0360(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_380[0x18];                                     // 0x0380(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnNotifyHeal(float StartHealth, float GoalHealth, float MaxHealth);
	void OnNotifyHit(float Damage, EDamageTypeCategory DamageType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LifeGaugeBaseWidget">();
	}
	static class ULifeGaugeBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULifeGaugeBaseWidget>();
	}
};
static_assert(alignof(ULifeGaugeBaseWidget) == 0x000008, "Wrong alignment on ULifeGaugeBaseWidget");
static_assert(sizeof(ULifeGaugeBaseWidget) == 0x000398, "Wrong size on ULifeGaugeBaseWidget");
static_assert(offsetof(ULifeGaugeBaseWidget, LifeGaugeColorData) == 0x000278, "Member 'ULifeGaugeBaseWidget::LifeGaugeColorData' has a wrong offset!");
static_assert(offsetof(ULifeGaugeBaseWidget, LifeGaugeImageBinder) == 0x000280, "Member 'ULifeGaugeBaseWidget::LifeGaugeImageBinder' has a wrong offset!");
static_assert(offsetof(ULifeGaugeBaseWidget, LifeGaugeRatioValueParamName) == 0x0002A8, "Member 'ULifeGaugeBaseWidget::LifeGaugeRatioValueParamName' has a wrong offset!");
static_assert(offsetof(ULifeGaugeBaseWidget, LifeGaugeColorParamName) == 0x0002B0, "Member 'ULifeGaugeBaseWidget::LifeGaugeColorParamName' has a wrong offset!");
static_assert(offsetof(ULifeGaugeBaseWidget, HealAmountImageBinder) == 0x0002B8, "Member 'ULifeGaugeBaseWidget::HealAmountImageBinder' has a wrong offset!");
static_assert(offsetof(ULifeGaugeBaseWidget, HitEffectLayer) == 0x0002E0, "Member 'ULifeGaugeBaseWidget::HitEffectLayer' has a wrong offset!");
static_assert(offsetof(ULifeGaugeBaseWidget, HealAmountRatioValueParamName) == 0x000300, "Member 'ULifeGaugeBaseWidget::HealAmountRatioValueParamName' has a wrong offset!");
static_assert(offsetof(ULifeGaugeBaseWidget, HealAmountRatioSartParamName) == 0x000308, "Member 'ULifeGaugeBaseWidget::HealAmountRatioSartParamName' has a wrong offset!");
static_assert(offsetof(ULifeGaugeBaseWidget, HealAmountRatioEndParamName) == 0x000310, "Member 'ULifeGaugeBaseWidget::HealAmountRatioEndParamName' has a wrong offset!");
static_assert(offsetof(ULifeGaugeBaseWidget, HealAmountColorParamName) == 0x000318, "Member 'ULifeGaugeBaseWidget::HealAmountColorParamName' has a wrong offset!");
static_assert(offsetof(ULifeGaugeBaseWidget, HealEffectTimeCurve) == 0x000320, "Member 'ULifeGaugeBaseWidget::HealEffectTimeCurve' has a wrong offset!");
static_assert(offsetof(ULifeGaugeBaseWidget, HitEffectClass) == 0x000328, "Member 'ULifeGaugeBaseWidget::HitEffectClass' has a wrong offset!");
static_assert(offsetof(ULifeGaugeBaseWidget, Item_Heal_FirstAid) == 0x000330, "Member 'ULifeGaugeBaseWidget::Item_Heal_FirstAid' has a wrong offset!");
static_assert(offsetof(ULifeGaugeBaseWidget, Item_Heal_MedKit) == 0x000338, "Member 'ULifeGaugeBaseWidget::Item_Heal_MedKit' has a wrong offset!");
static_assert(offsetof(ULifeGaugeBaseWidget, WarningAnimationBinder) == 0x000340, "Member 'ULifeGaugeBaseWidget::WarningAnimationBinder' has a wrong offset!");
static_assert(offsetof(ULifeGaugeBaseWidget, GroggyAnimationBinder) == 0x000360, "Member 'ULifeGaugeBaseWidget::GroggyAnimationBinder' has a wrong offset!");

// Class TslGame.LifeGaugeHitEffectBaseWidget
// 0x0098 (0x0310 - 0x0278)
class ULifeGaugeHitEffectBaseWidget : public UUmgBaseWidget
{
public:
	TArray<struct FGaugeAlphaCurveType>           AlphaCurveList;                                    // 0x0278(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Image                 HitEffectImage;                                    // 0x0288(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   BaseColorParamName;                                // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ColorLerpParamName;                                // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BrightAlphaParamName;                              // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HitEffectAlphaParamName;                           // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HitEffectStartParamName;                           // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HitEffectEndParamName;                             // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E0[0x30];                                     // 0x02E0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LifeGaugeHitEffectBaseWidget">();
	}
	static class ULifeGaugeHitEffectBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULifeGaugeHitEffectBaseWidget>();
	}
};
static_assert(alignof(ULifeGaugeHitEffectBaseWidget) == 0x000008, "Wrong alignment on ULifeGaugeHitEffectBaseWidget");
static_assert(sizeof(ULifeGaugeHitEffectBaseWidget) == 0x000310, "Wrong size on ULifeGaugeHitEffectBaseWidget");
static_assert(offsetof(ULifeGaugeHitEffectBaseWidget, AlphaCurveList) == 0x000278, "Member 'ULifeGaugeHitEffectBaseWidget::AlphaCurveList' has a wrong offset!");
static_assert(offsetof(ULifeGaugeHitEffectBaseWidget, HitEffectImage) == 0x000288, "Member 'ULifeGaugeHitEffectBaseWidget::HitEffectImage' has a wrong offset!");
static_assert(offsetof(ULifeGaugeHitEffectBaseWidget, BaseColorParamName) == 0x0002B0, "Member 'ULifeGaugeHitEffectBaseWidget::BaseColorParamName' has a wrong offset!");
static_assert(offsetof(ULifeGaugeHitEffectBaseWidget, ColorLerpParamName) == 0x0002B8, "Member 'ULifeGaugeHitEffectBaseWidget::ColorLerpParamName' has a wrong offset!");
static_assert(offsetof(ULifeGaugeHitEffectBaseWidget, BrightAlphaParamName) == 0x0002C0, "Member 'ULifeGaugeHitEffectBaseWidget::BrightAlphaParamName' has a wrong offset!");
static_assert(offsetof(ULifeGaugeHitEffectBaseWidget, HitEffectAlphaParamName) == 0x0002C8, "Member 'ULifeGaugeHitEffectBaseWidget::HitEffectAlphaParamName' has a wrong offset!");
static_assert(offsetof(ULifeGaugeHitEffectBaseWidget, HitEffectStartParamName) == 0x0002D0, "Member 'ULifeGaugeHitEffectBaseWidget::HitEffectStartParamName' has a wrong offset!");
static_assert(offsetof(ULifeGaugeHitEffectBaseWidget, HitEffectEndParamName) == 0x0002D8, "Member 'ULifeGaugeHitEffectBaseWidget::HitEffectEndParamName' has a wrong offset!");

// Class TslGame.LifeGaugeTemplateBaseWidget
// 0x0098 (0x0310 - 0x0278)
class ULifeGaugeTemplateBaseWidget : public UUmgBaseWidget
{
public:
	class UTslHealthGaugeData*                    LifeGaugeColorData;                                // 0x0278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Image                 LifeGaugeImageBinder;                              // 0x0280(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   LifeGaugeRatioValueParamName;                      // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LifeGaugeColorParamName;                           // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Animation             WarningAnimationBinder;                            // 0x02B8(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Image                 BackgroundImageBinder;                             // 0x02D8(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_300[0x10];                                     // 0x0300(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LifeGaugeTemplateBaseWidget">();
	}
	static class ULifeGaugeTemplateBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULifeGaugeTemplateBaseWidget>();
	}
};
static_assert(alignof(ULifeGaugeTemplateBaseWidget) == 0x000008, "Wrong alignment on ULifeGaugeTemplateBaseWidget");
static_assert(sizeof(ULifeGaugeTemplateBaseWidget) == 0x000310, "Wrong size on ULifeGaugeTemplateBaseWidget");
static_assert(offsetof(ULifeGaugeTemplateBaseWidget, LifeGaugeColorData) == 0x000278, "Member 'ULifeGaugeTemplateBaseWidget::LifeGaugeColorData' has a wrong offset!");
static_assert(offsetof(ULifeGaugeTemplateBaseWidget, LifeGaugeImageBinder) == 0x000280, "Member 'ULifeGaugeTemplateBaseWidget::LifeGaugeImageBinder' has a wrong offset!");
static_assert(offsetof(ULifeGaugeTemplateBaseWidget, LifeGaugeRatioValueParamName) == 0x0002A8, "Member 'ULifeGaugeTemplateBaseWidget::LifeGaugeRatioValueParamName' has a wrong offset!");
static_assert(offsetof(ULifeGaugeTemplateBaseWidget, LifeGaugeColorParamName) == 0x0002B0, "Member 'ULifeGaugeTemplateBaseWidget::LifeGaugeColorParamName' has a wrong offset!");
static_assert(offsetof(ULifeGaugeTemplateBaseWidget, WarningAnimationBinder) == 0x0002B8, "Member 'ULifeGaugeTemplateBaseWidget::WarningAnimationBinder' has a wrong offset!");
static_assert(offsetof(ULifeGaugeTemplateBaseWidget, BackgroundImageBinder) == 0x0002D8, "Member 'ULifeGaugeTemplateBaseWidget::BackgroundImageBinder' has a wrong offset!");

// Class TslGame.MapCarePackageItemIconBaseWidget
// 0x0070 (0x02E8 - 0x0278)
class UMapCarePackageItemIconBaseWidget : public UUmgBaseWidget
{
public:
	struct FUmgWidgetBinder_Border                IconImageBorderBinder;                             // 0x0278(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Image                 IconImageBinder;                                   // 0x0298(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   IconStateParamName;                                // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IconColorParamName;                                // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0[0x18];                                     // 0x02D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FEventReply OnButtonDown(const struct FGeometry& Geometry, const struct FPointerEvent& MouseEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapCarePackageItemIconBaseWidget">();
	}
	static class UMapCarePackageItemIconBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapCarePackageItemIconBaseWidget>();
	}
};
static_assert(alignof(UMapCarePackageItemIconBaseWidget) == 0x000008, "Wrong alignment on UMapCarePackageItemIconBaseWidget");
static_assert(sizeof(UMapCarePackageItemIconBaseWidget) == 0x0002E8, "Wrong size on UMapCarePackageItemIconBaseWidget");
static_assert(offsetof(UMapCarePackageItemIconBaseWidget, IconImageBorderBinder) == 0x000278, "Member 'UMapCarePackageItemIconBaseWidget::IconImageBorderBinder' has a wrong offset!");
static_assert(offsetof(UMapCarePackageItemIconBaseWidget, IconImageBinder) == 0x000298, "Member 'UMapCarePackageItemIconBaseWidget::IconImageBinder' has a wrong offset!");
static_assert(offsetof(UMapCarePackageItemIconBaseWidget, IconStateParamName) == 0x0002C0, "Member 'UMapCarePackageItemIconBaseWidget::IconStateParamName' has a wrong offset!");
static_assert(offsetof(UMapCarePackageItemIconBaseWidget, IconColorParamName) == 0x0002C8, "Member 'UMapCarePackageItemIconBaseWidget::IconColorParamName' has a wrong offset!");

// Class TslGame.MapCharacterIconBaseWidget
// 0x0180 (0x03F8 - 0x0278)
class UMapCharacterIconBaseWidget : public UUmgBaseWidget
{
public:
	struct FUmgWidgetBinder_Border                IconImageBorderBinder;                             // 0x0278(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Image                 IconImageBinder;                                   // 0x0298(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   IconStateParamName;                                // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IconRotationParamName;                             // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IconColorParamName;                                // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Border                PlayerNameBoderBinder;                             // 0x02D8(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_TextBlock             PlayerNameBinder;                                  // 0x02F8(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Border                LifeGaugeBorderBinder;                             // 0x0318(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_UserWidget            LifeGaugeWidgetBinder;                             // 0x0338(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Animation             AttackedAnimBinder;                                // 0x0358(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Animation             HittedAnimBinder;                                  // 0x0378(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Animation             GroggyAnimBinder;                                  // 0x0398(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Animation             FadeOutAnimBinder;                                 // 0x03B8(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D8[0x20];                                     // 0x03D8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FEventReply OnButtonDown(const struct FGeometry& Geometry, const struct FPointerEvent& MouseEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapCharacterIconBaseWidget">();
	}
	static class UMapCharacterIconBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapCharacterIconBaseWidget>();
	}
};
static_assert(alignof(UMapCharacterIconBaseWidget) == 0x000008, "Wrong alignment on UMapCharacterIconBaseWidget");
static_assert(sizeof(UMapCharacterIconBaseWidget) == 0x0003F8, "Wrong size on UMapCharacterIconBaseWidget");
static_assert(offsetof(UMapCharacterIconBaseWidget, IconImageBorderBinder) == 0x000278, "Member 'UMapCharacterIconBaseWidget::IconImageBorderBinder' has a wrong offset!");
static_assert(offsetof(UMapCharacterIconBaseWidget, IconImageBinder) == 0x000298, "Member 'UMapCharacterIconBaseWidget::IconImageBinder' has a wrong offset!");
static_assert(offsetof(UMapCharacterIconBaseWidget, IconStateParamName) == 0x0002C0, "Member 'UMapCharacterIconBaseWidget::IconStateParamName' has a wrong offset!");
static_assert(offsetof(UMapCharacterIconBaseWidget, IconRotationParamName) == 0x0002C8, "Member 'UMapCharacterIconBaseWidget::IconRotationParamName' has a wrong offset!");
static_assert(offsetof(UMapCharacterIconBaseWidget, IconColorParamName) == 0x0002D0, "Member 'UMapCharacterIconBaseWidget::IconColorParamName' has a wrong offset!");
static_assert(offsetof(UMapCharacterIconBaseWidget, PlayerNameBoderBinder) == 0x0002D8, "Member 'UMapCharacterIconBaseWidget::PlayerNameBoderBinder' has a wrong offset!");
static_assert(offsetof(UMapCharacterIconBaseWidget, PlayerNameBinder) == 0x0002F8, "Member 'UMapCharacterIconBaseWidget::PlayerNameBinder' has a wrong offset!");
static_assert(offsetof(UMapCharacterIconBaseWidget, LifeGaugeBorderBinder) == 0x000318, "Member 'UMapCharacterIconBaseWidget::LifeGaugeBorderBinder' has a wrong offset!");
static_assert(offsetof(UMapCharacterIconBaseWidget, LifeGaugeWidgetBinder) == 0x000338, "Member 'UMapCharacterIconBaseWidget::LifeGaugeWidgetBinder' has a wrong offset!");
static_assert(offsetof(UMapCharacterIconBaseWidget, AttackedAnimBinder) == 0x000358, "Member 'UMapCharacterIconBaseWidget::AttackedAnimBinder' has a wrong offset!");
static_assert(offsetof(UMapCharacterIconBaseWidget, HittedAnimBinder) == 0x000378, "Member 'UMapCharacterIconBaseWidget::HittedAnimBinder' has a wrong offset!");
static_assert(offsetof(UMapCharacterIconBaseWidget, GroggyAnimBinder) == 0x000398, "Member 'UMapCharacterIconBaseWidget::GroggyAnimBinder' has a wrong offset!");
static_assert(offsetof(UMapCharacterIconBaseWidget, FadeOutAnimBinder) == 0x0003B8, "Member 'UMapCharacterIconBaseWidget::FadeOutAnimBinder' has a wrong offset!");

// Class TslGame.MapGridWidget
// 0x03B0 (0x0628 - 0x0278)
class UMapGridWidget : public UUmgBaseWidget
{
public:
	struct FUmgWidgetBinder_Image                 MapImageBinder;                                    // 0x0278(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_CanvasPanel           MyMarkerLayerBinder;                               // 0x02A0(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_CanvasPanel           TeamMarkerLayerBinder;                             // 0x02C0(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSubclassOf<class UMapMarkerBaseWidget>       MapMarkerClass;                                    // 0x02E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_CanvasPanel           MyMapIconLayerBinder;                              // 0x02E8(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_CanvasPanel           OtherMapIconLayerBinder;                           // 0x0308(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_CanvasPanel           CarePackageItemIconLayerBinder;                    // 0x0328(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSubclassOf<class UMapCharacterIconBaseWidget> MapCharacterIconClass;                             // 0x0348(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UMapCarePackageItemIconBaseWidget> MapCarePackageItemIconClass;                       // 0x0350(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowName;                                         // 0x0358(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_359[0x7];                                      // 0x0359(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUmgWidgetBinder_Image                 RedzoneImageBinder;                                // 0x0360(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   RedzoneColorParamName;                             // 0x0388(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColorBlindColorSet                    RedzoneColorSet;                                   // 0x0390(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_SizeBox               ImageSizeBoxBinder;                                // 0x03A0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FColorBlindColorSet                    BluezoneColorSet;                                  // 0x03C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         ZoomLevel;                                         // 0x03D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShowGridZoomLevel;                                 // 0x03D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            ViewRatioCurve;                                    // 0x03D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRectangleViewMode;                                // 0x03E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E1[0x7];                                      // 0x03E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFont*                                  GridFont;                                          // 0x03E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FontTypeFace;                                      // 0x03F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                         GridTextHorizentalArray;                           // 0x03F8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class FString>                         GridTextVerticalArray;                             // 0x0408(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           ColorLargeGrid;                                    // 0x0418(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           ColorSmallGrid;                                    // 0x0428(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           ColorText;                                         // 0x0438(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           ColorSafetyZone;                                   // 0x0448(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         ThicknessLargeGrid;                                // 0x0458(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThicknessSmallGrid;                                // 0x045C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           ColorPoisonGasWarning;                             // 0x0460(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bDrawGridLine;                                     // 0x0470(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawGridText;                                     // 0x0471(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawNextPlayzoneGuideLine;                        // 0x0472(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseZOrderSort;                                    // 0x0473(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseTeamMemberColor;                               // 0x0474(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRemoveDeadIcon;                                   // 0x0475(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_476[0x12];                                     // 0x0476(0x0012)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               MatInst;                                           // 0x0488(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_490[0x18];                                     // 0x0490(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UMapMarkerBaseWidget*                   MyMapMarker;                                       // 0x04A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class ATeam*, class UMapMarkerBaseWidget*> TeamPlayerMarkers;                                 // 0x04B0(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UMapCharacterIconBaseWidget*            MyCharacterMapIcon;                                // 0x0500(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class AActor*, class UMapCharacterIconBaseWidget*> OtherCharacterMapIcons;                            // 0x0508(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TMap<class ACarePackageItem*, class UMapCarePackageItemIconBaseWidget*> MapCarePackageItemIcons;                           // 0x0558(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           ReplicatedCharacterListUpdateTimer;                // 0x05A8(0x0008)(Transient, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           ReplicatedCarePackageItemListUpdateTimer;          // 0x05B0(0x0008)(Transient, NativeAccessSpecifierPrivate)
	TArray<class ATslCharacter*>                  ReplicatedCharacterList;                           // 0x05B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ACarePackageItem*>               ReplicatedCarePackageItemList;                     // 0x05C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class ATeam*>                          ShowMarkerOnwerList;                               // 0x05D8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E8[0x20];                                     // 0x05E8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   CloseMySelf;                                       // 0x0608(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnHideOwner;                                       // 0x0618(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	void AddCenter_UC(const struct FVector2D& Offset_UC);
	struct FVector2D ClampPosition_UC(const struct FVector2D& Positon);
	struct FVector2D ClampPositionByWidgetSize_UC(const struct FVector2D& Positon, const struct FVector2D& WidgetSize);
	void CursorUCtoCenterMC(const struct FVector2D& UC, struct FVector2D* Offest_MC, bool* bUpdate);
	void GetMapImageWigetSizeAndImageOffset(struct FVector2D* WidgetSize, struct FVector2D* ImageOffset);
	void OnMapCarePackageItemIconClicked(class UMapCarePackageItemIconBaseWidget* MapIconWidget);
	void OnMapIconClicked(class UMapCharacterIconBaseWidget* MapIconWidget);
	void SetCenter_MC(const struct FVector2D& Center);
	void SetCharacterIconPositionAndRotation_UC(const struct FVector2D& Pos_UC, float Angle);
	void SetImageBrush(class UMaterialInstanceDynamic* NewMatInst);
	void SetZoomLevel(float NewZoomLevel);
	void UpdateRectangleView();
	void UpdateRectangleViewByWidgetSize(const struct FVector2D& WidgetSize);
	void UpdateReplicatedCarePackageItemList();
	void UpdateReplicatedCharacterList();
	void UpdateWidgetSize_UC(const struct FVector2D& WidgetSize);
	void UpdateZoomAndWidgetSize(float Zoom, const struct FVector2D& WidgetSize);

	void DrawMarker_UC(const struct FVector2D& MarkerCenter_UC) const;
	void DrawRedZone_UC(const struct FVector2D& Center_UC, float Radius_UC) const;
	struct FVector2D GetAlignment() const;
	class FString GetCharacterGridTextHorizental() const;
	class FString GetCharacterGridVertical() const;
	struct FVector2D GetLocalMousePosition() const;
	struct FVector2D GetScreenOffset() const;
	struct FVector2D GetWidgetPosition() const;
	struct FVector2D GetWidgetSize() const;
	float GetZoomLevel() const;
	bool IsMouseInMarker() const;
	struct FVector2D MCtoUC(const struct FVector2D& MapCoord) const;
	struct FVector2D UCtoMC(const struct FVector2D& UC) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapGridWidget">();
	}
	static class UMapGridWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapGridWidget>();
	}
};
static_assert(alignof(UMapGridWidget) == 0x000008, "Wrong alignment on UMapGridWidget");
static_assert(sizeof(UMapGridWidget) == 0x000628, "Wrong size on UMapGridWidget");
static_assert(offsetof(UMapGridWidget, MapImageBinder) == 0x000278, "Member 'UMapGridWidget::MapImageBinder' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, MyMarkerLayerBinder) == 0x0002A0, "Member 'UMapGridWidget::MyMarkerLayerBinder' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, TeamMarkerLayerBinder) == 0x0002C0, "Member 'UMapGridWidget::TeamMarkerLayerBinder' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, MapMarkerClass) == 0x0002E0, "Member 'UMapGridWidget::MapMarkerClass' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, MyMapIconLayerBinder) == 0x0002E8, "Member 'UMapGridWidget::MyMapIconLayerBinder' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, OtherMapIconLayerBinder) == 0x000308, "Member 'UMapGridWidget::OtherMapIconLayerBinder' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, CarePackageItemIconLayerBinder) == 0x000328, "Member 'UMapGridWidget::CarePackageItemIconLayerBinder' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, MapCharacterIconClass) == 0x000348, "Member 'UMapGridWidget::MapCharacterIconClass' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, MapCarePackageItemIconClass) == 0x000350, "Member 'UMapGridWidget::MapCarePackageItemIconClass' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, bShowName) == 0x000358, "Member 'UMapGridWidget::bShowName' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, RedzoneImageBinder) == 0x000360, "Member 'UMapGridWidget::RedzoneImageBinder' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, RedzoneColorParamName) == 0x000388, "Member 'UMapGridWidget::RedzoneColorParamName' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, RedzoneColorSet) == 0x000390, "Member 'UMapGridWidget::RedzoneColorSet' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, ImageSizeBoxBinder) == 0x0003A0, "Member 'UMapGridWidget::ImageSizeBoxBinder' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, BluezoneColorSet) == 0x0003C0, "Member 'UMapGridWidget::BluezoneColorSet' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, ZoomLevel) == 0x0003D0, "Member 'UMapGridWidget::ZoomLevel' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, ShowGridZoomLevel) == 0x0003D4, "Member 'UMapGridWidget::ShowGridZoomLevel' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, ViewRatioCurve) == 0x0003D8, "Member 'UMapGridWidget::ViewRatioCurve' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, bRectangleViewMode) == 0x0003E0, "Member 'UMapGridWidget::bRectangleViewMode' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, GridFont) == 0x0003E8, "Member 'UMapGridWidget::GridFont' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, FontTypeFace) == 0x0003F0, "Member 'UMapGridWidget::FontTypeFace' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, GridTextHorizentalArray) == 0x0003F8, "Member 'UMapGridWidget::GridTextHorizentalArray' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, GridTextVerticalArray) == 0x000408, "Member 'UMapGridWidget::GridTextVerticalArray' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, ColorLargeGrid) == 0x000418, "Member 'UMapGridWidget::ColorLargeGrid' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, ColorSmallGrid) == 0x000428, "Member 'UMapGridWidget::ColorSmallGrid' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, ColorText) == 0x000438, "Member 'UMapGridWidget::ColorText' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, ColorSafetyZone) == 0x000448, "Member 'UMapGridWidget::ColorSafetyZone' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, ThicknessLargeGrid) == 0x000458, "Member 'UMapGridWidget::ThicknessLargeGrid' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, ThicknessSmallGrid) == 0x00045C, "Member 'UMapGridWidget::ThicknessSmallGrid' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, ColorPoisonGasWarning) == 0x000460, "Member 'UMapGridWidget::ColorPoisonGasWarning' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, bDrawGridLine) == 0x000470, "Member 'UMapGridWidget::bDrawGridLine' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, bDrawGridText) == 0x000471, "Member 'UMapGridWidget::bDrawGridText' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, bDrawNextPlayzoneGuideLine) == 0x000472, "Member 'UMapGridWidget::bDrawNextPlayzoneGuideLine' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, bUseZOrderSort) == 0x000473, "Member 'UMapGridWidget::bUseZOrderSort' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, bUseTeamMemberColor) == 0x000474, "Member 'UMapGridWidget::bUseTeamMemberColor' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, bRemoveDeadIcon) == 0x000475, "Member 'UMapGridWidget::bRemoveDeadIcon' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, MatInst) == 0x000488, "Member 'UMapGridWidget::MatInst' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, MyMapMarker) == 0x0004A8, "Member 'UMapGridWidget::MyMapMarker' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, TeamPlayerMarkers) == 0x0004B0, "Member 'UMapGridWidget::TeamPlayerMarkers' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, MyCharacterMapIcon) == 0x000500, "Member 'UMapGridWidget::MyCharacterMapIcon' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, OtherCharacterMapIcons) == 0x000508, "Member 'UMapGridWidget::OtherCharacterMapIcons' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, MapCarePackageItemIcons) == 0x000558, "Member 'UMapGridWidget::MapCarePackageItemIcons' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, ReplicatedCharacterListUpdateTimer) == 0x0005A8, "Member 'UMapGridWidget::ReplicatedCharacterListUpdateTimer' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, ReplicatedCarePackageItemListUpdateTimer) == 0x0005B0, "Member 'UMapGridWidget::ReplicatedCarePackageItemListUpdateTimer' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, ReplicatedCharacterList) == 0x0005B8, "Member 'UMapGridWidget::ReplicatedCharacterList' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, ReplicatedCarePackageItemList) == 0x0005C8, "Member 'UMapGridWidget::ReplicatedCarePackageItemList' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, ShowMarkerOnwerList) == 0x0005D8, "Member 'UMapGridWidget::ShowMarkerOnwerList' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, CloseMySelf) == 0x000608, "Member 'UMapGridWidget::CloseMySelf' has a wrong offset!");
static_assert(offsetof(UMapGridWidget, OnHideOwner) == 0x000618, "Member 'UMapGridWidget::OnHideOwner' has a wrong offset!");

// Class TslGame.MapMarkerBaseWidget
// 0x0060 (0x02D8 - 0x0278)
class UMapMarkerBaseWidget : public UUmgBaseWidget
{
public:
	struct FUmgWidgetBinder_Image                 MarkerImageBinder;                                 // 0x0278(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   MarkerColorParmName;                               // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Animation             MarkerEmergingAnimBinder;                          // 0x02A8(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C8[0x10];                                     // 0x02C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapMarkerBaseWidget">();
	}
	static class UMapMarkerBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapMarkerBaseWidget>();
	}
};
static_assert(alignof(UMapMarkerBaseWidget) == 0x000008, "Wrong alignment on UMapMarkerBaseWidget");
static_assert(sizeof(UMapMarkerBaseWidget) == 0x0002D8, "Wrong size on UMapMarkerBaseWidget");
static_assert(offsetof(UMapMarkerBaseWidget, MarkerImageBinder) == 0x000278, "Member 'UMapMarkerBaseWidget::MarkerImageBinder' has a wrong offset!");
static_assert(offsetof(UMapMarkerBaseWidget, MarkerColorParmName) == 0x0002A0, "Member 'UMapMarkerBaseWidget::MarkerColorParmName' has a wrong offset!");
static_assert(offsetof(UMapMarkerBaseWidget, MarkerEmergingAnimBinder) == 0x0002A8, "Member 'UMapMarkerBaseWidget::MarkerEmergingAnimBinder' has a wrong offset!");

// Class TslGame.MiniMapBaseWidget
// 0x0028 (0x02A0 - 0x0278)
class UMiniMapBaseWidget : public UUmgBaseWidget
{
public:
	struct FUmgWidgetBinder_UserWidget            MapWidgetBinder;                                   // 0x0278(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MiniMapBaseWidget">();
	}
	static class UMiniMapBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMiniMapBaseWidget>();
	}
};
static_assert(alignof(UMiniMapBaseWidget) == 0x000008, "Wrong alignment on UMiniMapBaseWidget");
static_assert(sizeof(UMiniMapBaseWidget) == 0x0002A0, "Wrong size on UMiniMapBaseWidget");
static_assert(offsetof(UMiniMapBaseWidget, MapWidgetBinder) == 0x000278, "Member 'UMiniMapBaseWidget::MapWidgetBinder' has a wrong offset!");

// Class TslGame.TeamMarkWidget
// 0x01D0 (0x0448 - 0x0278)
class UTeamMarkWidget : public UUmgBaseWidget
{
public:
	class ATeam*                                  TeamMember;                                        // 0x0278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetZ;                                           // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImageSize;                                         // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TopMarkGapDistance;                                // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BottomMarkGapDistance;                             // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftRightMarkGapDistance;                          // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiagonalPercent;                                   // 0x0294(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeadMarkInvisibleTime;                             // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeadMarkInvisibleDistance;                         // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultImageAlpha;                                 // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultTextAlpha;                                  // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmingImageAlpha;                                   // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScopingImageAlpha;                                 // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmingTextAlpha;                                    // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScopingTextAlpha;                                  // 0x02B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMarkPosition                                 TeamMarkPosition;                                  // 0x02B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUmgWidgetBinder_Gerneral              StateSwitcherBinder;                               // 0x02C0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_TextBlock             PlayerNameTextBinder;                              // 0x02E0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Image                 OutLineImageBinder;                                // 0x0300(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Image                 NormalImageBinder;                                 // 0x0328(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Image                 DeadImageBinder;                                   // 0x0350(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Image                 VehicleImageBinder;                                // 0x0378(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Image                 ParachuteImageBinder;                              // 0x03A0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Image                 QuitterImageBinder;                                // 0x03C8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_UserWidget            GroggyCircleBinder;                                // 0x03F0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UTexture*                               OutScreenImage;                                    // 0x0410(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture*                               InScreenImage;                                     // 0x0418(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_420[0x18];                                     // 0x0420(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       Camera;                                            // 0x0438(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_440[0x8];                                      // 0x0440(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeTeamMarkGrid();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamMarkWidget">();
	}
	static class UTeamMarkWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamMarkWidget>();
	}
};
static_assert(alignof(UTeamMarkWidget) == 0x000008, "Wrong alignment on UTeamMarkWidget");
static_assert(sizeof(UTeamMarkWidget) == 0x000448, "Wrong size on UTeamMarkWidget");
static_assert(offsetof(UTeamMarkWidget, TeamMember) == 0x000278, "Member 'UTeamMarkWidget::TeamMember' has a wrong offset!");
static_assert(offsetof(UTeamMarkWidget, OffsetZ) == 0x000280, "Member 'UTeamMarkWidget::OffsetZ' has a wrong offset!");
static_assert(offsetof(UTeamMarkWidget, ImageSize) == 0x000284, "Member 'UTeamMarkWidget::ImageSize' has a wrong offset!");
static_assert(offsetof(UTeamMarkWidget, TopMarkGapDistance) == 0x000288, "Member 'UTeamMarkWidget::TopMarkGapDistance' has a wrong offset!");
static_assert(offsetof(UTeamMarkWidget, BottomMarkGapDistance) == 0x00028C, "Member 'UTeamMarkWidget::BottomMarkGapDistance' has a wrong offset!");
static_assert(offsetof(UTeamMarkWidget, LeftRightMarkGapDistance) == 0x000290, "Member 'UTeamMarkWidget::LeftRightMarkGapDistance' has a wrong offset!");
static_assert(offsetof(UTeamMarkWidget, DiagonalPercent) == 0x000294, "Member 'UTeamMarkWidget::DiagonalPercent' has a wrong offset!");
static_assert(offsetof(UTeamMarkWidget, DeadMarkInvisibleTime) == 0x000298, "Member 'UTeamMarkWidget::DeadMarkInvisibleTime' has a wrong offset!");
static_assert(offsetof(UTeamMarkWidget, DeadMarkInvisibleDistance) == 0x00029C, "Member 'UTeamMarkWidget::DeadMarkInvisibleDistance' has a wrong offset!");
static_assert(offsetof(UTeamMarkWidget, DefaultImageAlpha) == 0x0002A0, "Member 'UTeamMarkWidget::DefaultImageAlpha' has a wrong offset!");
static_assert(offsetof(UTeamMarkWidget, DefaultTextAlpha) == 0x0002A4, "Member 'UTeamMarkWidget::DefaultTextAlpha' has a wrong offset!");
static_assert(offsetof(UTeamMarkWidget, AmingImageAlpha) == 0x0002A8, "Member 'UTeamMarkWidget::AmingImageAlpha' has a wrong offset!");
static_assert(offsetof(UTeamMarkWidget, ScopingImageAlpha) == 0x0002AC, "Member 'UTeamMarkWidget::ScopingImageAlpha' has a wrong offset!");
static_assert(offsetof(UTeamMarkWidget, AmingTextAlpha) == 0x0002B0, "Member 'UTeamMarkWidget::AmingTextAlpha' has a wrong offset!");
static_assert(offsetof(UTeamMarkWidget, ScopingTextAlpha) == 0x0002B4, "Member 'UTeamMarkWidget::ScopingTextAlpha' has a wrong offset!");
static_assert(offsetof(UTeamMarkWidget, TeamMarkPosition) == 0x0002B8, "Member 'UTeamMarkWidget::TeamMarkPosition' has a wrong offset!");
static_assert(offsetof(UTeamMarkWidget, StateSwitcherBinder) == 0x0002C0, "Member 'UTeamMarkWidget::StateSwitcherBinder' has a wrong offset!");
static_assert(offsetof(UTeamMarkWidget, PlayerNameTextBinder) == 0x0002E0, "Member 'UTeamMarkWidget::PlayerNameTextBinder' has a wrong offset!");
static_assert(offsetof(UTeamMarkWidget, OutLineImageBinder) == 0x000300, "Member 'UTeamMarkWidget::OutLineImageBinder' has a wrong offset!");
static_assert(offsetof(UTeamMarkWidget, NormalImageBinder) == 0x000328, "Member 'UTeamMarkWidget::NormalImageBinder' has a wrong offset!");
static_assert(offsetof(UTeamMarkWidget, DeadImageBinder) == 0x000350, "Member 'UTeamMarkWidget::DeadImageBinder' has a wrong offset!");
static_assert(offsetof(UTeamMarkWidget, VehicleImageBinder) == 0x000378, "Member 'UTeamMarkWidget::VehicleImageBinder' has a wrong offset!");
static_assert(offsetof(UTeamMarkWidget, ParachuteImageBinder) == 0x0003A0, "Member 'UTeamMarkWidget::ParachuteImageBinder' has a wrong offset!");
static_assert(offsetof(UTeamMarkWidget, QuitterImageBinder) == 0x0003C8, "Member 'UTeamMarkWidget::QuitterImageBinder' has a wrong offset!");
static_assert(offsetof(UTeamMarkWidget, GroggyCircleBinder) == 0x0003F0, "Member 'UTeamMarkWidget::GroggyCircleBinder' has a wrong offset!");
static_assert(offsetof(UTeamMarkWidget, OutScreenImage) == 0x000410, "Member 'UTeamMarkWidget::OutScreenImage' has a wrong offset!");
static_assert(offsetof(UTeamMarkWidget, InScreenImage) == 0x000418, "Member 'UTeamMarkWidget::InScreenImage' has a wrong offset!");
static_assert(offsetof(UTeamMarkWidget, Camera) == 0x000438, "Member 'UTeamMarkWidget::Camera' has a wrong offset!");

// Class TslGame.TslAdaptiveCrosshairWidget
// 0x03C8 (0x0640 - 0x0278)
class UTslAdaptiveCrosshairWidget final : public UUmgBaseWidget
{
public:
	EWeaponClass                                  WeaponClass;                                       // 0x0278(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsShowWidget;                                     // 0x0279(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27A[0x6];                                      // 0x027A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColorBlindColorSet                    ColorBlindColors;                                  // 0x0280(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Image                 AdaptiveCrosshair_Binder;                          // 0x0290(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_CanvasPanel           CanvasBase_Binder;                                 // 0x02B8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_CanvasPanel           CenterCenter_Binder;                               // 0x02D8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_CanvasPanel           CenterCrosshair_Binder;                            // 0x02F8(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_CanvasPanel           CenterD_Binder;                                    // 0x0318(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Image                 CenterDOT_Binder;                                  // 0x0338(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_CanvasPanel           CenterL_Binder;                                    // 0x0360(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_CanvasPanel           CenterR_Binder;                                    // 0x0380(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_CanvasPanel           CenterU_Binder;                                    // 0x03A0(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Image                 Pistol_C_Binder;                                   // 0x03C0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Image                 Pistol_C_Gradient_Binder;                          // 0x03E8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Image                 Pistol_L_Binder;                                   // 0x0410(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Image                 Pistol_R_Binder;                                   // 0x0438(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Image                 Rifle_D_Binder;                                    // 0x0460(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Image                 Rifle_D_Arrow_Binder;                              // 0x0488(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Image                 Rifle_L_Binder;                                    // 0x04B0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Image                 Rifle_L_Arrow_Binder;                              // 0x04D8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Image                 Rifle_R_Binder;                                    // 0x0500(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Image                 Rifle_R_Arrow_Binder;                              // 0x0528(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Image                 Rifle_U_Binder;                                    // 0x0550(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Image                 Rifle_U_Arrow_Binder;                              // 0x0578(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Image                 Shotgun_D_Binder;                                  // 0x05A0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Image                 Shotgun_L_Binder;                                  // 0x05C8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Image                 Shotgun_R_Binder;                                  // 0x05F0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Image                 Shotgun_U_Binder;                                  // 0x0618(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	void DecideAdaptiveCrosshairColor();
	void HandleGameUserSettingApplied();
	void SetAdaptiveCrosshairPosition(const struct FVector2D& ScreenPosition, float Distance);
	void SetAdaptiveCrosshairVisibility(bool bVisible);
	void SetCenterCrosshairClass(EWeaponClass InWeaponClass, bool bHasWeapon);
	void SetCenterCrosshairDeviation(float InDeviation);
	void SetCenterCrosshairVisibility(bool bVisible);
	void SetShowCrosshairWidget(bool bShow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslAdaptiveCrosshairWidget">();
	}
	static class UTslAdaptiveCrosshairWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslAdaptiveCrosshairWidget>();
	}
};
static_assert(alignof(UTslAdaptiveCrosshairWidget) == 0x000008, "Wrong alignment on UTslAdaptiveCrosshairWidget");
static_assert(sizeof(UTslAdaptiveCrosshairWidget) == 0x000640, "Wrong size on UTslAdaptiveCrosshairWidget");
static_assert(offsetof(UTslAdaptiveCrosshairWidget, WeaponClass) == 0x000278, "Member 'UTslAdaptiveCrosshairWidget::WeaponClass' has a wrong offset!");
static_assert(offsetof(UTslAdaptiveCrosshairWidget, bIsShowWidget) == 0x000279, "Member 'UTslAdaptiveCrosshairWidget::bIsShowWidget' has a wrong offset!");
static_assert(offsetof(UTslAdaptiveCrosshairWidget, ColorBlindColors) == 0x000280, "Member 'UTslAdaptiveCrosshairWidget::ColorBlindColors' has a wrong offset!");
static_assert(offsetof(UTslAdaptiveCrosshairWidget, AdaptiveCrosshair_Binder) == 0x000290, "Member 'UTslAdaptiveCrosshairWidget::AdaptiveCrosshair_Binder' has a wrong offset!");
static_assert(offsetof(UTslAdaptiveCrosshairWidget, CanvasBase_Binder) == 0x0002B8, "Member 'UTslAdaptiveCrosshairWidget::CanvasBase_Binder' has a wrong offset!");
static_assert(offsetof(UTslAdaptiveCrosshairWidget, CenterCenter_Binder) == 0x0002D8, "Member 'UTslAdaptiveCrosshairWidget::CenterCenter_Binder' has a wrong offset!");
static_assert(offsetof(UTslAdaptiveCrosshairWidget, CenterCrosshair_Binder) == 0x0002F8, "Member 'UTslAdaptiveCrosshairWidget::CenterCrosshair_Binder' has a wrong offset!");
static_assert(offsetof(UTslAdaptiveCrosshairWidget, CenterD_Binder) == 0x000318, "Member 'UTslAdaptiveCrosshairWidget::CenterD_Binder' has a wrong offset!");
static_assert(offsetof(UTslAdaptiveCrosshairWidget, CenterDOT_Binder) == 0x000338, "Member 'UTslAdaptiveCrosshairWidget::CenterDOT_Binder' has a wrong offset!");
static_assert(offsetof(UTslAdaptiveCrosshairWidget, CenterL_Binder) == 0x000360, "Member 'UTslAdaptiveCrosshairWidget::CenterL_Binder' has a wrong offset!");
static_assert(offsetof(UTslAdaptiveCrosshairWidget, CenterR_Binder) == 0x000380, "Member 'UTslAdaptiveCrosshairWidget::CenterR_Binder' has a wrong offset!");
static_assert(offsetof(UTslAdaptiveCrosshairWidget, CenterU_Binder) == 0x0003A0, "Member 'UTslAdaptiveCrosshairWidget::CenterU_Binder' has a wrong offset!");
static_assert(offsetof(UTslAdaptiveCrosshairWidget, Pistol_C_Binder) == 0x0003C0, "Member 'UTslAdaptiveCrosshairWidget::Pistol_C_Binder' has a wrong offset!");
static_assert(offsetof(UTslAdaptiveCrosshairWidget, Pistol_C_Gradient_Binder) == 0x0003E8, "Member 'UTslAdaptiveCrosshairWidget::Pistol_C_Gradient_Binder' has a wrong offset!");
static_assert(offsetof(UTslAdaptiveCrosshairWidget, Pistol_L_Binder) == 0x000410, "Member 'UTslAdaptiveCrosshairWidget::Pistol_L_Binder' has a wrong offset!");
static_assert(offsetof(UTslAdaptiveCrosshairWidget, Pistol_R_Binder) == 0x000438, "Member 'UTslAdaptiveCrosshairWidget::Pistol_R_Binder' has a wrong offset!");
static_assert(offsetof(UTslAdaptiveCrosshairWidget, Rifle_D_Binder) == 0x000460, "Member 'UTslAdaptiveCrosshairWidget::Rifle_D_Binder' has a wrong offset!");
static_assert(offsetof(UTslAdaptiveCrosshairWidget, Rifle_D_Arrow_Binder) == 0x000488, "Member 'UTslAdaptiveCrosshairWidget::Rifle_D_Arrow_Binder' has a wrong offset!");
static_assert(offsetof(UTslAdaptiveCrosshairWidget, Rifle_L_Binder) == 0x0004B0, "Member 'UTslAdaptiveCrosshairWidget::Rifle_L_Binder' has a wrong offset!");
static_assert(offsetof(UTslAdaptiveCrosshairWidget, Rifle_L_Arrow_Binder) == 0x0004D8, "Member 'UTslAdaptiveCrosshairWidget::Rifle_L_Arrow_Binder' has a wrong offset!");
static_assert(offsetof(UTslAdaptiveCrosshairWidget, Rifle_R_Binder) == 0x000500, "Member 'UTslAdaptiveCrosshairWidget::Rifle_R_Binder' has a wrong offset!");
static_assert(offsetof(UTslAdaptiveCrosshairWidget, Rifle_R_Arrow_Binder) == 0x000528, "Member 'UTslAdaptiveCrosshairWidget::Rifle_R_Arrow_Binder' has a wrong offset!");
static_assert(offsetof(UTslAdaptiveCrosshairWidget, Rifle_U_Binder) == 0x000550, "Member 'UTslAdaptiveCrosshairWidget::Rifle_U_Binder' has a wrong offset!");
static_assert(offsetof(UTslAdaptiveCrosshairWidget, Rifle_U_Arrow_Binder) == 0x000578, "Member 'UTslAdaptiveCrosshairWidget::Rifle_U_Arrow_Binder' has a wrong offset!");
static_assert(offsetof(UTslAdaptiveCrosshairWidget, Shotgun_D_Binder) == 0x0005A0, "Member 'UTslAdaptiveCrosshairWidget::Shotgun_D_Binder' has a wrong offset!");
static_assert(offsetof(UTslAdaptiveCrosshairWidget, Shotgun_L_Binder) == 0x0005C8, "Member 'UTslAdaptiveCrosshairWidget::Shotgun_L_Binder' has a wrong offset!");
static_assert(offsetof(UTslAdaptiveCrosshairWidget, Shotgun_R_Binder) == 0x0005F0, "Member 'UTslAdaptiveCrosshairWidget::Shotgun_R_Binder' has a wrong offset!");
static_assert(offsetof(UTslAdaptiveCrosshairWidget, Shotgun_U_Binder) == 0x000618, "Member 'UTslAdaptiveCrosshairWidget::Shotgun_U_Binder' has a wrong offset!");

// Class TslGame.TslAlivePlayerInfoWidget
// 0x00F8 (0x0370 - 0x0278)
class UTslAlivePlayerInfoWidget : public UUmgBaseWidget
{
public:
	class ATslGameState*                          CachedTslGS;                                       // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Border                ColorOverlay_Binder;                               // 0x0280(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Animation             Warning_Binder;                                    // 0x02A0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Animation             Increasing_Binder;                                 // 0x02C0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Animation             Decreasing_Binder;                                 // 0x02E0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Animation             Default_Binder;                                    // 0x0300(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_TextBlock             AdditionalInfo_Binder;                             // 0x0320(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_TextBlock             SurvivorCount_Binder;                              // 0x0340(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsReplaying;                                      // 0x0360(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsHidden;                                         // 0x0361(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_362[0x2];                                      // 0x0362(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentCount;                                      // 0x0364(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DisplayCount;                                      // 0x0368(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WhileAnimCount;                                    // 0x036C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslAlivePlayerInfoWidget">();
	}
	static class UTslAlivePlayerInfoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslAlivePlayerInfoWidget>();
	}
};
static_assert(alignof(UTslAlivePlayerInfoWidget) == 0x000008, "Wrong alignment on UTslAlivePlayerInfoWidget");
static_assert(sizeof(UTslAlivePlayerInfoWidget) == 0x000370, "Wrong size on UTslAlivePlayerInfoWidget");
static_assert(offsetof(UTslAlivePlayerInfoWidget, CachedTslGS) == 0x000278, "Member 'UTslAlivePlayerInfoWidget::CachedTslGS' has a wrong offset!");
static_assert(offsetof(UTslAlivePlayerInfoWidget, ColorOverlay_Binder) == 0x000280, "Member 'UTslAlivePlayerInfoWidget::ColorOverlay_Binder' has a wrong offset!");
static_assert(offsetof(UTslAlivePlayerInfoWidget, Warning_Binder) == 0x0002A0, "Member 'UTslAlivePlayerInfoWidget::Warning_Binder' has a wrong offset!");
static_assert(offsetof(UTslAlivePlayerInfoWidget, Increasing_Binder) == 0x0002C0, "Member 'UTslAlivePlayerInfoWidget::Increasing_Binder' has a wrong offset!");
static_assert(offsetof(UTslAlivePlayerInfoWidget, Decreasing_Binder) == 0x0002E0, "Member 'UTslAlivePlayerInfoWidget::Decreasing_Binder' has a wrong offset!");
static_assert(offsetof(UTslAlivePlayerInfoWidget, Default_Binder) == 0x000300, "Member 'UTslAlivePlayerInfoWidget::Default_Binder' has a wrong offset!");
static_assert(offsetof(UTslAlivePlayerInfoWidget, AdditionalInfo_Binder) == 0x000320, "Member 'UTslAlivePlayerInfoWidget::AdditionalInfo_Binder' has a wrong offset!");
static_assert(offsetof(UTslAlivePlayerInfoWidget, SurvivorCount_Binder) == 0x000340, "Member 'UTslAlivePlayerInfoWidget::SurvivorCount_Binder' has a wrong offset!");
static_assert(offsetof(UTslAlivePlayerInfoWidget, bIsReplaying) == 0x000360, "Member 'UTslAlivePlayerInfoWidget::bIsReplaying' has a wrong offset!");
static_assert(offsetof(UTslAlivePlayerInfoWidget, bIsHidden) == 0x000361, "Member 'UTslAlivePlayerInfoWidget::bIsHidden' has a wrong offset!");
static_assert(offsetof(UTslAlivePlayerInfoWidget, CurrentCount) == 0x000364, "Member 'UTslAlivePlayerInfoWidget::CurrentCount' has a wrong offset!");
static_assert(offsetof(UTslAlivePlayerInfoWidget, DisplayCount) == 0x000368, "Member 'UTslAlivePlayerInfoWidget::DisplayCount' has a wrong offset!");
static_assert(offsetof(UTslAlivePlayerInfoWidget, WhileAnimCount) == 0x00036C, "Member 'UTslAlivePlayerInfoWidget::WhileAnimCount' has a wrong offset!");

// Class TslGame.TslBaseOptionWidget
// 0x0000 (0x0278 - 0x0278)
class UTslBaseOptionWidget : public UUmgBaseWidget
{
public:
	void OnApply();
	void OnDefault();
	void OnReset();

	bool IsChanged() const;
	bool IsEnableApply() const;
	bool IsKeyUp() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslBaseOptionWidget">();
	}
	static class UTslBaseOptionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslBaseOptionWidget>();
	}
};
static_assert(alignof(UTslBaseOptionWidget) == 0x000008, "Wrong alignment on UTslBaseOptionWidget");
static_assert(sizeof(UTslBaseOptionWidget) == 0x000278, "Wrong size on UTslBaseOptionWidget");

// Class TslGame.TslKeyDisplayWidget
// 0x0060 (0x02D8 - 0x0278)
class UTslKeyDisplayWidget : public UTslBaseOptionWidget
{
public:
	UMulticastDelegateProperty_                   OnKeyInputed;                                      // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TArray<class UTslKeyReceiverWidget*>          KeyReceiverWidgets;                                // 0x0288(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FUmgWidgetBinder_UserWidget>    KeyReceiverWidgetBinders;                          // 0x0298(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   InputName;                                         // 0x02A8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CategoryName;                                      // 0x02B0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   DisplayText;                                       // 0x02B8(0x0018)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          bGamepad;                                          // 0x02D0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAxisInput;                                        // 0x02D1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D2[0x2];                                      // 0x02D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AxisScale;                                         // 0x02D4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ApplyKey();
	void InitializeKeyDisplayWidget(bool bDefault);
	void SetupKeyDisplayWidget(const class FName& InInputName, const class FText& InDisplayName, const class FName& InCategoryName, bool InbAxisInput, float InAxisScale, bool InbGamepad);
	void TransferInputEvent(const struct FTslInputKey& TslInputKey);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslKeyDisplayWidget">();
	}
	static class UTslKeyDisplayWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslKeyDisplayWidget>();
	}
};
static_assert(alignof(UTslKeyDisplayWidget) == 0x000008, "Wrong alignment on UTslKeyDisplayWidget");
static_assert(sizeof(UTslKeyDisplayWidget) == 0x0002D8, "Wrong size on UTslKeyDisplayWidget");
static_assert(offsetof(UTslKeyDisplayWidget, OnKeyInputed) == 0x000278, "Member 'UTslKeyDisplayWidget::OnKeyInputed' has a wrong offset!");
static_assert(offsetof(UTslKeyDisplayWidget, KeyReceiverWidgets) == 0x000288, "Member 'UTslKeyDisplayWidget::KeyReceiverWidgets' has a wrong offset!");
static_assert(offsetof(UTslKeyDisplayWidget, KeyReceiverWidgetBinders) == 0x000298, "Member 'UTslKeyDisplayWidget::KeyReceiverWidgetBinders' has a wrong offset!");
static_assert(offsetof(UTslKeyDisplayWidget, InputName) == 0x0002A8, "Member 'UTslKeyDisplayWidget::InputName' has a wrong offset!");
static_assert(offsetof(UTslKeyDisplayWidget, CategoryName) == 0x0002B0, "Member 'UTslKeyDisplayWidget::CategoryName' has a wrong offset!");
static_assert(offsetof(UTslKeyDisplayWidget, DisplayText) == 0x0002B8, "Member 'UTslKeyDisplayWidget::DisplayText' has a wrong offset!");
static_assert(offsetof(UTslKeyDisplayWidget, bGamepad) == 0x0002D0, "Member 'UTslKeyDisplayWidget::bGamepad' has a wrong offset!");
static_assert(offsetof(UTslKeyDisplayWidget, bAxisInput) == 0x0002D1, "Member 'UTslKeyDisplayWidget::bAxisInput' has a wrong offset!");
static_assert(offsetof(UTslKeyDisplayWidget, AxisScale) == 0x0002D4, "Member 'UTslKeyDisplayWidget::AxisScale' has a wrong offset!");

// Class TslGame.TslKeyOptionWidget
// 0x0058 (0x02D0 - 0x0278)
class UTslKeyOptionWidget : public UTslBaseOptionWidget
{
public:
	struct FUmgWidgetBinder_Gerneral              ScrollBox_Binder;                                  // 0x0278(0x0020)(Edit, NativeAccessSpecifierPublic)
	TArray<class UTslKeySettingWidget*>           KeySettingWidgets;                                 // 0x0298(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UTslBaseOptionWidget>       MouseSettingWidgetClass;                           // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTslBaseOptionWidget*                   MouseSettingWidget;                                // 0x02B0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UTslKeySettingWidget>       KeySettingWidgetClass;                             // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           CategoryOrder;                                     // 0x02C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	void InitializeKeyAndMouseSetting();
	void OnKeyChanged(class UTslKeyDisplayWidget* InKeyDisplayWidget, const struct FTslInputKey& InInputedKey);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslKeyOptionWidget">();
	}
	static class UTslKeyOptionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslKeyOptionWidget>();
	}
};
static_assert(alignof(UTslKeyOptionWidget) == 0x000008, "Wrong alignment on UTslKeyOptionWidget");
static_assert(sizeof(UTslKeyOptionWidget) == 0x0002D0, "Wrong size on UTslKeyOptionWidget");
static_assert(offsetof(UTslKeyOptionWidget, ScrollBox_Binder) == 0x000278, "Member 'UTslKeyOptionWidget::ScrollBox_Binder' has a wrong offset!");
static_assert(offsetof(UTslKeyOptionWidget, KeySettingWidgets) == 0x000298, "Member 'UTslKeyOptionWidget::KeySettingWidgets' has a wrong offset!");
static_assert(offsetof(UTslKeyOptionWidget, MouseSettingWidgetClass) == 0x0002A8, "Member 'UTslKeyOptionWidget::MouseSettingWidgetClass' has a wrong offset!");
static_assert(offsetof(UTslKeyOptionWidget, MouseSettingWidget) == 0x0002B0, "Member 'UTslKeyOptionWidget::MouseSettingWidget' has a wrong offset!");
static_assert(offsetof(UTslKeyOptionWidget, KeySettingWidgetClass) == 0x0002B8, "Member 'UTslKeyOptionWidget::KeySettingWidgetClass' has a wrong offset!");
static_assert(offsetof(UTslKeyOptionWidget, CategoryOrder) == 0x0002C0, "Member 'UTslKeyOptionWidget::CategoryOrder' has a wrong offset!");

// Class TslGame.TslKeySettingWidget
// 0x0068 (0x02E0 - 0x0278)
class UTslKeySettingWidget : public UTslBaseOptionWidget
{
public:
	UMulticastDelegateProperty_                   OnKeyChanged;                                      // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TSubclassOf<class UTslKeyDisplayWidget>       KeyDisplayWidgetClass;                             // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Gerneral              KeyScrollBoxBinder;                                // 0x0290(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<class UTslKeyDisplayWidget*>           KeyDisplayWidgets;                                 // 0x02B0(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FText                                   DisplayText;                                       // 0x02C0(0x0018)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class FName                                   CategoryName;                                      // 0x02D8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitializeKeySettingWidget();
	void SetToDefault();
	void StartupKeySettingWidget(const class FName& InCategoryName, const class FText& InDisplayText);
	void TransferInputEvent(class UTslKeyDisplayWidget* KeyDisplayWidget, const struct FTslInputKey& TslInputKey);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslKeySettingWidget">();
	}
	static class UTslKeySettingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslKeySettingWidget>();
	}
};
static_assert(alignof(UTslKeySettingWidget) == 0x000008, "Wrong alignment on UTslKeySettingWidget");
static_assert(sizeof(UTslKeySettingWidget) == 0x0002E0, "Wrong size on UTslKeySettingWidget");
static_assert(offsetof(UTslKeySettingWidget, OnKeyChanged) == 0x000278, "Member 'UTslKeySettingWidget::OnKeyChanged' has a wrong offset!");
static_assert(offsetof(UTslKeySettingWidget, KeyDisplayWidgetClass) == 0x000288, "Member 'UTslKeySettingWidget::KeyDisplayWidgetClass' has a wrong offset!");
static_assert(offsetof(UTslKeySettingWidget, KeyScrollBoxBinder) == 0x000290, "Member 'UTslKeySettingWidget::KeyScrollBoxBinder' has a wrong offset!");
static_assert(offsetof(UTslKeySettingWidget, KeyDisplayWidgets) == 0x0002B0, "Member 'UTslKeySettingWidget::KeyDisplayWidgets' has a wrong offset!");
static_assert(offsetof(UTslKeySettingWidget, DisplayText) == 0x0002C0, "Member 'UTslKeySettingWidget::DisplayText' has a wrong offset!");
static_assert(offsetof(UTslKeySettingWidget, CategoryName) == 0x0002D8, "Member 'UTslKeySettingWidget::CategoryName' has a wrong offset!");

// Class TslGame.TslBoostGaugeWidget
// 0x0108 (0x0380 - 0x0278)
class UTslBoostGaugeWidget : public UUmgBaseWidget
{
public:
	class UMaterialInstanceDynamic*               MID_Gauge0_20;                                     // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               MID_Gauge20_60;                                    // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               MID_Gauge60_90;                                    // 0x0288(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               MID_Gauge90_100;                                   // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FUmgWidgetBinder_Animation             VanishingAnimBinder;                               // 0x0298(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Animation             WarningAnimBinder;                                 // 0x02B8(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Animation             EmergingAnimBinder;                                // 0x02D8(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Gerneral              Boost0_20ImageBinder;                              // 0x02F8(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Gerneral              Boost20_60ImageBinder;                             // 0x0318(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Gerneral              Boost60_90ImageBinder;                             // 0x0338(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Gerneral              Boost90_100ImageBinder;                            // 0x0358(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         DisplayingBoost;                                   // 0x0378(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsWarning;                                        // 0x037C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsVanished;                                       // 0x037D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_37E[0x2];                                      // 0x037E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslBoostGaugeWidget">();
	}
	static class UTslBoostGaugeWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslBoostGaugeWidget>();
	}
};
static_assert(alignof(UTslBoostGaugeWidget) == 0x000008, "Wrong alignment on UTslBoostGaugeWidget");
static_assert(sizeof(UTslBoostGaugeWidget) == 0x000380, "Wrong size on UTslBoostGaugeWidget");
static_assert(offsetof(UTslBoostGaugeWidget, MID_Gauge0_20) == 0x000278, "Member 'UTslBoostGaugeWidget::MID_Gauge0_20' has a wrong offset!");
static_assert(offsetof(UTslBoostGaugeWidget, MID_Gauge20_60) == 0x000280, "Member 'UTslBoostGaugeWidget::MID_Gauge20_60' has a wrong offset!");
static_assert(offsetof(UTslBoostGaugeWidget, MID_Gauge60_90) == 0x000288, "Member 'UTslBoostGaugeWidget::MID_Gauge60_90' has a wrong offset!");
static_assert(offsetof(UTslBoostGaugeWidget, MID_Gauge90_100) == 0x000290, "Member 'UTslBoostGaugeWidget::MID_Gauge90_100' has a wrong offset!");
static_assert(offsetof(UTslBoostGaugeWidget, VanishingAnimBinder) == 0x000298, "Member 'UTslBoostGaugeWidget::VanishingAnimBinder' has a wrong offset!");
static_assert(offsetof(UTslBoostGaugeWidget, WarningAnimBinder) == 0x0002B8, "Member 'UTslBoostGaugeWidget::WarningAnimBinder' has a wrong offset!");
static_assert(offsetof(UTslBoostGaugeWidget, EmergingAnimBinder) == 0x0002D8, "Member 'UTslBoostGaugeWidget::EmergingAnimBinder' has a wrong offset!");
static_assert(offsetof(UTslBoostGaugeWidget, Boost0_20ImageBinder) == 0x0002F8, "Member 'UTslBoostGaugeWidget::Boost0_20ImageBinder' has a wrong offset!");
static_assert(offsetof(UTslBoostGaugeWidget, Boost20_60ImageBinder) == 0x000318, "Member 'UTslBoostGaugeWidget::Boost20_60ImageBinder' has a wrong offset!");
static_assert(offsetof(UTslBoostGaugeWidget, Boost60_90ImageBinder) == 0x000338, "Member 'UTslBoostGaugeWidget::Boost60_90ImageBinder' has a wrong offset!");
static_assert(offsetof(UTslBoostGaugeWidget, Boost90_100ImageBinder) == 0x000358, "Member 'UTslBoostGaugeWidget::Boost90_100ImageBinder' has a wrong offset!");
static_assert(offsetof(UTslBoostGaugeWidget, DisplayingBoost) == 0x000378, "Member 'UTslBoostGaugeWidget::DisplayingBoost' has a wrong offset!");
static_assert(offsetof(UTslBoostGaugeWidget, bIsWarning) == 0x00037C, "Member 'UTslBoostGaugeWidget::bIsWarning' has a wrong offset!");
static_assert(offsetof(UTslBoostGaugeWidget, bIsVanished) == 0x00037D, "Member 'UTslBoostGaugeWidget::bIsVanished' has a wrong offset!");

// Class TslGame.TslBuffIconListWidget
// 0x00A8 (0x0320 - 0x0278)
class UTslBuffIconListWidget : public UUmgBaseWidget
{
public:
	struct FUmgWidgetBinder_SizeBox               RunBuffIconBlock_Binder;                           // 0x0278(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Image                 RunBuffIcon_Binder;                                // 0x0298(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_SizeBox               HealBuffIconBlock_Binder;                          // 0x02C0(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Image                 HealBuffIcon_Binder;                               // 0x02E0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture*                               HealBuffIconTex;                                   // 0x0308(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               RunBuffIconTex;                                    // 0x0310(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBoostHealOverTime;                                // 0x0318(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSpeedUp50;                                        // 0x0319(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSpeedUp80;                                        // 0x031A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31B[0x5];                                      // 0x031B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStartBuff(class FName BuffName, bool bStart);
	void UpdateHealBuffIcon();
	void UpdateHealBuffIconVisibility();
	void UpdateRunBuffIcon();
	void UpdateRunBuffIconVisibility();

	float GetBoostPercent() const;
	struct FLinearColor GetHealBuffIconOpacity() const;
	ESlateVisibility GetHealBuffVisibility() const;
	struct FLinearColor GetRunBuffIconOpacity() const;
	ESlateVisibility GetRunBuffVisibility() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslBuffIconListWidget">();
	}
	static class UTslBuffIconListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslBuffIconListWidget>();
	}
};
static_assert(alignof(UTslBuffIconListWidget) == 0x000008, "Wrong alignment on UTslBuffIconListWidget");
static_assert(sizeof(UTslBuffIconListWidget) == 0x000320, "Wrong size on UTslBuffIconListWidget");
static_assert(offsetof(UTslBuffIconListWidget, RunBuffIconBlock_Binder) == 0x000278, "Member 'UTslBuffIconListWidget::RunBuffIconBlock_Binder' has a wrong offset!");
static_assert(offsetof(UTslBuffIconListWidget, RunBuffIcon_Binder) == 0x000298, "Member 'UTslBuffIconListWidget::RunBuffIcon_Binder' has a wrong offset!");
static_assert(offsetof(UTslBuffIconListWidget, HealBuffIconBlock_Binder) == 0x0002C0, "Member 'UTslBuffIconListWidget::HealBuffIconBlock_Binder' has a wrong offset!");
static_assert(offsetof(UTslBuffIconListWidget, HealBuffIcon_Binder) == 0x0002E0, "Member 'UTslBuffIconListWidget::HealBuffIcon_Binder' has a wrong offset!");
static_assert(offsetof(UTslBuffIconListWidget, HealBuffIconTex) == 0x000308, "Member 'UTslBuffIconListWidget::HealBuffIconTex' has a wrong offset!");
static_assert(offsetof(UTslBuffIconListWidget, RunBuffIconTex) == 0x000310, "Member 'UTslBuffIconListWidget::RunBuffIconTex' has a wrong offset!");
static_assert(offsetof(UTslBuffIconListWidget, bBoostHealOverTime) == 0x000318, "Member 'UTslBuffIconListWidget::bBoostHealOverTime' has a wrong offset!");
static_assert(offsetof(UTslBuffIconListWidget, bSpeedUp50) == 0x000319, "Member 'UTslBuffIconListWidget::bSpeedUp50' has a wrong offset!");
static_assert(offsetof(UTslBuffIconListWidget, bSpeedUp80) == 0x00031A, "Member 'UTslBuffIconListWidget::bSpeedUp80' has a wrong offset!");

// Class TslGame.TslCompassMarkerWidget
// 0x0038 (0x02B0 - 0x0278)
class UTslCompassMarkerWidget : public UUmgBaseWidget
{
public:
	struct FUmgWidgetBinder_Image                 CompassMarkerImageBinder;                          // 0x0278(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         MarkerNumber;                                      // 0x02A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         XViewSize;                                         // 0x02A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShow;                                             // 0x02A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslCompassMarkerWidget">();
	}
	static class UTslCompassMarkerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslCompassMarkerWidget>();
	}
};
static_assert(alignof(UTslCompassMarkerWidget) == 0x000008, "Wrong alignment on UTslCompassMarkerWidget");
static_assert(sizeof(UTslCompassMarkerWidget) == 0x0002B0, "Wrong size on UTslCompassMarkerWidget");
static_assert(offsetof(UTslCompassMarkerWidget, CompassMarkerImageBinder) == 0x000278, "Member 'UTslCompassMarkerWidget::CompassMarkerImageBinder' has a wrong offset!");
static_assert(offsetof(UTslCompassMarkerWidget, MarkerNumber) == 0x0002A0, "Member 'UTslCompassMarkerWidget::MarkerNumber' has a wrong offset!");
static_assert(offsetof(UTslCompassMarkerWidget, XViewSize) == 0x0002A4, "Member 'UTslCompassMarkerWidget::XViewSize' has a wrong offset!");
static_assert(offsetof(UTslCompassMarkerWidget, bShow) == 0x0002A8, "Member 'UTslCompassMarkerWidget::bShow' has a wrong offset!");

// Class TslGame.TslCompassWidget
// 0x00D8 (0x0350 - 0x0278)
class UTslCompassWidget : public UUmgBaseWidget
{
public:
	class UMaterialInterface*                     MI_Compass;                                        // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               MID_Compass;                                       // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Image                 CompassImageBinder;                                // 0x0288(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Image                 MarkerImageBinder;                                 // 0x02B0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Overlay               MyOverlayBinder;                                   // 0x02D8(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Overlay               TeamOverlayBinder;                                 // 0x02F8(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UTslCompassMarkerWidget>    CompassMarkerWidgetClass;                          // 0x0318(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTslCompassMarkerWidget*                MyCompassMarkerWidget;                             // 0x0320(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTslCompassMarkerWidget*>        TeamMarkerWidgetOfTeam;                            // 0x0328(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         DivisionLevel;                                     // 0x0338(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Offset;                                            // 0x033C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClockwise;                                        // 0x0340(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_341[0x3];                                      // 0x0341(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Width;                                             // 0x0344(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInitilzed;                                      // 0x0348(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_349[0x7];                                      // 0x0349(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslCompassWidget">();
	}
	static class UTslCompassWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslCompassWidget>();
	}
};
static_assert(alignof(UTslCompassWidget) == 0x000008, "Wrong alignment on UTslCompassWidget");
static_assert(sizeof(UTslCompassWidget) == 0x000350, "Wrong size on UTslCompassWidget");
static_assert(offsetof(UTslCompassWidget, MI_Compass) == 0x000278, "Member 'UTslCompassWidget::MI_Compass' has a wrong offset!");
static_assert(offsetof(UTslCompassWidget, MID_Compass) == 0x000280, "Member 'UTslCompassWidget::MID_Compass' has a wrong offset!");
static_assert(offsetof(UTslCompassWidget, CompassImageBinder) == 0x000288, "Member 'UTslCompassWidget::CompassImageBinder' has a wrong offset!");
static_assert(offsetof(UTslCompassWidget, MarkerImageBinder) == 0x0002B0, "Member 'UTslCompassWidget::MarkerImageBinder' has a wrong offset!");
static_assert(offsetof(UTslCompassWidget, MyOverlayBinder) == 0x0002D8, "Member 'UTslCompassWidget::MyOverlayBinder' has a wrong offset!");
static_assert(offsetof(UTslCompassWidget, TeamOverlayBinder) == 0x0002F8, "Member 'UTslCompassWidget::TeamOverlayBinder' has a wrong offset!");
static_assert(offsetof(UTslCompassWidget, CompassMarkerWidgetClass) == 0x000318, "Member 'UTslCompassWidget::CompassMarkerWidgetClass' has a wrong offset!");
static_assert(offsetof(UTslCompassWidget, MyCompassMarkerWidget) == 0x000320, "Member 'UTslCompassWidget::MyCompassMarkerWidget' has a wrong offset!");
static_assert(offsetof(UTslCompassWidget, TeamMarkerWidgetOfTeam) == 0x000328, "Member 'UTslCompassWidget::TeamMarkerWidgetOfTeam' has a wrong offset!");
static_assert(offsetof(UTslCompassWidget, DivisionLevel) == 0x000338, "Member 'UTslCompassWidget::DivisionLevel' has a wrong offset!");
static_assert(offsetof(UTslCompassWidget, Offset) == 0x00033C, "Member 'UTslCompassWidget::Offset' has a wrong offset!");
static_assert(offsetof(UTslCompassWidget, bClockwise) == 0x000340, "Member 'UTslCompassWidget::bClockwise' has a wrong offset!");
static_assert(offsetof(UTslCompassWidget, Width) == 0x000344, "Member 'UTslCompassWidget::Width' has a wrong offset!");
static_assert(offsetof(UTslCompassWidget, bIsInitilzed) == 0x000348, "Member 'UTslCompassWidget::bIsInitilzed' has a wrong offset!");

// Class TslGame.TslGroggyCircleWidget
// 0x0060 (0x02D8 - 0x0278)
class UTslGroggyCircleWidget : public UUmgBaseWidget
{
public:
	class UMaterialInstanceDynamic*               MID_ProgressCircle;                                // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     MI_ProgressCircle;                                 // 0x0280(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Image                 CircleImageBinder;                                 // 0x0288(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Image                 CrossImageBinder;                                  // 0x02B0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslGroggyCircleWidget">();
	}
	static class UTslGroggyCircleWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslGroggyCircleWidget>();
	}
};
static_assert(alignof(UTslGroggyCircleWidget) == 0x000008, "Wrong alignment on UTslGroggyCircleWidget");
static_assert(sizeof(UTslGroggyCircleWidget) == 0x0002D8, "Wrong size on UTslGroggyCircleWidget");
static_assert(offsetof(UTslGroggyCircleWidget, MID_ProgressCircle) == 0x000278, "Member 'UTslGroggyCircleWidget::MID_ProgressCircle' has a wrong offset!");
static_assert(offsetof(UTslGroggyCircleWidget, MI_ProgressCircle) == 0x000280, "Member 'UTslGroggyCircleWidget::MI_ProgressCircle' has a wrong offset!");
static_assert(offsetof(UTslGroggyCircleWidget, CircleImageBinder) == 0x000288, "Member 'UTslGroggyCircleWidget::CircleImageBinder' has a wrong offset!");
static_assert(offsetof(UTslGroggyCircleWidget, CrossImageBinder) == 0x0002B0, "Member 'UTslGroggyCircleWidget::CrossImageBinder' has a wrong offset!");

// Class TslGame.TslKeyReceiverWidget
// 0x00A0 (0x0318 - 0x0278)
class UTslKeyReceiverWidget : public UUmgBaseWidget
{
public:
	UMulticastDelegateProperty_                   OnKeyReceived;                                     // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	struct FTslInputKey                           OriginKey;                                         // 0x0288(0x0020)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FKey                                   FirstDownKey;                                      // 0x02A8(0x0018)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FTslInputKey                           CurrentDownKey;                                    // 0x02C0(0x0020)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FTslInputKey                           LastDownedKey;                                     // 0x02E0(0x0020)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          bFocused;                                          // 0x0300(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableInput;                                      // 0x0301(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsKeyUp;                                          // 0x0302(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAxisInput;                                        // 0x0303(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AxisScale;                                         // 0x0304(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FKey>                           MouseButtons;                                      // 0x0308(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void KeyDown(const struct FKey& InKey);
	void KeyUp(const struct FKey& InKey);
	void UpdateKeyDown(const struct FKey& InKey);
	void UpdateKeyUp(const struct FKey& InKey);

	class FText GetLastDownedKeyName() const;
	bool IsInputKeyDown() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslKeyReceiverWidget">();
	}
	static class UTslKeyReceiverWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslKeyReceiverWidget>();
	}
};
static_assert(alignof(UTslKeyReceiverWidget) == 0x000008, "Wrong alignment on UTslKeyReceiverWidget");
static_assert(sizeof(UTslKeyReceiverWidget) == 0x000318, "Wrong size on UTslKeyReceiverWidget");
static_assert(offsetof(UTslKeyReceiverWidget, OnKeyReceived) == 0x000278, "Member 'UTslKeyReceiverWidget::OnKeyReceived' has a wrong offset!");
static_assert(offsetof(UTslKeyReceiverWidget, OriginKey) == 0x000288, "Member 'UTslKeyReceiverWidget::OriginKey' has a wrong offset!");
static_assert(offsetof(UTslKeyReceiverWidget, FirstDownKey) == 0x0002A8, "Member 'UTslKeyReceiverWidget::FirstDownKey' has a wrong offset!");
static_assert(offsetof(UTslKeyReceiverWidget, CurrentDownKey) == 0x0002C0, "Member 'UTslKeyReceiverWidget::CurrentDownKey' has a wrong offset!");
static_assert(offsetof(UTslKeyReceiverWidget, LastDownedKey) == 0x0002E0, "Member 'UTslKeyReceiverWidget::LastDownedKey' has a wrong offset!");
static_assert(offsetof(UTslKeyReceiverWidget, bFocused) == 0x000300, "Member 'UTslKeyReceiverWidget::bFocused' has a wrong offset!");
static_assert(offsetof(UTslKeyReceiverWidget, bEnableInput) == 0x000301, "Member 'UTslKeyReceiverWidget::bEnableInput' has a wrong offset!");
static_assert(offsetof(UTslKeyReceiverWidget, bIsKeyUp) == 0x000302, "Member 'UTslKeyReceiverWidget::bIsKeyUp' has a wrong offset!");
static_assert(offsetof(UTslKeyReceiverWidget, bAxisInput) == 0x000303, "Member 'UTslKeyReceiverWidget::bAxisInput' has a wrong offset!");
static_assert(offsetof(UTslKeyReceiverWidget, AxisScale) == 0x000304, "Member 'UTslKeyReceiverWidget::AxisScale' has a wrong offset!");
static_assert(offsetof(UTslKeyReceiverWidget, MouseButtons) == 0x000308, "Member 'UTslKeyReceiverWidget::MouseButtons' has a wrong offset!");

// Class TslGame.TslTeamInfoListWidget
// 0x0038 (0x02B0 - 0x0278)
class UTslTeamInfoListWidget : public UUmgBaseWidget
{
public:
	TArray<class UTslTeamInfoWidget*>             TeamInfoWidgetList;                                // 0x0278(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UTslTeamInfoWidget>         TeamInfoWidgetClass;                               // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_VerticalBox           VerticalBoxBinder;                                 // 0x0290(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslTeamInfoListWidget">();
	}
	static class UTslTeamInfoListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslTeamInfoListWidget>();
	}
};
static_assert(alignof(UTslTeamInfoListWidget) == 0x000008, "Wrong alignment on UTslTeamInfoListWidget");
static_assert(sizeof(UTslTeamInfoListWidget) == 0x0002B0, "Wrong size on UTslTeamInfoListWidget");
static_assert(offsetof(UTslTeamInfoListWidget, TeamInfoWidgetList) == 0x000278, "Member 'UTslTeamInfoListWidget::TeamInfoWidgetList' has a wrong offset!");
static_assert(offsetof(UTslTeamInfoListWidget, TeamInfoWidgetClass) == 0x000288, "Member 'UTslTeamInfoListWidget::TeamInfoWidgetClass' has a wrong offset!");
static_assert(offsetof(UTslTeamInfoListWidget, VerticalBoxBinder) == 0x000290, "Member 'UTslTeamInfoListWidget::VerticalBoxBinder' has a wrong offset!");

// Class TslGame.TslTeamInfoWidget
// 0x0170 (0x03E8 - 0x0278)
class UTslTeamInfoWidget : public UUmgBaseWidget
{
public:
	bool                                          bBindVoiceChatEvent;                               // 0x0278(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpeaking;                                         // 0x0279(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27A[0x6];                                      // 0x027A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUmgWidgetBinder_Border                InfoIconBorderBinder;                              // 0x0280(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Image                 InfoIconBinder;                                    // 0x02A0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Image                 SpeakingImageBinder;                               // 0x02C8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Image                 MarkerImageBinder;                                 // 0x02F0(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Image                 BoostImageBinder;                                  // 0x0318(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bUdateTeamNameColor;                               // 0x0340(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_341[0x7];                                      // 0x0341(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUmgWidgetBinder_TextBlock             TeamNameBinder;                                    // 0x0348(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Animation             OnSpeakAnimBinder;                                 // 0x0368(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_UserWidget            HealthGaugeWidgetBinder;                           // 0x0388(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FColorBlindColorSet                    ColorBlindColorSet;                                // 0x03A8(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Image                 TeamMemberColorBinder;                             // 0x03B8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class ATeam*                                  Team;                                              // 0x03E0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BindVoiceChatIfNeed();
	void DecideTeamNameColor();
	void OnVoiceChat(bool InbSpeaking, float InMeterEnergy);
	void SetTeam(class ATeam* InTeam);
	void UpdateHealthGaugeAndVisibility();
	void UpdateTeamInfoIcon();
	void UpdateTeamMarker();
	void UpdateTeamMemberColor();
	void UpdateTeamMemberName();
	void UpdateVivoxChat(const class FString& UniqueId, bool bIsTeamChannel, bool InbSpeaking, float InMeterEnergy);
	void UpdateVoiceImage();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslTeamInfoWidget">();
	}
	static class UTslTeamInfoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslTeamInfoWidget>();
	}
};
static_assert(alignof(UTslTeamInfoWidget) == 0x000008, "Wrong alignment on UTslTeamInfoWidget");
static_assert(sizeof(UTslTeamInfoWidget) == 0x0003E8, "Wrong size on UTslTeamInfoWidget");
static_assert(offsetof(UTslTeamInfoWidget, bBindVoiceChatEvent) == 0x000278, "Member 'UTslTeamInfoWidget::bBindVoiceChatEvent' has a wrong offset!");
static_assert(offsetof(UTslTeamInfoWidget, bSpeaking) == 0x000279, "Member 'UTslTeamInfoWidget::bSpeaking' has a wrong offset!");
static_assert(offsetof(UTslTeamInfoWidget, InfoIconBorderBinder) == 0x000280, "Member 'UTslTeamInfoWidget::InfoIconBorderBinder' has a wrong offset!");
static_assert(offsetof(UTslTeamInfoWidget, InfoIconBinder) == 0x0002A0, "Member 'UTslTeamInfoWidget::InfoIconBinder' has a wrong offset!");
static_assert(offsetof(UTslTeamInfoWidget, SpeakingImageBinder) == 0x0002C8, "Member 'UTslTeamInfoWidget::SpeakingImageBinder' has a wrong offset!");
static_assert(offsetof(UTslTeamInfoWidget, MarkerImageBinder) == 0x0002F0, "Member 'UTslTeamInfoWidget::MarkerImageBinder' has a wrong offset!");
static_assert(offsetof(UTslTeamInfoWidget, BoostImageBinder) == 0x000318, "Member 'UTslTeamInfoWidget::BoostImageBinder' has a wrong offset!");
static_assert(offsetof(UTslTeamInfoWidget, bUdateTeamNameColor) == 0x000340, "Member 'UTslTeamInfoWidget::bUdateTeamNameColor' has a wrong offset!");
static_assert(offsetof(UTslTeamInfoWidget, TeamNameBinder) == 0x000348, "Member 'UTslTeamInfoWidget::TeamNameBinder' has a wrong offset!");
static_assert(offsetof(UTslTeamInfoWidget, OnSpeakAnimBinder) == 0x000368, "Member 'UTslTeamInfoWidget::OnSpeakAnimBinder' has a wrong offset!");
static_assert(offsetof(UTslTeamInfoWidget, HealthGaugeWidgetBinder) == 0x000388, "Member 'UTslTeamInfoWidget::HealthGaugeWidgetBinder' has a wrong offset!");
static_assert(offsetof(UTslTeamInfoWidget, ColorBlindColorSet) == 0x0003A8, "Member 'UTslTeamInfoWidget::ColorBlindColorSet' has a wrong offset!");
static_assert(offsetof(UTslTeamInfoWidget, TeamMemberColorBinder) == 0x0003B8, "Member 'UTslTeamInfoWidget::TeamMemberColorBinder' has a wrong offset!");
static_assert(offsetof(UTslTeamInfoWidget, Team) == 0x0003E0, "Member 'UTslTeamInfoWidget::Team' has a wrong offset!");

// Class TslGame.VehicleFuelBaseWidget
// 0x00C0 (0x0338 - 0x0278)
class UVehicleFuelBaseWidget : public UUmgBaseWidget
{
public:
	struct FUmgWidgetBinder_Image                 OilGaugeImageBinder;                               // 0x0278(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Image                 OilGaugeBgImageBinder;                             // 0x02A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Image                 OilArrowImageBinder;                               // 0x02C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Overlay               GaugeBodyBinder;                                   // 0x02F0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           NormalColor;                                       // 0x0310(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           FuelEmptyColor;                                    // 0x0320(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   GaugePramName;                                     // 0x0330(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleFuelBaseWidget">();
	}
	static class UVehicleFuelBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleFuelBaseWidget>();
	}
};
static_assert(alignof(UVehicleFuelBaseWidget) == 0x000008, "Wrong alignment on UVehicleFuelBaseWidget");
static_assert(sizeof(UVehicleFuelBaseWidget) == 0x000338, "Wrong size on UVehicleFuelBaseWidget");
static_assert(offsetof(UVehicleFuelBaseWidget, OilGaugeImageBinder) == 0x000278, "Member 'UVehicleFuelBaseWidget::OilGaugeImageBinder' has a wrong offset!");
static_assert(offsetof(UVehicleFuelBaseWidget, OilGaugeBgImageBinder) == 0x0002A0, "Member 'UVehicleFuelBaseWidget::OilGaugeBgImageBinder' has a wrong offset!");
static_assert(offsetof(UVehicleFuelBaseWidget, OilArrowImageBinder) == 0x0002C8, "Member 'UVehicleFuelBaseWidget::OilArrowImageBinder' has a wrong offset!");
static_assert(offsetof(UVehicleFuelBaseWidget, GaugeBodyBinder) == 0x0002F0, "Member 'UVehicleFuelBaseWidget::GaugeBodyBinder' has a wrong offset!");
static_assert(offsetof(UVehicleFuelBaseWidget, NormalColor) == 0x000310, "Member 'UVehicleFuelBaseWidget::NormalColor' has a wrong offset!");
static_assert(offsetof(UVehicleFuelBaseWidget, FuelEmptyColor) == 0x000320, "Member 'UVehicleFuelBaseWidget::FuelEmptyColor' has a wrong offset!");
static_assert(offsetof(UVehicleFuelBaseWidget, GaugePramName) == 0x000330, "Member 'UVehicleFuelBaseWidget::GaugePramName' has a wrong offset!");

// Class TslGame.VehicleSeatInfoBaseWidget
// 0x0048 (0x02C0 - 0x0278)
class UVehicleSeatInfoBaseWidget : public UUmgBaseWidget
{
public:
	int32                                         SeatIndex;                                         // 0x0278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StateParamName;                                    // 0x0280(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_Image                 SeatImageBinder;                                   // 0x0288(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class APawn*                                  CachedVehiclePawn;                                 // 0x02B0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTslVehicleSeatComponent*               CachedSeatComponent;                               // 0x02B8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleSeatInfoBaseWidget">();
	}
	static class UVehicleSeatInfoBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleSeatInfoBaseWidget>();
	}
};
static_assert(alignof(UVehicleSeatInfoBaseWidget) == 0x000008, "Wrong alignment on UVehicleSeatInfoBaseWidget");
static_assert(sizeof(UVehicleSeatInfoBaseWidget) == 0x0002C0, "Wrong size on UVehicleSeatInfoBaseWidget");
static_assert(offsetof(UVehicleSeatInfoBaseWidget, SeatIndex) == 0x000278, "Member 'UVehicleSeatInfoBaseWidget::SeatIndex' has a wrong offset!");
static_assert(offsetof(UVehicleSeatInfoBaseWidget, StateParamName) == 0x000280, "Member 'UVehicleSeatInfoBaseWidget::StateParamName' has a wrong offset!");
static_assert(offsetof(UVehicleSeatInfoBaseWidget, SeatImageBinder) == 0x000288, "Member 'UVehicleSeatInfoBaseWidget::SeatImageBinder' has a wrong offset!");
static_assert(offsetof(UVehicleSeatInfoBaseWidget, CachedVehiclePawn) == 0x0002B0, "Member 'UVehicleSeatInfoBaseWidget::CachedVehiclePawn' has a wrong offset!");
static_assert(offsetof(UVehicleSeatInfoBaseWidget, CachedSeatComponent) == 0x0002B8, "Member 'UVehicleSeatInfoBaseWidget::CachedSeatComponent' has a wrong offset!");

// Class TslGame.VehicleStanceBaseWidget
// 0x0090 (0x0308 - 0x0278)
class UVehicleStanceBaseWidget : public UUmgBaseWidget
{
public:
	struct FUmgWidgetBinder_VerticalBox           VehicleIconAreaBinder;                             // 0x0278(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_TextBlock             SpeedTextBinder;                                   // 0x0298(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_UserWidget            LifeGaugeWidgetBinder;                             // 0x02B8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_UserWidget            FuelGaugeWidgetBinder;                             // 0x02D8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class APawn*                                  CachedVehiclePawn;                                 // 0x02F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            CachedVehicleIconWidget;                           // 0x0300(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleStanceBaseWidget">();
	}
	static class UVehicleStanceBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleStanceBaseWidget>();
	}
};
static_assert(alignof(UVehicleStanceBaseWidget) == 0x000008, "Wrong alignment on UVehicleStanceBaseWidget");
static_assert(sizeof(UVehicleStanceBaseWidget) == 0x000308, "Wrong size on UVehicleStanceBaseWidget");
static_assert(offsetof(UVehicleStanceBaseWidget, VehicleIconAreaBinder) == 0x000278, "Member 'UVehicleStanceBaseWidget::VehicleIconAreaBinder' has a wrong offset!");
static_assert(offsetof(UVehicleStanceBaseWidget, SpeedTextBinder) == 0x000298, "Member 'UVehicleStanceBaseWidget::SpeedTextBinder' has a wrong offset!");
static_assert(offsetof(UVehicleStanceBaseWidget, LifeGaugeWidgetBinder) == 0x0002B8, "Member 'UVehicleStanceBaseWidget::LifeGaugeWidgetBinder' has a wrong offset!");
static_assert(offsetof(UVehicleStanceBaseWidget, FuelGaugeWidgetBinder) == 0x0002D8, "Member 'UVehicleStanceBaseWidget::FuelGaugeWidgetBinder' has a wrong offset!");
static_assert(offsetof(UVehicleStanceBaseWidget, CachedVehiclePawn) == 0x0002F8, "Member 'UVehicleStanceBaseWidget::CachedVehiclePawn' has a wrong offset!");
static_assert(offsetof(UVehicleStanceBaseWidget, CachedVehicleIconWidget) == 0x000300, "Member 'UVehicleStanceBaseWidget::CachedVehicleIconWidget' has a wrong offset!");

// Class TslGame.VersionInfoBaseWidget
// 0x0050 (0x02C8 - 0x0278)
class UVersionInfoBaseWidget : public UUmgBaseWidget
{
public:
	class FText                                   WithNickNameFormat;                                // 0x0278(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   WithOutNickNameFormat;                             // 0x0290(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FUmgWidgetBinder_TextBlock             VersionInfoTextBinder;                             // 0x02A8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VersionInfoBaseWidget">();
	}
	static class UVersionInfoBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVersionInfoBaseWidget>();
	}
};
static_assert(alignof(UVersionInfoBaseWidget) == 0x000008, "Wrong alignment on UVersionInfoBaseWidget");
static_assert(sizeof(UVersionInfoBaseWidget) == 0x0002C8, "Wrong size on UVersionInfoBaseWidget");
static_assert(offsetof(UVersionInfoBaseWidget, WithNickNameFormat) == 0x000278, "Member 'UVersionInfoBaseWidget::WithNickNameFormat' has a wrong offset!");
static_assert(offsetof(UVersionInfoBaseWidget, WithOutNickNameFormat) == 0x000290, "Member 'UVersionInfoBaseWidget::WithOutNickNameFormat' has a wrong offset!");
static_assert(offsetof(UVersionInfoBaseWidget, VersionInfoTextBinder) == 0x0002A8, "Member 'UVersionInfoBaseWidget::VersionInfoTextBinder' has a wrong offset!");

// Class TslGame.WeaponSlotHudBaseWidget
// 0x01F8 (0x0470 - 0x0278)
class UWeaponSlotHudBaseWidget : public UUmgBaseWidget
{
public:
	struct FUmgWidgetBinder_UserWidget            CurrentWeaponSlotWidgetBinder;                     // 0x0278(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Animation             FadeInWeaponSlotAnimBinder;                        // 0x0298(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Animation             FadeOutWeaponSlotAnimBinder;                       // 0x02B8(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Animation             FadeInUnarmedWeaponSlotAminBinder;                 // 0x02D8(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Animation             FadeOutUnarmedWeaponSlotAminBinder;                // 0x02F8(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FUmgWidgetBinder_UserWidget>    WeaponSlotWidgetBinderList;                        // 0x0318(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Border                WeaponSlotListBorderBinder;                        // 0x0328(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Animation             FadeInSlotListAminBinder;                          // 0x0348(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FUmgWidgetBinder_Animation             FadeOutSlotListAminBinder;                         // 0x0368(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         SlotOffsetMultiply;                                // 0x0388(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlotPadding;                                       // 0x038C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSequence_Float                        MovingSequence;                                    // 0x0390(0x00A0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_430[0x30];                                     // 0x0430(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           FinishTimer;                                       // 0x0460(0x0008)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_468[0x8];                                      // 0x0468(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMovingFinished();
	void OnMovingStarted();
	void OnNotifyWeaponArmed();
	void OnNotifyWeaponChange(int32 WeaponIndex, float Duration);
	void OnNotifyWeaponUnarm(bool bIsUnarmed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponSlotHudBaseWidget">();
	}
	static class UWeaponSlotHudBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponSlotHudBaseWidget>();
	}
};
static_assert(alignof(UWeaponSlotHudBaseWidget) == 0x000008, "Wrong alignment on UWeaponSlotHudBaseWidget");
static_assert(sizeof(UWeaponSlotHudBaseWidget) == 0x000470, "Wrong size on UWeaponSlotHudBaseWidget");
static_assert(offsetof(UWeaponSlotHudBaseWidget, CurrentWeaponSlotWidgetBinder) == 0x000278, "Member 'UWeaponSlotHudBaseWidget::CurrentWeaponSlotWidgetBinder' has a wrong offset!");
static_assert(offsetof(UWeaponSlotHudBaseWidget, FadeInWeaponSlotAnimBinder) == 0x000298, "Member 'UWeaponSlotHudBaseWidget::FadeInWeaponSlotAnimBinder' has a wrong offset!");
static_assert(offsetof(UWeaponSlotHudBaseWidget, FadeOutWeaponSlotAnimBinder) == 0x0002B8, "Member 'UWeaponSlotHudBaseWidget::FadeOutWeaponSlotAnimBinder' has a wrong offset!");
static_assert(offsetof(UWeaponSlotHudBaseWidget, FadeInUnarmedWeaponSlotAminBinder) == 0x0002D8, "Member 'UWeaponSlotHudBaseWidget::FadeInUnarmedWeaponSlotAminBinder' has a wrong offset!");
static_assert(offsetof(UWeaponSlotHudBaseWidget, FadeOutUnarmedWeaponSlotAminBinder) == 0x0002F8, "Member 'UWeaponSlotHudBaseWidget::FadeOutUnarmedWeaponSlotAminBinder' has a wrong offset!");
static_assert(offsetof(UWeaponSlotHudBaseWidget, WeaponSlotWidgetBinderList) == 0x000318, "Member 'UWeaponSlotHudBaseWidget::WeaponSlotWidgetBinderList' has a wrong offset!");
static_assert(offsetof(UWeaponSlotHudBaseWidget, WeaponSlotListBorderBinder) == 0x000328, "Member 'UWeaponSlotHudBaseWidget::WeaponSlotListBorderBinder' has a wrong offset!");
static_assert(offsetof(UWeaponSlotHudBaseWidget, FadeInSlotListAminBinder) == 0x000348, "Member 'UWeaponSlotHudBaseWidget::FadeInSlotListAminBinder' has a wrong offset!");
static_assert(offsetof(UWeaponSlotHudBaseWidget, FadeOutSlotListAminBinder) == 0x000368, "Member 'UWeaponSlotHudBaseWidget::FadeOutSlotListAminBinder' has a wrong offset!");
static_assert(offsetof(UWeaponSlotHudBaseWidget, SlotOffsetMultiply) == 0x000388, "Member 'UWeaponSlotHudBaseWidget::SlotOffsetMultiply' has a wrong offset!");
static_assert(offsetof(UWeaponSlotHudBaseWidget, SlotPadding) == 0x00038C, "Member 'UWeaponSlotHudBaseWidget::SlotPadding' has a wrong offset!");
static_assert(offsetof(UWeaponSlotHudBaseWidget, MovingSequence) == 0x000390, "Member 'UWeaponSlotHudBaseWidget::MovingSequence' has a wrong offset!");
static_assert(offsetof(UWeaponSlotHudBaseWidget, FinishTimer) == 0x000460, "Member 'UWeaponSlotHudBaseWidget::FinishTimer' has a wrong offset!");

// Class TslGame.VehicleSurfaceAudioData
// 0x0010 (0x0038 - 0x0028)
class UVehicleSurfaceAudioData final : public UDataAsset
{
public:
	class UAkAudioEvent*                          EventIn;                                           // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          EventOut;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleSurfaceAudioData">();
	}
	static class UVehicleSurfaceAudioData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleSurfaceAudioData>();
	}
};
static_assert(alignof(UVehicleSurfaceAudioData) == 0x000008, "Wrong alignment on UVehicleSurfaceAudioData");
static_assert(sizeof(UVehicleSurfaceAudioData) == 0x000038, "Wrong size on UVehicleSurfaceAudioData");
static_assert(offsetof(UVehicleSurfaceAudioData, EventIn) == 0x000028, "Member 'UVehicleSurfaceAudioData::EventIn' has a wrong offset!");
static_assert(offsetof(UVehicleSurfaceAudioData, EventOut) == 0x000030, "Member 'UVehicleSurfaceAudioData::EventOut' has a wrong offset!");

// Class TslGame.TslVehicleHitComponent
// 0x0130 (0x0228 - 0x00F8)
class UTslVehicleHitComponent final : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   OnCharacterHit;                                    // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	class UMeshComponent*                         MeshComponent;                                     // 0x0108(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         HitCharacterDuration;                              // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_114[0x54];                                     // 0x0114(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeaveCharacterIgnoreDuration;                      // 0x0168(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CharacterHitMinimumVehicleSpeed;                   // 0x016C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CharacterDamageVelocityUnitMultiplier;             // 0x0170(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CharacterDamageMassUnitMultiplier;                 // 0x0174(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            CharacterDamageSpeedCurve;                         // 0x0178(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            CharacterDamageMassCurve;                          // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinimumCharacterDamage;                            // 0x0188(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CharacterLaunchSpeedMultiplier;                    // 0x018C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MinimumCharacterLaunchSpeed;                       // 0x0190(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PhysicsImpulseMultiplier;                          // 0x0194(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPhysicalMaterial*                      VoidPhysicalMaterial;                              // 0x0198(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PhysicsImpactModifier;                             // 0x01A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PhysicsImpactModifierUpsideDown;                   // 0x01A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PhysicsImpactAbsorption;                           // 0x01A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PhysicsImpactAbsorptionUpsideDown;                 // 0x01AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PhysicsImpactAbsorptionRider;                      // 0x01B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PhysicsImpactAbsorptionRiderUpsideDown;            // 0x01B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PhysicsImpactVehicleDamageMultiplier;              // 0x01B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PhysicsImpactRiderDamageMultiplier;                // 0x01BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UDamageType>                VehicleHitDamageType;                              // 0x01C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C8[0x4];                                      // 0x01C8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExplosionBaseDamage;                               // 0x01CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ExplosionMinimumDamage;                            // 0x01D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ExplosionRadiusInner;                              // 0x01D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ExplosionRadiusOuter;                              // 0x01D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ExplosionDamageFalloff;                            // 0x01DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UDamageType>                ExplosionDamageType;                               // 0x01E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECollisionChannel                             ExplosionDamagePreventionChannel;                  // 0x01E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E9[0xF];                                      // 0x01E9(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ImpulseLimitationSpeedThreshold;                   // 0x01F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CollectTime;                                       // 0x01FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_200[0x10];                                     // 0x0200(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVehicleDebugHit>               DebugHitHistory;                                   // 0x0210(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDeath(float KillingDamage, const struct FDamageEvent& DamageEvent, class ATslPlayerState* PlayerInstigator, class AActor* DamageCauser);
	void OnHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnSyncHit(const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslVehicleHitComponent">();
	}
	static class UTslVehicleHitComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslVehicleHitComponent>();
	}
};
static_assert(alignof(UTslVehicleHitComponent) == 0x000008, "Wrong alignment on UTslVehicleHitComponent");
static_assert(sizeof(UTslVehicleHitComponent) == 0x000228, "Wrong size on UTslVehicleHitComponent");
static_assert(offsetof(UTslVehicleHitComponent, OnCharacterHit) == 0x0000F8, "Member 'UTslVehicleHitComponent::OnCharacterHit' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, MeshComponent) == 0x000108, "Member 'UTslVehicleHitComponent::MeshComponent' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, HitCharacterDuration) == 0x000110, "Member 'UTslVehicleHitComponent::HitCharacterDuration' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, LeaveCharacterIgnoreDuration) == 0x000168, "Member 'UTslVehicleHitComponent::LeaveCharacterIgnoreDuration' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, CharacterHitMinimumVehicleSpeed) == 0x00016C, "Member 'UTslVehicleHitComponent::CharacterHitMinimumVehicleSpeed' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, CharacterDamageVelocityUnitMultiplier) == 0x000170, "Member 'UTslVehicleHitComponent::CharacterDamageVelocityUnitMultiplier' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, CharacterDamageMassUnitMultiplier) == 0x000174, "Member 'UTslVehicleHitComponent::CharacterDamageMassUnitMultiplier' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, CharacterDamageSpeedCurve) == 0x000178, "Member 'UTslVehicleHitComponent::CharacterDamageSpeedCurve' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, CharacterDamageMassCurve) == 0x000180, "Member 'UTslVehicleHitComponent::CharacterDamageMassCurve' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, MinimumCharacterDamage) == 0x000188, "Member 'UTslVehicleHitComponent::MinimumCharacterDamage' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, CharacterLaunchSpeedMultiplier) == 0x00018C, "Member 'UTslVehicleHitComponent::CharacterLaunchSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, MinimumCharacterLaunchSpeed) == 0x000190, "Member 'UTslVehicleHitComponent::MinimumCharacterLaunchSpeed' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, PhysicsImpulseMultiplier) == 0x000194, "Member 'UTslVehicleHitComponent::PhysicsImpulseMultiplier' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, VoidPhysicalMaterial) == 0x000198, "Member 'UTslVehicleHitComponent::VoidPhysicalMaterial' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, PhysicsImpactModifier) == 0x0001A0, "Member 'UTslVehicleHitComponent::PhysicsImpactModifier' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, PhysicsImpactModifierUpsideDown) == 0x0001A4, "Member 'UTslVehicleHitComponent::PhysicsImpactModifierUpsideDown' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, PhysicsImpactAbsorption) == 0x0001A8, "Member 'UTslVehicleHitComponent::PhysicsImpactAbsorption' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, PhysicsImpactAbsorptionUpsideDown) == 0x0001AC, "Member 'UTslVehicleHitComponent::PhysicsImpactAbsorptionUpsideDown' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, PhysicsImpactAbsorptionRider) == 0x0001B0, "Member 'UTslVehicleHitComponent::PhysicsImpactAbsorptionRider' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, PhysicsImpactAbsorptionRiderUpsideDown) == 0x0001B4, "Member 'UTslVehicleHitComponent::PhysicsImpactAbsorptionRiderUpsideDown' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, PhysicsImpactVehicleDamageMultiplier) == 0x0001B8, "Member 'UTslVehicleHitComponent::PhysicsImpactVehicleDamageMultiplier' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, PhysicsImpactRiderDamageMultiplier) == 0x0001BC, "Member 'UTslVehicleHitComponent::PhysicsImpactRiderDamageMultiplier' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, VehicleHitDamageType) == 0x0001C0, "Member 'UTslVehicleHitComponent::VehicleHitDamageType' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, ExplosionBaseDamage) == 0x0001CC, "Member 'UTslVehicleHitComponent::ExplosionBaseDamage' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, ExplosionMinimumDamage) == 0x0001D0, "Member 'UTslVehicleHitComponent::ExplosionMinimumDamage' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, ExplosionRadiusInner) == 0x0001D4, "Member 'UTslVehicleHitComponent::ExplosionRadiusInner' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, ExplosionRadiusOuter) == 0x0001D8, "Member 'UTslVehicleHitComponent::ExplosionRadiusOuter' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, ExplosionDamageFalloff) == 0x0001DC, "Member 'UTslVehicleHitComponent::ExplosionDamageFalloff' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, ExplosionDamageType) == 0x0001E0, "Member 'UTslVehicleHitComponent::ExplosionDamageType' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, ExplosionDamagePreventionChannel) == 0x0001E8, "Member 'UTslVehicleHitComponent::ExplosionDamagePreventionChannel' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, ImpulseLimitationSpeedThreshold) == 0x0001F8, "Member 'UTslVehicleHitComponent::ImpulseLimitationSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, CollectTime) == 0x0001FC, "Member 'UTslVehicleHitComponent::CollectTime' has a wrong offset!");
static_assert(offsetof(UTslVehicleHitComponent, DebugHitHistory) == 0x000210, "Member 'UTslVehicleHitComponent::DebugHitHistory' has a wrong offset!");

// Class TslGame.TslVehicleSeatComponent
// 0x0100 (0x01F8 - 0x00F8)
class UTslVehicleSeatComponent final : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   OnRide;                                            // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnLeave;                                           // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDriverRide;                                      // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDriverLeave;                                     // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPostDriverRide;                                  // 0x0138(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPostDriverLeave;                                 // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FVehicleSeatInfo>               SeatInfos;                                         // 0x0158(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UVehicleSeatInteractionComponent*> Seats;                                             // 0x0168(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          bUseSeatCamera;                                    // 0x0178(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDoFlipCheck;                                      // 0x0179(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_17A[0x2];                                      // 0x017A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FlipForce;                                         // 0x017C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDoEntryAngleCheck;                                // 0x0180(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_181[0x3];                                      // 0x0181(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinEntryAngle;                                     // 0x0184(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDampenPlayerVelocityOnLeave;                      // 0x0188(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_189[0x3];                                      // 0x0189(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OnLeaveVelocityMultiplier;                         // 0x018C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseActiveStabilize;                               // 0x0190(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_191[0x3];                                      // 0x0191(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class ATslCharacter>           LastDriver;                                        // 0x0194(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_19C[0x5C];                                     // 0x019C(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void KillAllRiders(float KillingDamage, const struct FDamageEvent& DamageEvent, class ATslPlayerState* PlayerInstigator, class AActor* DamageCauser);
	void Leave(class ATslCharacter* Rider, class UVehicleSeatInteractionComponent* Seat, bool bForce);
	void OnFuelChange(float CurrentFuel, float LastFuel, float FuelMax);
	void PostDriverLeave();
	void PostDriverRide();
	void Ride(class ATslCharacter* Rider, class UVehicleSeatInteractionComponent* Seat);
	void TryToFlip();
	void TryToLeave(class ATslCharacter* Rider, bool bForce);
	void TryToRide(class ATslCharacter* Rider, class UVehicleSeatInteractionComponent* Seat);
	void TryToStabilize();

	class ATslCharacter* GetDriver() const;
	class ATslCharacter* GetLastDriver(float LastDuration) const;
	TArray<class ATslCharacter*> GetRiders() const;
	class UVehicleSeatInteractionComponent* GetSeat(int32 SeatIndex) const;
	TArray<class UVehicleSeatInteractionComponent*> GetSeats() const;
	int32 GetVehicleSeatIndex(class UVehicleSeatInteractionComponent* Seat) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslVehicleSeatComponent">();
	}
	static class UTslVehicleSeatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslVehicleSeatComponent>();
	}
};
static_assert(alignof(UTslVehicleSeatComponent) == 0x000008, "Wrong alignment on UTslVehicleSeatComponent");
static_assert(sizeof(UTslVehicleSeatComponent) == 0x0001F8, "Wrong size on UTslVehicleSeatComponent");
static_assert(offsetof(UTslVehicleSeatComponent, OnRide) == 0x0000F8, "Member 'UTslVehicleSeatComponent::OnRide' has a wrong offset!");
static_assert(offsetof(UTslVehicleSeatComponent, OnLeave) == 0x000108, "Member 'UTslVehicleSeatComponent::OnLeave' has a wrong offset!");
static_assert(offsetof(UTslVehicleSeatComponent, OnDriverRide) == 0x000118, "Member 'UTslVehicleSeatComponent::OnDriverRide' has a wrong offset!");
static_assert(offsetof(UTslVehicleSeatComponent, OnDriverLeave) == 0x000128, "Member 'UTslVehicleSeatComponent::OnDriverLeave' has a wrong offset!");
static_assert(offsetof(UTslVehicleSeatComponent, OnPostDriverRide) == 0x000138, "Member 'UTslVehicleSeatComponent::OnPostDriverRide' has a wrong offset!");
static_assert(offsetof(UTslVehicleSeatComponent, OnPostDriverLeave) == 0x000148, "Member 'UTslVehicleSeatComponent::OnPostDriverLeave' has a wrong offset!");
static_assert(offsetof(UTslVehicleSeatComponent, SeatInfos) == 0x000158, "Member 'UTslVehicleSeatComponent::SeatInfos' has a wrong offset!");
static_assert(offsetof(UTslVehicleSeatComponent, Seats) == 0x000168, "Member 'UTslVehicleSeatComponent::Seats' has a wrong offset!");
static_assert(offsetof(UTslVehicleSeatComponent, bUseSeatCamera) == 0x000178, "Member 'UTslVehicleSeatComponent::bUseSeatCamera' has a wrong offset!");
static_assert(offsetof(UTslVehicleSeatComponent, bDoFlipCheck) == 0x000179, "Member 'UTslVehicleSeatComponent::bDoFlipCheck' has a wrong offset!");
static_assert(offsetof(UTslVehicleSeatComponent, FlipForce) == 0x00017C, "Member 'UTslVehicleSeatComponent::FlipForce' has a wrong offset!");
static_assert(offsetof(UTslVehicleSeatComponent, bDoEntryAngleCheck) == 0x000180, "Member 'UTslVehicleSeatComponent::bDoEntryAngleCheck' has a wrong offset!");
static_assert(offsetof(UTslVehicleSeatComponent, MinEntryAngle) == 0x000184, "Member 'UTslVehicleSeatComponent::MinEntryAngle' has a wrong offset!");
static_assert(offsetof(UTslVehicleSeatComponent, bDampenPlayerVelocityOnLeave) == 0x000188, "Member 'UTslVehicleSeatComponent::bDampenPlayerVelocityOnLeave' has a wrong offset!");
static_assert(offsetof(UTslVehicleSeatComponent, OnLeaveVelocityMultiplier) == 0x00018C, "Member 'UTslVehicleSeatComponent::OnLeaveVelocityMultiplier' has a wrong offset!");
static_assert(offsetof(UTslVehicleSeatComponent, bUseActiveStabilize) == 0x000190, "Member 'UTslVehicleSeatComponent::bUseActiveStabilize' has a wrong offset!");
static_assert(offsetof(UTslVehicleSeatComponent, LastDriver) == 0x000194, "Member 'UTslVehicleSeatComponent::LastDriver' has a wrong offset!");

// Class TslGame.TslVehicleTempComponent
// 0x0008 (0x0100 - 0x00F8)
class UTslVehicleTempComponent final : public UActorComponent
{
public:
	float                                         TickInterval;                                      // 0x00F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslVehicleTempComponent">();
	}
	static class UTslVehicleTempComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslVehicleTempComponent>();
	}
};
static_assert(alignof(UTslVehicleTempComponent) == 0x000008, "Wrong alignment on UTslVehicleTempComponent");
static_assert(sizeof(UTslVehicleTempComponent) == 0x000100, "Wrong size on UTslVehicleTempComponent");
static_assert(offsetof(UTslVehicleTempComponent, TickInterval) == 0x0000F8, "Member 'UTslVehicleTempComponent::TickInterval' has a wrong offset!");

// Class TslGame.TslWeapon_Trajectory
// 0x0180 (0x0B78 - 0x09F8)
class ATslWeapon_Trajectory final : public ATslWeapon_Gun
{
public:
	float                                         TrajectoryGravityZ;                                // 0x09F8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoilSpreadScale;                                 // 0x09FC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FireAtViewPoint;                                   // 0x0A00(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A01[0x3];                                      // 0x0A01(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultTimerFrequency;                             // 0x0A04(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CrouchSpreadModifier;                              // 0x0A08(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProneSpreadModifier;                               // 0x0A0C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WalkSpread;                                        // 0x0A10(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RunSpread;                                         // 0x0A14(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpSpread;                                        // 0x0A18(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1C[0x4];                                      // 0x0A1C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTrajectoryWeaponData                  TrajectoryConfig;                                  // 0x0A20(0x0060)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FRecoilInfo                            RecoilInfo;                                        // 0x0A80(0x0068)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class ATslImpactEffect>           ImpactTemplate;                                    // 0x0AE8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        TrailFX;                                           // 0x0AF0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TrailTargetParam;                                  // 0x0AF8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B00[0x18];                                     // 0x0B00(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponSpread;                                      // 0x0B18(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoilModifier_Stand;                              // 0x0B1C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoilModifier_Crouch;                             // 0x0B20(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoilModifier_Prone;                              // 0x0B24(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VerticalRecoilMin;                                 // 0x0B28(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VerticalRecoilMax;                                 // 0x0B2C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B30[0x48];                                     // 0x0B30(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_WeaponSpread(float LastWeaponSpread);
	void ServerNotifyCrack(class ATslCharacter* TargetCharacter, const struct FVector_NetQuantize& LocationRelative, float BulletVelocity);
	void ServerNotifyHit(const struct FHitResult& Impact, const struct FVector_NetQuantize& Origin, const struct FVector& TraceStart, const struct FVector& PreLocation, const struct FVector_NetQuantizeNormal& ShootDir, float TravelDistance, const struct FAttackId& AttackId, uint32 HitSeq, const struct FVector& RelLocation);
	void SimulateHit_Reliable(const struct FHitResult& Impact, const struct FVector& RelLocation);
	void SimulateHit_UnReliable(const struct FHitResult& Impact, const struct FVector& RelLocation);

	struct FVector GetBulletLocation() const;
	struct FRotator GetBulletRotation() const;
	struct FVector2D GetCurrentRecoilTarget() const;
	float GetCurrentRecoilValue() const;
	float GetCurrentReoveryTarget() const;
	float GetCurrentStabilityVar() const;
	struct FRecoilInfo GetRecoilInfo() const;
	struct FTrajectoryWeaponData GetTrajectoryConfig() const;
	bool IsBulletInAir() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslWeapon_Trajectory">();
	}
	static class ATslWeapon_Trajectory* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslWeapon_Trajectory>();
	}
};
static_assert(alignof(ATslWeapon_Trajectory) == 0x000008, "Wrong alignment on ATslWeapon_Trajectory");
static_assert(sizeof(ATslWeapon_Trajectory) == 0x000B78, "Wrong size on ATslWeapon_Trajectory");
static_assert(offsetof(ATslWeapon_Trajectory, TrajectoryGravityZ) == 0x0009F8, "Member 'ATslWeapon_Trajectory::TrajectoryGravityZ' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Trajectory, RecoilSpreadScale) == 0x0009FC, "Member 'ATslWeapon_Trajectory::RecoilSpreadScale' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Trajectory, FireAtViewPoint) == 0x000A00, "Member 'ATslWeapon_Trajectory::FireAtViewPoint' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Trajectory, DefaultTimerFrequency) == 0x000A04, "Member 'ATslWeapon_Trajectory::DefaultTimerFrequency' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Trajectory, CrouchSpreadModifier) == 0x000A08, "Member 'ATslWeapon_Trajectory::CrouchSpreadModifier' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Trajectory, ProneSpreadModifier) == 0x000A0C, "Member 'ATslWeapon_Trajectory::ProneSpreadModifier' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Trajectory, WalkSpread) == 0x000A10, "Member 'ATslWeapon_Trajectory::WalkSpread' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Trajectory, RunSpread) == 0x000A14, "Member 'ATslWeapon_Trajectory::RunSpread' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Trajectory, JumpSpread) == 0x000A18, "Member 'ATslWeapon_Trajectory::JumpSpread' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Trajectory, TrajectoryConfig) == 0x000A20, "Member 'ATslWeapon_Trajectory::TrajectoryConfig' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Trajectory, RecoilInfo) == 0x000A80, "Member 'ATslWeapon_Trajectory::RecoilInfo' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Trajectory, ImpactTemplate) == 0x000AE8, "Member 'ATslWeapon_Trajectory::ImpactTemplate' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Trajectory, TrailFX) == 0x000AF0, "Member 'ATslWeapon_Trajectory::TrailFX' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Trajectory, TrailTargetParam) == 0x000AF8, "Member 'ATslWeapon_Trajectory::TrailTargetParam' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Trajectory, WeaponSpread) == 0x000B18, "Member 'ATslWeapon_Trajectory::WeaponSpread' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Trajectory, RecoilModifier_Stand) == 0x000B1C, "Member 'ATslWeapon_Trajectory::RecoilModifier_Stand' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Trajectory, RecoilModifier_Crouch) == 0x000B20, "Member 'ATslWeapon_Trajectory::RecoilModifier_Crouch' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Trajectory, RecoilModifier_Prone) == 0x000B24, "Member 'ATslWeapon_Trajectory::RecoilModifier_Prone' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Trajectory, VerticalRecoilMin) == 0x000B28, "Member 'ATslWeapon_Trajectory::VerticalRecoilMin' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Trajectory, VerticalRecoilMax) == 0x000B2C, "Member 'ATslWeapon_Trajectory::VerticalRecoilMax' has a wrong offset!");

// Class TslGame.TslWeapon_Melee
// 0x00B8 (0x0860 - 0x07A8)
class ATslWeapon_Melee final : public ATslWeapon
{
public:
	class UAkAudioEvent*                          AttackSoundAk;                                     // 0x07A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FMeleeWeaponAnim>               AttackAnims;                                       // 0x07B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	float                                         Damage;                                            // 0x07C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         WeaponImpact;                                      // 0x07C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x07C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EHitCheckType                                 HitCheckType;                                      // 0x07D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7D1[0x3];                                      // 0x07D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AllowedHitRangeLeeway;                             // 0x07D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class ATslImpactEffect>           ImpactTemplate;                                    // 0x07D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCapsuleComponent*                      HitCapsuleComponent;                               // 0x07E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7E8[0x78];                                     // 0x07E8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientAttack(int32 AnimIndex);
	void ClientHit_Confirmed(const struct FHitResult& Impact);
	void OnAnimationNotify(const class FName& NotifyName);
	void OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted);
	void ServerAttack(int32 AnimIndex);
	void ServerNotifyHit(const TArray<struct FHitResult>& Impacts, const struct FAttackId& AttackId, uint32 HitSeq);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslWeapon_Melee">();
	}
	static class ATslWeapon_Melee* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslWeapon_Melee>();
	}
};
static_assert(alignof(ATslWeapon_Melee) == 0x000008, "Wrong alignment on ATslWeapon_Melee");
static_assert(sizeof(ATslWeapon_Melee) == 0x000860, "Wrong size on ATslWeapon_Melee");
static_assert(offsetof(ATslWeapon_Melee, AttackSoundAk) == 0x0007A8, "Member 'ATslWeapon_Melee::AttackSoundAk' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Melee, AttackAnims) == 0x0007B0, "Member 'ATslWeapon_Melee::AttackAnims' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Melee, Damage) == 0x0007C0, "Member 'ATslWeapon_Melee::Damage' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Melee, WeaponImpact) == 0x0007C4, "Member 'ATslWeapon_Melee::WeaponImpact' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Melee, DamageType) == 0x0007C8, "Member 'ATslWeapon_Melee::DamageType' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Melee, HitCheckType) == 0x0007D0, "Member 'ATslWeapon_Melee::HitCheckType' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Melee, AllowedHitRangeLeeway) == 0x0007D4, "Member 'ATslWeapon_Melee::AllowedHitRangeLeeway' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Melee, ImpactTemplate) == 0x0007D8, "Member 'ATslWeapon_Melee::ImpactTemplate' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Melee, HitCapsuleComponent) == 0x0007E0, "Member 'ATslWeapon_Melee::HitCapsuleComponent' has a wrong offset!");

// Class TslGame.TslWeapon_Throwable
// 0x00E0 (0x0888 - 0x07A8)
class ATslWeapon_Throwable final : public ATslWeapon
{
public:
	struct FThrowableWeaponData                   ThrowableConfig;                                   // 0x07A8(0x0098)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_840[0x18];                                     // 0x0840(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	EThrowableState                               ThrowableState;                                    // 0x0858(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_859[0x7];                                      // 0x0859(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ThrowWeaponSocketName;                             // 0x0860(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                PawnMotionContributionMultiplier;                  // 0x0868(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_874[0x4];                                      // 0x0874(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ATslParticle*                           PinOffEffect;                                      // 0x0878(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 RingAttachment;                                    // 0x0880(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ClientNotifyReset();
	int32 GetThrowableCount();
	int32 GetThrowableCountInInventory();
	void OnAnimationNotify(const class FName& NotifyName);
	void OnRep_ThrowableState(EThrowableState LastThrowableState);
	void ServerFireProjectile(const struct FVector& RelativeLocation, const struct FVector& AimDirection);
	void ServerRequestCancelThrow();
	void ServerStartCooking();
	void ServerStartPinOff();

	struct FVector CalculateFinalThrowVelocity(const struct FVector& AimDirection) const;
	EThrowableState GetThrowableState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslWeapon_Throwable">();
	}
	static class ATslWeapon_Throwable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslWeapon_Throwable>();
	}
};
static_assert(alignof(ATslWeapon_Throwable) == 0x000008, "Wrong alignment on ATslWeapon_Throwable");
static_assert(sizeof(ATslWeapon_Throwable) == 0x000888, "Wrong size on ATslWeapon_Throwable");
static_assert(offsetof(ATslWeapon_Throwable, ThrowableConfig) == 0x0007A8, "Member 'ATslWeapon_Throwable::ThrowableConfig' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Throwable, ThrowableState) == 0x000858, "Member 'ATslWeapon_Throwable::ThrowableState' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Throwable, ThrowWeaponSocketName) == 0x000860, "Member 'ATslWeapon_Throwable::ThrowWeaponSocketName' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Throwable, PawnMotionContributionMultiplier) == 0x000868, "Member 'ATslWeapon_Throwable::PawnMotionContributionMultiplier' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Throwable, PinOffEffect) == 0x000878, "Member 'ATslWeapon_Throwable::PinOffEffect' has a wrong offset!");
static_assert(offsetof(ATslWeapon_Throwable, RingAttachment) == 0x000880, "Member 'ATslWeapon_Throwable::RingAttachment' has a wrong offset!");

// Class TslGame.TslMotorbikeVehicle_Standalone
// 0x0000 (0x0868 - 0x0868)
class ATslMotorbikeVehicle_Standalone : public ATslMotorbikeVehicle
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslMotorbikeVehicle_Standalone">();
	}
	static class ATslMotorbikeVehicle_Standalone* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATslMotorbikeVehicle_Standalone>();
	}
};
static_assert(alignof(ATslMotorbikeVehicle_Standalone) == 0x000008, "Wrong alignment on ATslMotorbikeVehicle_Standalone");
static_assert(sizeof(ATslMotorbikeVehicle_Standalone) == 0x000868, "Wrong size on ATslMotorbikeVehicle_Standalone");

// Class TslGame.TslWheelEffectType
// 0x0080 (0x00A8 - 0x0028)
class UTslWheelEffectType final : public UDataAsset
{
public:
	class UAkAudioEvent*                          Sound;                                             // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               DefaultFxClass;                                    // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               ConcreteFxClass;                                   // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               DirtFxClass;                                       // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               WaterFxClass;                                      // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               MetalFxClass;                                      // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               WoodFxClass;                                       // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               GrassFxClass;                                      // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               GlassFxClass;                                      // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               RockFxClass;                                       // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               SandFxClass;                                       // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultMinSpeed;                                   // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConcreteMinSpeed;                                  // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirtMinSpeed;                                      // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaterMinSpeed;                                     // 0x008C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MetalMinSpeed;                                     // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WoodMinSpeed;                                      // 0x0094(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrassMinSpeed;                                     // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlassMinSpeed;                                     // 0x009C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RockMinSpeed;                                      // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SandMinSpeed;                                      // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TslWheelEffectType">();
	}
	static class UTslWheelEffectType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTslWheelEffectType>();
	}
};
static_assert(alignof(UTslWheelEffectType) == 0x000008, "Wrong alignment on UTslWheelEffectType");
static_assert(sizeof(UTslWheelEffectType) == 0x0000A8, "Wrong size on UTslWheelEffectType");
static_assert(offsetof(UTslWheelEffectType, Sound) == 0x000028, "Member 'UTslWheelEffectType::Sound' has a wrong offset!");
static_assert(offsetof(UTslWheelEffectType, DefaultFxClass) == 0x000030, "Member 'UTslWheelEffectType::DefaultFxClass' has a wrong offset!");
static_assert(offsetof(UTslWheelEffectType, ConcreteFxClass) == 0x000038, "Member 'UTslWheelEffectType::ConcreteFxClass' has a wrong offset!");
static_assert(offsetof(UTslWheelEffectType, DirtFxClass) == 0x000040, "Member 'UTslWheelEffectType::DirtFxClass' has a wrong offset!");
static_assert(offsetof(UTslWheelEffectType, WaterFxClass) == 0x000048, "Member 'UTslWheelEffectType::WaterFxClass' has a wrong offset!");
static_assert(offsetof(UTslWheelEffectType, MetalFxClass) == 0x000050, "Member 'UTslWheelEffectType::MetalFxClass' has a wrong offset!");
static_assert(offsetof(UTslWheelEffectType, WoodFxClass) == 0x000058, "Member 'UTslWheelEffectType::WoodFxClass' has a wrong offset!");
static_assert(offsetof(UTslWheelEffectType, GrassFxClass) == 0x000060, "Member 'UTslWheelEffectType::GrassFxClass' has a wrong offset!");
static_assert(offsetof(UTslWheelEffectType, GlassFxClass) == 0x000068, "Member 'UTslWheelEffectType::GlassFxClass' has a wrong offset!");
static_assert(offsetof(UTslWheelEffectType, RockFxClass) == 0x000070, "Member 'UTslWheelEffectType::RockFxClass' has a wrong offset!");
static_assert(offsetof(UTslWheelEffectType, SandFxClass) == 0x000078, "Member 'UTslWheelEffectType::SandFxClass' has a wrong offset!");
static_assert(offsetof(UTslWheelEffectType, DefaultMinSpeed) == 0x000080, "Member 'UTslWheelEffectType::DefaultMinSpeed' has a wrong offset!");
static_assert(offsetof(UTslWheelEffectType, ConcreteMinSpeed) == 0x000084, "Member 'UTslWheelEffectType::ConcreteMinSpeed' has a wrong offset!");
static_assert(offsetof(UTslWheelEffectType, DirtMinSpeed) == 0x000088, "Member 'UTslWheelEffectType::DirtMinSpeed' has a wrong offset!");
static_assert(offsetof(UTslWheelEffectType, WaterMinSpeed) == 0x00008C, "Member 'UTslWheelEffectType::WaterMinSpeed' has a wrong offset!");
static_assert(offsetof(UTslWheelEffectType, MetalMinSpeed) == 0x000090, "Member 'UTslWheelEffectType::MetalMinSpeed' has a wrong offset!");
static_assert(offsetof(UTslWheelEffectType, WoodMinSpeed) == 0x000094, "Member 'UTslWheelEffectType::WoodMinSpeed' has a wrong offset!");
static_assert(offsetof(UTslWheelEffectType, GrassMinSpeed) == 0x000098, "Member 'UTslWheelEffectType::GrassMinSpeed' has a wrong offset!");
static_assert(offsetof(UTslWheelEffectType, GlassMinSpeed) == 0x00009C, "Member 'UTslWheelEffectType::GlassMinSpeed' has a wrong offset!");
static_assert(offsetof(UTslWheelEffectType, RockMinSpeed) == 0x0000A0, "Member 'UTslWheelEffectType::RockMinSpeed' has a wrong offset!");
static_assert(offsetof(UTslWheelEffectType, SandMinSpeed) == 0x0000A4, "Member 'UTslWheelEffectType::SandMinSpeed' has a wrong offset!");

// Class TslGame.VehicleRiderComponent
// 0x0058 (0x0150 - 0x00F8)
class UVehicleRiderComponent final : public UActorComponent
{
public:
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SeatIndex;                                         // 0x0100(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_104[0x3C];                                     // 0x0104(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  LastVehiclePawn;                                   // 0x0140(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VehicleRiderComponent">();
	}
	static class UVehicleRiderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVehicleRiderComponent>();
	}
};
static_assert(alignof(UVehicleRiderComponent) == 0x000008, "Wrong alignment on UVehicleRiderComponent");
static_assert(sizeof(UVehicleRiderComponent) == 0x000150, "Wrong size on UVehicleRiderComponent");
static_assert(offsetof(UVehicleRiderComponent, SeatIndex) == 0x000100, "Member 'UVehicleRiderComponent::SeatIndex' has a wrong offset!");
static_assert(offsetof(UVehicleRiderComponent, LastVehiclePawn) == 0x000140, "Member 'UVehicleRiderComponent::LastVehiclePawn' has a wrong offset!");

// Class TslGame.ChannelResponse
// 0x0050 (0x00E8 - 0x0098)
class UChannelResponse final : public UVivoxResponse
{
public:
	uint8                                         Pad_98[0x50];                                      // 0x0098(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChannelResponse">();
	}
	static class UChannelResponse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChannelResponse>();
	}
};
static_assert(alignof(UChannelResponse) == 0x000008, "Wrong alignment on UChannelResponse");
static_assert(sizeof(UChannelResponse) == 0x0000E8, "Wrong size on UChannelResponse");

// Class TslGame.KeyRevokeResponse
// 0x0020 (0x00B8 - 0x0098)
class UKeyRevokeResponse final : public UVivoxResponse
{
public:
	uint8                                         Pad_98[0x20];                                      // 0x0098(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KeyRevokeResponse">();
	}
	static class UKeyRevokeResponse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKeyRevokeResponse>();
	}
};
static_assert(alignof(UKeyRevokeResponse) == 0x000008, "Wrong alignment on UKeyRevokeResponse");
static_assert(sizeof(UKeyRevokeResponse) == 0x0000B8, "Wrong size on UKeyRevokeResponse");

// Class TslGame.KeyAddResponse
// 0x0030 (0x00C8 - 0x0098)
class UKeyAddResponse final : public UVivoxResponse
{
public:
	uint8                                         Pad_98[0x30];                                      // 0x0098(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KeyAddResponse">();
	}
	static class UKeyAddResponse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKeyAddResponse>();
	}
};
static_assert(alignof(UKeyAddResponse) == 0x000008, "Wrong alignment on UKeyAddResponse");
static_assert(sizeof(UKeyAddResponse) == 0x0000C8, "Wrong size on UKeyAddResponse");

// Class TslGame.VivoxComponent
// 0x0048 (0x01E0 - 0x0198)
class UVivoxComponent final : public UVivoxBaseComponent
{
public:
	uint8                                         Pad_198[0x2C];                                     // 0x0198(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SuddenMovementDistance;                            // 0x01C4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SuddenMovementModifier;                            // 0x01C8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SuddenMovementModifierDuration;                    // 0x01CC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SuddenMovementModifierRestoreDuration;             // 0x01D0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D4[0x4];                                      // 0x01D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableObserverTeamChat;                           // 0x01D8(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D9[0x7];                                      // 0x01D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyTimedVolumeModifier(EVivoxChannelType ChannelType, float NewModifier, float Duration, float RestoreDuration);
	void ServerSetObserverTeamNum(int32 NewTeamNum);
	void ServerTestAccessToken();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VivoxComponent">();
	}
	static class UVivoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVivoxComponent>();
	}
};
static_assert(alignof(UVivoxComponent) == 0x000008, "Wrong alignment on UVivoxComponent");
static_assert(sizeof(UVivoxComponent) == 0x0001E0, "Wrong size on UVivoxComponent");
static_assert(offsetof(UVivoxComponent, SuddenMovementDistance) == 0x0001C4, "Member 'UVivoxComponent::SuddenMovementDistance' has a wrong offset!");
static_assert(offsetof(UVivoxComponent, SuddenMovementModifier) == 0x0001C8, "Member 'UVivoxComponent::SuddenMovementModifier' has a wrong offset!");
static_assert(offsetof(UVivoxComponent, SuddenMovementModifierDuration) == 0x0001CC, "Member 'UVivoxComponent::SuddenMovementModifierDuration' has a wrong offset!");
static_assert(offsetof(UVivoxComponent, SuddenMovementModifierRestoreDuration) == 0x0001D0, "Member 'UVivoxComponent::SuddenMovementModifierRestoreDuration' has a wrong offset!");
static_assert(offsetof(UVivoxComponent, bEnableObserverTeamChat) == 0x0001D8, "Member 'UVivoxComponent::bEnableObserverTeamChat' has a wrong offset!");

// Class TslGame.VivoxLobbyComponent
// 0x0038 (0x01D0 - 0x0198)
class UVivoxLobbyComponent final : public UVivoxBaseComponent
{
public:
	uint8                                         Pad_198[0x38];                                     // 0x0198(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VivoxLobbyComponent">();
	}
	static class UVivoxLobbyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVivoxLobbyComponent>();
	}
};
static_assert(alignof(UVivoxLobbyComponent) == 0x000008, "Wrong alignment on UVivoxLobbyComponent");
static_assert(sizeof(UVivoxLobbyComponent) == 0x0001D0, "Wrong size on UVivoxLobbyComponent");

// Class TslGame.VivoxManager
// 0x00F0 (0x0118 - 0x0028)
class UVivoxManager final : public UObject
{
public:
	class UWorld*                                 World;                                             // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVivoxConnectionInfo                   ConnectionInfo;                                    // 0x0038(0x0020)(NativeAccessSpecifierPrivate)
	bool                                          bUseEphmeralChannel;                               // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AuthId;                                            // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AuthPwd;                                           // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int64                                         AccessTokenExpirationTime;                         // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 Issuer;                                            // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 Key;                                               // 0x0098(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USignInResponse*                        SignIn;                                            // 0x00B8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UKeyAddResponse*                        KeyAdd;                                            // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UKeyRevokeResponse*                     KeyRevoke;                                         // 0x00C8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UChannelResponse*>               Channels;                                          // 0x00D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATslPlayerController*>           PlayerControllers;                                 // 0x00F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	int32                                         ProximalMaxRange;                                  // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ProximalClampingDistance;                          // 0x0104(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ProximalDistanceModel;                             // 0x0108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10C[0xC];                                      // 0x010C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAddKeyFail(const class UVivoxResponse* Response);
	void OnAddKeySuccess(const class UVivoxResponse* Response);
	void OnChannelFail(const class UVivoxResponse* Response);
	void OnChannelSuccess(const class UVivoxResponse* Response);
	void OnRevokeKeyFail(const class UVivoxResponse* Response);
	void OnRevokeKeySuccess(const class UVivoxResponse* Response);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VivoxManager">();
	}
	static class UVivoxManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVivoxManager>();
	}
};
static_assert(alignof(UVivoxManager) == 0x000008, "Wrong alignment on UVivoxManager");
static_assert(sizeof(UVivoxManager) == 0x000118, "Wrong size on UVivoxManager");
static_assert(offsetof(UVivoxManager, World) == 0x000028, "Member 'UVivoxManager::World' has a wrong offset!");
static_assert(offsetof(UVivoxManager, ConnectionInfo) == 0x000038, "Member 'UVivoxManager::ConnectionInfo' has a wrong offset!");
static_assert(offsetof(UVivoxManager, bUseEphmeralChannel) == 0x000058, "Member 'UVivoxManager::bUseEphmeralChannel' has a wrong offset!");
static_assert(offsetof(UVivoxManager, AuthId) == 0x000060, "Member 'UVivoxManager::AuthId' has a wrong offset!");
static_assert(offsetof(UVivoxManager, AuthPwd) == 0x000070, "Member 'UVivoxManager::AuthPwd' has a wrong offset!");
static_assert(offsetof(UVivoxManager, AccessTokenExpirationTime) == 0x000080, "Member 'UVivoxManager::AccessTokenExpirationTime' has a wrong offset!");
static_assert(offsetof(UVivoxManager, Issuer) == 0x000088, "Member 'UVivoxManager::Issuer' has a wrong offset!");
static_assert(offsetof(UVivoxManager, Key) == 0x000098, "Member 'UVivoxManager::Key' has a wrong offset!");
static_assert(offsetof(UVivoxManager, SignIn) == 0x0000B8, "Member 'UVivoxManager::SignIn' has a wrong offset!");
static_assert(offsetof(UVivoxManager, KeyAdd) == 0x0000C0, "Member 'UVivoxManager::KeyAdd' has a wrong offset!");
static_assert(offsetof(UVivoxManager, KeyRevoke) == 0x0000C8, "Member 'UVivoxManager::KeyRevoke' has a wrong offset!");
static_assert(offsetof(UVivoxManager, Channels) == 0x0000D0, "Member 'UVivoxManager::Channels' has a wrong offset!");
static_assert(offsetof(UVivoxManager, PlayerControllers) == 0x0000F0, "Member 'UVivoxManager::PlayerControllers' has a wrong offset!");
static_assert(offsetof(UVivoxManager, ProximalMaxRange) == 0x000100, "Member 'UVivoxManager::ProximalMaxRange' has a wrong offset!");
static_assert(offsetof(UVivoxManager, ProximalClampingDistance) == 0x000104, "Member 'UVivoxManager::ProximalClampingDistance' has a wrong offset!");
static_assert(offsetof(UVivoxManager, ProximalDistanceModel) == 0x000108, "Member 'UVivoxManager::ProximalDistanceModel' has a wrong offset!");

// Class TslGame.WeaponAnimInfoComponent
// 0x0060 (0x0158 - 0x00F8)
class UWeaponAnimInfoComponent : public UActorComponent
{
public:
	class FName                                   WeaponAttachPointPistol;                           // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WeaponAttachPointRifle;                            // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WeaponAttachPointThrowable;                        // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WeaponAttachPointMelee;                            // 0x0110(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 MeshComponent;                                     // 0x0118(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTslAccessoryComponent*                 CharacterAccessory_Primary;                        // 0x0120(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTslAccessoryComponent*                 CharacterAccessory_Secondary;                      // 0x0128(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTslAccessoryComponent*                 CharacterAccessory_Sidearm;                        // 0x0130(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTslAccessoryComponent*                 CharacterAccessory_Melee;                          // 0x0138(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTslAccessoryComponent*                 CharacterAccessory_Thrown;                         // 0x0140(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   WeaponLeftHandIKAttachPoint;                       // 0x0148(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_150[0x8];                                      // 0x0150(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAccessorySlot(class UTslAccessoryComponent* NewAccessoryComponent, EAccessorySlot Slot);

	class UTslAccessoryComponent* GetAccessorySlot(EAccessorySlot Slot) const;
	class ATslWeapon* GetCurrentWeapon() const;
	struct FTransform GetWeaponHandIK_Left(const class ATslWeapon* Weapon) const;
	struct FTransform GetWeaponHandIK_Right(const class ATslWeapon* Weapon) const;
	struct FTransform GetWeaponLeftHandIKTransform(const class ATslWeapon* Weapon) const;
	bool HasWeaponLeftHandIKSocket(const class ATslWeapon* Weapon) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponAnimInfoComponent">();
	}
	static class UWeaponAnimInfoComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponAnimInfoComponent>();
	}
};
static_assert(alignof(UWeaponAnimInfoComponent) == 0x000008, "Wrong alignment on UWeaponAnimInfoComponent");
static_assert(sizeof(UWeaponAnimInfoComponent) == 0x000158, "Wrong size on UWeaponAnimInfoComponent");
static_assert(offsetof(UWeaponAnimInfoComponent, WeaponAttachPointPistol) == 0x0000F8, "Member 'UWeaponAnimInfoComponent::WeaponAttachPointPistol' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInfoComponent, WeaponAttachPointRifle) == 0x000100, "Member 'UWeaponAnimInfoComponent::WeaponAttachPointRifle' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInfoComponent, WeaponAttachPointThrowable) == 0x000108, "Member 'UWeaponAnimInfoComponent::WeaponAttachPointThrowable' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInfoComponent, WeaponAttachPointMelee) == 0x000110, "Member 'UWeaponAnimInfoComponent::WeaponAttachPointMelee' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInfoComponent, MeshComponent) == 0x000118, "Member 'UWeaponAnimInfoComponent::MeshComponent' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInfoComponent, CharacterAccessory_Primary) == 0x000120, "Member 'UWeaponAnimInfoComponent::CharacterAccessory_Primary' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInfoComponent, CharacterAccessory_Secondary) == 0x000128, "Member 'UWeaponAnimInfoComponent::CharacterAccessory_Secondary' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInfoComponent, CharacterAccessory_Sidearm) == 0x000130, "Member 'UWeaponAnimInfoComponent::CharacterAccessory_Sidearm' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInfoComponent, CharacterAccessory_Melee) == 0x000138, "Member 'UWeaponAnimInfoComponent::CharacterAccessory_Melee' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInfoComponent, CharacterAccessory_Thrown) == 0x000140, "Member 'UWeaponAnimInfoComponent::CharacterAccessory_Thrown' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInfoComponent, WeaponLeftHandIKAttachPoint) == 0x000148, "Member 'UWeaponAnimInfoComponent::WeaponLeftHandIKAttachPoint' has a wrong offset!");

// Class TslGame.CharacterWeaponAnimInfoComponent
// 0x0038 (0x0190 - 0x0158)
class UCharacterWeaponAnimInfoComponent final : public UWeaponAnimInfoComponent
{
public:
	class FName                                   WeaponAttachPointPistolDriving;                    // 0x0158(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   WeaponAttachPointPistolSitting;                    // 0x0160(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   WeaponAttachPointRifleDriving;                     // 0x0168(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   WeaponAttachPointRifleSitting;                     // 0x0170(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   WeaponAttachPointRifleAim;                         // 0x0178(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   WeaponAttachPointThrowableDriving;                 // 0x0180(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   WeaponAttachPointMeleeDriving;                     // 0x0188(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterWeaponAnimInfoComponent">();
	}
	static class UCharacterWeaponAnimInfoComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterWeaponAnimInfoComponent>();
	}
};
static_assert(alignof(UCharacterWeaponAnimInfoComponent) == 0x000008, "Wrong alignment on UCharacterWeaponAnimInfoComponent");
static_assert(sizeof(UCharacterWeaponAnimInfoComponent) == 0x000190, "Wrong size on UCharacterWeaponAnimInfoComponent");
static_assert(offsetof(UCharacterWeaponAnimInfoComponent, WeaponAttachPointPistolDriving) == 0x000158, "Member 'UCharacterWeaponAnimInfoComponent::WeaponAttachPointPistolDriving' has a wrong offset!");
static_assert(offsetof(UCharacterWeaponAnimInfoComponent, WeaponAttachPointPistolSitting) == 0x000160, "Member 'UCharacterWeaponAnimInfoComponent::WeaponAttachPointPistolSitting' has a wrong offset!");
static_assert(offsetof(UCharacterWeaponAnimInfoComponent, WeaponAttachPointRifleDriving) == 0x000168, "Member 'UCharacterWeaponAnimInfoComponent::WeaponAttachPointRifleDriving' has a wrong offset!");
static_assert(offsetof(UCharacterWeaponAnimInfoComponent, WeaponAttachPointRifleSitting) == 0x000170, "Member 'UCharacterWeaponAnimInfoComponent::WeaponAttachPointRifleSitting' has a wrong offset!");
static_assert(offsetof(UCharacterWeaponAnimInfoComponent, WeaponAttachPointRifleAim) == 0x000178, "Member 'UCharacterWeaponAnimInfoComponent::WeaponAttachPointRifleAim' has a wrong offset!");
static_assert(offsetof(UCharacterWeaponAnimInfoComponent, WeaponAttachPointThrowableDriving) == 0x000180, "Member 'UCharacterWeaponAnimInfoComponent::WeaponAttachPointThrowableDriving' has a wrong offset!");
static_assert(offsetof(UCharacterWeaponAnimInfoComponent, WeaponAttachPointMeleeDriving) == 0x000188, "Member 'UCharacterWeaponAnimInfoComponent::WeaponAttachPointMeleeDriving' has a wrong offset!");

}

