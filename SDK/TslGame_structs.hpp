#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: TslGame

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "InputCore_structs.hpp"
#include "TslCommon_structs.hpp"
#include "Engine_structs.hpp"
#include "SlateCore_structs.hpp"


namespace SDK
{

// Enum TslGame.EPopupButtonID
// NumValues: 0x0003
enum class EPopupButtonID : uint8
{
	Cancel_Or_No                             = 0,
	Yes_Or_OK                                = 1,
	EPopupButtonID_MAX                       = 2,
};

// Enum TslGame.ESystemMessageType
// NumValues: 0x0006
enum class ESystemMessageType : uint8
{
	Debug                                    = 0,
	Notify                                   = 1,
	Warning                                  = 2,
	Error                                    = 3,
	Important                                = 4,
	ESystemMessageType_MAX                   = 5,
};

// Enum TslGame.EDamageReason
// NumValues: 0x0008
enum class EDamageReason : uint8
{
	None                                     = 0,
	HeadShot                                 = 1,
	TorsoShot                                = 2,
	StomachShot                              = 3,
	ArmShot                                  = 4,
	LegShot                                  = 5,
	NonSpecific                              = 6,
	EDamageReason_MAX                        = 7,
};

// Enum TslGame.EDamageTypeCategory
// NumValues: 0x0010
enum class EDamageTypeCategory : uint8
{
	Damage_None                              = 0,
	Damage_Instant                           = 1,
	Damage_Gun                               = 2,
	Damage_Melee                             = 3,
	Damage_ZombieMelee                       = 4,
	Damage_Groggy                            = 5,
	Damage_BlueZone                          = 6,
	Damage_VehicleHit                        = 7,
	Damage_Molotov                           = 8,
	Damage_Explosion                         = 9,
	Damage_Explosion_Grenade                 = 10,
	Damage_Explosion_RedZone                 = 11,
	Damage_Explosion_Vehicle                 = 12,
	Damage_Instant_Fall                      = 13,
	Damage_Drown                             = 14,
	Damage_MAX                               = 15,
};

// Enum TslGame.EThrownWeaponType
// NumValues: 0x0004
enum class EThrownWeaponType : uint8
{
	Thrown_Grenade                           = 0,
	Thrown_Molotov                           = 1,
	Thrown_Other                             = 2,
	Thrown_MAX                               = 3,
};

// Enum TslGame.EPowerUpType
// NumValues: 0x0008
enum class EPowerUpType : uint8
{
	PowerUp_None                             = 0,
	PowerUp_Bandage                          = 1,
	PowerUp_FirstAid                         = 2,
	PowerUp_MedKit                           = 3,
	PowerUp_EnergyDrink                      = 4,
	PowerUp_Painkillers                      = 5,
	PowerUp_Adrenaline                       = 6,
	PowerUp_MAX                              = 7,
};

// Enum TslGame.EPopupStyle
// NumValues: 0x0004
enum class EPopupStyle : uint8
{
	Ok_Cancel                                = 0,
	Ok                                       = 1,
	Yes_No                                   = 2,
	EPopupStyle_MAX                          = 3,
};

// Enum TslGame.EWidgetShowType
// NumValues: 0x0004
enum class EWidgetShowType : uint8
{
	Show                                     = 0,
	Hide                                     = 1,
	Toggle                                   = 2,
	EWidgetShowType_MAX                      = 3,
};

// Enum TslGame.EMovementDirection
// NumValues: 0x0009
enum class EMovementDirection : uint8
{
	F_Direction                              = 0,
	L_Direction                              = 1,
	R_Direction                              = 2,
	B_Direction                              = 3,
	FL_Direction                             = 4,
	FR_Direction                             = 5,
	BL_Direction                             = 6,
	BR_Direction                             = 7,
	EMovementDirection_MAX                   = 8,
};

// Enum TslGame.EAnimStanceType
// NumValues: 0x0004
enum class EAnimStanceType : uint8
{
	AnimType_Stand                           = 0,
	AnimType_Crouch                          = 1,
	AnimType_Prone                           = 2,
	AnimType_MAX                             = 3,
};

// Enum TslGame.EBuffOverlapSolveMethod
// NumValues: 0x0004
enum class EBuffOverlapSolveMethod : uint8
{
	IgnoreLater                              = 0,
	Overwrite                                = 1,
	RestartTimer                             = 2,
	EBuffOverlapSolveMethod_MAX              = 3,
};

// Enum TslGame.ECastAnim
// NumValues: 0x0009
enum class ECastAnim : uint8
{
	None                                     = 0,
	Bandage                                  = 1,
	FirstAid                                 = 2,
	Medkit                                   = 3,
	EnergyDrink                              = 4,
	Painkiller                               = 5,
	Adrenaline                               = 6,
	Door                                     = 7,
	ECastAnim_MAX                            = 8,
};

// Enum TslGame.ECastLevel
// NumValues: 0x0004
enum class ECastLevel : uint8
{
	None                                     = 0,
	NoRestriction                            = 1,
	Restriction                              = 2,
	ECastLevel_MAX                           = 3,
};

// Enum TslGame.ECastPriority
// NumValues: 0x0006
enum class ECastPriority : uint8
{
	None                                     = 0,
	Low                                      = 1,
	Normal                                   = 2,
	High                                     = 3,
	Max                                      = 4,
	ECastPriority_MAX                        = 5,
};

// Enum TslGame.EUiShowType
// NumValues: 0x0005
enum class EUiShowType : uint8
{
	AlwaysShow                               = 0,
	TpsOnlyShow                              = 1,
	FpsOnlyShow                              = 2,
	AlwaysHide                               = 3,
	EUiShowType_MAX                          = 4,
};

// Enum TslGame.ETslInputModes
// NumValues: 0x0004
enum class ETslInputModes : uint8
{
	Toggle                                   = 0,
	Hold                                     = 1,
	DoubleTap                                = 2,
	ETslInputModes_MAX                       = 3,
};

// Enum TslGame.EGameplayFunctionalities
// NumValues: 0x0002
enum class EGameplayFunctionalities : uint8
{
	FreeLookInterp                           = 0,
	EGameplayFunctionalities_MAX             = 1,
};

// Enum TslGame.EInputModeSettingActions
// NumValues: 0x000A
enum class EInputModeSettingActions : uint8
{
	Crouch                                   = 0,
	Prone                                    = 1,
	Walk                                     = 2,
	Sprint                                   = 3,
	HoldRotation                             = 4,
	HoldBreath                               = 5,
	Peek                                     = 6,
	Map                                      = 7,
	ADS                                      = 8,
	EInputModeSettingActions_MAX             = 9,
};

// Enum TslGame.EKeyBindingSlot
// NumValues: 0x0003
enum class EKeyBindingSlot : uint8
{
	FirstKey                                 = 0,
	SecondKey                                = 1,
	EKeyBindingSlot_MAX                      = 2,
};

// Enum TslGame.EReportCause
// NumValues: 0x0006
enum class EReportCause : uint8
{
	Default                                  = 0,
	Cheat                                    = 1,
	TeamKill                                 = 2,
	Teaming                                  = 3,
	InappropriateID                          = 4,
	EReportCause_MAX                         = 5,
};

// Enum TslGame.ESubjectToReport
// NumValues: 0x0003
enum class ESubjectToReport : uint8
{
	Killer                                   = 0,
	Spectating_Player                        = 1,
	ESubjectToReport_MAX                     = 2,
};

// Enum TslGame.ECarePackageIconType
// NumValues: 0x0004
enum class ECarePackageIconType : uint8
{
	Normal                                   = 0,
	Flying                                   = 1,
	Opened                                   = 2,
	ECarePackageIconType_MAX                 = 3,
};

// Enum TslGame.ECharacterIconType
// NumValues: 0x0008
enum class ECharacterIconType : uint8
{
	Normal                                   = 0,
	Vehicle                                  = 1,
	Parachute                                = 2,
	Die                                      = 3,
	Groggy                                   = 4,
	Quitter                                  = 5,
	Observer                                 = 6,
	ECharacterIconType_MAX                   = 7,
};

// Enum TslGame.EObserverCameraMode
// NumValues: 0x0005
enum class EObserverCameraMode : uint8
{
	FixedCamera                              = 0,
	FreeCamera                               = 1,
	PlayerCamera                             = 2,
	FollowCamera                             = 3,
	EObserverCameraMode_MAX                  = 4,
};

// Enum TslGame.EObserverAuthorityType
// NumValues: 0x0005
enum class EObserverAuthorityType : uint8
{
	None                                     = 0,
	FromBeginning                            = 1,
	AfterDeath                               = 2,
	AfterExtermination                       = 3,
	EObserverAuthorityType_MAX               = 4,
};

// Enum TslGame.EValueType
// NumValues: 0x0005
enum class EValueType : uint8
{
	Float                                    = 0,
	Int                                      = 1,
	String                                   = 2,
	Bool                                     = 3,
	EValueType_MAX                           = 4,
};

// Enum TslGame.EQualityType
// NumValues: 0x0009
enum class EQualityType : uint8
{
	EMainQuality                             = 0,
	EViewDistanceQuality                     = 1,
	EShadowQuality                           = 2,
	EAntiAliasingQuality                     = 3,
	ETextureQuality                          = 4,
	EVisualEffectQuality                     = 5,
	EPostProcessingQuality                   = 6,
	EFoliageQuality                          = 7,
	EQualityType_MAX                         = 8,
};

// Enum TslGame.ENearClippingLevel
// NumValues: 0x0005
enum class ENearClippingLevel : uint8
{
	Default                                  = 0,
	Low                                      = 1,
	Middle                                   = 2,
	High                                     = 3,
	ENearClippingLevel_MAX                   = 4,
};

// Enum TslGame.EThingSpotGroupType
// NumValues: 0x000F
enum class EThingSpotGroupType : uint8
{
	GroupA                                   = 0,
	GroupB                                   = 1,
	GroupC                                   = 2,
	GroupD                                   = 3,
	GroupE                                   = 4,
	GroupF                                   = 5,
	GroupG                                   = 6,
	GroupH                                   = 7,
	GroupI                                   = 8,
	GroupJ                                   = 9,
	GroupK                                   = 10,
	GroupL                                   = 11,
	GroupM                                   = 12,
	GroupN                                   = 13,
	EThingSpotGroupType_MAX                  = 14,
};

// Enum TslGame.EPhysMaterialType
// NumValues: 0x0008
enum class EPhysMaterialType : uint8
{
	Unknown                                  = 0,
	Asphalt                                  = 1,
	Dirt                                     = 2,
	Water                                    = 3,
	Wood                                     = 4,
	Stone                                    = 5,
	Metal                                    = 6,
	EPhysMaterialType_MAX                    = 7,
};

// Enum TslGame.EEquipableItemSoundType
// NumValues: 0x0009
enum class EEquipableItemSoundType : uint8
{
	None                                     = 0,
	Vest                                     = 1,
	LongCoat                                 = 2,
	HipSack                                  = 3,
	Cloth                                    = 4,
	BackPack                                 = 5,
	MilitaryShoes                            = 6,
	Sneakers                                 = 7,
	EEquipableItemSoundType_MAX              = 8,
};

// Enum TslGame.EEquipableItemSoundGroup
// NumValues: 0x0003
enum class EEquipableItemSoundGroup : uint8
{
	Default                                  = 0,
	Shoes                                    = 1,
	EEquipableItemSoundGroup_MAX             = 2,
};

// Enum TslGame.EColorBlindType
// NumValues: 0x0005
enum class EColorBlindType : uint8
{
	Normal                                   = 0,
	Deuteranopia                             = 1,
	Protanopia                               = 2,
	Tritanopia                               = 3,
	EColorBlindType_MAX                      = 4,
};

// Enum TslGame.ETslPhysMaterialType
// NumValues: 0x000A
enum class ETslPhysMaterialType : uint8
{
	Unknown                                  = 0,
	Concrete                                 = 1,
	Dirt                                     = 2,
	Water                                    = 3,
	Metal                                    = 4,
	Wood                                     = 5,
	Grass                                    = 6,
	Glass                                    = 7,
	Flesh                                    = 8,
	ETslPhysMaterialType_MAX                 = 9,
};

// Enum TslGame.ETargetingType
// NumValues: 0x0004
enum class ETargetingType : uint8
{
	Targeting_None                           = 0,
	Targeting_Aiming                         = 1,
	Targeting_Scoping                        = 2,
	Targeting_MAX                            = 3,
};

// Enum TslGame.EAccessorySlot
// NumValues: 0x0006
enum class EAccessorySlot : uint8
{
	Slot_Primary                             = 0,
	Slot_Secondary                           = 1,
	Slot_SideArm                             = 2,
	Slot_Melee                               = 3,
	Slot_Thrown                              = 4,
	Slot_MAX                                 = 5,
};

// Enum TslGame.EAnimWeaponType
// NumValues: 0x0006
enum class EAnimWeaponType : uint8
{
	None                                     = 0,
	Rifle                                    = 1,
	Pistol                                   = 2,
	Throwable                                = 3,
	Melee                                    = 4,
	EAnimWeaponType_MAX                      = 5,
};

// Enum TslGame.ECameraViewBehaviour
// NumValues: 0x0004
enum class ECameraViewBehaviour : uint8
{
	FpsAndTps                                = 0,
	FpsOnly                                  = 1,
	TpsOnly                                  = 2,
	ECameraViewBehaviour_MAX                 = 3,
};

// Enum TslGame.EMatchStartType
// NumValues: 0x0003
enum class EMatchStartType : uint8
{
	Normal                                   = 0,
	Airborne                                 = 1,
	EMatchStartType_MAX                      = 2,
};

// Enum TslGame.EGender
// NumValues: 0x0003
enum class EGender : uint8
{
	Male                                     = 0,
	Female                                   = 1,
	EGender_MAX                              = 2,
};

// Enum TslGame.EAttackType
// NumValues: 0x0008
enum class EAttackType : uint8
{
	None                                     = 0,
	Weapon                                   = 1,
	VehicleCrash                             = 2,
	VehicleExplosion                         = 3,
	Fall                                     = 4,
	BlueZone                                 = 5,
	RedZone                                  = 6,
	EAttackType_MAX                          = 7,
};

// Enum TslGame.EPlayerMoveType
// NumValues: 0x0003
enum class EPlayerMoveType : uint8
{
	OnFoot                                   = 0,
	OnVehicle                                = 1,
	EPlayerMoveType_MAX                      = 2,
};

// Enum TslGame.ELobbyItemPointSellingType
// NumValues: 0x0003
enum class ELobbyItemPointSellingType : uint8
{
	Normal                                   = 0,
	WeeklyDouble                             = 1,
	ELobbyItemPointSellingType_MAX           = 2,
};

// Enum TslGame.ELobbyItemTier
// NumValues: 0x000B
enum class ELobbyItemTier : uint8
{
	Basic                                    = 0,
	Common                                   = 1,
	Classic                                  = 2,
	Special                                  = 3,
	Rare                                     = 4,
	Elite                                    = 5,
	Epic                                     = 6,
	Legendary                                = 7,
	Ultimate                                 = 8,
	Event                                    = 9,
	ELobbyItemTier_MAX                       = 10,
};

// Enum TslGame.ELobbyItemCategory
// NumValues: 0x000C
enum class ELobbyItemCategory : uint8
{
	Belt                                     = 0,
	Body                                     = 1,
	Eyes                                     = 2,
	Feet                                     = 3,
	Head                                     = 4,
	Jacket                                   = 5,
	Legs                                     = 6,
	Mask                                     = 7,
	Hands                                    = 8,
	Box                                      = 9,
	Key                                      = 10,
	ELobbyItemCategory_MAX                   = 11,
};

// Enum TslGame.EItemCategory
// NumValues: 0x0007
enum class EItemCategory : uint8
{
	None                                     = 0,
	Equipment                                = 1,
	Weapon                                   = 2,
	Attachment                               = 3,
	Ammunition                               = 4,
	Use                                      = 5,
	EItemCategory_MAX                        = 6,
};

// Enum TslGame.EForceRefreshDummy
// NumValues: 0x0003
enum class EForceRefreshDummy : uint8
{
	Refresh1                                 = 0,
	Refresh2                                 = 1,
	EForceRefreshDummy_MAX                   = 2,
};

// Enum TslGame.EHackDetectionType
// NumValues: 0x0009
enum class EHackDetectionType : uint8
{
	WEAPON_INVALID_IMPACT                    = 0,
	WEAPON_INVALID_ORIGIN                    = 1,
	WEAPON_INVALID_RANGE                     = 2,
	WEAPON_INVALID_SEQUENCE                  = 3,
	WEAPON_INVALID_HITLAG                    = 4,
	WEAPON_INVALID_AMMO                      = 5,
	WEAPON_WALL_CHECK                        = 6,
	IGNORE_WALL                              = 7,
	EHackDetectionType_MAX                   = 8,
};

// Enum TslGame.EInteractionPhase
// NumValues: 0x0003
enum class EInteractionPhase : uint8
{
	First                                    = 0,
	Second                                   = 1,
	EInteractionPhase_MAX                    = 2,
};

// Enum TslGame.EWeaponGripLeftHand
// NumValues: 0x0005
enum class EWeaponGripLeftHand : uint8
{
	NormalRifle                              = 0,
	Foregrip1                                = 1,
	Foregrip2                                = 2,
	Thompson                                 = 3,
	EWeaponGripLeftHand_MAX                  = 4,
};

// Enum TslGame.EWeaponAttachmentSlotID
// NumValues: 0x0007
enum class EWeaponAttachmentSlotID : uint8
{
	None                                     = 0,
	Muzzle                                   = 1,
	LowerRail                                = 2,
	UpperRail                                = 3,
	Magazine                                 = 4,
	Stock                                    = 5,
	EWeaponAttachmentSlotID_MAX              = 6,
};

// Enum TslGame.EItemSpotGroupType
// NumValues: 0x000B
enum class EItemSpotGroupType : uint8
{
	GroupA                                   = 0,
	GroupB                                   = 1,
	GroupC                                   = 2,
	GroupD                                   = 3,
	GroupE                                   = 4,
	GroupF                                   = 5,
	GroupG                                   = 6,
	GroupH                                   = 7,
	GroupI                                   = 8,
	GroupJ                                   = 9,
	EItemSpotGroupType_MAX                   = 10,
};

// Enum TslGame.EItemSpotType
// NumValues: 0x0007
enum class EItemSpotType : uint8
{
	TypeA                                    = 0,
	TypeB                                    = 1,
	TypeC                                    = 2,
	TypeD                                    = 3,
	TypeE                                    = 4,
	TypeF                                    = 5,
	EItemSpotType_MAX                        = 6,
};

// Enum TslGame.EEquipSlotID
// NumValues: 0x0011
enum class EEquipSlotID : uint8
{
	Head                                     = 0,
	Eyes                                     = 1,
	Mask                                     = 2,
	Torso                                    = 3,
	TorsoArmor                               = 4,
	Outer                                    = 5,
	Backpack                                 = 6,
	Hands                                    = 7,
	Legs                                     = 8,
	Feet                                     = 9,
	Belt                                     = 10,
	WeaponPrimary                            = 11,
	WeaponSecondary                          = 12,
	WeaponMelee                              = 13,
	WeaponThrowable                          = 14,
	MaxOrNone                                = 15,
	EEquipSlotID_MAX                         = 16,
};

// Enum TslGame.EDurabilityConsumeType
// NumValues: 0x0003
enum class EDurabilityConsumeType : uint8
{
	TotalDamage                              = 0,
	AbsorbDamage                             = 1,
	EDurabilityConsumeType_MAX               = 2,
};

// Enum TslGame.EAnimStance
// NumValues: 0x0005
enum class EAnimStance : uint8
{
	Stand                                    = 0,
	Crouch                                   = 1,
	Prone                                    = 2,
	Groggy                                   = 3,
	EAnimStance_MAX                          = 4,
};

// Enum TslGame.EWeaponClass
// NumValues: 0x000B
enum class EWeaponClass : uint8
{
	Class_Pistol                             = 0,
	Class_SMG                                = 1,
	Class_Rifle                              = 2,
	Class_Carbine                            = 3,
	Class_Shotgun                            = 4,
	Class_Sniper                             = 5,
	Class_DMR                                = 6,
	Class_LMG                                = 7,
	Class_Melee                              = 8,
	Class_Throwable                          = 9,
	Class_MAX                                = 10,
};

// Enum TslGame.EAttachmentCalculateType
// NumValues: 0x0003
enum class EAttachmentCalculateType : uint8
{
	Addition                                 = 0,
	Multiply                                 = 1,
	EAttachmentCalculateType_MAX             = 2,
};

// Enum TslGame.EFiringMode
// NumValues: 0x0004
enum class EFiringMode : uint8
{
	Normal                                   = 0,
	Burst                                    = 1,
	FullAuto                                 = 2,
	EFiringMode_MAX                          = 3,
};

// Enum TslGame.EWeaponHand
// NumValues: 0x0003
enum class EWeaponHand : uint8
{
	Left                                     = 0,
	Right                                    = 1,
	EWeaponHand_MAX                          = 2,
};

// Enum TslGame.ELobbyItemBundleType
// NumValues: 0x0003
enum class ELobbyItemBundleType : uint8
{
	Bundle                                   = 0,
	Generator                                = 1,
	ELobbyItemBundleType_MAX                 = 2,
};

// Enum TslGame.ELobbyLinkState
// NumValues: 0x0006
enum class ELobbyLinkState : uint8
{
	Disconnect                               = 0,
	WaitInitialize                           = 1,
	WaitStart                                = 2,
	Gaming                                   = 3,
	Finished                                 = 4,
	ELobbyLinkState_MAX                      = 5,
};

// Enum TslGame.EParameterLUTChannel
// NumValues: 0x0007
enum class EParameterLUTChannel : uint8
{
	R                                        = 0,
	G                                        = 1,
	B                                        = 2,
	A                                        = 3,
	RGBA                                     = 4,
	Undefined                                = 5,
	EParameterLUTChannel_MAX                 = 6,
};

// Enum TslGame.EMaterialParameterType
// NumValues: 0x0006
enum class EMaterialParameterType : uint8
{
	Bool                                     = 0,
	Scalar                                   = 1,
	Vector                                   = 2,
	Texture                                  = 3,
	Undefined                                = 4,
	EMaterialParameterType_MAX               = 5,
};

// Enum TslGame.EWeaponReloadAnimExec
// NumValues: 0x0005
enum class EWeaponReloadAnimExec : uint8
{
	Tactical                                 = 0,
	Charge                                   = 1,
	Single                                   = 2,
	Loop                                     = 3,
	EWeaponReloadAnimExec_MAX                = 4,
};

// Enum TslGame.EWeaponReloadMethod
// NumValues: 0x0004
enum class EWeaponReloadMethod : uint8
{
	Magazine                                 = 0,
	OneByOne                                 = 1,
	OneByOneAndClip                          = 2,
	EWeaponReloadMethod_MAX                  = 3,
};

// Enum TslGame.EHornSoundType
// NumValues: 0x0004
enum class EHornSoundType : uint8
{
	HornOn                                   = 0,
	HornOff                                  = 1,
	InstantHorn                              = 2,
	EHornSoundType_MAX                       = 3,
};

// Enum TslGame.EVehicleAnimType
// NumValues: 0x001A
enum class EVehicleAnimType : uint8
{
	DefaultDriver                            = 0,
	DefaultPassenger                         = 1,
	BuggyDriver                              = 2,
	BuggyPassenger                           = 3,
	DaciaDriver                              = 4,
	DaciaPassengerFR                         = 5,
	DaciaPassengerBL                         = 6,
	DaciaPassengerBC                         = 7,
	DaciaPassengerBR                         = 8,
	UazDriver                                = 9,
	UazPassengerFR                           = 10,
	UazPassengerBL                           = 11,
	UazPassengerBC                           = 12,
	UazPassengerBR                           = 13,
	BoatDriver                               = 14,
	BoatPassengerFR                          = 15,
	BoatPassengerBL                          = 16,
	BoatPassengerBC                          = 17,
	BoatPassengerBR                          = 18,
	MotoDriver                               = 19,
	MotoPassenger                            = 20,
	MotoSidecar                              = 21,
	MotoDriverSidecar                        = 22,
	MotoPassengerSidecar                     = 23,
	AircraftPassenger                        = 24,
	EVehicleAnimType_MAX                     = 25,
};

// Enum TslGame.ERiderType
// NumValues: 0x0003
enum class ERiderType : uint8
{
	Driver                                   = 0,
	Passenger                                = 1,
	ERiderType_MAX                           = 2,
};

// Enum TslGame.EVaultAnimType
// NumValues: 0x0020
enum class EVaultAnimType : uint8
{
	VaultNone                                = 0,
	Vault200_Stationary                      = 1,
	Vault200_Mobile                          = 2,
	Vault160_Stationary                      = 3,
	Vault160_Mobile                          = 4,
	Vault120_Stationary                      = 5,
	Vault120_Mobile                          = 6,
	Vault120_Slide                           = 7,
	Vault120_Narrow                          = 8,
	Vault90_Stationary                       = 9,
	Vault90_Mobile                           = 10,
	Vault90_Slide                            = 11,
	Vault90_Narrow                           = 12,
	Climb200_Stationary                      = 13,
	Climb200_Mobile                          = 14,
	Climb200_Slide                           = 15,
	Climb200_Narrow                          = 16,
	Climb160_Stationary                      = 17,
	Climb160_Mobile                          = 18,
	Climb160_Slide                           = 19,
	Climb160_Narrow                          = 20,
	Climb120_Stationary                      = 21,
	Climb120_Mobile                          = 22,
	Climb120_Slide                           = 23,
	Climb120_Narrow                          = 24,
	Climb90_Stationary                       = 25,
	Climb90_Mobile                           = 26,
	Climb90_Slide                            = 27,
	Climb90_Narrow                           = 28,
	Vault90Roll                              = 29,
	Vault120Window                           = 30,
	EVaultAnimType_MAX                       = 31,
};

// Enum TslGame.EPunchDamageType
// NumValues: 0x0003
enum class EPunchDamageType : uint8
{
	PunchDamage_Light                        = 0,
	PunchDamage_Heavy                        = 1,
	PunchDamage_MAX                          = 2,
};

// Enum TslGame.EMovementType
// NumValues: 0x0013
enum class EMovementType : uint8
{
	M_StandWalk                              = 0,
	M_StandRun                               = 1,
	M_StandSprint                            = 2,
	M_CrouchWalk                             = 3,
	M_CrouchRun                              = 4,
	M_CrouchSprint                           = 5,
	M_ProneWalk                              = 6,
	M_ProneRun                               = 7,
	M_ProneSprint                            = 8,
	M_StandScope                             = 9,
	M_CrouchScope                            = 10,
	M_ProneScope                             = 11,
	M_StandAim                               = 12,
	M_CrouchAim                              = 13,
	M_ProneAim                               = 14,
	M_Swim                                   = 15,
	M_UnderwaterSwim                         = 16,
	M_DBNO                                   = 17,
	M_MAX                                    = 18,
};

// Enum TslGame.EDoorState
// NumValues: 0x0005
enum class EDoorState : uint8
{
	Closed                                   = 0,
	Closing                                  = 1,
	Opened                                   = 2,
	Opening                                  = 3,
	EDoorState_MAX                           = 4,
};

// Enum TslGame.EThingGroupSpawnType
// NumValues: 0x0004
enum class EThingGroupSpawnType : uint8
{
	None                                     = 0,
	Probability                              = 1,
	TotalCount                               = 2,
	EThingGroupSpawnType_MAX                 = 3,
};

// Enum TslGame.ETeamVehicleType
// NumValues: 0x0004
enum class ETeamVehicleType : uint8
{
	Team_None                                = 0,
	Team_Vehicle                             = 1,
	Team_Parachute                           = 2,
	Team_MAX                                 = 3,
};

// Enum TslGame.EWheelContactType
// NumValues: 0x0005
enum class EWheelContactType : uint8
{
	WCT_Static                               = 0,
	WCT_Roll                                 = 1,
	WCT_LatSlip                              = 2,
	WCT_LongSlip                             = 3,
	WCT_MAX                                  = 4,
};

// Enum TslGame.EAnimPawnState
// NumValues: 0x000B
enum class EAnimPawnState : uint8
{
	PS_OnFoot                                = 0,
	PS_VehicleDriver                         = 1,
	PS_VehiclePassenger                      = 2,
	PS_Freefall                              = 3,
	PS_Parachute                             = 4,
	PS_Swim                                  = 5,
	PS_DBNO                                  = 6,
	PS_Reviving                              = 7,
	PS_Flying                                = 8,
	PS_ActiveRagdoll                         = 9,
	PS_MAX                                   = 10,
};

// Enum TslGame.EDamageVictimActorType
// NumValues: 0x0005
enum class EDamageVictimActorType : uint8
{
	Character                                = 0,
	Vehicle                                  = 1,
	Wheel                                    = 2,
	DestructibleActor                        = 3,
	EDamageVictimActorType_MAX               = 4,
};

// Enum TslGame.ETslFenceSelector
// NumValues: 0x0006
enum class ETslFenceSelector : uint8
{
	None                                     = 0,
	Use_1                                    = 1,
	Use_2                                    = 2,
	Use_3                                    = 3,
	Use_4                                    = 4,
	ETslFenceSelector_MAX                    = 5,
};

// Enum TslGame.EReactionType
// NumValues: 0x0004
enum class EReactionType : uint8
{
	Reaciton_None                            = 0,
	Reaction_Physics                         = 1,
	Reaction_Destructible                    = 2,
	EReactionType_MAX                        = 3,
};

// Enum TslGame.EPlayerAuthState
// NumValues: 0x0004
enum class EPlayerAuthState : uint8
{
	None                                     = 0,
	Login                                    = 1,
	Logout                                   = 2,
	EPlayerAuthState_MAX                     = 3,
};

// Enum TslGame.EAttachParent
// NumValues: 0x0004
enum class EAttachParent : uint8
{
	None                                     = 0,
	Character                                = 1,
	WeaponGun                                = 2,
	EAttachParent_MAX                        = 3,
};

// Enum TslGame.EProjectileExplodeState
// NumValues: 0x0004
enum class EProjectileExplodeState : uint8
{
	NotExplode                               = 0,
	ImpactExplode                            = 1,
	TimerExplode                             = 2,
	EProjectileExplodeState_MAX              = 3,
};

// Enum TslGame.EProjectileExplosionRotationType
// NumValues: 0x0003
enum class EProjectileExplosionRotationType : uint8
{
	ProjectileUpVector                       = 0,
	WorldUpVector                            = 1,
	EProjectileExplosionRotationType_MAX     = 2,
};

// Enum TslGame.EMolotovSimulationType
// NumValues: 0x0004
enum class EMolotovSimulationType : uint8
{
	Molotov_SimulationImpact                 = 0,
	Molotov_SimulationProjectile             = 1,
	Molotov_SimulationFragment               = 2,
	Molotov_MAX                              = 3,
};

// Enum TslGame.EBluezoneState
// NumValues: 0x0004
enum class EBluezoneState : uint8
{
	None                                     = 0,
	Wait                                     = 1,
	Release                                  = 2,
	EBluezoneState_MAX                       = 3,
};

// Enum TslGame.EEquipableItemIconVisibility
// NumValues: 0x0003
enum class EEquipableItemIconVisibility : uint8
{
	Always                                   = 0,
	WhenEquipped                             = 1,
	EEquipableItemIconVisibility_MAX         = 2,
};

// Enum TslGame.EMarkStates
// NumValues: 0x0007
enum class EMarkStates : uint8
{
	Normal                                   = 0,
	Groggy                                   = 1,
	Dead                                     = 2,
	Vehicle                                  = 3,
	Parachute                                = 4,
	Quitter                                  = 5,
	EMarkStates_MAX                          = 6,
};

// Enum TslGame.EMarkPosition
// NumValues: 0x000A
enum class EMarkPosition : uint8
{
	Mid                                      = 0,
	Top                                      = 1,
	Right                                    = 2,
	Left                                     = 3,
	Bottom                                   = 4,
	TopRight                                 = 5,
	TopLeft                                  = 6,
	BottomLeft                               = 7,
	BottomRight                              = 8,
	EMarkPosition_MAX                        = 9,
};

// Enum TslGame.ENoReloadGuideType
// NumValues: 0x0003
enum class ENoReloadGuideType : uint8
{
	Alwyas                                   = 0,
	WhenCurrentWeapon                        = 1,
	ENoReloadGuideType_MAX                   = 2,
};

// Enum TslGame.ESurfaceEffect
// NumValues: 0x0019
enum class ESurfaceEffect : uint8
{
	S_Concrete_Roll                          = 0,
	S_Concrete_Skid                          = 1,
	S_Concrete_Spin                          = 2,
	S_Dirt_Roll                              = 3,
	S_Dirt_Skid                              = 4,
	S_Dirt_Spin                              = 5,
	S_Water_Roll                             = 6,
	S_Water_Skid                             = 7,
	S_Water_Spin                             = 8,
	S_Metal_Roll                             = 9,
	S_Metal_Skid                             = 10,
	S_Metal_Spin                             = 11,
	S_Wood_Roll                              = 12,
	S_Wood_Skid                              = 13,
	S_Wood_Spin                              = 14,
	S_Rock_Roll                              = 15,
	S_Rock_Skid                              = 16,
	S_Rock_Spin                              = 17,
	S_Grass_Roll                             = 18,
	S_Grass_Skid                             = 19,
	S_Grass_Spin                             = 20,
	S_Sand_Roll                              = 21,
	S_Sand_Skid                              = 22,
	S_Sand_Spin                              = 23,
	S_MAX                                    = 24,
};

// Enum TslGame.EHitCheckType
// NumValues: 0x0003
enum class EHitCheckType : uint8
{
	HitCheck_Once                            = 0,
	HitCheck_Multi                           = 1,
	HitCheck_MAX                             = 2,
};

// Enum TslGame.EThrowableState
// NumValues: 0x0006
enum class EThrowableState : uint8
{
	Idle                                     = 0,
	PinOff                                   = 1,
	Cooking                                  = 2,
	Throw                                    = 3,
	Dropped                                  = 4,
	EThrowableState_MAX                      = 5,
};

// Enum TslGame.EProjectileExplosionStartType
// NumValues: 0x0005
enum class EProjectileExplosionStartType : uint8
{
	NotStart                                 = 0,
	Impact                                   = 1,
	Delay                                    = 2,
	ImpactOrDelay                            = 3,
	EProjectileExplosionStartType_MAX        = 4,
};

// Enum TslGame.EVivoxResponseState
// NumValues: 0x0005
enum class EVivoxResponseState : uint8
{
	NotRequested                             = 0,
	Requested                                = 1,
	Fail                                     = 2,
	Success                                  = 3,
	EVivoxResponseState_MAX                  = 4,
};

// Enum TslGame.EVivoxChannelType
// NumValues: 0x0005
enum class EVivoxChannelType : uint8
{
	None                                     = 0,
	All                                      = 1,
	GlobalOnly                               = 2,
	TeamOnly                                 = 3,
	EVivoxChannelType_MAX                    = 4,
};

// Enum TslGame.EVivoxChannelJoinState
// NumValues: 0x0005
enum class EVivoxChannelJoinState : uint8
{
	NotJoined                                = 0,
	Joining                                  = 1,
	Leaving                                  = 2,
	Joined                                   = 3,
	EVivoxChannelJoinState_MAX               = 4,
};

// Enum TslGame.EVivoxLoginState
// NumValues: 0x0004
enum class EVivoxLoginState : uint8
{
	NotLoggedin                              = 0,
	Loggingin                                = 1,
	Loggedin                                 = 2,
	EVivoxLoginState_MAX                     = 3,
};

// Enum TslGame.EVivoxConnectionState
// NumValues: 0x0004
enum class EVivoxConnectionState : uint8
{
	NotConnected                             = 0,
	Connecting                               = 1,
	Connected                                = 2,
	EVivoxConnectionState_MAX                = 3,
};

// ScriptStruct TslGame.Teams
// 0x0018 (0x0018 - 0x0000)
struct FTeams final
{
public:
	int32                                         TeamNum;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ATeam*>                          Members;                                           // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeams) == 0x000008, "Wrong alignment on FTeams");
static_assert(sizeof(FTeams) == 0x000018, "Wrong size on FTeams");
static_assert(offsetof(FTeams, TeamNum) == 0x000000, "Member 'FTeams::TeamNum' has a wrong offset!");
static_assert(offsetof(FTeams, Members) == 0x000008, "Member 'FTeams::Members' has a wrong offset!");

// ScriptStruct TslGame.DeathMessage
// 0x0080 (0x0080 - 0x0000)
struct FDeathMessage final
{
public:
	class FString                                 KillerName;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 VictimName;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bKillerIsOwner : 1;                                // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bVictimIsOwner : 1;                                // 0x0020(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KillerTeamNum;                                     // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VictimTeamNum;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTslDamageType*                         DamageType;                                        // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   InsertMessage;                                     // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	EDamageReason                                 DamageReason;                                      // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGroggy;                                           // 0x0051(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AlivePlayerNum;                                    // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AliveTeamNum;                                      // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DamageCauserName;                                  // 0x0060(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	bool                                          bIsKillerExist;                                    // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStealKilled;                                    // 0x0079(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x6];                                       // 0x007A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDeathMessage) == 0x000008, "Wrong alignment on FDeathMessage");
static_assert(sizeof(FDeathMessage) == 0x000080, "Wrong size on FDeathMessage");
static_assert(offsetof(FDeathMessage, KillerName) == 0x000000, "Member 'FDeathMessage::KillerName' has a wrong offset!");
static_assert(offsetof(FDeathMessage, VictimName) == 0x000010, "Member 'FDeathMessage::VictimName' has a wrong offset!");
static_assert(offsetof(FDeathMessage, KillerTeamNum) == 0x000024, "Member 'FDeathMessage::KillerTeamNum' has a wrong offset!");
static_assert(offsetof(FDeathMessage, VictimTeamNum) == 0x000028, "Member 'FDeathMessage::VictimTeamNum' has a wrong offset!");
static_assert(offsetof(FDeathMessage, DamageType) == 0x000030, "Member 'FDeathMessage::DamageType' has a wrong offset!");
static_assert(offsetof(FDeathMessage, InsertMessage) == 0x000038, "Member 'FDeathMessage::InsertMessage' has a wrong offset!");
static_assert(offsetof(FDeathMessage, DamageReason) == 0x000050, "Member 'FDeathMessage::DamageReason' has a wrong offset!");
static_assert(offsetof(FDeathMessage, bGroggy) == 0x000051, "Member 'FDeathMessage::bGroggy' has a wrong offset!");
static_assert(offsetof(FDeathMessage, AlivePlayerNum) == 0x000054, "Member 'FDeathMessage::AlivePlayerNum' has a wrong offset!");
static_assert(offsetof(FDeathMessage, AliveTeamNum) == 0x000058, "Member 'FDeathMessage::AliveTeamNum' has a wrong offset!");
static_assert(offsetof(FDeathMessage, DamageCauserName) == 0x000060, "Member 'FDeathMessage::DamageCauserName' has a wrong offset!");
static_assert(offsetof(FDeathMessage, bIsKillerExist) == 0x000078, "Member 'FDeathMessage::bIsKillerExist' has a wrong offset!");
static_assert(offsetof(FDeathMessage, bIsStealKilled) == 0x000079, "Member 'FDeathMessage::bIsStealKilled' has a wrong offset!");

// ScriptStruct TslGame.WuLogVehicle
// 0x0028 (0x0028 - 0x0000)
struct FWuLogVehicle final
{
public:
	class FString                                 VehicleType;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 VehicleId;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HealthPercent;                                     // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FeulPercent;                                       // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuLogVehicle) == 0x000008, "Wrong alignment on FWuLogVehicle");
static_assert(sizeof(FWuLogVehicle) == 0x000028, "Wrong size on FWuLogVehicle");
static_assert(offsetof(FWuLogVehicle, VehicleType) == 0x000000, "Member 'FWuLogVehicle::VehicleType' has a wrong offset!");
static_assert(offsetof(FWuLogVehicle, VehicleId) == 0x000010, "Member 'FWuLogVehicle::VehicleId' has a wrong offset!");
static_assert(offsetof(FWuLogVehicle, HealthPercent) == 0x000020, "Member 'FWuLogVehicle::HealthPercent' has a wrong offset!");
static_assert(offsetof(FWuLogVehicle, FeulPercent) == 0x000024, "Member 'FWuLogVehicle::FeulPercent' has a wrong offset!");

// ScriptStruct TslGame.LobbyFaceElementDetail
// 0x0048 (0x0048 - 0x0000)
struct FLobbyFaceElementDetail final
{
public:
	int32                                         ColorIndex;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCustomizableObject>     BodyAsset;                                         // 0x0008(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCustomizableObject>     FaceAsset;                                         // 0x0028(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLobbyFaceElementDetail) == 0x000008, "Wrong alignment on FLobbyFaceElementDetail");
static_assert(sizeof(FLobbyFaceElementDetail) == 0x000048, "Wrong size on FLobbyFaceElementDetail");
static_assert(offsetof(FLobbyFaceElementDetail, ColorIndex) == 0x000000, "Member 'FLobbyFaceElementDetail::ColorIndex' has a wrong offset!");
static_assert(offsetof(FLobbyFaceElementDetail, Color) == 0x000004, "Member 'FLobbyFaceElementDetail::Color' has a wrong offset!");
static_assert(offsetof(FLobbyFaceElementDetail, BodyAsset) == 0x000008, "Member 'FLobbyFaceElementDetail::BodyAsset' has a wrong offset!");
static_assert(offsetof(FLobbyFaceElementDetail, FaceAsset) == 0x000028, "Member 'FLobbyFaceElementDetail::FaceAsset' has a wrong offset!");

// ScriptStruct TslGame.LobbyFaceElement
// 0x0028 (0x0028 - 0x0000)
struct FLobbyFaceElement final
{
public:
	EGender                                       Gender;                                            // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 FaceType;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLobbyFaceElementDetail>        ColorData;                                         // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLobbyFaceElement) == 0x000008, "Wrong alignment on FLobbyFaceElement");
static_assert(sizeof(FLobbyFaceElement) == 0x000028, "Wrong size on FLobbyFaceElement");
static_assert(offsetof(FLobbyFaceElement, Gender) == 0x000000, "Member 'FLobbyFaceElement::Gender' has a wrong offset!");
static_assert(offsetof(FLobbyFaceElement, FaceType) == 0x000008, "Member 'FLobbyFaceElement::FaceType' has a wrong offset!");
static_assert(offsetof(FLobbyFaceElement, ColorData) == 0x000018, "Member 'FLobbyFaceElement::ColorData' has a wrong offset!");

// ScriptStruct TslGame.TslStartParameter
// 0x0080 (0x0080 - 0x0000)
struct FTslStartParameter final
{
public:
	bool                                          bIsCustomGame;                                     // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MapName;                                           // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchId;                                           // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinPlayerCount;                                    // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPlayerCount;                                    // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            StringParameter;                                   // 0x0030(0x0050)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTslStartParameter) == 0x000008, "Wrong alignment on FTslStartParameter");
static_assert(sizeof(FTslStartParameter) == 0x000080, "Wrong size on FTslStartParameter");
static_assert(offsetof(FTslStartParameter, bIsCustomGame) == 0x000000, "Member 'FTslStartParameter::bIsCustomGame' has a wrong offset!");
static_assert(offsetof(FTslStartParameter, MapName) == 0x000008, "Member 'FTslStartParameter::MapName' has a wrong offset!");
static_assert(offsetof(FTslStartParameter, MatchId) == 0x000018, "Member 'FTslStartParameter::MatchId' has a wrong offset!");
static_assert(offsetof(FTslStartParameter, MinPlayerCount) == 0x000028, "Member 'FTslStartParameter::MinPlayerCount' has a wrong offset!");
static_assert(offsetof(FTslStartParameter, MaxPlayerCount) == 0x00002C, "Member 'FTslStartParameter::MaxPlayerCount' has a wrong offset!");
static_assert(offsetof(FTslStartParameter, StringParameter) == 0x000030, "Member 'FTslStartParameter::StringParameter' has a wrong offset!");

// ScriptStruct TslGame.TslSplinePoint
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FTslSplinePoint final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTslSplinePoint) == 0x000004, "Wrong alignment on FTslSplinePoint");
static_assert(sizeof(FTslSplinePoint) == 0x00001C, "Wrong size on FTslSplinePoint");

// ScriptStruct TslGame.TslInputKey
// 0x0020 (0x0020 - 0x0000)
struct FTslInputKey final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         bShift : 1;                                        // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bCtrl : 1;                                         // 0x0018(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAlt : 1;                                          // 0x0018(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTslInputKey) == 0x000008, "Wrong alignment on FTslInputKey");
static_assert(sizeof(FTslInputKey) == 0x000020, "Wrong size on FTslInputKey");
static_assert(offsetof(FTslInputKey, Key) == 0x000000, "Member 'FTslInputKey::Key' has a wrong offset!");

// ScriptStruct TslGame.VehicleEffectInfo
// 0x00F0 (0x00F0 - 0x0000)
struct FVehicleEffectInfo final
{
public:
	TSubclassOf<class ATslParticle>               Explosion;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamagedPercentMax;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATslParticle>               Damaged;                                           // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               Destroyed;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          EngineSound;                                       // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          EngineSound_Remote;                                // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               Muffler;                                           // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               Muffler2;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               Boost;                                             // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               Boost2;                                            // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               FrontTrail;                                        // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               RearTrail;                                         // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               Thruster;                                          // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               Thruster2;                                         // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               FrontFoamLeft;                                     // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               FrontFoamRight;                                    // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            ImpactNormalForceRange;                            // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               ImpactDefault;                                     // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               ImpactConcrete;                                    // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               ImpactDirt;                                        // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               ImpactWater;                                       // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               ImpactMetal;                                       // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               ImpactWood;                                        // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               ImpactGlass;                                       // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               ImpactGrass;                                       // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               ImpactRock;                                        // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               ImpactSand;                                        // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               ImpactFlesh;                                       // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxImpactCount;                                    // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVehicleEffectInfo) == 0x000008, "Wrong alignment on FVehicleEffectInfo");
static_assert(sizeof(FVehicleEffectInfo) == 0x0000F0, "Wrong size on FVehicleEffectInfo");
static_assert(offsetof(FVehicleEffectInfo, Explosion) == 0x000000, "Member 'FVehicleEffectInfo::Explosion' has a wrong offset!");
static_assert(offsetof(FVehicleEffectInfo, DamagedPercentMax) == 0x000008, "Member 'FVehicleEffectInfo::DamagedPercentMax' has a wrong offset!");
static_assert(offsetof(FVehicleEffectInfo, Damaged) == 0x000010, "Member 'FVehicleEffectInfo::Damaged' has a wrong offset!");
static_assert(offsetof(FVehicleEffectInfo, Destroyed) == 0x000018, "Member 'FVehicleEffectInfo::Destroyed' has a wrong offset!");
static_assert(offsetof(FVehicleEffectInfo, EngineSound) == 0x000020, "Member 'FVehicleEffectInfo::EngineSound' has a wrong offset!");
static_assert(offsetof(FVehicleEffectInfo, EngineSound_Remote) == 0x000028, "Member 'FVehicleEffectInfo::EngineSound_Remote' has a wrong offset!");
static_assert(offsetof(FVehicleEffectInfo, Muffler) == 0x000030, "Member 'FVehicleEffectInfo::Muffler' has a wrong offset!");
static_assert(offsetof(FVehicleEffectInfo, Muffler2) == 0x000038, "Member 'FVehicleEffectInfo::Muffler2' has a wrong offset!");
static_assert(offsetof(FVehicleEffectInfo, Boost) == 0x000040, "Member 'FVehicleEffectInfo::Boost' has a wrong offset!");
static_assert(offsetof(FVehicleEffectInfo, Boost2) == 0x000048, "Member 'FVehicleEffectInfo::Boost2' has a wrong offset!");
static_assert(offsetof(FVehicleEffectInfo, FrontTrail) == 0x000050, "Member 'FVehicleEffectInfo::FrontTrail' has a wrong offset!");
static_assert(offsetof(FVehicleEffectInfo, RearTrail) == 0x000058, "Member 'FVehicleEffectInfo::RearTrail' has a wrong offset!");
static_assert(offsetof(FVehicleEffectInfo, Thruster) == 0x000060, "Member 'FVehicleEffectInfo::Thruster' has a wrong offset!");
static_assert(offsetof(FVehicleEffectInfo, Thruster2) == 0x000068, "Member 'FVehicleEffectInfo::Thruster2' has a wrong offset!");
static_assert(offsetof(FVehicleEffectInfo, FrontFoamLeft) == 0x000070, "Member 'FVehicleEffectInfo::FrontFoamLeft' has a wrong offset!");
static_assert(offsetof(FVehicleEffectInfo, FrontFoamRight) == 0x000078, "Member 'FVehicleEffectInfo::FrontFoamRight' has a wrong offset!");
static_assert(offsetof(FVehicleEffectInfo, ImpactNormalForceRange) == 0x000080, "Member 'FVehicleEffectInfo::ImpactNormalForceRange' has a wrong offset!");
static_assert(offsetof(FVehicleEffectInfo, ImpactDefault) == 0x000090, "Member 'FVehicleEffectInfo::ImpactDefault' has a wrong offset!");
static_assert(offsetof(FVehicleEffectInfo, ImpactConcrete) == 0x000098, "Member 'FVehicleEffectInfo::ImpactConcrete' has a wrong offset!");
static_assert(offsetof(FVehicleEffectInfo, ImpactDirt) == 0x0000A0, "Member 'FVehicleEffectInfo::ImpactDirt' has a wrong offset!");
static_assert(offsetof(FVehicleEffectInfo, ImpactWater) == 0x0000A8, "Member 'FVehicleEffectInfo::ImpactWater' has a wrong offset!");
static_assert(offsetof(FVehicleEffectInfo, ImpactMetal) == 0x0000B0, "Member 'FVehicleEffectInfo::ImpactMetal' has a wrong offset!");
static_assert(offsetof(FVehicleEffectInfo, ImpactWood) == 0x0000B8, "Member 'FVehicleEffectInfo::ImpactWood' has a wrong offset!");
static_assert(offsetof(FVehicleEffectInfo, ImpactGlass) == 0x0000C0, "Member 'FVehicleEffectInfo::ImpactGlass' has a wrong offset!");
static_assert(offsetof(FVehicleEffectInfo, ImpactGrass) == 0x0000C8, "Member 'FVehicleEffectInfo::ImpactGrass' has a wrong offset!");
static_assert(offsetof(FVehicleEffectInfo, ImpactRock) == 0x0000D0, "Member 'FVehicleEffectInfo::ImpactRock' has a wrong offset!");
static_assert(offsetof(FVehicleEffectInfo, ImpactSand) == 0x0000D8, "Member 'FVehicleEffectInfo::ImpactSand' has a wrong offset!");
static_assert(offsetof(FVehicleEffectInfo, ImpactFlesh) == 0x0000E0, "Member 'FVehicleEffectInfo::ImpactFlesh' has a wrong offset!");
static_assert(offsetof(FVehicleEffectInfo, MaxImpactCount) == 0x0000E8, "Member 'FVehicleEffectInfo::MaxImpactCount' has a wrong offset!");

// ScriptStruct TslGame.ItemSpawnTogetherDataRow
// 0x0030 (0x0038 - 0x0008)
struct FItemSpawnTogetherDataRow final : public FTableRowBase
{
public:
	struct FName                                   ValueFilter;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FName                                   CategoryFilter;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UItem>                      SpawnedItem;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UItem>                      TogetherItem;                                      // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackCount;                                        // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountMin;                                          // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountMax;                                          // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemSpawnTogetherDataRow) == 0x000008, "Wrong alignment on FItemSpawnTogetherDataRow");
static_assert(sizeof(FItemSpawnTogetherDataRow) == 0x000038, "Wrong size on FItemSpawnTogetherDataRow");
static_assert(offsetof(FItemSpawnTogetherDataRow, ValueFilter) == 0x000008, "Member 'FItemSpawnTogetherDataRow::ValueFilter' has a wrong offset!");
static_assert(offsetof(FItemSpawnTogetherDataRow, CategoryFilter) == 0x000010, "Member 'FItemSpawnTogetherDataRow::CategoryFilter' has a wrong offset!");
static_assert(offsetof(FItemSpawnTogetherDataRow, SpawnedItem) == 0x000018, "Member 'FItemSpawnTogetherDataRow::SpawnedItem' has a wrong offset!");
static_assert(offsetof(FItemSpawnTogetherDataRow, TogetherItem) == 0x000020, "Member 'FItemSpawnTogetherDataRow::TogetherItem' has a wrong offset!");
static_assert(offsetof(FItemSpawnTogetherDataRow, StackCount) == 0x000028, "Member 'FItemSpawnTogetherDataRow::StackCount' has a wrong offset!");
static_assert(offsetof(FItemSpawnTogetherDataRow, CountMin) == 0x00002C, "Member 'FItemSpawnTogetherDataRow::CountMin' has a wrong offset!");
static_assert(offsetof(FItemSpawnTogetherDataRow, CountMax) == 0x000030, "Member 'FItemSpawnTogetherDataRow::CountMax' has a wrong offset!");

// ScriptStruct TslGame.ReplayItem
// 0x0040 (0x0040 - 0x0000)
struct FReplayItem final
{
public:
	class FString                                 FriendlyName;                                      // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLive;                                           // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              Date;                                              // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         SizeInBytes;                                       // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LengthInMS;                                        // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumViewers;                                        // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReplayItem) == 0x000008, "Wrong alignment on FReplayItem");
static_assert(sizeof(FReplayItem) == 0x000040, "Wrong size on FReplayItem");
static_assert(offsetof(FReplayItem, FriendlyName) == 0x000000, "Member 'FReplayItem::FriendlyName' has a wrong offset!");
static_assert(offsetof(FReplayItem, Name) == 0x000010, "Member 'FReplayItem::Name' has a wrong offset!");
static_assert(offsetof(FReplayItem, bIsLive) == 0x000020, "Member 'FReplayItem::bIsLive' has a wrong offset!");
static_assert(offsetof(FReplayItem, Date) == 0x000028, "Member 'FReplayItem::Date' has a wrong offset!");
static_assert(offsetof(FReplayItem, SizeInBytes) == 0x000030, "Member 'FReplayItem::SizeInBytes' has a wrong offset!");
static_assert(offsetof(FReplayItem, LengthInMS) == 0x000034, "Member 'FReplayItem::LengthInMS' has a wrong offset!");
static_assert(offsetof(FReplayItem, NumViewers) == 0x000038, "Member 'FReplayItem::NumViewers' has a wrong offset!");

// ScriptStruct TslGame.TslFriendPresence
// 0x0005 (0x0005 - 0x0000)
struct FTslFriendPresence final
{
public:
	bool                                          IsOnline;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPlaying;                                         // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPlayingThisGame;                                 // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsJoinable;                                        // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Status;                                            // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTslFriendPresence) == 0x000001, "Wrong alignment on FTslFriendPresence");
static_assert(sizeof(FTslFriendPresence) == 0x000005, "Wrong size on FTslFriendPresence");
static_assert(offsetof(FTslFriendPresence, IsOnline) == 0x000000, "Member 'FTslFriendPresence::IsOnline' has a wrong offset!");
static_assert(offsetof(FTslFriendPresence, IsPlaying) == 0x000001, "Member 'FTslFriendPresence::IsPlaying' has a wrong offset!");
static_assert(offsetof(FTslFriendPresence, IsPlayingThisGame) == 0x000002, "Member 'FTslFriendPresence::IsPlayingThisGame' has a wrong offset!");
static_assert(offsetof(FTslFriendPresence, IsJoinable) == 0x000003, "Member 'FTslFriendPresence::IsJoinable' has a wrong offset!");
static_assert(offsetof(FTslFriendPresence, Status) == 0x000004, "Member 'FTslFriendPresence::Status' has a wrong offset!");

// ScriptStruct TslGame.ReplayKillEventItem
// 0x0004 (0x0004 - 0x0000)
struct FReplayKillEventItem final
{
public:
	int32                                         Time;                                              // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReplayKillEventItem) == 0x000004, "Wrong alignment on FReplayKillEventItem");
static_assert(sizeof(FReplayKillEventItem) == 0x000004, "Wrong size on FReplayKillEventItem");
static_assert(offsetof(FReplayKillEventItem, Time) == 0x000000, "Member 'FReplayKillEventItem::Time' has a wrong offset!");

// ScriptStruct TslGame.SequenceBase
// 0x0098 (0x0098 - 0x0000)
struct FSequenceBase
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            Widget;                                            // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20[0x78];                                      // 0x0020(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSequenceBase) == 0x000008, "Wrong alignment on FSequenceBase");
static_assert(sizeof(FSequenceBase) == 0x000098, "Wrong size on FSequenceBase");
static_assert(offsetof(FSequenceBase, Widget) == 0x000018, "Member 'FSequenceBase::Widget' has a wrong offset!");

// ScriptStruct TslGame.Sequence_Vector
// 0x0008 (0x00A0 - 0x0098)
struct FSequence_Vector final : public FSequenceBase
{
public:
	class UCurveVector*                           VectorCurve;                                       // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSequence_Vector) == 0x000008, "Wrong alignment on FSequence_Vector");
static_assert(sizeof(FSequence_Vector) == 0x0000A0, "Wrong size on FSequence_Vector");
static_assert(offsetof(FSequence_Vector, VectorCurve) == 0x000098, "Member 'FSequence_Vector::VectorCurve' has a wrong offset!");

// ScriptStruct TslGame.TslWidgetConfig
// 0x0010 (0x0010 - 0x0000)
struct FTslWidgetConfig final
{
public:
	TSubclassOf<class UUserWidget>                WidgetClass;                                       // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefaultShow;                                      // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMouse;                                         // 0x0009(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCloseByEscape;                                    // 0x000A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ZOrder;                                            // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTslWidgetConfig) == 0x000008, "Wrong alignment on FTslWidgetConfig");
static_assert(sizeof(FTslWidgetConfig) == 0x000010, "Wrong size on FTslWidgetConfig");
static_assert(offsetof(FTslWidgetConfig, WidgetClass) == 0x000000, "Member 'FTslWidgetConfig::WidgetClass' has a wrong offset!");
static_assert(offsetof(FTslWidgetConfig, bDefaultShow) == 0x000008, "Member 'FTslWidgetConfig::bDefaultShow' has a wrong offset!");
static_assert(offsetof(FTslWidgetConfig, bUseMouse) == 0x000009, "Member 'FTslWidgetConfig::bUseMouse' has a wrong offset!");
static_assert(offsetof(FTslWidgetConfig, bCloseByEscape) == 0x00000A, "Member 'FTslWidgetConfig::bCloseByEscape' has a wrong offset!");
static_assert(offsetof(FTslWidgetConfig, ZOrder) == 0x00000C, "Member 'FTslWidgetConfig::ZOrder' has a wrong offset!");

// ScriptStruct TslGame.TslWidgetState
// 0x0020 (0x0020 - 0x0000)
struct FTslWidgetState final
{
public:
	struct FTslWidgetConfig                       Config;                                            // 0x0000(0x0010)(NativeAccessSpecifierPublic)
	class UUserWidget*                            Widget;                                            // 0x0010(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTslWidgetState) == 0x000008, "Wrong alignment on FTslWidgetState");
static_assert(sizeof(FTslWidgetState) == 0x000020, "Wrong size on FTslWidgetState");
static_assert(offsetof(FTslWidgetState, Config) == 0x000000, "Member 'FTslWidgetState::Config' has a wrong offset!");
static_assert(offsetof(FTslWidgetState, Widget) == 0x000010, "Member 'FTslWidgetState::Widget' has a wrong offset!");

// ScriptStruct TslGame.TslReportedInfo
// 0x0028 (0x0028 - 0x0000)
struct FTslReportedInfo final
{
public:
	class FString                                 PlayerName;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NetId;                                             // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamId;                                            // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Ranking;                                           // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTslReportedInfo) == 0x000008, "Wrong alignment on FTslReportedInfo");
static_assert(sizeof(FTslReportedInfo) == 0x000028, "Wrong size on FTslReportedInfo");
static_assert(offsetof(FTslReportedInfo, PlayerName) == 0x000000, "Member 'FTslReportedInfo::PlayerName' has a wrong offset!");
static_assert(offsetof(FTslReportedInfo, NetId) == 0x000010, "Member 'FTslReportedInfo::NetId' has a wrong offset!");
static_assert(offsetof(FTslReportedInfo, TeamId) == 0x000020, "Member 'FTslReportedInfo::TeamId' has a wrong offset!");
static_assert(offsetof(FTslReportedInfo, Ranking) == 0x000024, "Member 'FTslReportedInfo::Ranking' has a wrong offset!");

// ScriptStruct TslGame.AnimSpeedInfo
// 0x0020 (0x0020 - 0x0000)
struct FAnimSpeedInfo final
{
public:
	float                                         F;                                                 // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         L;                                                 // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         R;                                                 // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FL;                                                // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FR;                                                // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BL;                                                // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BR;                                                // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimSpeedInfo) == 0x000004, "Wrong alignment on FAnimSpeedInfo");
static_assert(sizeof(FAnimSpeedInfo) == 0x000020, "Wrong size on FAnimSpeedInfo");
static_assert(offsetof(FAnimSpeedInfo, F) == 0x000000, "Member 'FAnimSpeedInfo::F' has a wrong offset!");
static_assert(offsetof(FAnimSpeedInfo, L) == 0x000004, "Member 'FAnimSpeedInfo::L' has a wrong offset!");
static_assert(offsetof(FAnimSpeedInfo, R) == 0x000008, "Member 'FAnimSpeedInfo::R' has a wrong offset!");
static_assert(offsetof(FAnimSpeedInfo, B) == 0x00000C, "Member 'FAnimSpeedInfo::B' has a wrong offset!");
static_assert(offsetof(FAnimSpeedInfo, FL) == 0x000010, "Member 'FAnimSpeedInfo::FL' has a wrong offset!");
static_assert(offsetof(FAnimSpeedInfo, FR) == 0x000014, "Member 'FAnimSpeedInfo::FR' has a wrong offset!");
static_assert(offsetof(FAnimSpeedInfo, BL) == 0x000018, "Member 'FAnimSpeedInfo::BL' has a wrong offset!");
static_assert(offsetof(FAnimSpeedInfo, BR) == 0x00001C, "Member 'FAnimSpeedInfo::BR' has a wrong offset!");

// ScriptStruct TslGame.AnimInfo
// 0x0068 (0x0068 - 0x0000)
struct FAnimInfo final
{
public:
	class UBlendSpace*                            BlendSpaceRef;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BlendSpaceFPPRef;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BlendSpaceRelaxedRef;                              // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace*                            BlendSpaceRelaxedFPPRef;                           // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnimSpeedInfo                         AnimSpeed_Walk;                                    // 0x0020(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FAnimSpeedInfo                         AnimSpeed_Run;                                     // 0x0040(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AnimSpeed_Sprint;                                  // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimInfo) == 0x000008, "Wrong alignment on FAnimInfo");
static_assert(sizeof(FAnimInfo) == 0x000068, "Wrong size on FAnimInfo");
static_assert(offsetof(FAnimInfo, BlendSpaceRef) == 0x000000, "Member 'FAnimInfo::BlendSpaceRef' has a wrong offset!");
static_assert(offsetof(FAnimInfo, BlendSpaceFPPRef) == 0x000008, "Member 'FAnimInfo::BlendSpaceFPPRef' has a wrong offset!");
static_assert(offsetof(FAnimInfo, BlendSpaceRelaxedRef) == 0x000010, "Member 'FAnimInfo::BlendSpaceRelaxedRef' has a wrong offset!");
static_assert(offsetof(FAnimInfo, BlendSpaceRelaxedFPPRef) == 0x000018, "Member 'FAnimInfo::BlendSpaceRelaxedFPPRef' has a wrong offset!");
static_assert(offsetof(FAnimInfo, AnimSpeed_Walk) == 0x000020, "Member 'FAnimInfo::AnimSpeed_Walk' has a wrong offset!");
static_assert(offsetof(FAnimInfo, AnimSpeed_Run) == 0x000040, "Member 'FAnimInfo::AnimSpeed_Run' has a wrong offset!");
static_assert(offsetof(FAnimInfo, AnimSpeed_Sprint) == 0x000060, "Member 'FAnimInfo::AnimSpeed_Sprint' has a wrong offset!");

// ScriptStruct TslGame.MaterialParametersData
// 0x0020 (0x0020 - 0x0000)
struct FMaterialParametersData final
{
public:
	TArray<struct FLinearColor>                   Vectors;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UTexture*>                       Textures;                                          // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialParametersData) == 0x000008, "Wrong alignment on FMaterialParametersData");
static_assert(sizeof(FMaterialParametersData) == 0x000020, "Wrong size on FMaterialParametersData");
static_assert(offsetof(FMaterialParametersData, Vectors) == 0x000000, "Member 'FMaterialParametersData::Vectors' has a wrong offset!");
static_assert(offsetof(FMaterialParametersData, Textures) == 0x000010, "Member 'FMaterialParametersData::Textures' has a wrong offset!");

// ScriptStruct TslGame.WeaponData
// 0x0090 (0x0090 - 0x0000)
struct FWeaponData final
{
public:
	float                                         TargetingFOV;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HoldBreathFOV;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FName                                   Rarity;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SocketOffset_Shoulder;                             // 0x0010(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                SocketOffset_Hand;                                 // 0x001C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bApplyGripPoseLeft;                                // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponGripLeftHand                           WeaponGripLeft;                                    // 0x0029(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponClass                                  WeaponClass;                                       // 0x002A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDefaultScoreMultiplier;                        // 0x002B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScoreMultiplierByDamage;                           // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScoreMultiplierByKill;                             // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwayModifier_Pitch;                                // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwayModifier_YawOffset;                            // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwayModifier_Movement;                             // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwayModifier_Stand;                                // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwayModifier_Crouch;                               // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwayModifier_Prone;                                // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraDOF_Range;                                   // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraDOF_NearRange;                               // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraDOF_Power;                                   // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDynamicReverbAK;                               // 0x0058(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentWeaponZero;                                 // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinWeaponZero;                                     // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxWeaponZero;                                     // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationKick;                                     // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           RecoilMontage;                                     // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DestructibleDoor;                                  // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EThrownWeaponType                             ThrownType;                                        // 0x0079(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x2];                                       // 0x007A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WeaponEquipDuration;                               // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponReadyDuration;                               // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceFireAfterEquip;                              // 0x0084(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PhysicalBodyHitImpactPower;                        // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponData) == 0x000008, "Wrong alignment on FWeaponData");
static_assert(sizeof(FWeaponData) == 0x000090, "Wrong size on FWeaponData");
static_assert(offsetof(FWeaponData, TargetingFOV) == 0x000000, "Member 'FWeaponData::TargetingFOV' has a wrong offset!");
static_assert(offsetof(FWeaponData, HoldBreathFOV) == 0x000004, "Member 'FWeaponData::HoldBreathFOV' has a wrong offset!");
static_assert(offsetof(FWeaponData, Rarity) == 0x000008, "Member 'FWeaponData::Rarity' has a wrong offset!");
static_assert(offsetof(FWeaponData, SocketOffset_Shoulder) == 0x000010, "Member 'FWeaponData::SocketOffset_Shoulder' has a wrong offset!");
static_assert(offsetof(FWeaponData, SocketOffset_Hand) == 0x00001C, "Member 'FWeaponData::SocketOffset_Hand' has a wrong offset!");
static_assert(offsetof(FWeaponData, bApplyGripPoseLeft) == 0x000028, "Member 'FWeaponData::bApplyGripPoseLeft' has a wrong offset!");
static_assert(offsetof(FWeaponData, WeaponGripLeft) == 0x000029, "Member 'FWeaponData::WeaponGripLeft' has a wrong offset!");
static_assert(offsetof(FWeaponData, WeaponClass) == 0x00002A, "Member 'FWeaponData::WeaponClass' has a wrong offset!");
static_assert(offsetof(FWeaponData, bUseDefaultScoreMultiplier) == 0x00002B, "Member 'FWeaponData::bUseDefaultScoreMultiplier' has a wrong offset!");
static_assert(offsetof(FWeaponData, ScoreMultiplierByDamage) == 0x00002C, "Member 'FWeaponData::ScoreMultiplierByDamage' has a wrong offset!");
static_assert(offsetof(FWeaponData, ScoreMultiplierByKill) == 0x000030, "Member 'FWeaponData::ScoreMultiplierByKill' has a wrong offset!");
static_assert(offsetof(FWeaponData, SwayModifier_Pitch) == 0x000034, "Member 'FWeaponData::SwayModifier_Pitch' has a wrong offset!");
static_assert(offsetof(FWeaponData, SwayModifier_YawOffset) == 0x000038, "Member 'FWeaponData::SwayModifier_YawOffset' has a wrong offset!");
static_assert(offsetof(FWeaponData, SwayModifier_Movement) == 0x00003C, "Member 'FWeaponData::SwayModifier_Movement' has a wrong offset!");
static_assert(offsetof(FWeaponData, SwayModifier_Stand) == 0x000040, "Member 'FWeaponData::SwayModifier_Stand' has a wrong offset!");
static_assert(offsetof(FWeaponData, SwayModifier_Crouch) == 0x000044, "Member 'FWeaponData::SwayModifier_Crouch' has a wrong offset!");
static_assert(offsetof(FWeaponData, SwayModifier_Prone) == 0x000048, "Member 'FWeaponData::SwayModifier_Prone' has a wrong offset!");
static_assert(offsetof(FWeaponData, CameraDOF_Range) == 0x00004C, "Member 'FWeaponData::CameraDOF_Range' has a wrong offset!");
static_assert(offsetof(FWeaponData, CameraDOF_NearRange) == 0x000050, "Member 'FWeaponData::CameraDOF_NearRange' has a wrong offset!");
static_assert(offsetof(FWeaponData, CameraDOF_Power) == 0x000054, "Member 'FWeaponData::CameraDOF_Power' has a wrong offset!");
static_assert(offsetof(FWeaponData, bUseDynamicReverbAK) == 0x000058, "Member 'FWeaponData::bUseDynamicReverbAK' has a wrong offset!");
static_assert(offsetof(FWeaponData, CurrentWeaponZero) == 0x00005C, "Member 'FWeaponData::CurrentWeaponZero' has a wrong offset!");
static_assert(offsetof(FWeaponData, MinWeaponZero) == 0x000060, "Member 'FWeaponData::MinWeaponZero' has a wrong offset!");
static_assert(offsetof(FWeaponData, MaxWeaponZero) == 0x000064, "Member 'FWeaponData::MaxWeaponZero' has a wrong offset!");
static_assert(offsetof(FWeaponData, AnimationKick) == 0x000068, "Member 'FWeaponData::AnimationKick' has a wrong offset!");
static_assert(offsetof(FWeaponData, RecoilMontage) == 0x000070, "Member 'FWeaponData::RecoilMontage' has a wrong offset!");
static_assert(offsetof(FWeaponData, DestructibleDoor) == 0x000078, "Member 'FWeaponData::DestructibleDoor' has a wrong offset!");
static_assert(offsetof(FWeaponData, ThrownType) == 0x000079, "Member 'FWeaponData::ThrownType' has a wrong offset!");
static_assert(offsetof(FWeaponData, WeaponEquipDuration) == 0x00007C, "Member 'FWeaponData::WeaponEquipDuration' has a wrong offset!");
static_assert(offsetof(FWeaponData, WeaponReadyDuration) == 0x000080, "Member 'FWeaponData::WeaponReadyDuration' has a wrong offset!");
static_assert(offsetof(FWeaponData, bForceFireAfterEquip) == 0x000084, "Member 'FWeaponData::bForceFireAfterEquip' has a wrong offset!");
static_assert(offsetof(FWeaponData, PhysicalBodyHitImpactPower) == 0x000088, "Member 'FWeaponData::PhysicalBodyHitImpactPower' has a wrong offset!");

// ScriptStruct TslGame.WeaponAttachmentData
// 0x00B8 (0x00B8 - 0x0000)
struct FWeaponAttachmentData final
{
public:
	EWeaponAttachmentSlotID                       AttachmentSlotID;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FName                                   AttachmentTag;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FName                                   Name;                                              // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FName                                   MouseSensitiveName;                                // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Magnification;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecreaseRecoilPatternScale;                        // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmmoPerClip;                                       // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReloadAnimationPlayRate;                           // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MultipleFiringBulletsSpread;                       // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MultipleFiringSpreadBase;                          // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MultipleAmmoSpeed;                                 // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilMultiplierHorizontal;                        // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilMultiplierVertical;                          // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilRecoveryMultiplier;                          // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwayMultiplier;                                    // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationKickMultiplier;                           // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeviationMultiplier;                               // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ADSSpeedMultiplier;                                // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GripType_MN;                                       // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarrelLengthAdditive;                              // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        MuzzleFx;                                          // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FName                                   MuzzleAttachPoint;                                 // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                IKHandOffset;                                      // 0x0070(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               IKHandRotation;                                    // 0x007C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EWeaponGripLeftHand                           WeaponGripLeft;                                    // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          MuzzleSound;                                       // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CharacterReloadTactical;                           // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           WeaponReloadTactical;                              // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CharacterReloadCharge;                             // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           WeaponReloadCharge;                                // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponAttachmentData) == 0x000008, "Wrong alignment on FWeaponAttachmentData");
static_assert(sizeof(FWeaponAttachmentData) == 0x0000B8, "Wrong size on FWeaponAttachmentData");
static_assert(offsetof(FWeaponAttachmentData, AttachmentSlotID) == 0x000000, "Member 'FWeaponAttachmentData::AttachmentSlotID' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentData, AttachmentTag) == 0x000008, "Member 'FWeaponAttachmentData::AttachmentTag' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentData, Name) == 0x000010, "Member 'FWeaponAttachmentData::Name' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentData, MouseSensitiveName) == 0x000018, "Member 'FWeaponAttachmentData::MouseSensitiveName' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentData, Magnification) == 0x000020, "Member 'FWeaponAttachmentData::Magnification' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentData, DecreaseRecoilPatternScale) == 0x000024, "Member 'FWeaponAttachmentData::DecreaseRecoilPatternScale' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentData, AmmoPerClip) == 0x000028, "Member 'FWeaponAttachmentData::AmmoPerClip' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentData, ReloadAnimationPlayRate) == 0x00002C, "Member 'FWeaponAttachmentData::ReloadAnimationPlayRate' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentData, MultipleFiringBulletsSpread) == 0x000030, "Member 'FWeaponAttachmentData::MultipleFiringBulletsSpread' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentData, MultipleFiringSpreadBase) == 0x000034, "Member 'FWeaponAttachmentData::MultipleFiringSpreadBase' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentData, MultipleAmmoSpeed) == 0x000038, "Member 'FWeaponAttachmentData::MultipleAmmoSpeed' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentData, RecoilMultiplierHorizontal) == 0x00003C, "Member 'FWeaponAttachmentData::RecoilMultiplierHorizontal' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentData, RecoilMultiplierVertical) == 0x000040, "Member 'FWeaponAttachmentData::RecoilMultiplierVertical' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentData, RecoilRecoveryMultiplier) == 0x000044, "Member 'FWeaponAttachmentData::RecoilRecoveryMultiplier' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentData, SwayMultiplier) == 0x000048, "Member 'FWeaponAttachmentData::SwayMultiplier' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentData, AnimationKickMultiplier) == 0x00004C, "Member 'FWeaponAttachmentData::AnimationKickMultiplier' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentData, DeviationMultiplier) == 0x000050, "Member 'FWeaponAttachmentData::DeviationMultiplier' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentData, ADSSpeedMultiplier) == 0x000054, "Member 'FWeaponAttachmentData::ADSSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentData, GripType_MN) == 0x000058, "Member 'FWeaponAttachmentData::GripType_MN' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentData, BarrelLengthAdditive) == 0x00005C, "Member 'FWeaponAttachmentData::BarrelLengthAdditive' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentData, MuzzleFx) == 0x000060, "Member 'FWeaponAttachmentData::MuzzleFx' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentData, MuzzleAttachPoint) == 0x000068, "Member 'FWeaponAttachmentData::MuzzleAttachPoint' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentData, IKHandOffset) == 0x000070, "Member 'FWeaponAttachmentData::IKHandOffset' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentData, IKHandRotation) == 0x00007C, "Member 'FWeaponAttachmentData::IKHandRotation' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentData, WeaponGripLeft) == 0x000088, "Member 'FWeaponAttachmentData::WeaponGripLeft' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentData, MuzzleSound) == 0x000090, "Member 'FWeaponAttachmentData::MuzzleSound' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentData, CharacterReloadTactical) == 0x000098, "Member 'FWeaponAttachmentData::CharacterReloadTactical' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentData, WeaponReloadTactical) == 0x0000A0, "Member 'FWeaponAttachmentData::WeaponReloadTactical' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentData, CharacterReloadCharge) == 0x0000A8, "Member 'FWeaponAttachmentData::CharacterReloadCharge' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentData, WeaponReloadCharge) == 0x0000B0, "Member 'FWeaponAttachmentData::WeaponReloadCharge' has a wrong offset!");

// ScriptStruct TslGame.WeaponAttachmentWeaponTagData
// 0x00E0 (0x00E0 - 0x0000)
struct FWeaponAttachmentWeaponTagData final
{
public:
	struct FName                                   WeaponTag;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             AttachmentMeshAsset;                               // 0x0008(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWeaponAttachmentData                  AttachmentData;                                    // 0x0028(0x00B8)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponAttachmentWeaponTagData) == 0x000008, "Wrong alignment on FWeaponAttachmentWeaponTagData");
static_assert(sizeof(FWeaponAttachmentWeaponTagData) == 0x0000E0, "Wrong size on FWeaponAttachmentWeaponTagData");
static_assert(offsetof(FWeaponAttachmentWeaponTagData, WeaponTag) == 0x000000, "Member 'FWeaponAttachmentWeaponTagData::WeaponTag' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentWeaponTagData, AttachmentMeshAsset) == 0x000008, "Member 'FWeaponAttachmentWeaponTagData::AttachmentMeshAsset' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentWeaponTagData, AttachmentData) == 0x000028, "Member 'FWeaponAttachmentWeaponTagData::AttachmentData' has a wrong offset!");

// ScriptStruct TslGame.LobbyItemDesc
// 0x0030 (0x0030 - 0x0000)
struct FLobbyItemDesc final
{
public:
	uint8                                         bCashSellable : 1;                                 // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPointSellable : 1;                                // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bMarketable : 1;                                   // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bPointRefundable : 1;                              // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ELobbyItemTier                                Tier;                                              // 0x0004(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELobbyItemCategory                            Category;                                          // 0x0005(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x0008(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         CashSellingPrice;                                  // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELobbyItemPointSellingType                    PointSellingType;                                  // 0x0024(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PointSellingPrice;                                 // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PointRefundingPrice;                               // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLobbyItemDesc) == 0x000008, "Wrong alignment on FLobbyItemDesc");
static_assert(sizeof(FLobbyItemDesc) == 0x000030, "Wrong size on FLobbyItemDesc");
static_assert(offsetof(FLobbyItemDesc, Tier) == 0x000004, "Member 'FLobbyItemDesc::Tier' has a wrong offset!");
static_assert(offsetof(FLobbyItemDesc, Category) == 0x000005, "Member 'FLobbyItemDesc::Category' has a wrong offset!");
static_assert(offsetof(FLobbyItemDesc, Description) == 0x000008, "Member 'FLobbyItemDesc::Description' has a wrong offset!");
static_assert(offsetof(FLobbyItemDesc, CashSellingPrice) == 0x000020, "Member 'FLobbyItemDesc::CashSellingPrice' has a wrong offset!");
static_assert(offsetof(FLobbyItemDesc, PointSellingType) == 0x000024, "Member 'FLobbyItemDesc::PointSellingType' has a wrong offset!");
static_assert(offsetof(FLobbyItemDesc, PointSellingPrice) == 0x000028, "Member 'FLobbyItemDesc::PointSellingPrice' has a wrong offset!");
static_assert(offsetof(FLobbyItemDesc, PointRefundingPrice) == 0x00002C, "Member 'FLobbyItemDesc::PointRefundingPrice' has a wrong offset!");

// ScriptStruct TslGame.WuLogGameState
// 0x0044 (0x0044 - 0x0000)
struct FWuLogGameState final
{
public:
	int32                                         ElapsedTime;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumAliveTeams;                                     // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumJoinPlayers;                                    // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumStartPlayers;                                   // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumAlivePlayers;                                   // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SafetyZonePosition;                                // 0x0014(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SafetyZoneRadius;                                  // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PoisonGasWarningPosition;                          // 0x0024(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PoisonGasWarningRadius;                            // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RedZonePosition;                                   // 0x0034(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RedZoneRadius;                                     // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuLogGameState) == 0x000004, "Wrong alignment on FWuLogGameState");
static_assert(sizeof(FWuLogGameState) == 0x000044, "Wrong size on FWuLogGameState");
static_assert(offsetof(FWuLogGameState, ElapsedTime) == 0x000000, "Member 'FWuLogGameState::ElapsedTime' has a wrong offset!");
static_assert(offsetof(FWuLogGameState, NumAliveTeams) == 0x000004, "Member 'FWuLogGameState::NumAliveTeams' has a wrong offset!");
static_assert(offsetof(FWuLogGameState, NumJoinPlayers) == 0x000008, "Member 'FWuLogGameState::NumJoinPlayers' has a wrong offset!");
static_assert(offsetof(FWuLogGameState, NumStartPlayers) == 0x00000C, "Member 'FWuLogGameState::NumStartPlayers' has a wrong offset!");
static_assert(offsetof(FWuLogGameState, NumAlivePlayers) == 0x000010, "Member 'FWuLogGameState::NumAlivePlayers' has a wrong offset!");
static_assert(offsetof(FWuLogGameState, SafetyZonePosition) == 0x000014, "Member 'FWuLogGameState::SafetyZonePosition' has a wrong offset!");
static_assert(offsetof(FWuLogGameState, SafetyZoneRadius) == 0x000020, "Member 'FWuLogGameState::SafetyZoneRadius' has a wrong offset!");
static_assert(offsetof(FWuLogGameState, PoisonGasWarningPosition) == 0x000024, "Member 'FWuLogGameState::PoisonGasWarningPosition' has a wrong offset!");
static_assert(offsetof(FWuLogGameState, PoisonGasWarningRadius) == 0x000030, "Member 'FWuLogGameState::PoisonGasWarningRadius' has a wrong offset!");
static_assert(offsetof(FWuLogGameState, RedZonePosition) == 0x000034, "Member 'FWuLogGameState::RedZonePosition' has a wrong offset!");
static_assert(offsetof(FWuLogGameState, RedZoneRadius) == 0x000040, "Member 'FWuLogGameState::RedZoneRadius' has a wrong offset!");

// ScriptStruct TslGame.WuLogCharacter
// 0x0038 (0x0038 - 0x0000)
struct FWuLogCharacter final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NetId;                                             // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamId;                                            // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Health;                                            // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0028(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Ranking;                                           // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuLogCharacter) == 0x000008, "Wrong alignment on FWuLogCharacter");
static_assert(sizeof(FWuLogCharacter) == 0x000038, "Wrong size on FWuLogCharacter");
static_assert(offsetof(FWuLogCharacter, Name) == 0x000000, "Member 'FWuLogCharacter::Name' has a wrong offset!");
static_assert(offsetof(FWuLogCharacter, NetId) == 0x000010, "Member 'FWuLogCharacter::NetId' has a wrong offset!");
static_assert(offsetof(FWuLogCharacter, TeamId) == 0x000020, "Member 'FWuLogCharacter::TeamId' has a wrong offset!");
static_assert(offsetof(FWuLogCharacter, Health) == 0x000024, "Member 'FWuLogCharacter::Health' has a wrong offset!");
static_assert(offsetof(FWuLogCharacter, Location) == 0x000028, "Member 'FWuLogCharacter::Location' has a wrong offset!");
static_assert(offsetof(FWuLogCharacter, Ranking) == 0x000034, "Member 'FWuLogCharacter::Ranking' has a wrong offset!");

// ScriptStruct TslGame.WuLogVehicleDestroy
// 0x0090 (0x00B8 - 0x0028)
struct FWuLogVehicleDestroy final : public FLogBase
{
public:
	int32                                         AttackId;                                          // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWuLogCharacter                        Attacker;                                          // 0x0030(0x0038)(NativeAccessSpecifierPublic)
	struct FWuLogVehicle                          Vehicle;                                           // 0x0068(0x0028)(NativeAccessSpecifierPublic)
	class FString                                 DamageTypeCategory;                                // 0x0090(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DamageCauserName;                                  // 0x00A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x00B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWuLogVehicleDestroy) == 0x000008, "Wrong alignment on FWuLogVehicleDestroy");
static_assert(sizeof(FWuLogVehicleDestroy) == 0x0000B8, "Wrong size on FWuLogVehicleDestroy");
static_assert(offsetof(FWuLogVehicleDestroy, AttackId) == 0x000028, "Member 'FWuLogVehicleDestroy::AttackId' has a wrong offset!");
static_assert(offsetof(FWuLogVehicleDestroy, Attacker) == 0x000030, "Member 'FWuLogVehicleDestroy::Attacker' has a wrong offset!");
static_assert(offsetof(FWuLogVehicleDestroy, Vehicle) == 0x000068, "Member 'FWuLogVehicleDestroy::Vehicle' has a wrong offset!");
static_assert(offsetof(FWuLogVehicleDestroy, DamageTypeCategory) == 0x000090, "Member 'FWuLogVehicleDestroy::DamageTypeCategory' has a wrong offset!");
static_assert(offsetof(FWuLogVehicleDestroy, DamageCauserName) == 0x0000A0, "Member 'FWuLogVehicleDestroy::DamageCauserName' has a wrong offset!");
static_assert(offsetof(FWuLogVehicleDestroy, Distance) == 0x0000B0, "Member 'FWuLogVehicleDestroy::Distance' has a wrong offset!");

// ScriptStruct TslGame.CastConfig
// 0x0030 (0x0030 - 0x0000)
struct FCastConfig final
{
public:
	class FText                                   CastName;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         CastTime;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECastPriority                                 CastPriority;                                      // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECastLevel                                    CastLevel;                                         // 0x001D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CastMaxDistance;                                   // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CasterAndCastObjectMaxDistance;                    // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CastMaxSpeed;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECastAnim                                     CastAnim;                                          // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCastConfig) == 0x000008, "Wrong alignment on FCastConfig");
static_assert(sizeof(FCastConfig) == 0x000030, "Wrong size on FCastConfig");
static_assert(offsetof(FCastConfig, CastName) == 0x000000, "Member 'FCastConfig::CastName' has a wrong offset!");
static_assert(offsetof(FCastConfig, CastTime) == 0x000018, "Member 'FCastConfig::CastTime' has a wrong offset!");
static_assert(offsetof(FCastConfig, CastPriority) == 0x00001C, "Member 'FCastConfig::CastPriority' has a wrong offset!");
static_assert(offsetof(FCastConfig, CastLevel) == 0x00001D, "Member 'FCastConfig::CastLevel' has a wrong offset!");
static_assert(offsetof(FCastConfig, CastMaxDistance) == 0x000020, "Member 'FCastConfig::CastMaxDistance' has a wrong offset!");
static_assert(offsetof(FCastConfig, CasterAndCastObjectMaxDistance) == 0x000024, "Member 'FCastConfig::CasterAndCastObjectMaxDistance' has a wrong offset!");
static_assert(offsetof(FCastConfig, CastMaxSpeed) == 0x000028, "Member 'FCastConfig::CastMaxSpeed' has a wrong offset!");
static_assert(offsetof(FCastConfig, CastAnim) == 0x00002C, "Member 'FCastConfig::CastAnim' has a wrong offset!");

// ScriptStruct TslGame.PlayerHitInfo
// 0x000C (0x000C - 0x0000)
struct FPlayerHitInfo final
{
public:
	int32                                         Hits;                                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damages;                                           // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Kills;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerHitInfo) == 0x000004, "Wrong alignment on FPlayerHitInfo");
static_assert(sizeof(FPlayerHitInfo) == 0x00000C, "Wrong size on FPlayerHitInfo");
static_assert(offsetof(FPlayerHitInfo, Hits) == 0x000000, "Member 'FPlayerHitInfo::Hits' has a wrong offset!");
static_assert(offsetof(FPlayerHitInfo, Damages) == 0x000004, "Member 'FPlayerHitInfo::Damages' has a wrong offset!");
static_assert(offsetof(FPlayerHitInfo, Kills) == 0x000008, "Member 'FPlayerHitInfo::Kills' has a wrong offset!");

// ScriptStruct TslGame.PlayerAttackInfo
// 0x0058 (0x0058 - 0x0000)
struct FPlayerAttackInfo final
{
public:
	int32                                         Shots;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EDamageReason, struct FPlayerHitInfo>    HitInfoMap;                                        // 0x0008(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerAttackInfo) == 0x000008, "Wrong alignment on FPlayerAttackInfo");
static_assert(sizeof(FPlayerAttackInfo) == 0x000058, "Wrong size on FPlayerAttackInfo");
static_assert(offsetof(FPlayerAttackInfo, Shots) == 0x000000, "Member 'FPlayerAttackInfo::Shots' has a wrong offset!");
static_assert(offsetof(FPlayerAttackInfo, HitInfoMap) == 0x000008, "Member 'FPlayerAttackInfo::HitInfoMap' has a wrong offset!");

// ScriptStruct TslGame.TslFriend
// 0x0038 (0x0038 - 0x0000)
struct FTslFriend final
{
public:
	class FString                                 UserSerial;                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UserRealName;                                      // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UserDisplayName;                                   // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTslFriendPresence                     Presence;                                          // 0x0030(0x0005)(NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTslFriend) == 0x000008, "Wrong alignment on FTslFriend");
static_assert(sizeof(FTslFriend) == 0x000038, "Wrong size on FTslFriend");
static_assert(offsetof(FTslFriend, UserSerial) == 0x000000, "Member 'FTslFriend::UserSerial' has a wrong offset!");
static_assert(offsetof(FTslFriend, UserRealName) == 0x000010, "Member 'FTslFriend::UserRealName' has a wrong offset!");
static_assert(offsetof(FTslFriend, UserDisplayName) == 0x000020, "Member 'FTslFriend::UserDisplayName' has a wrong offset!");
static_assert(offsetof(FTslFriend, Presence) == 0x000030, "Member 'FTslFriend::Presence' has a wrong offset!");

// ScriptStruct TslGame.TslClientAuthData
// 0x0060 (0x0060 - 0x0000)
struct FTslClientAuthData final
{
public:
	class FString                                 PlatformType;                                      // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AppID;                                             // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UserSerial;                                        // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccessToken;                                       // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UserDisplayName;                                   // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerNetId;                                       // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTslClientAuthData) == 0x000008, "Wrong alignment on FTslClientAuthData");
static_assert(sizeof(FTslClientAuthData) == 0x000060, "Wrong size on FTslClientAuthData");
static_assert(offsetof(FTslClientAuthData, PlatformType) == 0x000000, "Member 'FTslClientAuthData::PlatformType' has a wrong offset!");
static_assert(offsetof(FTslClientAuthData, AppID) == 0x000010, "Member 'FTslClientAuthData::AppID' has a wrong offset!");
static_assert(offsetof(FTslClientAuthData, UserSerial) == 0x000020, "Member 'FTslClientAuthData::UserSerial' has a wrong offset!");
static_assert(offsetof(FTslClientAuthData, AccessToken) == 0x000030, "Member 'FTslClientAuthData::AccessToken' has a wrong offset!");
static_assert(offsetof(FTslClientAuthData, UserDisplayName) == 0x000040, "Member 'FTslClientAuthData::UserDisplayName' has a wrong offset!");
static_assert(offsetof(FTslClientAuthData, PlayerNetId) == 0x000050, "Member 'FTslClientAuthData::PlayerNetId' has a wrong offset!");

// ScriptStruct TslGame.ItemSpawnWeightElement
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FItemSpawnWeightElement final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemSpawnWeightElement) == 0x000008, "Wrong alignment on FItemSpawnWeightElement");
static_assert(sizeof(FItemSpawnWeightElement) == 0x000010, "Wrong size on FItemSpawnWeightElement");

// ScriptStruct TslGame.BlueZoneCustomOption
// 0x0014 (0x0014 - 0x0000)
struct FBlueZoneCustomOption final
{
public:
	int32                                         PhaseNum;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarningDuration;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReleaseDuration;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PoisonGasDamagePerSecond;                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusRate;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlueZoneCustomOption) == 0x000004, "Wrong alignment on FBlueZoneCustomOption");
static_assert(sizeof(FBlueZoneCustomOption) == 0x000014, "Wrong size on FBlueZoneCustomOption");
static_assert(offsetof(FBlueZoneCustomOption, PhaseNum) == 0x000000, "Member 'FBlueZoneCustomOption::PhaseNum' has a wrong offset!");
static_assert(offsetof(FBlueZoneCustomOption, WarningDuration) == 0x000004, "Member 'FBlueZoneCustomOption::WarningDuration' has a wrong offset!");
static_assert(offsetof(FBlueZoneCustomOption, ReleaseDuration) == 0x000008, "Member 'FBlueZoneCustomOption::ReleaseDuration' has a wrong offset!");
static_assert(offsetof(FBlueZoneCustomOption, PoisonGasDamagePerSecond) == 0x00000C, "Member 'FBlueZoneCustomOption::PoisonGasDamagePerSecond' has a wrong offset!");
static_assert(offsetof(FBlueZoneCustomOption, RadiusRate) == 0x000010, "Member 'FBlueZoneCustomOption::RadiusRate' has a wrong offset!");

// ScriptStruct TslGame.SplashObject
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FSplashObject final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSplashObject) == 0x000004, "Wrong alignment on FSplashObject");
static_assert(sizeof(FSplashObject) == 0x00000C, "Wrong size on FSplashObject");

// ScriptStruct TslGame.RedZoneCustomOption
// 0x001C (0x001C - 0x0000)
struct FRedZoneCustomOption final
{
public:
	bool                                          bIsActive;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MultiplierRedZoneExplosionDensity;                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MultiplierRedZoneStartTime;                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MultiplierRedZoneEndTime;                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MultiplierRedZoneExplosionDelay;                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MultiplierRedZoneDuration;                         // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MultiplierRedZoneArea;                             // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRedZoneCustomOption) == 0x000004, "Wrong alignment on FRedZoneCustomOption");
static_assert(sizeof(FRedZoneCustomOption) == 0x00001C, "Wrong size on FRedZoneCustomOption");
static_assert(offsetof(FRedZoneCustomOption, bIsActive) == 0x000000, "Member 'FRedZoneCustomOption::bIsActive' has a wrong offset!");
static_assert(offsetof(FRedZoneCustomOption, MultiplierRedZoneExplosionDensity) == 0x000004, "Member 'FRedZoneCustomOption::MultiplierRedZoneExplosionDensity' has a wrong offset!");
static_assert(offsetof(FRedZoneCustomOption, MultiplierRedZoneStartTime) == 0x000008, "Member 'FRedZoneCustomOption::MultiplierRedZoneStartTime' has a wrong offset!");
static_assert(offsetof(FRedZoneCustomOption, MultiplierRedZoneEndTime) == 0x00000C, "Member 'FRedZoneCustomOption::MultiplierRedZoneEndTime' has a wrong offset!");
static_assert(offsetof(FRedZoneCustomOption, MultiplierRedZoneExplosionDelay) == 0x000010, "Member 'FRedZoneCustomOption::MultiplierRedZoneExplosionDelay' has a wrong offset!");
static_assert(offsetof(FRedZoneCustomOption, MultiplierRedZoneDuration) == 0x000014, "Member 'FRedZoneCustomOption::MultiplierRedZoneDuration' has a wrong offset!");
static_assert(offsetof(FRedZoneCustomOption, MultiplierRedZoneArea) == 0x000018, "Member 'FRedZoneCustomOption::MultiplierRedZoneArea' has a wrong offset!");

// ScriptStruct TslGame.BlockAction
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FBlockAction final
{
public:
	struct FName                                   ActionName;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputEvent                                   KeyEvent;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBlockAction) == 0x000008, "Wrong alignment on FBlockAction");
static_assert(sizeof(FBlockAction) == 0x000010, "Wrong size on FBlockAction");
static_assert(offsetof(FBlockAction, ActionName) == 0x000000, "Member 'FBlockAction::ActionName' has a wrong offset!");
static_assert(offsetof(FBlockAction, KeyEvent) == 0x000008, "Member 'FBlockAction::KeyEvent' has a wrong offset!");

// ScriptStruct TslGame.LobbyItemBundleElement
// 0x0028 (0x0028 - 0x0000)
struct FLobbyItemBundleElement final
{
public:
	TSoftClassPtr<class UClass>                   ItemAsset;                                         // 0x0000(0x0020)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BundleId;                                          // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Quantity;                                          // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLobbyItemBundleElement) == 0x000008, "Wrong alignment on FLobbyItemBundleElement");
static_assert(sizeof(FLobbyItemBundleElement) == 0x000028, "Wrong size on FLobbyItemBundleElement");
static_assert(offsetof(FLobbyItemBundleElement, ItemAsset) == 0x000000, "Member 'FLobbyItemBundleElement::ItemAsset' has a wrong offset!");
static_assert(offsetof(FLobbyItemBundleElement, BundleId) == 0x000020, "Member 'FLobbyItemBundleElement::BundleId' has a wrong offset!");
static_assert(offsetof(FLobbyItemBundleElement, Quantity) == 0x000024, "Member 'FLobbyItemBundleElement::Quantity' has a wrong offset!");

// ScriptStruct TslGame.LobbyItemBundle
// 0x0030 (0x0030 - 0x0000)
struct FLobbyItemBundle final
{
public:
	int32                                         BundleId;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BundleName;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELobbyItemBundleType                          Type;                                              // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLobbyItemBundleElement>        ItemList;                                          // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLobbyItemBundle) == 0x000008, "Wrong alignment on FLobbyItemBundle");
static_assert(sizeof(FLobbyItemBundle) == 0x000030, "Wrong size on FLobbyItemBundle");
static_assert(offsetof(FLobbyItemBundle, BundleId) == 0x000000, "Member 'FLobbyItemBundle::BundleId' has a wrong offset!");
static_assert(offsetof(FLobbyItemBundle, BundleName) == 0x000008, "Member 'FLobbyItemBundle::BundleName' has a wrong offset!");
static_assert(offsetof(FLobbyItemBundle, Type) == 0x000018, "Member 'FLobbyItemBundle::Type' has a wrong offset!");
static_assert(offsetof(FLobbyItemBundle, ItemList) == 0x000020, "Member 'FLobbyItemBundle::ItemList' has a wrong offset!");

// ScriptStruct TslGame.TslPlayerMatchResultInfo
// 0x0020 (0x0020 - 0x0000)
struct FTslPlayerMatchResultInfo final
{
public:
	class FString                                 PlayerName;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumKills;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Ranking;                                           // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamId;                                            // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumStartTeamMember;                                // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTslPlayerMatchResultInfo) == 0x000008, "Wrong alignment on FTslPlayerMatchResultInfo");
static_assert(sizeof(FTslPlayerMatchResultInfo) == 0x000020, "Wrong size on FTslPlayerMatchResultInfo");
static_assert(offsetof(FTslPlayerMatchResultInfo, PlayerName) == 0x000000, "Member 'FTslPlayerMatchResultInfo::PlayerName' has a wrong offset!");
static_assert(offsetof(FTslPlayerMatchResultInfo, NumKills) == 0x000010, "Member 'FTslPlayerMatchResultInfo::NumKills' has a wrong offset!");
static_assert(offsetof(FTslPlayerMatchResultInfo, Ranking) == 0x000014, "Member 'FTslPlayerMatchResultInfo::Ranking' has a wrong offset!");
static_assert(offsetof(FTslPlayerMatchResultInfo, TeamId) == 0x000018, "Member 'FTslPlayerMatchResultInfo::TeamId' has a wrong offset!");
static_assert(offsetof(FTslPlayerMatchResultInfo, NumStartTeamMember) == 0x00001C, "Member 'FTslPlayerMatchResultInfo::NumStartTeamMember' has a wrong offset!");

// ScriptStruct TslGame.DroppedItemInfo
// 0x0018 (0x0018 - 0x0000)
struct FDroppedItemInfo final
{
public:
	class UItem*                                  Item;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDroppedItemInfo) == 0x000008, "Wrong alignment on FDroppedItemInfo");
static_assert(sizeof(FDroppedItemInfo) == 0x000018, "Wrong size on FDroppedItemInfo");
static_assert(offsetof(FDroppedItemInfo, Item) == 0x000000, "Member 'FDroppedItemInfo::Item' has a wrong offset!");

// ScriptStruct TslGame.WuStringFloatPair
// 0x0018 (0x0018 - 0x0000)
struct FWuStringFloatPair final
{
public:
	class FString                                 First;                                             // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Second;                                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWuStringFloatPair) == 0x000008, "Wrong alignment on FWuStringFloatPair");
static_assert(sizeof(FWuStringFloatPair) == 0x000018, "Wrong size on FWuStringFloatPair");
static_assert(offsetof(FWuStringFloatPair, First) == 0x000000, "Member 'FWuStringFloatPair::First' has a wrong offset!");
static_assert(offsetof(FWuStringFloatPair, Second) == 0x000010, "Member 'FWuStringFloatPair::Second' has a wrong offset!");

// ScriptStruct TslGame.NearClippingLevelOverZ
// 0x0008 (0x0008 - 0x0000)
struct FNearClippingLevelOverZ final
{
public:
	float                                         Z;                                                 // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENearClippingLevel                            Level;                                             // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNearClippingLevelOverZ) == 0x000004, "Wrong alignment on FNearClippingLevelOverZ");
static_assert(sizeof(FNearClippingLevelOverZ) == 0x000008, "Wrong size on FNearClippingLevelOverZ");
static_assert(offsetof(FNearClippingLevelOverZ, Z) == 0x000000, "Member 'FNearClippingLevelOverZ::Z' has a wrong offset!");
static_assert(offsetof(FNearClippingLevelOverZ, Level) == 0x000004, "Member 'FNearClippingLevelOverZ::Level' has a wrong offset!");

// ScriptStruct TslGame.PackagedItemInfo
// 0x0010 (0x0010 - 0x0000)
struct FPackagedItemInfo final
{
public:
	TSubclassOf<class UItem>                      ItemType;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPackagedItemInfo) == 0x000008, "Wrong alignment on FPackagedItemInfo");
static_assert(sizeof(FPackagedItemInfo) == 0x000010, "Wrong size on FPackagedItemInfo");
static_assert(offsetof(FPackagedItemInfo, ItemType) == 0x000000, "Member 'FPackagedItemInfo::ItemType' has a wrong offset!");
static_assert(offsetof(FPackagedItemInfo, Count) == 0x000008, "Member 'FPackagedItemInfo::Count' has a wrong offset!");

// ScriptStruct TslGame.NearClippingValue
// 0x0008 (0x0008 - 0x0000)
struct FNearClippingValue final
{
public:
	ENearClippingLevel                            Level;                                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNearClippingValue) == 0x000004, "Wrong alignment on FNearClippingValue");
static_assert(sizeof(FNearClippingValue) == 0x000008, "Wrong size on FNearClippingValue");
static_assert(offsetof(FNearClippingValue, Level) == 0x000000, "Member 'FNearClippingValue::Level' has a wrong offset!");
static_assert(offsetof(FNearClippingValue, Value) == 0x000004, "Member 'FNearClippingValue::Value' has a wrong offset!");

// ScriptStruct TslGame.NameWeight
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FNameWeight final
{
public:
	struct FName                                   Name;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNameWeight) == 0x000008, "Wrong alignment on FNameWeight");
static_assert(sizeof(FNameWeight) == 0x000010, "Wrong size on FNameWeight");
static_assert(offsetof(FNameWeight, Name) == 0x000000, "Member 'FNameWeight::Name' has a wrong offset!");
static_assert(offsetof(FNameWeight, Weight) == 0x000008, "Member 'FNameWeight::Weight' has a wrong offset!");

// ScriptStruct TslGame.ItemSpotTypeProperty
// 0x0038 (0x0038 - 0x0000)
struct FItemSpotTypeProperty final
{
public:
	EItemSpotType                                 SpotType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpotPercentMin;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpotPercentMax;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemsPerSpotMin;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemsPerSpotMax;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNameWeight>                    WeightsPerValue;                                   // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FNameWeight>                    WeightsPerCategory;                                // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemSpotTypeProperty) == 0x000008, "Wrong alignment on FItemSpotTypeProperty");
static_assert(sizeof(FItemSpotTypeProperty) == 0x000038, "Wrong size on FItemSpotTypeProperty");
static_assert(offsetof(FItemSpotTypeProperty, SpotType) == 0x000000, "Member 'FItemSpotTypeProperty::SpotType' has a wrong offset!");
static_assert(offsetof(FItemSpotTypeProperty, SpotPercentMin) == 0x000004, "Member 'FItemSpotTypeProperty::SpotPercentMin' has a wrong offset!");
static_assert(offsetof(FItemSpotTypeProperty, SpotPercentMax) == 0x000008, "Member 'FItemSpotTypeProperty::SpotPercentMax' has a wrong offset!");
static_assert(offsetof(FItemSpotTypeProperty, ItemsPerSpotMin) == 0x00000C, "Member 'FItemSpotTypeProperty::ItemsPerSpotMin' has a wrong offset!");
static_assert(offsetof(FItemSpotTypeProperty, ItemsPerSpotMax) == 0x000010, "Member 'FItemSpotTypeProperty::ItemsPerSpotMax' has a wrong offset!");
static_assert(offsetof(FItemSpotTypeProperty, WeightsPerValue) == 0x000018, "Member 'FItemSpotTypeProperty::WeightsPerValue' has a wrong offset!");
static_assert(offsetof(FItemSpotTypeProperty, WeightsPerCategory) == 0x000028, "Member 'FItemSpotTypeProperty::WeightsPerCategory' has a wrong offset!");

// ScriptStruct TslGame.LevelLoadingBoostParameters
// 0x0010 (0x0010 - 0x0000)
struct FLevelLoadingBoostParameters final
{
public:
	float                                         AsyncLoadingTimeLimit;                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PriorityAsyncLoadingExtraTime;                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LevelStreamingActorsUpdateTimeLimit;               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LevelStreamingComponentsRegistrationGranularity;   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelLoadingBoostParameters) == 0x000004, "Wrong alignment on FLevelLoadingBoostParameters");
static_assert(sizeof(FLevelLoadingBoostParameters) == 0x000010, "Wrong size on FLevelLoadingBoostParameters");
static_assert(offsetof(FLevelLoadingBoostParameters, AsyncLoadingTimeLimit) == 0x000000, "Member 'FLevelLoadingBoostParameters::AsyncLoadingTimeLimit' has a wrong offset!");
static_assert(offsetof(FLevelLoadingBoostParameters, PriorityAsyncLoadingExtraTime) == 0x000004, "Member 'FLevelLoadingBoostParameters::PriorityAsyncLoadingExtraTime' has a wrong offset!");
static_assert(offsetof(FLevelLoadingBoostParameters, LevelStreamingActorsUpdateTimeLimit) == 0x000008, "Member 'FLevelLoadingBoostParameters::LevelStreamingActorsUpdateTimeLimit' has a wrong offset!");
static_assert(offsetof(FLevelLoadingBoostParameters, LevelStreamingComponentsRegistrationGranularity) == 0x00000C, "Member 'FLevelLoadingBoostParameters::LevelStreamingComponentsRegistrationGranularity' has a wrong offset!");

// ScriptStruct TslGame.WheelContactData
// 0x0003 (0x0003 - 0x0000)
struct FWheelContactData final
{
public:
	uint8                                         Pad_0[0x3];                                        // 0x0000(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWheelContactData) == 0x000001, "Wrong alignment on FWheelContactData");
static_assert(sizeof(FWheelContactData) == 0x000003, "Wrong size on FWheelContactData");

// ScriptStruct TslGame.LobbyHairElementDetail
// 0x0028 (0x0028 - 0x0000)
struct FLobbyHairElementDetail final
{
public:
	int32                                         ColorIndex;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCustomizableObject>     HairAsset;                                         // 0x0008(0x0020)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLobbyHairElementDetail) == 0x000008, "Wrong alignment on FLobbyHairElementDetail");
static_assert(sizeof(FLobbyHairElementDetail) == 0x000028, "Wrong size on FLobbyHairElementDetail");
static_assert(offsetof(FLobbyHairElementDetail, ColorIndex) == 0x000000, "Member 'FLobbyHairElementDetail::ColorIndex' has a wrong offset!");
static_assert(offsetof(FLobbyHairElementDetail, Color) == 0x000004, "Member 'FLobbyHairElementDetail::Color' has a wrong offset!");
static_assert(offsetof(FLobbyHairElementDetail, HairAsset) == 0x000008, "Member 'FLobbyHairElementDetail::HairAsset' has a wrong offset!");

// ScriptStruct TslGame.TslPlayerStatistics
// 0x0004 (0x0004 - 0x0000)
struct FTslPlayerStatistics final
{
public:
	int32                                         NumKills;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTslPlayerStatistics) == 0x000004, "Wrong alignment on FTslPlayerStatistics");
static_assert(sizeof(FTslPlayerStatistics) == 0x000004, "Wrong size on FTslPlayerStatistics");
static_assert(offsetof(FTslPlayerStatistics, NumKills) == 0x000000, "Member 'FTslPlayerStatistics::NumKills' has a wrong offset!");

// ScriptStruct TslGame.TslPlayerStatisticsNotReplicated
// 0x00A8 (0x00A8 - 0x0000)
struct FTslPlayerStatisticsNotReplicated final
{
public:
	float                                         MovedDistanceOnFeetMeter;                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovedDistanceOnVehicleMeter;                       // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, struct FPlayerAttackInfo> AttacksGivenInfos;                                 // 0x0008(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FString, struct FPlayerAttackInfo> AttacksTakenInfos;                                 // 0x0058(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTslPlayerStatisticsNotReplicated) == 0x000008, "Wrong alignment on FTslPlayerStatisticsNotReplicated");
static_assert(sizeof(FTslPlayerStatisticsNotReplicated) == 0x0000A8, "Wrong size on FTslPlayerStatisticsNotReplicated");
static_assert(offsetof(FTslPlayerStatisticsNotReplicated, MovedDistanceOnFeetMeter) == 0x000000, "Member 'FTslPlayerStatisticsNotReplicated::MovedDistanceOnFeetMeter' has a wrong offset!");
static_assert(offsetof(FTslPlayerStatisticsNotReplicated, MovedDistanceOnVehicleMeter) == 0x000004, "Member 'FTslPlayerStatisticsNotReplicated::MovedDistanceOnVehicleMeter' has a wrong offset!");
static_assert(offsetof(FTslPlayerStatisticsNotReplicated, AttacksGivenInfos) == 0x000008, "Member 'FTslPlayerStatisticsNotReplicated::AttacksGivenInfos' has a wrong offset!");
static_assert(offsetof(FTslPlayerStatisticsNotReplicated, AttacksTakenInfos) == 0x000058, "Member 'FTslPlayerStatisticsNotReplicated::AttacksTakenInfos' has a wrong offset!");

// ScriptStruct TslGame.ThrowableAnim
// 0x0018 (0x0018 - 0x0000)
struct FThrowableAnim final
{
public:
	class UAnimMontage*                           PinOff;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Cooking;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Release;                                           // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FThrowableAnim) == 0x000008, "Wrong alignment on FThrowableAnim");
static_assert(sizeof(FThrowableAnim) == 0x000018, "Wrong size on FThrowableAnim");
static_assert(offsetof(FThrowableAnim, PinOff) == 0x000000, "Member 'FThrowableAnim::PinOff' has a wrong offset!");
static_assert(offsetof(FThrowableAnim, Cooking) == 0x000008, "Member 'FThrowableAnim::Cooking' has a wrong offset!");
static_assert(offsetof(FThrowableAnim, Release) == 0x000010, "Member 'FThrowableAnim::Release' has a wrong offset!");

// ScriptStruct TslGame.WeaponAttachmentTagData
// 0x0018 (0x0018 - 0x0000)
struct FWeaponAttachmentTagData final
{
public:
	EWeaponAttachmentSlotID                       AttachmentSlotID;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FName>                           AttachableTags;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponAttachmentTagData) == 0x000008, "Wrong alignment on FWeaponAttachmentTagData");
static_assert(sizeof(FWeaponAttachmentTagData) == 0x000018, "Wrong size on FWeaponAttachmentTagData");
static_assert(offsetof(FWeaponAttachmentTagData, AttachmentSlotID) == 0x000000, "Member 'FWeaponAttachmentTagData::AttachmentSlotID' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentTagData, AttachableTags) == 0x000008, "Member 'FWeaponAttachmentTagData::AttachableTags' has a wrong offset!");

// ScriptStruct TslGame.RecoilPatternData
// 0x0008 (0x0008 - 0x0000)
struct FRecoilPatternData final
{
public:
	float                                         Magnitude;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRecoilPatternData) == 0x000004, "Wrong alignment on FRecoilPatternData");
static_assert(sizeof(FRecoilPatternData) == 0x000008, "Wrong size on FRecoilPatternData");
static_assert(offsetof(FRecoilPatternData, Magnitude) == 0x000000, "Member 'FRecoilPatternData::Magnitude' has a wrong offset!");
static_assert(offsetof(FRecoilPatternData, Angle) == 0x000004, "Member 'FRecoilPatternData::Angle' has a wrong offset!");

// ScriptStruct TslGame.PingPongSummary
// 0x000C (0x000C - 0x0000)
struct FPingPongSummary final
{
public:
	float                                         UnreliableAverageDelayMsec;                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReliableAverageDelayMsec;                          // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          UnreliableSentCount;                               // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          UnreliableMissCount;                               // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int8                                          ReliableCount;                                     // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPingPongSummary) == 0x000004, "Wrong alignment on FPingPongSummary");
static_assert(sizeof(FPingPongSummary) == 0x00000C, "Wrong size on FPingPongSummary");
static_assert(offsetof(FPingPongSummary, UnreliableAverageDelayMsec) == 0x000000, "Member 'FPingPongSummary::UnreliableAverageDelayMsec' has a wrong offset!");
static_assert(offsetof(FPingPongSummary, ReliableAverageDelayMsec) == 0x000004, "Member 'FPingPongSummary::ReliableAverageDelayMsec' has a wrong offset!");
static_assert(offsetof(FPingPongSummary, UnreliableSentCount) == 0x000008, "Member 'FPingPongSummary::UnreliableSentCount' has a wrong offset!");
static_assert(offsetof(FPingPongSummary, UnreliableMissCount) == 0x000009, "Member 'FPingPongSummary::UnreliableMissCount' has a wrong offset!");
static_assert(offsetof(FPingPongSummary, ReliableCount) == 0x00000A, "Member 'FPingPongSummary::ReliableCount' has a wrong offset!");

// ScriptStruct TslGame.LobbyHairElement
// 0x0028 (0x0028 - 0x0000)
struct FLobbyHairElement final
{
public:
	EGender                                       Gender;                                            // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HairType;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLobbyHairElementDetail>        ColorData;                                         // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLobbyHairElement) == 0x000008, "Wrong alignment on FLobbyHairElement");
static_assert(sizeof(FLobbyHairElement) == 0x000028, "Wrong size on FLobbyHairElement");
static_assert(offsetof(FLobbyHairElement, Gender) == 0x000000, "Member 'FLobbyHairElement::Gender' has a wrong offset!");
static_assert(offsetof(FLobbyHairElement, HairType) == 0x000008, "Member 'FLobbyHairElement::HairType' has a wrong offset!");
static_assert(offsetof(FLobbyHairElement, ColorData) == 0x000018, "Member 'FLobbyHairElement::ColorData' has a wrong offset!");

// ScriptStruct TslGame.UmgWidgetBinder
// 0x0018 (0x0018 - 0x0000)
struct FUmgWidgetBinder
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            Parent;                                            // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FUmgWidgetBinder) == 0x000008, "Wrong alignment on FUmgWidgetBinder");
static_assert(sizeof(FUmgWidgetBinder) == 0x000018, "Wrong size on FUmgWidgetBinder");
static_assert(offsetof(FUmgWidgetBinder, Name) == 0x000008, "Member 'FUmgWidgetBinder::Name' has a wrong offset!");
static_assert(offsetof(FUmgWidgetBinder, Parent) == 0x000010, "Member 'FUmgWidgetBinder::Parent' has a wrong offset!");

// ScriptStruct TslGame.ItemInitiator
// 0x0010 (0x0010 - 0x0000)
struct FItemInitiator final
{
public:
	TSubclassOf<class UItem>                      ItemClass;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackCount;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemInitiator) == 0x000008, "Wrong alignment on FItemInitiator");
static_assert(sizeof(FItemInitiator) == 0x000010, "Wrong size on FItemInitiator");
static_assert(offsetof(FItemInitiator, ItemClass) == 0x000000, "Member 'FItemInitiator::ItemClass' has a wrong offset!");
static_assert(offsetof(FItemInitiator, StackCount) == 0x000008, "Member 'FItemInitiator::StackCount' has a wrong offset!");

// ScriptStruct TslGame.WeaponAttachmentTagPositionData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FWeaponAttachmentTagPositionData final
{
public:
	struct FName                                   AttachmentTag;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FName                                   AttachmentPoint;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponAttachmentTagPositionData) == 0x000008, "Wrong alignment on FWeaponAttachmentTagPositionData");
static_assert(sizeof(FWeaponAttachmentTagPositionData) == 0x000010, "Wrong size on FWeaponAttachmentTagPositionData");
static_assert(offsetof(FWeaponAttachmentTagPositionData, AttachmentTag) == 0x000000, "Member 'FWeaponAttachmentTagPositionData::AttachmentTag' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentTagPositionData, AttachmentPoint) == 0x000008, "Member 'FWeaponAttachmentTagPositionData::AttachmentPoint' has a wrong offset!");

// ScriptStruct TslGame.WeaponAttachmentPositionData
// 0x0020 (0x0020 - 0x0000)
struct FWeaponAttachmentPositionData final
{
public:
	EWeaponAttachmentSlotID                       AttachmentSlotID;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FName                                   AttachmentPoint;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FWeaponAttachmentTagPositionData> AttachmentPointByTag;                              // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponAttachmentPositionData) == 0x000008, "Wrong alignment on FWeaponAttachmentPositionData");
static_assert(sizeof(FWeaponAttachmentPositionData) == 0x000020, "Wrong size on FWeaponAttachmentPositionData");
static_assert(offsetof(FWeaponAttachmentPositionData, AttachmentSlotID) == 0x000000, "Member 'FWeaponAttachmentPositionData::AttachmentSlotID' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentPositionData, AttachmentPoint) == 0x000008, "Member 'FWeaponAttachmentPositionData::AttachmentPoint' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentPositionData, AttachmentPointByTag) == 0x000010, "Member 'FWeaponAttachmentPositionData::AttachmentPointByTag' has a wrong offset!");

// ScriptStruct TslGame.WuStringStringPair
// 0x0020 (0x0020 - 0x0000)
struct FWuStringStringPair final
{
public:
	class FString                                 First;                                             // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Second;                                            // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuStringStringPair) == 0x000008, "Wrong alignment on FWuStringStringPair");
static_assert(sizeof(FWuStringStringPair) == 0x000020, "Wrong size on FWuStringStringPair");
static_assert(offsetof(FWuStringStringPair, First) == 0x000000, "Member 'FWuStringStringPair::First' has a wrong offset!");
static_assert(offsetof(FWuStringStringPair, Second) == 0x000010, "Member 'FWuStringStringPair::Second' has a wrong offset!");

// ScriptStruct TslGame.WuGameOverrideParameterRequest
// 0x0020 (0x0020 - 0x0000)
struct FWuGameOverrideParameterRequest final
{
public:
	class FString                                 MatchId;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FWuStringStringPair>            StringParameters;                                  // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuGameOverrideParameterRequest) == 0x000008, "Wrong alignment on FWuGameOverrideParameterRequest");
static_assert(sizeof(FWuGameOverrideParameterRequest) == 0x000020, "Wrong size on FWuGameOverrideParameterRequest");
static_assert(offsetof(FWuGameOverrideParameterRequest, MatchId) == 0x000000, "Member 'FWuGameOverrideParameterRequest::MatchId' has a wrong offset!");
static_assert(offsetof(FWuGameOverrideParameterRequest, StringParameters) == 0x000010, "Member 'FWuGameOverrideParameterRequest::StringParameters' has a wrong offset!");

// ScriptStruct TslGame.GeneralItemSpawnProb
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FGeneralItemSpawnProb final
{
public:
	float                                         ProbabilityPercent;                                // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FName                                   ValueFilter;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FName                                   CategoryFilter;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGeneralItemSpawnProb) == 0x000008, "Wrong alignment on FGeneralItemSpawnProb");
static_assert(sizeof(FGeneralItemSpawnProb) == 0x000018, "Wrong size on FGeneralItemSpawnProb");
static_assert(offsetof(FGeneralItemSpawnProb, ProbabilityPercent) == 0x000000, "Member 'FGeneralItemSpawnProb::ProbabilityPercent' has a wrong offset!");
static_assert(offsetof(FGeneralItemSpawnProb, ValueFilter) == 0x000008, "Member 'FGeneralItemSpawnProb::ValueFilter' has a wrong offset!");
static_assert(offsetof(FGeneralItemSpawnProb, CategoryFilter) == 0x000010, "Member 'FGeneralItemSpawnProb::CategoryFilter' has a wrong offset!");

// ScriptStruct TslGame.UmgWidgetBinder_Overlay
// 0x0008 (0x0020 - 0x0018)
struct FUmgWidgetBinder_Overlay final : public FUmgWidgetBinder
{
public:
	class UOverlay*                               CachedOverlay;                                     // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FUmgWidgetBinder_Overlay) == 0x000008, "Wrong alignment on FUmgWidgetBinder_Overlay");
static_assert(sizeof(FUmgWidgetBinder_Overlay) == 0x000020, "Wrong size on FUmgWidgetBinder_Overlay");
static_assert(offsetof(FUmgWidgetBinder_Overlay, CachedOverlay) == 0x000018, "Member 'FUmgWidgetBinder_Overlay::CachedOverlay' has a wrong offset!");

// ScriptStruct TslGame.ItemSpawnCountElement
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FItemSpawnCountElement final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemSpawnCountElement) == 0x000008, "Wrong alignment on FItemSpawnCountElement");
static_assert(sizeof(FItemSpawnCountElement) == 0x000018, "Wrong size on FItemSpawnCountElement");

// ScriptStruct TslGame.WuLogPlayerKicked
// 0x0048 (0x0070 - 0x0028)
struct FWuLogPlayerKicked final : public FLogBase
{
public:
	struct FWuLogCharacter                        Character;                                         // 0x0028(0x0038)(NativeAccessSpecifierPublic)
	class FString                                 Reason;                                            // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuLogPlayerKicked) == 0x000008, "Wrong alignment on FWuLogPlayerKicked");
static_assert(sizeof(FWuLogPlayerKicked) == 0x000070, "Wrong size on FWuLogPlayerKicked");
static_assert(offsetof(FWuLogPlayerKicked, Character) == 0x000028, "Member 'FWuLogPlayerKicked::Character' has a wrong offset!");
static_assert(offsetof(FWuLogPlayerKicked, Reason) == 0x000060, "Member 'FWuLogPlayerKicked::Reason' has a wrong offset!");

// ScriptStruct TslGame.WeaponBasicAnim
// 0x0018 (0x0018 - 0x0000)
struct FWeaponBasicAnim final
{
public:
	class UAnimMontage*                           PullOut;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           PutIn;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Pickup;                                            // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponBasicAnim) == 0x000008, "Wrong alignment on FWeaponBasicAnim");
static_assert(sizeof(FWeaponBasicAnim) == 0x000018, "Wrong size on FWeaponBasicAnim");
static_assert(offsetof(FWeaponBasicAnim, PullOut) == 0x000000, "Member 'FWeaponBasicAnim::PullOut' has a wrong offset!");
static_assert(offsetof(FWeaponBasicAnim, PutIn) == 0x000008, "Member 'FWeaponBasicAnim::PutIn' has a wrong offset!");
static_assert(offsetof(FWeaponBasicAnim, Pickup) == 0x000010, "Member 'FWeaponBasicAnim::Pickup' has a wrong offset!");

// ScriptStruct TslGame.WuLogItem
// 0x0048 (0x0048 - 0x0000)
struct FWuLogItem final
{
public:
	class FString                                 ItemId;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackCount;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Category;                                          // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SubCategory;                                       // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         AttachedItems;                                     // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuLogItem) == 0x000008, "Wrong alignment on FWuLogItem");
static_assert(sizeof(FWuLogItem) == 0x000048, "Wrong size on FWuLogItem");
static_assert(offsetof(FWuLogItem, ItemId) == 0x000000, "Member 'FWuLogItem::ItemId' has a wrong offset!");
static_assert(offsetof(FWuLogItem, StackCount) == 0x000010, "Member 'FWuLogItem::StackCount' has a wrong offset!");
static_assert(offsetof(FWuLogItem, Category) == 0x000018, "Member 'FWuLogItem::Category' has a wrong offset!");
static_assert(offsetof(FWuLogItem, SubCategory) == 0x000028, "Member 'FWuLogItem::SubCategory' has a wrong offset!");
static_assert(offsetof(FWuLogItem, AttachedItems) == 0x000038, "Member 'FWuLogItem::AttachedItems' has a wrong offset!");

// ScriptStruct TslGame.WuLogItemDetach
// 0x00C8 (0x00F0 - 0x0028)
struct FWuLogItemDetach final : public FLogBase
{
public:
	struct FWuLogCharacter                        Character;                                         // 0x0028(0x0038)(NativeAccessSpecifierPublic)
	struct FWuLogItem                             ParentItem;                                        // 0x0060(0x0048)(NativeAccessSpecifierPublic)
	struct FWuLogItem                             ChildItem;                                         // 0x00A8(0x0048)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuLogItemDetach) == 0x000008, "Wrong alignment on FWuLogItemDetach");
static_assert(sizeof(FWuLogItemDetach) == 0x0000F0, "Wrong size on FWuLogItemDetach");
static_assert(offsetof(FWuLogItemDetach, Character) == 0x000028, "Member 'FWuLogItemDetach::Character' has a wrong offset!");
static_assert(offsetof(FWuLogItemDetach, ParentItem) == 0x000060, "Member 'FWuLogItemDetach::ParentItem' has a wrong offset!");
static_assert(offsetof(FWuLogItemDetach, ChildItem) == 0x0000A8, "Member 'FWuLogItemDetach::ChildItem' has a wrong offset!");

// ScriptStruct TslGame.ItemSpawnDataRow
// 0x0020 (0x0028 - 0x0008)
struct FItemSpawnDataRow final : public FTableRowBase
{
public:
	struct FName                                   ValueFilter;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FName                                   CategoryFilter;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UItem>                      Item;                                              // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackCount;                                        // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemSpawnDataRow) == 0x000008, "Wrong alignment on FItemSpawnDataRow");
static_assert(sizeof(FItemSpawnDataRow) == 0x000028, "Wrong size on FItemSpawnDataRow");
static_assert(offsetof(FItemSpawnDataRow, ValueFilter) == 0x000008, "Member 'FItemSpawnDataRow::ValueFilter' has a wrong offset!");
static_assert(offsetof(FItemSpawnDataRow, CategoryFilter) == 0x000010, "Member 'FItemSpawnDataRow::CategoryFilter' has a wrong offset!");
static_assert(offsetof(FItemSpawnDataRow, Item) == 0x000018, "Member 'FItemSpawnDataRow::Item' has a wrong offset!");
static_assert(offsetof(FItemSpawnDataRow, StackCount) == 0x000020, "Member 'FItemSpawnDataRow::StackCount' has a wrong offset!");
static_assert(offsetof(FItemSpawnDataRow, Weight) == 0x000024, "Member 'FItemSpawnDataRow::Weight' has a wrong offset!");

// ScriptStruct TslGame.HighlightRecordConfig
// 0x000C (0x000C - 0x0000)
struct FHighlightRecordConfig final
{
public:
	float                                         BeforeDurationSec;                                 // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AfterDurationSec;                                  // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LinkWaitDurationSec;                               // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHighlightRecordConfig) == 0x000004, "Wrong alignment on FHighlightRecordConfig");
static_assert(sizeof(FHighlightRecordConfig) == 0x00000C, "Wrong size on FHighlightRecordConfig");
static_assert(offsetof(FHighlightRecordConfig, BeforeDurationSec) == 0x000000, "Member 'FHighlightRecordConfig::BeforeDurationSec' has a wrong offset!");
static_assert(offsetof(FHighlightRecordConfig, AfterDurationSec) == 0x000004, "Member 'FHighlightRecordConfig::AfterDurationSec' has a wrong offset!");
static_assert(offsetof(FHighlightRecordConfig, LinkWaitDurationSec) == 0x000008, "Member 'FHighlightRecordConfig::LinkWaitDurationSec' has a wrong offset!");

// ScriptStruct TslGame.WeaponAttachmentAssetData
// 0x0030 (0x0030 - 0x0000)
struct FWeaponAttachmentAssetData final
{
public:
	EWeaponAttachmentSlotID                       AttachmentSlotID;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FName                                   AttachmentTag;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             AttachmentMeshAsset;                               // 0x0010(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponAttachmentAssetData) == 0x000008, "Wrong alignment on FWeaponAttachmentAssetData");
static_assert(sizeof(FWeaponAttachmentAssetData) == 0x000030, "Wrong size on FWeaponAttachmentAssetData");
static_assert(offsetof(FWeaponAttachmentAssetData, AttachmentSlotID) == 0x000000, "Member 'FWeaponAttachmentAssetData::AttachmentSlotID' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentAssetData, AttachmentTag) == 0x000008, "Member 'FWeaponAttachmentAssetData::AttachmentTag' has a wrong offset!");
static_assert(offsetof(FWeaponAttachmentAssetData, AttachmentMeshAsset) == 0x000010, "Member 'FWeaponAttachmentAssetData::AttachmentMeshAsset' has a wrong offset!");

// ScriptStruct TslGame.EquipPosition
// 0x0008 (0x0008 - 0x0000)
struct FEquipPosition final
{
public:
	EEquipSlotID                                  SlotID;                                            // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Index;                                             // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEquipPosition) == 0x000004, "Wrong alignment on FEquipPosition");
static_assert(sizeof(FEquipPosition) == 0x000008, "Wrong size on FEquipPosition");
static_assert(offsetof(FEquipPosition, SlotID) == 0x000000, "Member 'FEquipPosition::SlotID' has a wrong offset!");
static_assert(offsetof(FEquipPosition, Index) == 0x000004, "Member 'FEquipPosition::Index' has a wrong offset!");

// ScriptStruct TslGame.WeaponRollAnim
// 0x0010 (0x0010 - 0x0000)
struct FWeaponRollAnim final
{
public:
	class UAnimMontage*                           RollLeft;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RollRight;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponRollAnim) == 0x000008, "Wrong alignment on FWeaponRollAnim");
static_assert(sizeof(FWeaponRollAnim) == 0x000010, "Wrong size on FWeaponRollAnim");
static_assert(offsetof(FWeaponRollAnim, RollLeft) == 0x000000, "Member 'FWeaponRollAnim::RollLeft' has a wrong offset!");
static_assert(offsetof(FWeaponRollAnim, RollRight) == 0x000008, "Member 'FWeaponRollAnim::RollRight' has a wrong offset!");

// ScriptStruct TslGame.PathPair
// 0x0010 (0x0010 - 0x0000)
struct FPathPair final
{
public:
	struct FVector2D                              StartPosition;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              EndPosition;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPathPair) == 0x000004, "Wrong alignment on FPathPair");
static_assert(sizeof(FPathPair) == 0x000010, "Wrong size on FPathPair");
static_assert(offsetof(FPathPair, StartPosition) == 0x000000, "Member 'FPathPair::StartPosition' has a wrong offset!");
static_assert(offsetof(FPathPair, EndPosition) == 0x000008, "Member 'FPathPair::EndPosition' has a wrong offset!");

// ScriptStruct TslGame.WeaponAnim
// 0x0010 (0x0010 - 0x0000)
struct FWeaponAnim final
{
public:
	class UAnimMontage*                           Pawn1P;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Pawn3P;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponAnim) == 0x000008, "Wrong alignment on FWeaponAnim");
static_assert(sizeof(FWeaponAnim) == 0x000010, "Wrong size on FWeaponAnim");
static_assert(offsetof(FWeaponAnim, Pawn1P) == 0x000000, "Member 'FWeaponAnim::Pawn1P' has a wrong offset!");
static_assert(offsetof(FWeaponAnim, Pawn3P) == 0x000008, "Member 'FWeaponAnim::Pawn3P' has a wrong offset!");

// ScriptStruct TslGame.WuLogMatchStart
// 0x0010 (0x0038 - 0x0028)
struct FWuLogMatchStart final : public FLogBase
{
public:
	TArray<struct FWuLogCharacter>                Characters;                                        // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuLogMatchStart) == 0x000008, "Wrong alignment on FWuLogMatchStart");
static_assert(sizeof(FWuLogMatchStart) == 0x000038, "Wrong size on FWuLogMatchStart");
static_assert(offsetof(FWuLogMatchStart, Characters) == 0x000028, "Member 'FWuLogMatchStart::Characters' has a wrong offset!");

// ScriptStruct TslGame.ItemSpotGroupTypeProperty
// 0x0168 (0x0168 - 0x0000)
struct FItemSpotGroupTypeProperty final
{
public:
	EItemSpotGroupType                            SpotGroupType;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpotGroupPercent;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FItemSpotTypeProperty>          SpotTypeProperties;                                // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x150];                                     // 0x0018(0x0150)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemSpotGroupTypeProperty) == 0x000008, "Wrong alignment on FItemSpotGroupTypeProperty");
static_assert(sizeof(FItemSpotGroupTypeProperty) == 0x000168, "Wrong size on FItemSpotGroupTypeProperty");
static_assert(offsetof(FItemSpotGroupTypeProperty, SpotGroupType) == 0x000000, "Member 'FItemSpotGroupTypeProperty::SpotGroupType' has a wrong offset!");
static_assert(offsetof(FItemSpotGroupTypeProperty, SpotGroupPercent) == 0x000004, "Member 'FItemSpotGroupTypeProperty::SpotGroupPercent' has a wrong offset!");
static_assert(offsetof(FItemSpotGroupTypeProperty, SpotTypeProperties) == 0x000008, "Member 'FItemSpotGroupTypeProperty::SpotTypeProperties' has a wrong offset!");

// ScriptStruct TslGame.MaterialMergerParameters
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FMaterialMergerParameters final
{
public:
	struct FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMaterialParameterType                        Type;                                              // 0x0008(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStoreToLUT;                                       // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LUTIndex;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParameterLUTChannel                          LUTChannel;                                        // 0x0010(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMaterialMergerParameters) == 0x000008, "Wrong alignment on FMaterialMergerParameters");
static_assert(sizeof(FMaterialMergerParameters) == 0x000018, "Wrong size on FMaterialMergerParameters");
static_assert(offsetof(FMaterialMergerParameters, Name) == 0x000000, "Member 'FMaterialMergerParameters::Name' has a wrong offset!");
static_assert(offsetof(FMaterialMergerParameters, Type) == 0x000008, "Member 'FMaterialMergerParameters::Type' has a wrong offset!");
static_assert(offsetof(FMaterialMergerParameters, bStoreToLUT) == 0x000009, "Member 'FMaterialMergerParameters::bStoreToLUT' has a wrong offset!");
static_assert(offsetof(FMaterialMergerParameters, LUTIndex) == 0x00000C, "Member 'FMaterialMergerParameters::LUTIndex' has a wrong offset!");
static_assert(offsetof(FMaterialMergerParameters, LUTChannel) == 0x000010, "Member 'FMaterialMergerParameters::LUTChannel' has a wrong offset!");

// ScriptStruct TslGame.BattleRoyalePoisionGasData
// 0x001C (0x001C - 0x0000)
struct FBattleRoyalePoisionGasData final
{
public:
	float                                         StartDelay;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarningDuration;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReleaseDuration;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusRate;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomRadiusRate;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PoisonGasDamagePerSecond;                          // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpreadRatio;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattleRoyalePoisionGasData) == 0x000004, "Wrong alignment on FBattleRoyalePoisionGasData");
static_assert(sizeof(FBattleRoyalePoisionGasData) == 0x00001C, "Wrong size on FBattleRoyalePoisionGasData");
static_assert(offsetof(FBattleRoyalePoisionGasData, StartDelay) == 0x000000, "Member 'FBattleRoyalePoisionGasData::StartDelay' has a wrong offset!");
static_assert(offsetof(FBattleRoyalePoisionGasData, WarningDuration) == 0x000004, "Member 'FBattleRoyalePoisionGasData::WarningDuration' has a wrong offset!");
static_assert(offsetof(FBattleRoyalePoisionGasData, ReleaseDuration) == 0x000008, "Member 'FBattleRoyalePoisionGasData::ReleaseDuration' has a wrong offset!");
static_assert(offsetof(FBattleRoyalePoisionGasData, RadiusRate) == 0x00000C, "Member 'FBattleRoyalePoisionGasData::RadiusRate' has a wrong offset!");
static_assert(offsetof(FBattleRoyalePoisionGasData, RandomRadiusRate) == 0x000010, "Member 'FBattleRoyalePoisionGasData::RandomRadiusRate' has a wrong offset!");
static_assert(offsetof(FBattleRoyalePoisionGasData, PoisonGasDamagePerSecond) == 0x000014, "Member 'FBattleRoyalePoisionGasData::PoisonGasDamagePerSecond' has a wrong offset!");
static_assert(offsetof(FBattleRoyalePoisionGasData, SpreadRatio) == 0x000018, "Member 'FBattleRoyalePoisionGasData::SpreadRatio' has a wrong offset!");

// ScriptStruct TslGame.WeaponGunAnim
// 0x00F0 (0x00F0 - 0x0000)
struct FWeaponGunAnim final
{
public:
	class UAnimMontage*                           Fire;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bLoopedFire : 1;                                   // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           Reload;                                            // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace1D*                          CharacterGripBlendspace;                           // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        CharacterLHGripBlendspace;                         // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CharacterFire;                                     // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CharacterFireCycle;                                // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CharacterFireSelector;                             // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CharacterReloadTactical;                           // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CharacterReloadCharge;                             // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CharacterReloadByOneStart;                         // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CharacterReloadByOneStop;                          // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           CharacterReloadByOneSingle;                        // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           WeaponReloadTactical;                              // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           WeaponReloadCharge;                                // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReloadDurationTactical;                            // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReloadDurationCharge;                              // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReloadDurationStart;                               // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReloadDurationLoop;                                // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReloadDurationMagOut;                              // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseBoltAction;                                    // 0x008C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FireCycleDelay;                                    // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireCycleDuration;                                 // 0x0094(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCycleAfterLastShot;                               // 0x0098(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCycleDuringReload;                                // 0x0099(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCameraShake>               ShotCameraShake;                                   // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShake>               ShotCameraShakeIronsight;                          // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShake>               ShotCameraShakeADS;                                // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraAnim*                            CycleCameraAnim;                                   // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilKickADS;                                     // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RecoilADSSocketOffsetScale;                        // 0x00C4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                MagDropLinearVelocity;                             // 0x00D0(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                MagDropAngularVelocity;                            // 0x00DC(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         InertiaInterpMultiplier;                           // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InertiaClampMultiplier;                            // 0x00EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponGunAnim) == 0x000008, "Wrong alignment on FWeaponGunAnim");
static_assert(sizeof(FWeaponGunAnim) == 0x0000F0, "Wrong size on FWeaponGunAnim");
static_assert(offsetof(FWeaponGunAnim, Fire) == 0x000000, "Member 'FWeaponGunAnim::Fire' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, Reload) == 0x000010, "Member 'FWeaponGunAnim::Reload' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, CharacterGripBlendspace) == 0x000018, "Member 'FWeaponGunAnim::CharacterGripBlendspace' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, CharacterLHGripBlendspace) == 0x000020, "Member 'FWeaponGunAnim::CharacterLHGripBlendspace' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, CharacterFire) == 0x000028, "Member 'FWeaponGunAnim::CharacterFire' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, CharacterFireCycle) == 0x000030, "Member 'FWeaponGunAnim::CharacterFireCycle' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, CharacterFireSelector) == 0x000038, "Member 'FWeaponGunAnim::CharacterFireSelector' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, CharacterReloadTactical) == 0x000040, "Member 'FWeaponGunAnim::CharacterReloadTactical' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, CharacterReloadCharge) == 0x000048, "Member 'FWeaponGunAnim::CharacterReloadCharge' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, CharacterReloadByOneStart) == 0x000050, "Member 'FWeaponGunAnim::CharacterReloadByOneStart' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, CharacterReloadByOneStop) == 0x000058, "Member 'FWeaponGunAnim::CharacterReloadByOneStop' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, CharacterReloadByOneSingle) == 0x000060, "Member 'FWeaponGunAnim::CharacterReloadByOneSingle' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, WeaponReloadTactical) == 0x000068, "Member 'FWeaponGunAnim::WeaponReloadTactical' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, WeaponReloadCharge) == 0x000070, "Member 'FWeaponGunAnim::WeaponReloadCharge' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, ReloadDurationTactical) == 0x000078, "Member 'FWeaponGunAnim::ReloadDurationTactical' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, ReloadDurationCharge) == 0x00007C, "Member 'FWeaponGunAnim::ReloadDurationCharge' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, ReloadDurationStart) == 0x000080, "Member 'FWeaponGunAnim::ReloadDurationStart' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, ReloadDurationLoop) == 0x000084, "Member 'FWeaponGunAnim::ReloadDurationLoop' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, ReloadDurationMagOut) == 0x000088, "Member 'FWeaponGunAnim::ReloadDurationMagOut' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, bUseBoltAction) == 0x00008C, "Member 'FWeaponGunAnim::bUseBoltAction' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, FireCycleDelay) == 0x000090, "Member 'FWeaponGunAnim::FireCycleDelay' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, FireCycleDuration) == 0x000094, "Member 'FWeaponGunAnim::FireCycleDuration' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, bCycleAfterLastShot) == 0x000098, "Member 'FWeaponGunAnim::bCycleAfterLastShot' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, bCycleDuringReload) == 0x000099, "Member 'FWeaponGunAnim::bCycleDuringReload' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, ShotCameraShake) == 0x0000A0, "Member 'FWeaponGunAnim::ShotCameraShake' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, ShotCameraShakeIronsight) == 0x0000A8, "Member 'FWeaponGunAnim::ShotCameraShakeIronsight' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, ShotCameraShakeADS) == 0x0000B0, "Member 'FWeaponGunAnim::ShotCameraShakeADS' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, CycleCameraAnim) == 0x0000B8, "Member 'FWeaponGunAnim::CycleCameraAnim' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, RecoilKickADS) == 0x0000C0, "Member 'FWeaponGunAnim::RecoilKickADS' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, RecoilADSSocketOffsetScale) == 0x0000C4, "Member 'FWeaponGunAnim::RecoilADSSocketOffsetScale' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, MagDropLinearVelocity) == 0x0000D0, "Member 'FWeaponGunAnim::MagDropLinearVelocity' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, MagDropAngularVelocity) == 0x0000DC, "Member 'FWeaponGunAnim::MagDropAngularVelocity' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, InertiaInterpMultiplier) == 0x0000E8, "Member 'FWeaponGunAnim::InertiaInterpMultiplier' has a wrong offset!");
static_assert(offsetof(FWeaponGunAnim, InertiaClampMultiplier) == 0x0000EC, "Member 'FWeaponGunAnim::InertiaClampMultiplier' has a wrong offset!");

// ScriptStruct TslGame.WeaponDeviationData
// 0x0040 (0x0040 - 0x0000)
struct FWeaponDeviationData final
{
public:
	float                                         DeviationBase;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeviationBaseAim;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeviationBaseADS;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeviationRecoilGain;                               // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeviationRecoilGainAim;                            // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeviationRecoilGainADS;                            // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeviationMax;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeviationMinMove;                                  // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeviationMaxMove;                                  // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeviationMoveMultiplier;                           // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeviationMoveMinReferenceVelocity;                 // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeviationMoveMaxReferenceVelocity;                 // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeviationStanceStand;                              // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeviationStanceCrouch;                             // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeviationStanceProne;                              // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeviationStanceJump;                               // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponDeviationData) == 0x000004, "Wrong alignment on FWeaponDeviationData");
static_assert(sizeof(FWeaponDeviationData) == 0x000040, "Wrong size on FWeaponDeviationData");
static_assert(offsetof(FWeaponDeviationData, DeviationBase) == 0x000000, "Member 'FWeaponDeviationData::DeviationBase' has a wrong offset!");
static_assert(offsetof(FWeaponDeviationData, DeviationBaseAim) == 0x000004, "Member 'FWeaponDeviationData::DeviationBaseAim' has a wrong offset!");
static_assert(offsetof(FWeaponDeviationData, DeviationBaseADS) == 0x000008, "Member 'FWeaponDeviationData::DeviationBaseADS' has a wrong offset!");
static_assert(offsetof(FWeaponDeviationData, DeviationRecoilGain) == 0x00000C, "Member 'FWeaponDeviationData::DeviationRecoilGain' has a wrong offset!");
static_assert(offsetof(FWeaponDeviationData, DeviationRecoilGainAim) == 0x000010, "Member 'FWeaponDeviationData::DeviationRecoilGainAim' has a wrong offset!");
static_assert(offsetof(FWeaponDeviationData, DeviationRecoilGainADS) == 0x000014, "Member 'FWeaponDeviationData::DeviationRecoilGainADS' has a wrong offset!");
static_assert(offsetof(FWeaponDeviationData, DeviationMax) == 0x000018, "Member 'FWeaponDeviationData::DeviationMax' has a wrong offset!");
static_assert(offsetof(FWeaponDeviationData, DeviationMinMove) == 0x00001C, "Member 'FWeaponDeviationData::DeviationMinMove' has a wrong offset!");
static_assert(offsetof(FWeaponDeviationData, DeviationMaxMove) == 0x000020, "Member 'FWeaponDeviationData::DeviationMaxMove' has a wrong offset!");
static_assert(offsetof(FWeaponDeviationData, DeviationMoveMultiplier) == 0x000024, "Member 'FWeaponDeviationData::DeviationMoveMultiplier' has a wrong offset!");
static_assert(offsetof(FWeaponDeviationData, DeviationMoveMinReferenceVelocity) == 0x000028, "Member 'FWeaponDeviationData::DeviationMoveMinReferenceVelocity' has a wrong offset!");
static_assert(offsetof(FWeaponDeviationData, DeviationMoveMaxReferenceVelocity) == 0x00002C, "Member 'FWeaponDeviationData::DeviationMoveMaxReferenceVelocity' has a wrong offset!");
static_assert(offsetof(FWeaponDeviationData, DeviationStanceStand) == 0x000030, "Member 'FWeaponDeviationData::DeviationStanceStand' has a wrong offset!");
static_assert(offsetof(FWeaponDeviationData, DeviationStanceCrouch) == 0x000034, "Member 'FWeaponDeviationData::DeviationStanceCrouch' has a wrong offset!");
static_assert(offsetof(FWeaponDeviationData, DeviationStanceProne) == 0x000038, "Member 'FWeaponDeviationData::DeviationStanceProne' has a wrong offset!");
static_assert(offsetof(FWeaponDeviationData, DeviationStanceJump) == 0x00003C, "Member 'FWeaponDeviationData::DeviationStanceJump' has a wrong offset!");

// ScriptStruct TslGame.WeaponGunData
// 0x0090 (0x0090 - 0x0000)
struct FWeaponGunData final
{
public:
	TSubclassOf<class UAmmoItem>                  AmmoItemClass;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        TracerClass;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmmoPerClip;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenShots;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoAnimReloadDuration;                              // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EFiringMode>                           FiringModes;                                       // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         BurstShots;                                        // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BurstDelay;                                        // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletPerFiring;                                   // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FiringBulletsSpread;                               // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsArrowProjectile;                                // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRotationFromBarrelWhenScoped;                     // 0x0041(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWeaponReloadMethod                           ReloadMethod;                                      // 0x0042(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x1];                                       // 0x0043(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReloadDurationByOneInitial;                        // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReloadDurationByOneLoop;                           // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementModifierAim;                               // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementModifierScope;                             // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponLength;                                      // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShoulderLength;                                    // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponSuppressorLength;                            // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceRadius;                                       // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceAdditiveZ;                                    // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugWeaponCollision;                              // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HandWeaponOffset;                                  // 0x006C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                HandWeaponOffsetFPP;                               // 0x0078(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bManualCycleAfterShot;                             // 0x0084(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bManualCycleInitialStateReady;                     // 0x0085(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_86[0x2];                                       // 0x0086(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LongTailDelay;                                     // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeaponGunData) == 0x000008, "Wrong alignment on FWeaponGunData");
static_assert(sizeof(FWeaponGunData) == 0x000090, "Wrong size on FWeaponGunData");
static_assert(offsetof(FWeaponGunData, AmmoItemClass) == 0x000000, "Member 'FWeaponGunData::AmmoItemClass' has a wrong offset!");
static_assert(offsetof(FWeaponGunData, TracerClass) == 0x000008, "Member 'FWeaponGunData::TracerClass' has a wrong offset!");
static_assert(offsetof(FWeaponGunData, AmmoPerClip) == 0x000010, "Member 'FWeaponGunData::AmmoPerClip' has a wrong offset!");
static_assert(offsetof(FWeaponGunData, TimeBetweenShots) == 0x000014, "Member 'FWeaponGunData::TimeBetweenShots' has a wrong offset!");
static_assert(offsetof(FWeaponGunData, NoAnimReloadDuration) == 0x000018, "Member 'FWeaponGunData::NoAnimReloadDuration' has a wrong offset!");
static_assert(offsetof(FWeaponGunData, FiringModes) == 0x000020, "Member 'FWeaponGunData::FiringModes' has a wrong offset!");
static_assert(offsetof(FWeaponGunData, BurstShots) == 0x000030, "Member 'FWeaponGunData::BurstShots' has a wrong offset!");
static_assert(offsetof(FWeaponGunData, BurstDelay) == 0x000034, "Member 'FWeaponGunData::BurstDelay' has a wrong offset!");
static_assert(offsetof(FWeaponGunData, BulletPerFiring) == 0x000038, "Member 'FWeaponGunData::BulletPerFiring' has a wrong offset!");
static_assert(offsetof(FWeaponGunData, FiringBulletsSpread) == 0x00003C, "Member 'FWeaponGunData::FiringBulletsSpread' has a wrong offset!");
static_assert(offsetof(FWeaponGunData, bIsArrowProjectile) == 0x000040, "Member 'FWeaponGunData::bIsArrowProjectile' has a wrong offset!");
static_assert(offsetof(FWeaponGunData, bRotationFromBarrelWhenScoped) == 0x000041, "Member 'FWeaponGunData::bRotationFromBarrelWhenScoped' has a wrong offset!");
static_assert(offsetof(FWeaponGunData, ReloadMethod) == 0x000042, "Member 'FWeaponGunData::ReloadMethod' has a wrong offset!");
static_assert(offsetof(FWeaponGunData, ReloadDurationByOneInitial) == 0x000044, "Member 'FWeaponGunData::ReloadDurationByOneInitial' has a wrong offset!");
static_assert(offsetof(FWeaponGunData, ReloadDurationByOneLoop) == 0x000048, "Member 'FWeaponGunData::ReloadDurationByOneLoop' has a wrong offset!");
static_assert(offsetof(FWeaponGunData, MovementModifierAim) == 0x00004C, "Member 'FWeaponGunData::MovementModifierAim' has a wrong offset!");
static_assert(offsetof(FWeaponGunData, MovementModifierScope) == 0x000050, "Member 'FWeaponGunData::MovementModifierScope' has a wrong offset!");
static_assert(offsetof(FWeaponGunData, WeaponLength) == 0x000054, "Member 'FWeaponGunData::WeaponLength' has a wrong offset!");
static_assert(offsetof(FWeaponGunData, ShoulderLength) == 0x000058, "Member 'FWeaponGunData::ShoulderLength' has a wrong offset!");
static_assert(offsetof(FWeaponGunData, WeaponSuppressorLength) == 0x00005C, "Member 'FWeaponGunData::WeaponSuppressorLength' has a wrong offset!");
static_assert(offsetof(FWeaponGunData, TraceRadius) == 0x000060, "Member 'FWeaponGunData::TraceRadius' has a wrong offset!");
static_assert(offsetof(FWeaponGunData, TraceAdditiveZ) == 0x000064, "Member 'FWeaponGunData::TraceAdditiveZ' has a wrong offset!");
static_assert(offsetof(FWeaponGunData, DebugWeaponCollision) == 0x000068, "Member 'FWeaponGunData::DebugWeaponCollision' has a wrong offset!");
static_assert(offsetof(FWeaponGunData, HandWeaponOffset) == 0x00006C, "Member 'FWeaponGunData::HandWeaponOffset' has a wrong offset!");
static_assert(offsetof(FWeaponGunData, HandWeaponOffsetFPP) == 0x000078, "Member 'FWeaponGunData::HandWeaponOffsetFPP' has a wrong offset!");
static_assert(offsetof(FWeaponGunData, bManualCycleAfterShot) == 0x000084, "Member 'FWeaponGunData::bManualCycleAfterShot' has a wrong offset!");
static_assert(offsetof(FWeaponGunData, bManualCycleInitialStateReady) == 0x000085, "Member 'FWeaponGunData::bManualCycleInitialStateReady' has a wrong offset!");
static_assert(offsetof(FWeaponGunData, LongTailDelay) == 0x000088, "Member 'FWeaponGunData::LongTailDelay' has a wrong offset!");

// ScriptStruct TslGame.VehicleSeatInfo
// 0x0018 (0x0018 - 0x0000)
struct FVehicleSeatInfo final
{
public:
	TSubclassOf<class AVehicleSeatActor>          SeatClass;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FName                                   RideSocketName;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FName                                   LeaveSocketName;                                   // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVehicleSeatInfo) == 0x000008, "Wrong alignment on FVehicleSeatInfo");
static_assert(sizeof(FVehicleSeatInfo) == 0x000018, "Wrong size on FVehicleSeatInfo");
static_assert(offsetof(FVehicleSeatInfo, SeatClass) == 0x000000, "Member 'FVehicleSeatInfo::SeatClass' has a wrong offset!");
static_assert(offsetof(FVehicleSeatInfo, RideSocketName) == 0x000008, "Member 'FVehicleSeatInfo::RideSocketName' has a wrong offset!");
static_assert(offsetof(FVehicleSeatInfo, LeaveSocketName) == 0x000010, "Member 'FVehicleSeatInfo::LeaveSocketName' has a wrong offset!");

// ScriptStruct TslGame.HornSoundInfo
// 0x0010 (0x0010 - 0x0000)
struct FHornSoundInfo final
{
public:
	class UAkAudioEvent*                          HornOnSound;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          HornOffSound;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHornSoundInfo) == 0x000008, "Wrong alignment on FHornSoundInfo");
static_assert(sizeof(FHornSoundInfo) == 0x000010, "Wrong size on FHornSoundInfo");
static_assert(offsetof(FHornSoundInfo, HornOnSound) == 0x000000, "Member 'FHornSoundInfo::HornOnSound' has a wrong offset!");
static_assert(offsetof(FHornSoundInfo, HornOffSound) == 0x000008, "Member 'FHornSoundInfo::HornOffSound' has a wrong offset!");

// ScriptStruct TslGame.TakeHitInfo
// 0x0040 (0x0040 - 0x0000)
struct FTakeHitInfo final
{
public:
	float                                         ActualDamage;                                      // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ATslPlayerState>         PlayerInstigator;                                  // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    DamageOrigin;                                      // 0x0018(0x000C)(NativeAccessSpecifierPublic)
	struct FVector_NetQuantize                    RelHitLocation;                                    // 0x0024(0x000C)(NativeAccessSpecifierPublic)
	struct FName                                   BoneName;                                          // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageMaxRadius;                                   // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ShotDirPitch;                                      // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ShotDirYaw;                                        // 0x003D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPointDamage : 1;                                  // 0x003E(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bRadialDamage : 1;                                 // 0x003E(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bKilled : 1;                                       // 0x003E(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         EnsureReplicationByte;                             // 0x003F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FTakeHitInfo) == 0x000008, "Wrong alignment on FTakeHitInfo");
static_assert(sizeof(FTakeHitInfo) == 0x000040, "Wrong size on FTakeHitInfo");
static_assert(offsetof(FTakeHitInfo, ActualDamage) == 0x000000, "Member 'FTakeHitInfo::ActualDamage' has a wrong offset!");
static_assert(offsetof(FTakeHitInfo, DamageType) == 0x000008, "Member 'FTakeHitInfo::DamageType' has a wrong offset!");
static_assert(offsetof(FTakeHitInfo, PlayerInstigator) == 0x000010, "Member 'FTakeHitInfo::PlayerInstigator' has a wrong offset!");
static_assert(offsetof(FTakeHitInfo, DamageOrigin) == 0x000018, "Member 'FTakeHitInfo::DamageOrigin' has a wrong offset!");
static_assert(offsetof(FTakeHitInfo, RelHitLocation) == 0x000024, "Member 'FTakeHitInfo::RelHitLocation' has a wrong offset!");
static_assert(offsetof(FTakeHitInfo, BoneName) == 0x000030, "Member 'FTakeHitInfo::BoneName' has a wrong offset!");
static_assert(offsetof(FTakeHitInfo, DamageMaxRadius) == 0x000038, "Member 'FTakeHitInfo::DamageMaxRadius' has a wrong offset!");
static_assert(offsetof(FTakeHitInfo, ShotDirPitch) == 0x00003C, "Member 'FTakeHitInfo::ShotDirPitch' has a wrong offset!");
static_assert(offsetof(FTakeHitInfo, ShotDirYaw) == 0x00003D, "Member 'FTakeHitInfo::ShotDirYaw' has a wrong offset!");
static_assert(offsetof(FTakeHitInfo, EnsureReplicationByte) == 0x00003F, "Member 'FTakeHitInfo::EnsureReplicationByte' has a wrong offset!");

// ScriptStruct TslGame.ZombieCustomizationData
// 0x0028 (0x0028 - 0x0000)
struct FZombieCustomizationData final
{
public:
	class FString                                 StringOptionKey;                                   // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGender                                       Gender;                                            // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ZombieOptionValues;                                // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZombieCustomizationData) == 0x000008, "Wrong alignment on FZombieCustomizationData");
static_assert(sizeof(FZombieCustomizationData) == 0x000028, "Wrong size on FZombieCustomizationData");
static_assert(offsetof(FZombieCustomizationData, StringOptionKey) == 0x000000, "Member 'FZombieCustomizationData::StringOptionKey' has a wrong offset!");
static_assert(offsetof(FZombieCustomizationData, Gender) == 0x000010, "Member 'FZombieCustomizationData::Gender' has a wrong offset!");
static_assert(offsetof(FZombieCustomizationData, ZombieOptionValues) == 0x000018, "Member 'FZombieCustomizationData::ZombieOptionValues' has a wrong offset!");

// ScriptStruct TslGame.BuffWithBoostGauge
// 0x0018 (0x0018 - 0x0000)
struct FBuffWithBoostGauge final
{
public:
	float                                         BoostGauge;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ATslBuff>                   Buff;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FName                                   OverlapId;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBuffWithBoostGauge) == 0x000008, "Wrong alignment on FBuffWithBoostGauge");
static_assert(sizeof(FBuffWithBoostGauge) == 0x000018, "Wrong size on FBuffWithBoostGauge");
static_assert(offsetof(FBuffWithBoostGauge, BoostGauge) == 0x000000, "Member 'FBuffWithBoostGauge::BoostGauge' has a wrong offset!");
static_assert(offsetof(FBuffWithBoostGauge, Buff) == 0x000008, "Member 'FBuffWithBoostGauge::Buff' has a wrong offset!");
static_assert(offsetof(FBuffWithBoostGauge, OverlapId) == 0x000010, "Member 'FBuffWithBoostGauge::OverlapId' has a wrong offset!");

// ScriptStruct TslGame.CharacterAnim
// 0x0010 (0x0010 - 0x0000)
struct FCharacterAnim final
{
public:
	class UAnimMontage*                           PickUpAnim;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           DeathAnim;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterAnim) == 0x000008, "Wrong alignment on FCharacterAnim");
static_assert(sizeof(FCharacterAnim) == 0x000010, "Wrong size on FCharacterAnim");
static_assert(offsetof(FCharacterAnim, PickUpAnim) == 0x000000, "Member 'FCharacterAnim::PickUpAnim' has a wrong offset!");
static_assert(offsetof(FCharacterAnim, DeathAnim) == 0x000008, "Member 'FCharacterAnim::DeathAnim' has a wrong offset!");

// ScriptStruct TslGame.StanceTransition
// 0x0010 (0x0010 - 0x0000)
struct FStanceTransition final
{
public:
	class UAnimMontage*                           TransitionAnim;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanPlayInMoving;                                   // 0x0008(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStanceTransition) == 0x000008, "Wrong alignment on FStanceTransition");
static_assert(sizeof(FStanceTransition) == 0x000010, "Wrong size on FStanceTransition");
static_assert(offsetof(FStanceTransition, TransitionAnim) == 0x000000, "Member 'FStanceTransition::TransitionAnim' has a wrong offset!");
static_assert(offsetof(FStanceTransition, CanPlayInMoving) == 0x000008, "Member 'FStanceTransition::CanPlayInMoving' has a wrong offset!");

// ScriptStruct TslGame.StanceTransitionData
// 0x0060 (0x0060 - 0x0000)
struct FStanceTransitionData final
{
public:
	struct FStanceTransition                      StandToCrouch;                                     // 0x0000(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FStanceTransition                      CrouchToStand;                                     // 0x0010(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FStanceTransition                      StandToProne;                                      // 0x0020(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FStanceTransition                      ProneToStand;                                      // 0x0030(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FStanceTransition                      CrouchToProne;                                     // 0x0040(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FStanceTransition                      ProneToCrouch;                                     // 0x0050(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStanceTransitionData) == 0x000008, "Wrong alignment on FStanceTransitionData");
static_assert(sizeof(FStanceTransitionData) == 0x000060, "Wrong size on FStanceTransitionData");
static_assert(offsetof(FStanceTransitionData, StandToCrouch) == 0x000000, "Member 'FStanceTransitionData::StandToCrouch' has a wrong offset!");
static_assert(offsetof(FStanceTransitionData, CrouchToStand) == 0x000010, "Member 'FStanceTransitionData::CrouchToStand' has a wrong offset!");
static_assert(offsetof(FStanceTransitionData, StandToProne) == 0x000020, "Member 'FStanceTransitionData::StandToProne' has a wrong offset!");
static_assert(offsetof(FStanceTransitionData, ProneToStand) == 0x000030, "Member 'FStanceTransitionData::ProneToStand' has a wrong offset!");
static_assert(offsetof(FStanceTransitionData, CrouchToProne) == 0x000040, "Member 'FStanceTransitionData::CrouchToProne' has a wrong offset!");
static_assert(offsetof(FStanceTransitionData, ProneToCrouch) == 0x000050, "Member 'FStanceTransitionData::ProneToCrouch' has a wrong offset!");

// ScriptStruct TslGame.InventoryItem
// 0x0010 (0x0010 - 0x0000)
struct FInventoryItem final
{
public:
	int32                                         Index;                                             // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UItem*                                  Item;                                              // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInventoryItem) == 0x000008, "Wrong alignment on FInventoryItem");
static_assert(sizeof(FInventoryItem) == 0x000010, "Wrong size on FInventoryItem");
static_assert(offsetof(FInventoryItem, Index) == 0x000000, "Member 'FInventoryItem::Index' has a wrong offset!");
static_assert(offsetof(FInventoryItem, Item) == 0x000008, "Member 'FInventoryItem::Item' has a wrong offset!");

// ScriptStruct TslGame.GeneralSpotGroupProperty
// 0x0020 (0x0020 - 0x0000)
struct FGeneralSpotGroupProperty
{
public:
	EThingSpotGroupType                           GroupType;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActiveByStartVolume;                              // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EThingGroupSpawnType                          SpawnType;                                         // 0x0002(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x1];                                        // 0x0003(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatRange                            TotalCountRange;                                   // 0x0004(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         TotalCountMultiplierWithPlayerCount;               // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProbabilityPercent;                                // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProbabilityPercentMultiplierWithPlayerCount;       // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGeneralSpotGroupProperty) == 0x000004, "Wrong alignment on FGeneralSpotGroupProperty");
static_assert(sizeof(FGeneralSpotGroupProperty) == 0x000020, "Wrong size on FGeneralSpotGroupProperty");
static_assert(offsetof(FGeneralSpotGroupProperty, GroupType) == 0x000000, "Member 'FGeneralSpotGroupProperty::GroupType' has a wrong offset!");
static_assert(offsetof(FGeneralSpotGroupProperty, bActiveByStartVolume) == 0x000001, "Member 'FGeneralSpotGroupProperty::bActiveByStartVolume' has a wrong offset!");
static_assert(offsetof(FGeneralSpotGroupProperty, SpawnType) == 0x000002, "Member 'FGeneralSpotGroupProperty::SpawnType' has a wrong offset!");
static_assert(offsetof(FGeneralSpotGroupProperty, TotalCountRange) == 0x000004, "Member 'FGeneralSpotGroupProperty::TotalCountRange' has a wrong offset!");
static_assert(offsetof(FGeneralSpotGroupProperty, TotalCountMultiplierWithPlayerCount) == 0x000014, "Member 'FGeneralSpotGroupProperty::TotalCountMultiplierWithPlayerCount' has a wrong offset!");
static_assert(offsetof(FGeneralSpotGroupProperty, ProbabilityPercent) == 0x000018, "Member 'FGeneralSpotGroupProperty::ProbabilityPercent' has a wrong offset!");
static_assert(offsetof(FGeneralSpotGroupProperty, ProbabilityPercentMultiplierWithPlayerCount) == 0x00001C, "Member 'FGeneralSpotGroupProperty::ProbabilityPercentMultiplierWithPlayerCount' has a wrong offset!");

// ScriptStruct TslGame.PackageSpawnProb
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FPackageSpawnProb final
{
public:
	float                                         ProbabilityPercent;                                // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FName                                   ValueFilter;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FName                                   CategoryFilter;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPackageSpawnProb) == 0x000008, "Wrong alignment on FPackageSpawnProb");
static_assert(sizeof(FPackageSpawnProb) == 0x000018, "Wrong size on FPackageSpawnProb");
static_assert(offsetof(FPackageSpawnProb, ProbabilityPercent) == 0x000000, "Member 'FPackageSpawnProb::ProbabilityPercent' has a wrong offset!");
static_assert(offsetof(FPackageSpawnProb, ValueFilter) == 0x000008, "Member 'FPackageSpawnProb::ValueFilter' has a wrong offset!");
static_assert(offsetof(FPackageSpawnProb, CategoryFilter) == 0x000010, "Member 'FPackageSpawnProb::CategoryFilter' has a wrong offset!");

// ScriptStruct TslGame.PackageSpotGroupProperty
// 0x0018 (0x0038 - 0x0020)
struct FPackageSpotGroupProperty final : public FGeneralSpotGroupProperty
{
public:
	TSubclassOf<class AItemPackage>               ItemPackageClass;                                  // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPackageSpawnProb>              PackageSpawnProbArray;                             // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPackageSpotGroupProperty) == 0x000008, "Wrong alignment on FPackageSpotGroupProperty");
static_assert(sizeof(FPackageSpotGroupProperty) == 0x000038, "Wrong size on FPackageSpotGroupProperty");
static_assert(offsetof(FPackageSpotGroupProperty, ItemPackageClass) == 0x000020, "Member 'FPackageSpotGroupProperty::ItemPackageClass' has a wrong offset!");
static_assert(offsetof(FPackageSpotGroupProperty, PackageSpawnProbArray) == 0x000028, "Member 'FPackageSpotGroupProperty::PackageSpawnProbArray' has a wrong offset!");

// ScriptStruct TslGame.VehicleSpawnDataRow
// 0x0018 (0x0020 - 0x0008)
struct FVehicleSpawnDataRow final : public FTableRowBase
{
public:
	struct FName                                   CategoryFilter;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class APawn>                      Vehicle;                                           // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSnapToFloor;                                      // 0x001C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVehicleSpawnDataRow) == 0x000008, "Wrong alignment on FVehicleSpawnDataRow");
static_assert(sizeof(FVehicleSpawnDataRow) == 0x000020, "Wrong size on FVehicleSpawnDataRow");
static_assert(offsetof(FVehicleSpawnDataRow, CategoryFilter) == 0x000008, "Member 'FVehicleSpawnDataRow::CategoryFilter' has a wrong offset!");
static_assert(offsetof(FVehicleSpawnDataRow, Vehicle) == 0x000010, "Member 'FVehicleSpawnDataRow::Vehicle' has a wrong offset!");
static_assert(offsetof(FVehicleSpawnDataRow, Weight) == 0x000018, "Member 'FVehicleSpawnDataRow::Weight' has a wrong offset!");
static_assert(offsetof(FVehicleSpawnDataRow, bSnapToFloor) == 0x00001C, "Member 'FVehicleSpawnDataRow::bSnapToFloor' has a wrong offset!");

// ScriptStruct TslGame.VehicleSpotGroupProperty
// 0x0020 (0x0040 - 0x0020)
struct FVehicleSpotGroupProperty final : public FGeneralSpotGroupProperty
{
public:
	TArray<struct FNameWeight>                    WeightsPerCategory;                                // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FFloatRange                            FuelPercentRange;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVehicleSpotGroupProperty) == 0x000008, "Wrong alignment on FVehicleSpotGroupProperty");
static_assert(sizeof(FVehicleSpotGroupProperty) == 0x000040, "Wrong size on FVehicleSpotGroupProperty");
static_assert(offsetof(FVehicleSpotGroupProperty, WeightsPerCategory) == 0x000020, "Member 'FVehicleSpotGroupProperty::WeightsPerCategory' has a wrong offset!");
static_assert(offsetof(FVehicleSpotGroupProperty, FuelPercentRange) == 0x000030, "Member 'FVehicleSpotGroupProperty::FuelPercentRange' has a wrong offset!");

// ScriptStruct TslGame.AircraftParticle
// 0x0010 (0x0010 - 0x0000)
struct FAircraftParticle final
{
public:
	TSubclassOf<class ATslParticle>               ParticleClass;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FName                                   AttachSocket;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAircraftParticle) == 0x000008, "Wrong alignment on FAircraftParticle");
static_assert(sizeof(FAircraftParticle) == 0x000010, "Wrong size on FAircraftParticle");
static_assert(offsetof(FAircraftParticle, ParticleClass) == 0x000000, "Member 'FAircraftParticle::ParticleClass' has a wrong offset!");
static_assert(offsetof(FAircraftParticle, AttachSocket) == 0x000008, "Member 'FAircraftParticle::AttachSocket' has a wrong offset!");

// ScriptStruct TslGame.WuLogVehicleRide
// 0x0060 (0x0088 - 0x0028)
struct FWuLogVehicleRide final : public FLogBase
{
public:
	struct FWuLogCharacter                        Character;                                         // 0x0028(0x0038)(NativeAccessSpecifierPublic)
	struct FWuLogVehicle                          Vehicle;                                           // 0x0060(0x0028)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuLogVehicleRide) == 0x000008, "Wrong alignment on FWuLogVehicleRide");
static_assert(sizeof(FWuLogVehicleRide) == 0x000088, "Wrong size on FWuLogVehicleRide");
static_assert(offsetof(FWuLogVehicleRide, Character) == 0x000028, "Member 'FWuLogVehicleRide::Character' has a wrong offset!");
static_assert(offsetof(FWuLogVehicleRide, Vehicle) == 0x000060, "Member 'FWuLogVehicleRide::Vehicle' has a wrong offset!");

// ScriptStruct TslGame.DropCarePackageTableData
// 0x0008 (0x0008 - 0x0000)
struct FDropCarePackageTableData final
{
public:
	int32                                         DropCount;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DropPercent;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDropCarePackageTableData) == 0x000004, "Wrong alignment on FDropCarePackageTableData");
static_assert(sizeof(FDropCarePackageTableData) == 0x000008, "Wrong size on FDropCarePackageTableData");
static_assert(offsetof(FDropCarePackageTableData, DropCount) == 0x000000, "Member 'FDropCarePackageTableData::DropCount' has a wrong offset!");
static_assert(offsetof(FDropCarePackageTableData, DropPercent) == 0x000004, "Member 'FDropCarePackageTableData::DropPercent' has a wrong offset!");

// ScriptStruct TslGame.InteractionCollisionData
// 0x0014 (0x0014 - 0x0000)
struct FInteractionCollisionData final
{
public:
	float                                         CapsuleHalfHeight;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleRadius;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CapsuleOffset;                                     // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionCollisionData) == 0x000004, "Wrong alignment on FInteractionCollisionData");
static_assert(sizeof(FInteractionCollisionData) == 0x000014, "Wrong size on FInteractionCollisionData");
static_assert(offsetof(FInteractionCollisionData, CapsuleHalfHeight) == 0x000000, "Member 'FInteractionCollisionData::CapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(FInteractionCollisionData, CapsuleRadius) == 0x000004, "Member 'FInteractionCollisionData::CapsuleRadius' has a wrong offset!");
static_assert(offsetof(FInteractionCollisionData, CapsuleOffset) == 0x000008, "Member 'FInteractionCollisionData::CapsuleOffset' has a wrong offset!");

// ScriptStruct TslGame.HornPlayInfo
// 0x0008 (0x0008 - 0x0000)
struct FHornPlayInfo final
{
public:
	bool                                          bMakeSureDirty;                                    // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHornSoundType                                HornSoundType;                                     // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KeyPressedTime;                                    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHornPlayInfo) == 0x000004, "Wrong alignment on FHornPlayInfo");
static_assert(sizeof(FHornPlayInfo) == 0x000008, "Wrong size on FHornPlayInfo");
static_assert(offsetof(FHornPlayInfo, bMakeSureDirty) == 0x000000, "Member 'FHornPlayInfo::bMakeSureDirty' has a wrong offset!");
static_assert(offsetof(FHornPlayInfo, HornSoundType) == 0x000001, "Member 'FHornPlayInfo::HornSoundType' has a wrong offset!");
static_assert(offsetof(FHornPlayInfo, KeyPressedTime) == 0x000004, "Member 'FHornPlayInfo::KeyPressedTime' has a wrong offset!");

// ScriptStruct TslGame.TslImpactSoundInfo
// 0x0060 (0x0060 - 0x0000)
struct FTslImpactSoundInfo final
{
public:
	class UAkAudioEvent*                          DefaultSoundAk;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          ConcreteSoundAk;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          DirtSoundAk;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          WaterSoundAk;                                      // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          MetalSoundAk;                                      // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          WoodSoundAk;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          GrassSoundAk;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          GlassSoundAk;                                      // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          FleshSoundAk;                                      // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          RockSoundAk;                                       // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          SandSoundAk;                                       // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          MudSoundAk;                                        // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTslImpactSoundInfo) == 0x000008, "Wrong alignment on FTslImpactSoundInfo");
static_assert(sizeof(FTslImpactSoundInfo) == 0x000060, "Wrong size on FTslImpactSoundInfo");
static_assert(offsetof(FTslImpactSoundInfo, DefaultSoundAk) == 0x000000, "Member 'FTslImpactSoundInfo::DefaultSoundAk' has a wrong offset!");
static_assert(offsetof(FTslImpactSoundInfo, ConcreteSoundAk) == 0x000008, "Member 'FTslImpactSoundInfo::ConcreteSoundAk' has a wrong offset!");
static_assert(offsetof(FTslImpactSoundInfo, DirtSoundAk) == 0x000010, "Member 'FTslImpactSoundInfo::DirtSoundAk' has a wrong offset!");
static_assert(offsetof(FTslImpactSoundInfo, WaterSoundAk) == 0x000018, "Member 'FTslImpactSoundInfo::WaterSoundAk' has a wrong offset!");
static_assert(offsetof(FTslImpactSoundInfo, MetalSoundAk) == 0x000020, "Member 'FTslImpactSoundInfo::MetalSoundAk' has a wrong offset!");
static_assert(offsetof(FTslImpactSoundInfo, WoodSoundAk) == 0x000028, "Member 'FTslImpactSoundInfo::WoodSoundAk' has a wrong offset!");
static_assert(offsetof(FTslImpactSoundInfo, GrassSoundAk) == 0x000030, "Member 'FTslImpactSoundInfo::GrassSoundAk' has a wrong offset!");
static_assert(offsetof(FTslImpactSoundInfo, GlassSoundAk) == 0x000038, "Member 'FTslImpactSoundInfo::GlassSoundAk' has a wrong offset!");
static_assert(offsetof(FTslImpactSoundInfo, FleshSoundAk) == 0x000040, "Member 'FTslImpactSoundInfo::FleshSoundAk' has a wrong offset!");
static_assert(offsetof(FTslImpactSoundInfo, RockSoundAk) == 0x000048, "Member 'FTslImpactSoundInfo::RockSoundAk' has a wrong offset!");
static_assert(offsetof(FTslImpactSoundInfo, SandSoundAk) == 0x000050, "Member 'FTslImpactSoundInfo::SandSoundAk' has a wrong offset!");
static_assert(offsetof(FTslImpactSoundInfo, MudSoundAk) == 0x000058, "Member 'FTslImpactSoundInfo::MudSoundAk' has a wrong offset!");

// ScriptStruct TslGame.VaultingTask
// 0x0040 (0x0040 - 0x0000)
struct FVaultingTask final
{
public:
	struct FVector                                V_Start;                                           // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                V_Apex;                                            // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                V_ApexAdditive;                                    // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                V_End;                                             // 0x0024(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EVaultAnimType                                InVaultType;                                       // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndToFall;                                        // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Direction;                                         // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerSpeed;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceFromObject;                                // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVaultingTask) == 0x000004, "Wrong alignment on FVaultingTask");
static_assert(sizeof(FVaultingTask) == 0x000040, "Wrong size on FVaultingTask");
static_assert(offsetof(FVaultingTask, V_Start) == 0x000000, "Member 'FVaultingTask::V_Start' has a wrong offset!");
static_assert(offsetof(FVaultingTask, V_Apex) == 0x00000C, "Member 'FVaultingTask::V_Apex' has a wrong offset!");
static_assert(offsetof(FVaultingTask, V_ApexAdditive) == 0x000018, "Member 'FVaultingTask::V_ApexAdditive' has a wrong offset!");
static_assert(offsetof(FVaultingTask, V_End) == 0x000024, "Member 'FVaultingTask::V_End' has a wrong offset!");
static_assert(offsetof(FVaultingTask, InVaultType) == 0x000030, "Member 'FVaultingTask::InVaultType' has a wrong offset!");
static_assert(offsetof(FVaultingTask, bEndToFall) == 0x000031, "Member 'FVaultingTask::bEndToFall' has a wrong offset!");
static_assert(offsetof(FVaultingTask, Direction) == 0x000034, "Member 'FVaultingTask::Direction' has a wrong offset!");
static_assert(offsetof(FVaultingTask, PlayerSpeed) == 0x000038, "Member 'FVaultingTask::PlayerSpeed' has a wrong offset!");
static_assert(offsetof(FVaultingTask, DistanceFromObject) == 0x00003C, "Member 'FVaultingTask::DistanceFromObject' has a wrong offset!");

// ScriptStruct TslGame.TslPointDamageEvent
// 0x0008 (0x00B8 - 0x00B0)
struct FTslPointDamageEvent final : public FPointDamageEvent
{
public:
	bool                                          bDestructibleDoor;                                 // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTslPointDamageEvent) == 0x000008, "Wrong alignment on FTslPointDamageEvent");
static_assert(sizeof(FTslPointDamageEvent) == 0x0000B8, "Wrong size on FTslPointDamageEvent");
static_assert(offsetof(FTslPointDamageEvent, bDestructibleDoor) == 0x0000B0, "Member 'FTslPointDamageEvent::bDestructibleDoor' has a wrong offset!");

// ScriptStruct TslGame.CustomMouseSensitiveData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FCustomMouseSensitiveData final
{
public:
	struct FName                                   MouseSensitiveName;                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseSensitivity;                                  // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastConvertedMouseSensitivity;                     // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomMouseSensitiveData) == 0x000008, "Wrong alignment on FCustomMouseSensitiveData");
static_assert(sizeof(FCustomMouseSensitiveData) == 0x000010, "Wrong size on FCustomMouseSensitiveData");
static_assert(offsetof(FCustomMouseSensitiveData, MouseSensitiveName) == 0x000000, "Member 'FCustomMouseSensitiveData::MouseSensitiveName' has a wrong offset!");
static_assert(offsetof(FCustomMouseSensitiveData, MouseSensitivity) == 0x000008, "Member 'FCustomMouseSensitiveData::MouseSensitivity' has a wrong offset!");
static_assert(offsetof(FCustomMouseSensitiveData, LastConvertedMouseSensitivity) == 0x00000C, "Member 'FCustomMouseSensitiveData::LastConvertedMouseSensitivity' has a wrong offset!");

// ScriptStruct TslGame.DamageRatioInfo
// 0x0008 (0x0008 - 0x0000)
struct FDamageRatioInfo final
{
public:
	float                                         DamageRatio;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageVictimActorType                        DamageVictimActorType;                             // 0x0004(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageRatioInfo) == 0x000004, "Wrong alignment on FDamageRatioInfo");
static_assert(sizeof(FDamageRatioInfo) == 0x000008, "Wrong size on FDamageRatioInfo");
static_assert(offsetof(FDamageRatioInfo, DamageRatio) == 0x000000, "Member 'FDamageRatioInfo::DamageRatio' has a wrong offset!");
static_assert(offsetof(FDamageRatioInfo, DamageVictimActorType) == 0x000004, "Member 'FDamageRatioInfo::DamageVictimActorType' has a wrong offset!");

// ScriptStruct TslGame.WuLogPlayerMakeGroggy
// 0x00A0 (0x00C8 - 0x0028)
struct FWuLogPlayerMakeGroggy final : public FLogBase
{
public:
	int32                                         AttackId;                                          // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWuLogCharacter                        Attacker;                                          // 0x0030(0x0038)(NativeAccessSpecifierPublic)
	struct FWuLogCharacter                        Victim;                                            // 0x0068(0x0038)(NativeAccessSpecifierPublic)
	class FString                                 DamageTypeCategory;                                // 0x00A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DamageCauserName;                                  // 0x00B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWuLogPlayerMakeGroggy) == 0x000008, "Wrong alignment on FWuLogPlayerMakeGroggy");
static_assert(sizeof(FWuLogPlayerMakeGroggy) == 0x0000C8, "Wrong size on FWuLogPlayerMakeGroggy");
static_assert(offsetof(FWuLogPlayerMakeGroggy, AttackId) == 0x000028, "Member 'FWuLogPlayerMakeGroggy::AttackId' has a wrong offset!");
static_assert(offsetof(FWuLogPlayerMakeGroggy, Attacker) == 0x000030, "Member 'FWuLogPlayerMakeGroggy::Attacker' has a wrong offset!");
static_assert(offsetof(FWuLogPlayerMakeGroggy, Victim) == 0x000068, "Member 'FWuLogPlayerMakeGroggy::Victim' has a wrong offset!");
static_assert(offsetof(FWuLogPlayerMakeGroggy, DamageTypeCategory) == 0x0000A0, "Member 'FWuLogPlayerMakeGroggy::DamageTypeCategory' has a wrong offset!");
static_assert(offsetof(FWuLogPlayerMakeGroggy, DamageCauserName) == 0x0000B0, "Member 'FWuLogPlayerMakeGroggy::DamageCauserName' has a wrong offset!");
static_assert(offsetof(FWuLogPlayerMakeGroggy, Distance) == 0x0000C0, "Member 'FWuLogPlayerMakeGroggy::Distance' has a wrong offset!");

// ScriptStruct TslGame.TslChatStyle
// 0x0980 (0x0988 - 0x0008)
struct FTslChatStyle final : public FSlateWidgetStyle
{
public:
	struct FEditableTextBoxStyle                  TextEntryStyle;                                    // 0x0008(0x0870)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            BackingBrush;                                      // 0x0878(0x0090)(Edit, NativeAccessSpecifierPublic)
	struct FSlateColor                            BoxBorderColor;                                    // 0x0908(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FSlateColor                            TextColor;                                         // 0x0930(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FSlateSound                            RxMessgeSound;                                     // 0x0958(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSlateSound                            TxMessgeSound;                                     // 0x0970(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTslChatStyle) == 0x000008, "Wrong alignment on FTslChatStyle");
static_assert(sizeof(FTslChatStyle) == 0x000988, "Wrong size on FTslChatStyle");
static_assert(offsetof(FTslChatStyle, TextEntryStyle) == 0x000008, "Member 'FTslChatStyle::TextEntryStyle' has a wrong offset!");
static_assert(offsetof(FTslChatStyle, BackingBrush) == 0x000878, "Member 'FTslChatStyle::BackingBrush' has a wrong offset!");
static_assert(offsetof(FTslChatStyle, BoxBorderColor) == 0x000908, "Member 'FTslChatStyle::BoxBorderColor' has a wrong offset!");
static_assert(offsetof(FTslChatStyle, TextColor) == 0x000930, "Member 'FTslChatStyle::TextColor' has a wrong offset!");
static_assert(offsetof(FTslChatStyle, RxMessgeSound) == 0x000958, "Member 'FTslChatStyle::RxMessgeSound' has a wrong offset!");
static_assert(offsetof(FTslChatStyle, TxMessgeSound) == 0x000970, "Member 'FTslChatStyle::TxMessgeSound' has a wrong offset!");

// ScriptStruct TslGame.DamageFieldLayout
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FDamageFieldLayout final
{
public:
	float                                         CreationDelay;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LocationOffset;                                    // 0x0004(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0xC];                                        // 0x000C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageFieldLayout) == 0x000008, "Wrong alignment on FDamageFieldLayout");
static_assert(sizeof(FDamageFieldLayout) == 0x000018, "Wrong size on FDamageFieldLayout");
static_assert(offsetof(FDamageFieldLayout, CreationDelay) == 0x000000, "Member 'FDamageFieldLayout::CreationDelay' has a wrong offset!");
static_assert(offsetof(FDamageFieldLayout, LocationOffset) == 0x000004, "Member 'FDamageFieldLayout::LocationOffset' has a wrong offset!");

// ScriptStruct TslGame.DoorBreakingStateLegacy
// 0x0001 (0x0001 - 0x0000)
struct FDoorBreakingStateLegacy final
{
public:
	uint8                                         bIsBrokenTop : 1;                                  // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsBrokenCenter : 1;                               // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsBrokenBottom : 1;                               // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsDM : 1;                                         // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FDoorBreakingStateLegacy) == 0x000001, "Wrong alignment on FDoorBreakingStateLegacy");
static_assert(sizeof(FDoorBreakingStateLegacy) == 0x000001, "Wrong size on FDoorBreakingStateLegacy");

// ScriptStruct TslGame.WuLogItemPickup
// 0x0080 (0x00A8 - 0x0028)
struct FWuLogItemPickup final : public FLogBase
{
public:
	struct FWuLogCharacter                        Character;                                         // 0x0028(0x0038)(NativeAccessSpecifierPublic)
	struct FWuLogItem                             Item;                                              // 0x0060(0x0048)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuLogItemPickup) == 0x000008, "Wrong alignment on FWuLogItemPickup");
static_assert(sizeof(FWuLogItemPickup) == 0x0000A8, "Wrong size on FWuLogItemPickup");
static_assert(offsetof(FWuLogItemPickup, Character) == 0x000028, "Member 'FWuLogItemPickup::Character' has a wrong offset!");
static_assert(offsetof(FWuLogItemPickup, Item) == 0x000060, "Member 'FWuLogItemPickup::Item' has a wrong offset!");

// ScriptStruct TslGame.DecalEffectData
// 0x0028 (0x0028 - 0x0000)
struct FDecalEffectData final
{
public:
	class UMaterial*                              Material;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatRange                            Size;                                              // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FadeScreenSize;                                    // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeStartDelay;                                    // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeDuration;                                      // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRandomInput;                                   // 0x0024(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRandomRoll;                                    // 0x0025(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReversal;                                         // 0x0026(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27[0x1];                                       // 0x0027(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDecalEffectData) == 0x000008, "Wrong alignment on FDecalEffectData");
static_assert(sizeof(FDecalEffectData) == 0x000028, "Wrong size on FDecalEffectData");
static_assert(offsetof(FDecalEffectData, Material) == 0x000000, "Member 'FDecalEffectData::Material' has a wrong offset!");
static_assert(offsetof(FDecalEffectData, Size) == 0x000008, "Member 'FDecalEffectData::Size' has a wrong offset!");
static_assert(offsetof(FDecalEffectData, FadeScreenSize) == 0x000018, "Member 'FDecalEffectData::FadeScreenSize' has a wrong offset!");
static_assert(offsetof(FDecalEffectData, FadeStartDelay) == 0x00001C, "Member 'FDecalEffectData::FadeStartDelay' has a wrong offset!");
static_assert(offsetof(FDecalEffectData, FadeDuration) == 0x000020, "Member 'FDecalEffectData::FadeDuration' has a wrong offset!");
static_assert(offsetof(FDecalEffectData, bUseRandomInput) == 0x000024, "Member 'FDecalEffectData::bUseRandomInput' has a wrong offset!");
static_assert(offsetof(FDecalEffectData, bUseRandomRoll) == 0x000025, "Member 'FDecalEffectData::bUseRandomRoll' has a wrong offset!");
static_assert(offsetof(FDecalEffectData, bReversal) == 0x000026, "Member 'FDecalEffectData::bReversal' has a wrong offset!");

// ScriptStruct TslGame.DecalEffectDataSet
// 0x0168 (0x0168 - 0x0000)
struct FDecalEffectDataSet final
{
public:
	struct FDecalEffectData                       DefaultDecal;                                      // 0x0000(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDecalEffectData                       ConcreteDecal;                                     // 0x0028(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDecalEffectData                       DirtDecal;                                         // 0x0050(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDecalEffectData                       WaterDecal;                                        // 0x0078(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDecalEffectData                       MetalDecal;                                        // 0x00A0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDecalEffectData                       WoodDecal;                                         // 0x00C8(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDecalEffectData                       GlassDecal;                                        // 0x00F0(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDecalEffectData                       GrassDecal;                                        // 0x0118(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDecalEffectData                       FleshDecal;                                        // 0x0140(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDecalEffectDataSet) == 0x000008, "Wrong alignment on FDecalEffectDataSet");
static_assert(sizeof(FDecalEffectDataSet) == 0x000168, "Wrong size on FDecalEffectDataSet");
static_assert(offsetof(FDecalEffectDataSet, DefaultDecal) == 0x000000, "Member 'FDecalEffectDataSet::DefaultDecal' has a wrong offset!");
static_assert(offsetof(FDecalEffectDataSet, ConcreteDecal) == 0x000028, "Member 'FDecalEffectDataSet::ConcreteDecal' has a wrong offset!");
static_assert(offsetof(FDecalEffectDataSet, DirtDecal) == 0x000050, "Member 'FDecalEffectDataSet::DirtDecal' has a wrong offset!");
static_assert(offsetof(FDecalEffectDataSet, WaterDecal) == 0x000078, "Member 'FDecalEffectDataSet::WaterDecal' has a wrong offset!");
static_assert(offsetof(FDecalEffectDataSet, MetalDecal) == 0x0000A0, "Member 'FDecalEffectDataSet::MetalDecal' has a wrong offset!");
static_assert(offsetof(FDecalEffectDataSet, WoodDecal) == 0x0000C8, "Member 'FDecalEffectDataSet::WoodDecal' has a wrong offset!");
static_assert(offsetof(FDecalEffectDataSet, GlassDecal) == 0x0000F0, "Member 'FDecalEffectDataSet::GlassDecal' has a wrong offset!");
static_assert(offsetof(FDecalEffectDataSet, GrassDecal) == 0x000118, "Member 'FDecalEffectDataSet::GrassDecal' has a wrong offset!");
static_assert(offsetof(FDecalEffectDataSet, FleshDecal) == 0x000140, "Member 'FDecalEffectDataSet::FleshDecal' has a wrong offset!");

// ScriptStruct TslGame.PointDamageReactionData
// 0x0010 (0x0010 - 0x0000)
struct FPointDamageReactionData final
{
public:
	EReactionType                                 ReactionType;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReactionForceFactor;                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReactionMinDamage;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageAccumulateTimeout;                           // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPointDamageReactionData) == 0x000004, "Wrong alignment on FPointDamageReactionData");
static_assert(sizeof(FPointDamageReactionData) == 0x000010, "Wrong size on FPointDamageReactionData");
static_assert(offsetof(FPointDamageReactionData, ReactionType) == 0x000000, "Member 'FPointDamageReactionData::ReactionType' has a wrong offset!");
static_assert(offsetof(FPointDamageReactionData, ReactionForceFactor) == 0x000004, "Member 'FPointDamageReactionData::ReactionForceFactor' has a wrong offset!");
static_assert(offsetof(FPointDamageReactionData, ReactionMinDamage) == 0x000008, "Member 'FPointDamageReactionData::ReactionMinDamage' has a wrong offset!");
static_assert(offsetof(FPointDamageReactionData, DamageAccumulateTimeout) == 0x00000C, "Member 'FPointDamageReactionData::DamageAccumulateTimeout' has a wrong offset!");

// ScriptStruct TslGame.RadialDamageReactionData
// 0x000C (0x000C - 0x0000)
struct FRadialDamageReactionData final
{
public:
	EReactionType                                 ReactionType;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReactionForceFactor;                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReactionMinDamage;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRadialDamageReactionData) == 0x000004, "Wrong alignment on FRadialDamageReactionData");
static_assert(sizeof(FRadialDamageReactionData) == 0x00000C, "Wrong size on FRadialDamageReactionData");
static_assert(offsetof(FRadialDamageReactionData, ReactionType) == 0x000000, "Member 'FRadialDamageReactionData::ReactionType' has a wrong offset!");
static_assert(offsetof(FRadialDamageReactionData, ReactionForceFactor) == 0x000004, "Member 'FRadialDamageReactionData::ReactionForceFactor' has a wrong offset!");
static_assert(offsetof(FRadialDamageReactionData, ReactionMinDamage) == 0x000008, "Member 'FRadialDamageReactionData::ReactionMinDamage' has a wrong offset!");

// ScriptStruct TslGame.VehicleReactionData
// 0x000C (0x000C - 0x0000)
struct FVehicleReactionData final
{
public:
	EReactionType                                 ReactionType;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReactionForceFactor;                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReactionMinSpeed;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVehicleReactionData) == 0x000004, "Wrong alignment on FVehicleReactionData");
static_assert(sizeof(FVehicleReactionData) == 0x00000C, "Wrong size on FVehicleReactionData");
static_assert(offsetof(FVehicleReactionData, ReactionType) == 0x000000, "Member 'FVehicleReactionData::ReactionType' has a wrong offset!");
static_assert(offsetof(FVehicleReactionData, ReactionForceFactor) == 0x000004, "Member 'FVehicleReactionData::ReactionForceFactor' has a wrong offset!");
static_assert(offsetof(FVehicleReactionData, ReactionMinSpeed) == 0x000008, "Member 'FVehicleReactionData::ReactionMinSpeed' has a wrong offset!");

// ScriptStruct TslGame.PresetColor
// 0x0038 (0x0038 - 0x0000)
struct FPresetColor final
{
public:
	struct FLinearColor                           Color;                                             // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 ColorString;                                       // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPresetColor) == 0x000008, "Wrong alignment on FPresetColor");
static_assert(sizeof(FPresetColor) == 0x000038, "Wrong size on FPresetColor");
static_assert(offsetof(FPresetColor, Color) == 0x000000, "Member 'FPresetColor::Color' has a wrong offset!");
static_assert(offsetof(FPresetColor, DisplayName) == 0x000010, "Member 'FPresetColor::DisplayName' has a wrong offset!");
static_assert(offsetof(FPresetColor, ColorString) == 0x000028, "Member 'FPresetColor::ColorString' has a wrong offset!");

// ScriptStruct TslGame.CustomGameUpdateCharacterInfo
// 0x0014 (0x0014 - 0x0000)
struct FCustomGameUpdateCharacterInfo final
{
public:
	bool                                          bIsZombie;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGroggyMode;                                     // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReviveCastingTime;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MultiplierGroggyDamagePerSecond;                   // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MultiplierPunchDamage;                             // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MultiplierZombieToZombieDamage;                    // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomGameUpdateCharacterInfo) == 0x000004, "Wrong alignment on FCustomGameUpdateCharacterInfo");
static_assert(sizeof(FCustomGameUpdateCharacterInfo) == 0x000014, "Wrong size on FCustomGameUpdateCharacterInfo");
static_assert(offsetof(FCustomGameUpdateCharacterInfo, bIsZombie) == 0x000000, "Member 'FCustomGameUpdateCharacterInfo::bIsZombie' has a wrong offset!");
static_assert(offsetof(FCustomGameUpdateCharacterInfo, bIsGroggyMode) == 0x000001, "Member 'FCustomGameUpdateCharacterInfo::bIsGroggyMode' has a wrong offset!");
static_assert(offsetof(FCustomGameUpdateCharacterInfo, ReviveCastingTime) == 0x000004, "Member 'FCustomGameUpdateCharacterInfo::ReviveCastingTime' has a wrong offset!");
static_assert(offsetof(FCustomGameUpdateCharacterInfo, MultiplierGroggyDamagePerSecond) == 0x000008, "Member 'FCustomGameUpdateCharacterInfo::MultiplierGroggyDamagePerSecond' has a wrong offset!");
static_assert(offsetof(FCustomGameUpdateCharacterInfo, MultiplierPunchDamage) == 0x00000C, "Member 'FCustomGameUpdateCharacterInfo::MultiplierPunchDamage' has a wrong offset!");
static_assert(offsetof(FCustomGameUpdateCharacterInfo, MultiplierZombieToZombieDamage) == 0x000010, "Member 'FCustomGameUpdateCharacterInfo::MultiplierZombieToZombieDamage' has a wrong offset!");

// ScriptStruct TslGame.ColorBlindType
// 0x0020 (0x0020 - 0x0000)
struct FColorBlindType final
{
public:
	EColorBlindType                               Key;                                               // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FColorBlindType) == 0x000008, "Wrong alignment on FColorBlindType");
static_assert(sizeof(FColorBlindType) == 0x000020, "Wrong size on FColorBlindType");
static_assert(offsetof(FColorBlindType, Key) == 0x000000, "Member 'FColorBlindType::Key' has a wrong offset!");
static_assert(offsetof(FColorBlindType, DisplayName) == 0x000008, "Member 'FColorBlindType::DisplayName' has a wrong offset!");

// ScriptStruct TslGame.ColorBlindColorData
// 0x0014 (0x0014 - 0x0000)
struct FColorBlindColorData final
{
public:
	EColorBlindType                               Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Color;                                             // 0x0004(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FColorBlindColorData) == 0x000004, "Wrong alignment on FColorBlindColorData");
static_assert(sizeof(FColorBlindColorData) == 0x000014, "Wrong size on FColorBlindColorData");
static_assert(offsetof(FColorBlindColorData, Type) == 0x000000, "Member 'FColorBlindColorData::Type' has a wrong offset!");
static_assert(offsetof(FColorBlindColorData, Color) == 0x000004, "Member 'FColorBlindColorData::Color' has a wrong offset!");

// ScriptStruct TslGame.ColorBlindColorSet
// 0x0010 (0x0010 - 0x0000)
struct FColorBlindColorSet final
{
public:
	TArray<struct FColorBlindColorData>           ColorSet;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FColorBlindColorSet) == 0x000008, "Wrong alignment on FColorBlindColorSet");
static_assert(sizeof(FColorBlindColorSet) == 0x000010, "Wrong size on FColorBlindColorSet");
static_assert(offsetof(FColorBlindColorSet, ColorSet) == 0x000000, "Member 'FColorBlindColorSet::ColorSet' has a wrong offset!");

// ScriptStruct TslGame.UiType
// 0x0028 (0x0028 - 0x0000)
struct FUiType final
{
public:
	class FText                                   DisplayUiName;                                     // 0x0000(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FString                                 UiKey;                                             // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUiType) == 0x000008, "Wrong alignment on FUiType");
static_assert(sizeof(FUiType) == 0x000028, "Wrong size on FUiType");
static_assert(offsetof(FUiType, DisplayUiName) == 0x000000, "Member 'FUiType::DisplayUiName' has a wrong offset!");
static_assert(offsetof(FUiType, UiKey) == 0x000018, "Member 'FUiType::UiKey' has a wrong offset!");

// ScriptStruct TslGame.OverrideScalabilityValue
// 0x0028 (0x0028 - 0x0000)
struct FOverrideScalabilityValue final
{
public:
	class FString                                 ConsoleName;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EValueType                                    ValueType;                                         // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Values;                                            // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOverrideScalabilityValue) == 0x000008, "Wrong alignment on FOverrideScalabilityValue");
static_assert(sizeof(FOverrideScalabilityValue) == 0x000028, "Wrong size on FOverrideScalabilityValue");
static_assert(offsetof(FOverrideScalabilityValue, ConsoleName) == 0x000000, "Member 'FOverrideScalabilityValue::ConsoleName' has a wrong offset!");
static_assert(offsetof(FOverrideScalabilityValue, ValueType) == 0x000010, "Member 'FOverrideScalabilityValue::ValueType' has a wrong offset!");
static_assert(offsetof(FOverrideScalabilityValue, Values) == 0x000018, "Member 'FOverrideScalabilityValue::Values' has a wrong offset!");

// ScriptStruct TslGame.OverrideScalability
// 0x0018 (0x0018 - 0x0000)
struct FOverrideScalability final
{
public:
	EQualityType                                  QualityType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FOverrideScalabilityValue>      OverrideScalabilityValues;                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOverrideScalability) == 0x000008, "Wrong alignment on FOverrideScalability");
static_assert(sizeof(FOverrideScalability) == 0x000018, "Wrong size on FOverrideScalability");
static_assert(offsetof(FOverrideScalability, QualityType) == 0x000000, "Member 'FOverrideScalability::QualityType' has a wrong offset!");
static_assert(offsetof(FOverrideScalability, OverrideScalabilityValues) == 0x000008, "Member 'FOverrideScalability::OverrideScalabilityValues' has a wrong offset!");

// ScriptStruct TslGame.KeyInputModeName
// 0x0020 (0x0020 - 0x0000)
struct FKeyInputModeName final
{
public:
	struct FName                                   ModeName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKeyInputModeName) == 0x000008, "Wrong alignment on FKeyInputModeName");
static_assert(sizeof(FKeyInputModeName) == 0x000020, "Wrong size on FKeyInputModeName");
static_assert(offsetof(FKeyInputModeName, ModeName) == 0x000000, "Member 'FKeyInputModeName::ModeName' has a wrong offset!");
static_assert(offsetof(FKeyInputModeName, DisplayName) == 0x000008, "Member 'FKeyInputModeName::DisplayName' has a wrong offset!");

// ScriptStruct TslGame.WuMatchRating
// 0x0010 (0x0010 - 0x0000)
struct FWuMatchRating final
{
public:
	int32                                         Rating;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WinPoints;                                         // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KillPoints;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MMR;                                               // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuMatchRating) == 0x000004, "Wrong alignment on FWuMatchRating");
static_assert(sizeof(FWuMatchRating) == 0x000010, "Wrong size on FWuMatchRating");
static_assert(offsetof(FWuMatchRating, Rating) == 0x000000, "Member 'FWuMatchRating::Rating' has a wrong offset!");
static_assert(offsetof(FWuMatchRating, WinPoints) == 0x000004, "Member 'FWuMatchRating::WinPoints' has a wrong offset!");
static_assert(offsetof(FWuMatchRating, KillPoints) == 0x000008, "Member 'FWuMatchRating::KillPoints' has a wrong offset!");
static_assert(offsetof(FWuMatchRating, MMR) == 0x00000C, "Member 'FWuMatchRating::MMR' has a wrong offset!");

// ScriptStruct TslGame.WuStringBoolPair
// 0x0018 (0x0018 - 0x0000)
struct FWuStringBoolPair final
{
public:
	class FString                                 First;                                             // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Second;                                            // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWuStringBoolPair) == 0x000008, "Wrong alignment on FWuStringBoolPair");
static_assert(sizeof(FWuStringBoolPair) == 0x000018, "Wrong size on FWuStringBoolPair");
static_assert(offsetof(FWuStringBoolPair, First) == 0x000000, "Member 'FWuStringBoolPair::First' has a wrong offset!");
static_assert(offsetof(FWuStringBoolPair, Second) == 0x000010, "Member 'FWuStringBoolPair::Second' has a wrong offset!");

// ScriptStruct TslGame.WuCharacterCustomizationOptions
// 0x0040 (0x0040 - 0x0000)
struct FWuCharacterCustomizationOptions final
{
public:
	TArray<struct FWuStringBoolPair>              BoolOptions;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FWuStringFloatPair>             FloatOptions;                                      // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FWuStringStringPair>            StringOptions;                                     // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         ItemIds;                                           // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuCharacterCustomizationOptions) == 0x000008, "Wrong alignment on FWuCharacterCustomizationOptions");
static_assert(sizeof(FWuCharacterCustomizationOptions) == 0x000040, "Wrong size on FWuCharacterCustomizationOptions");
static_assert(offsetof(FWuCharacterCustomizationOptions, BoolOptions) == 0x000000, "Member 'FWuCharacterCustomizationOptions::BoolOptions' has a wrong offset!");
static_assert(offsetof(FWuCharacterCustomizationOptions, FloatOptions) == 0x000010, "Member 'FWuCharacterCustomizationOptions::FloatOptions' has a wrong offset!");
static_assert(offsetof(FWuCharacterCustomizationOptions, StringOptions) == 0x000020, "Member 'FWuCharacterCustomizationOptions::StringOptions' has a wrong offset!");
static_assert(offsetof(FWuCharacterCustomizationOptions, ItemIds) == 0x000030, "Member 'FWuCharacterCustomizationOptions::ItemIds' has a wrong offset!");

// ScriptStruct TslGame.WuCharacterInfo
// 0x0058 (0x0058 - 0x0000)
struct FWuCharacterInfo final
{
public:
	class FString                                 Nickname;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Gender;                                            // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWuCharacterCustomizationOptions       CustomizationOptions;                              // 0x0018(0x0040)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuCharacterInfo) == 0x000008, "Wrong alignment on FWuCharacterInfo");
static_assert(sizeof(FWuCharacterInfo) == 0x000058, "Wrong size on FWuCharacterInfo");
static_assert(offsetof(FWuCharacterInfo, Nickname) == 0x000000, "Member 'FWuCharacterInfo::Nickname' has a wrong offset!");
static_assert(offsetof(FWuCharacterInfo, Gender) == 0x000010, "Member 'FWuCharacterInfo::Gender' has a wrong offset!");
static_assert(offsetof(FWuCharacterInfo, CustomizationOptions) == 0x000018, "Member 'FWuCharacterInfo::CustomizationOptions' has a wrong offset!");

// ScriptStruct TslGame.WuUserAuthInfo
// 0x0088 (0x0088 - 0x0000)
struct FWuUserAuthInfo final
{
public:
	class FString                                 PlayerNetId;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamId;                                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWuMatchRating                         Rating;                                            // 0x0014(0x0010)(NativeAccessSpecifierPublic)
	bool                                          IsZombie;                                          // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWuCharacterInfo                       CharacterInfo;                                     // 0x0028(0x0058)(NativeAccessSpecifierPublic)
	int32                                         ObserverAuthorityType;                             // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BattlEyeDisabled;                                  // 0x0084(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWuUserAuthInfo) == 0x000008, "Wrong alignment on FWuUserAuthInfo");
static_assert(sizeof(FWuUserAuthInfo) == 0x000088, "Wrong size on FWuUserAuthInfo");
static_assert(offsetof(FWuUserAuthInfo, PlayerNetId) == 0x000000, "Member 'FWuUserAuthInfo::PlayerNetId' has a wrong offset!");
static_assert(offsetof(FWuUserAuthInfo, TeamId) == 0x000010, "Member 'FWuUserAuthInfo::TeamId' has a wrong offset!");
static_assert(offsetof(FWuUserAuthInfo, Rating) == 0x000014, "Member 'FWuUserAuthInfo::Rating' has a wrong offset!");
static_assert(offsetof(FWuUserAuthInfo, IsZombie) == 0x000024, "Member 'FWuUserAuthInfo::IsZombie' has a wrong offset!");
static_assert(offsetof(FWuUserAuthInfo, CharacterInfo) == 0x000028, "Member 'FWuUserAuthInfo::CharacterInfo' has a wrong offset!");
static_assert(offsetof(FWuUserAuthInfo, ObserverAuthorityType) == 0x000080, "Member 'FWuUserAuthInfo::ObserverAuthorityType' has a wrong offset!");
static_assert(offsetof(FWuUserAuthInfo, BattlEyeDisabled) == 0x000084, "Member 'FWuUserAuthInfo::BattlEyeDisabled' has a wrong offset!");

// ScriptStruct TslGame.SurportQualityLevel
// 0x0020 (0x0020 - 0x0000)
struct FSurportQualityLevel final
{
public:
	int32                                         QualityLevel;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayQualityLevelName;                           // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSurportQualityLevel) == 0x000008, "Wrong alignment on FSurportQualityLevel");
static_assert(sizeof(FSurportQualityLevel) == 0x000020, "Wrong size on FSurportQualityLevel");
static_assert(offsetof(FSurportQualityLevel, QualityLevel) == 0x000000, "Member 'FSurportQualityLevel::QualityLevel' has a wrong offset!");
static_assert(offsetof(FSurportQualityLevel, DisplayQualityLevelName) == 0x000008, "Member 'FSurportQualityLevel::DisplayQualityLevelName' has a wrong offset!");

// ScriptStruct TslGame.ScreenResolution
// 0x0008 (0x0008 - 0x0000)
struct FScreenResolution final
{
public:
	int32                                         Width;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Height;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScreenResolution) == 0x000004, "Wrong alignment on FScreenResolution");
static_assert(sizeof(FScreenResolution) == 0x000008, "Wrong size on FScreenResolution");
static_assert(offsetof(FScreenResolution, Width) == 0x000000, "Member 'FScreenResolution::Width' has a wrong offset!");
static_assert(offsetof(FScreenResolution, Height) == 0x000004, "Member 'FScreenResolution::Height' has a wrong offset!");

// ScriptStruct TslGame.CustomizableMouseSensitiveName
// 0x0028 (0x0028 - 0x0000)
struct FCustomizableMouseSensitiveName final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FName                                   MouseSensitiveName;                                // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseSensitivity;                                  // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomizableMouseSensitiveName) == 0x000008, "Wrong alignment on FCustomizableMouseSensitiveName");
static_assert(sizeof(FCustomizableMouseSensitiveName) == 0x000028, "Wrong size on FCustomizableMouseSensitiveName");
static_assert(offsetof(FCustomizableMouseSensitiveName, DisplayName) == 0x000000, "Member 'FCustomizableMouseSensitiveName::DisplayName' has a wrong offset!");
static_assert(offsetof(FCustomizableMouseSensitiveName, MouseSensitiveName) == 0x000018, "Member 'FCustomizableMouseSensitiveName::MouseSensitiveName' has a wrong offset!");
static_assert(offsetof(FCustomizableMouseSensitiveName, MouseSensitivity) == 0x000020, "Member 'FCustomizableMouseSensitiveName::MouseSensitivity' has a wrong offset!");

// ScriptStruct TslGame.CustomizableAxisName
// 0x0030 (0x0030 - 0x0000)
struct FCustomizableAxisName final
{
public:
	struct FName                                   Category;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FName                                   AxisName;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomizableAxisName) == 0x000008, "Wrong alignment on FCustomizableAxisName");
static_assert(sizeof(FCustomizableAxisName) == 0x000030, "Wrong size on FCustomizableAxisName");
static_assert(offsetof(FCustomizableAxisName, Category) == 0x000000, "Member 'FCustomizableAxisName::Category' has a wrong offset!");
static_assert(offsetof(FCustomizableAxisName, AxisName) == 0x000008, "Member 'FCustomizableAxisName::AxisName' has a wrong offset!");
static_assert(offsetof(FCustomizableAxisName, DisplayName) == 0x000010, "Member 'FCustomizableAxisName::DisplayName' has a wrong offset!");
static_assert(offsetof(FCustomizableAxisName, Scale) == 0x000028, "Member 'FCustomizableAxisName::Scale' has a wrong offset!");

// ScriptStruct TslGame.CustomizableActionName
// 0x0028 (0x0028 - 0x0000)
struct FCustomizableActionName final
{
public:
	struct FName                                   Category;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FName                                   ActionName;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0010(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomizableActionName) == 0x000008, "Wrong alignment on FCustomizableActionName");
static_assert(sizeof(FCustomizableActionName) == 0x000028, "Wrong size on FCustomizableActionName");
static_assert(offsetof(FCustomizableActionName, Category) == 0x000000, "Member 'FCustomizableActionName::Category' has a wrong offset!");
static_assert(offsetof(FCustomizableActionName, ActionName) == 0x000008, "Member 'FCustomizableActionName::ActionName' has a wrong offset!");
static_assert(offsetof(FCustomizableActionName, DisplayName) == 0x000010, "Member 'FCustomizableActionName::DisplayName' has a wrong offset!");

// ScriptStruct TslGame.ReportCauseData
// 0x0020 (0x0020 - 0x0000)
struct FReportCauseData final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EReportCause                                  ReportCauseType;                                   // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReportCauseData) == 0x000008, "Wrong alignment on FReportCauseData");
static_assert(sizeof(FReportCauseData) == 0x000020, "Wrong size on FReportCauseData");
static_assert(offsetof(FReportCauseData, DisplayName) == 0x000000, "Member 'FReportCauseData::DisplayName' has a wrong offset!");
static_assert(offsetof(FReportCauseData, ReportCauseType) == 0x000018, "Member 'FReportCauseData::ReportCauseType' has a wrong offset!");

// ScriptStruct TslGame.SubjectToReport
// 0x0020 (0x0020 - 0x0000)
struct FSubjectToReport final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	ESubjectToReport                              SubjectToReportType;                               // 0x0018(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSubjectToReport) == 0x000008, "Wrong alignment on FSubjectToReport");
static_assert(sizeof(FSubjectToReport) == 0x000020, "Wrong size on FSubjectToReport");
static_assert(offsetof(FSubjectToReport, DisplayName) == 0x000000, "Member 'FSubjectToReport::DisplayName' has a wrong offset!");
static_assert(offsetof(FSubjectToReport, SubjectToReportType) == 0x000018, "Member 'FSubjectToReport::SubjectToReportType' has a wrong offset!");

// ScriptStruct TslGame.CustomizableCategoryData
// 0x0030 (0x0030 - 0x0000)
struct FCustomizableCategoryData final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FName                                   Category;                                          // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FName>                           NotDuplicateCategoryNames;                         // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomizableCategoryData) == 0x000008, "Wrong alignment on FCustomizableCategoryData");
static_assert(sizeof(FCustomizableCategoryData) == 0x000030, "Wrong size on FCustomizableCategoryData");
static_assert(offsetof(FCustomizableCategoryData, DisplayName) == 0x000000, "Member 'FCustomizableCategoryData::DisplayName' has a wrong offset!");
static_assert(offsetof(FCustomizableCategoryData, Category) == 0x000018, "Member 'FCustomizableCategoryData::Category' has a wrong offset!");
static_assert(offsetof(FCustomizableCategoryData, NotDuplicateCategoryNames) == 0x000020, "Member 'FCustomizableCategoryData::NotDuplicateCategoryNames' has a wrong offset!");

// ScriptStruct TslGame.BoneBinding
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FBoneBinding final
{
public:
	struct FName                                   ImpactBone;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FName                                   ReactionBone;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoneBinding) == 0x000008, "Wrong alignment on FBoneBinding");
static_assert(sizeof(FBoneBinding) == 0x000010, "Wrong size on FBoneBinding");
static_assert(offsetof(FBoneBinding, ImpactBone) == 0x000000, "Member 'FBoneBinding::ImpactBone' has a wrong offset!");
static_assert(offsetof(FBoneBinding, ReactionBone) == 0x000008, "Member 'FBoneBinding::ReactionBone' has a wrong offset!");

// ScriptStruct TslGame.LimitCustomStringParameter
// 0x0018 (0x0018 - 0x0000)
struct FLimitCustomStringParameter final
{
public:
	class FString                                 CustomStringParameter;                             // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinLimit;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxLimit;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLimitCustomStringParameter) == 0x000008, "Wrong alignment on FLimitCustomStringParameter");
static_assert(sizeof(FLimitCustomStringParameter) == 0x000018, "Wrong size on FLimitCustomStringParameter");
static_assert(offsetof(FLimitCustomStringParameter, CustomStringParameter) == 0x000000, "Member 'FLimitCustomStringParameter::CustomStringParameter' has a wrong offset!");
static_assert(offsetof(FLimitCustomStringParameter, MinLimit) == 0x000010, "Member 'FLimitCustomStringParameter::MinLimit' has a wrong offset!");
static_assert(offsetof(FLimitCustomStringParameter, MaxLimit) == 0x000014, "Member 'FLimitCustomStringParameter::MaxLimit' has a wrong offset!");

// ScriptStruct TslGame.MatchPreparerClass
// 0x0010 (0x0010 - 0x0000)
struct FMatchPreparerClass final
{
public:
	EMatchStartType                               Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UMatchPreparer>             Class;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchPreparerClass) == 0x000008, "Wrong alignment on FMatchPreparerClass");
static_assert(sizeof(FMatchPreparerClass) == 0x000010, "Wrong size on FMatchPreparerClass");
static_assert(offsetof(FMatchPreparerClass, Type) == 0x000000, "Member 'FMatchPreparerClass::Type' has a wrong offset!");
static_assert(offsetof(FMatchPreparerClass, Class) == 0x000008, "Member 'FMatchPreparerClass::Class' has a wrong offset!");

// ScriptStruct TslGame.CustomActionKeyData
// 0x0018 (0x0018 - 0x0000)
struct FCustomActionKeyData final
{
public:
	struct FName                                   ActionName;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTslInputKey>                   Keys;                                              // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomActionKeyData) == 0x000008, "Wrong alignment on FCustomActionKeyData");
static_assert(sizeof(FCustomActionKeyData) == 0x000018, "Wrong size on FCustomActionKeyData");
static_assert(offsetof(FCustomActionKeyData, ActionName) == 0x000000, "Member 'FCustomActionKeyData::ActionName' has a wrong offset!");
static_assert(offsetof(FCustomActionKeyData, Keys) == 0x000008, "Member 'FCustomActionKeyData::Keys' has a wrong offset!");

// ScriptStruct TslGame.CustomAxisKeyData
// 0x0020 (0x0020 - 0x0000)
struct FCustomAxisKeyData final
{
public:
	struct FName                                   AxisName;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTslInputKey>                   Keys;                                              // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomAxisKeyData) == 0x000008, "Wrong alignment on FCustomAxisKeyData");
static_assert(sizeof(FCustomAxisKeyData) == 0x000020, "Wrong size on FCustomAxisKeyData");
static_assert(offsetof(FCustomAxisKeyData, AxisName) == 0x000000, "Member 'FCustomAxisKeyData::AxisName' has a wrong offset!");
static_assert(offsetof(FCustomAxisKeyData, Scale) == 0x000008, "Member 'FCustomAxisKeyData::Scale' has a wrong offset!");
static_assert(offsetof(FCustomAxisKeyData, Keys) == 0x000010, "Member 'FCustomAxisKeyData::Keys' has a wrong offset!");

// ScriptStruct TslGame.CustomInputSettings
// 0x0040 (0x0040 - 0x0000)
struct FCustomInputSettings final
{
public:
	TArray<struct FCustomActionKeyData>           ActionKeyList;                                     // 0x0000(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FCustomAxisKeyData>             AxisKeyList;                                       // 0x0010(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FCustomMouseSensitiveData>      MouseSensitiveList;                                // 0x0020(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	bool                                          bInvertMouse;                                      // 0x0030(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0xF];                                       // 0x0031(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomInputSettings) == 0x000008, "Wrong alignment on FCustomInputSettings");
static_assert(sizeof(FCustomInputSettings) == 0x000040, "Wrong size on FCustomInputSettings");
static_assert(offsetof(FCustomInputSettings, ActionKeyList) == 0x000000, "Member 'FCustomInputSettings::ActionKeyList' has a wrong offset!");
static_assert(offsetof(FCustomInputSettings, AxisKeyList) == 0x000010, "Member 'FCustomInputSettings::AxisKeyList' has a wrong offset!");
static_assert(offsetof(FCustomInputSettings, MouseSensitiveList) == 0x000020, "Member 'FCustomInputSettings::MouseSensitiveList' has a wrong offset!");
static_assert(offsetof(FCustomInputSettings, bInvertMouse) == 0x000030, "Member 'FCustomInputSettings::bInvertMouse' has a wrong offset!");

// ScriptStruct TslGame.QualityLevelInfo
// 0x0020 (0x0020 - 0x0000)
struct FQualityLevelInfo final
{
public:
	EQualityType                                  QualityType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayQualityLevelName;                           // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQualityLevelInfo) == 0x000008, "Wrong alignment on FQualityLevelInfo");
static_assert(sizeof(FQualityLevelInfo) == 0x000020, "Wrong size on FQualityLevelInfo");
static_assert(offsetof(FQualityLevelInfo, QualityType) == 0x000000, "Member 'FQualityLevelInfo::QualityType' has a wrong offset!");
static_assert(offsetof(FQualityLevelInfo, DisplayQualityLevelName) == 0x000008, "Member 'FQualityLevelInfo::DisplayQualityLevelName' has a wrong offset!");

// ScriptStruct TslGame.HealthColorData
// 0x0018 (0x0018 - 0x0000)
struct FHealthColorData final
{
public:
	struct FFloatInterval                         HealthPercentRange;                                // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHealthColorData) == 0x000004, "Wrong alignment on FHealthColorData");
static_assert(sizeof(FHealthColorData) == 0x000018, "Wrong size on FHealthColorData");
static_assert(offsetof(FHealthColorData, HealthPercentRange) == 0x000000, "Member 'FHealthColorData::HealthPercentRange' has a wrong offset!");
static_assert(offsetof(FHealthColorData, Color) == 0x000008, "Member 'FHealthColorData::Color' has a wrong offset!");

// ScriptStruct TslGame.UmgWidgetBinder_Gerneral
// 0x0008 (0x0020 - 0x0018)
struct FUmgWidgetBinder_Gerneral final : public FUmgWidgetBinder
{
public:
	class UWidget*                                CachedWidget;                                      // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FUmgWidgetBinder_Gerneral) == 0x000008, "Wrong alignment on FUmgWidgetBinder_Gerneral");
static_assert(sizeof(FUmgWidgetBinder_Gerneral) == 0x000020, "Wrong size on FUmgWidgetBinder_Gerneral");
static_assert(offsetof(FUmgWidgetBinder_Gerneral, CachedWidget) == 0x000018, "Member 'FUmgWidgetBinder_Gerneral::CachedWidget' has a wrong offset!");

// ScriptStruct TslGame.WeatherLevelInfo
// 0x0028 (0x0028 - 0x0000)
struct FWeatherLevelInfo final
{
public:
	class FString                                 WeatherId;                                         // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FName                                   WeatherLevel;                                      // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindowLightIntensity;                              // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWeatherLevelInfo) == 0x000008, "Wrong alignment on FWeatherLevelInfo");
static_assert(sizeof(FWeatherLevelInfo) == 0x000028, "Wrong size on FWeatherLevelInfo");
static_assert(offsetof(FWeatherLevelInfo, WeatherId) == 0x000000, "Member 'FWeatherLevelInfo::WeatherId' has a wrong offset!");
static_assert(offsetof(FWeatherLevelInfo, Weight) == 0x000010, "Member 'FWeatherLevelInfo::Weight' has a wrong offset!");
static_assert(offsetof(FWeatherLevelInfo, WeatherLevel) == 0x000018, "Member 'FWeatherLevelInfo::WeatherLevel' has a wrong offset!");
static_assert(offsetof(FWeatherLevelInfo, WindowLightIntensity) == 0x000020, "Member 'FWeatherLevelInfo::WindowLightIntensity' has a wrong offset!");

// ScriptStruct TslGame.TslMenuItemStyle
// 0x01B0 (0x01B8 - 0x0008)
struct FTslMenuItemStyle final : public FSlateWidgetStyle
{
public:
	struct FSlateBrush                            BackgroundBrush;                                   // 0x0008(0x0090)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            LeftArrowImage;                                    // 0x0098(0x0090)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            RightArrowImage;                                   // 0x0128(0x0090)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTslMenuItemStyle) == 0x000008, "Wrong alignment on FTslMenuItemStyle");
static_assert(sizeof(FTslMenuItemStyle) == 0x0001B8, "Wrong size on FTslMenuItemStyle");
static_assert(offsetof(FTslMenuItemStyle, BackgroundBrush) == 0x000008, "Member 'FTslMenuItemStyle::BackgroundBrush' has a wrong offset!");
static_assert(offsetof(FTslMenuItemStyle, LeftArrowImage) == 0x000098, "Member 'FTslMenuItemStyle::LeftArrowImage' has a wrong offset!");
static_assert(offsetof(FTslMenuItemStyle, RightArrowImage) == 0x000128, "Member 'FTslMenuItemStyle::RightArrowImage' has a wrong offset!");

// ScriptStruct TslGame.TslMenuSoundsStyle
// 0x0030 (0x0038 - 0x0008)
struct FTslMenuSoundsStyle final : public FSlateWidgetStyle
{
public:
	struct FSlateSound                            StartGameSound;                                    // 0x0008(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSlateSound                            ExitGameSound;                                     // 0x0020(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTslMenuSoundsStyle) == 0x000008, "Wrong alignment on FTslMenuSoundsStyle");
static_assert(sizeof(FTslMenuSoundsStyle) == 0x000038, "Wrong size on FTslMenuSoundsStyle");
static_assert(offsetof(FTslMenuSoundsStyle, StartGameSound) == 0x000008, "Member 'FTslMenuSoundsStyle::StartGameSound' has a wrong offset!");
static_assert(offsetof(FTslMenuSoundsStyle, ExitGameSound) == 0x000020, "Member 'FTslMenuSoundsStyle::ExitGameSound' has a wrong offset!");

// ScriptStruct TslGame.TslMenuStyle
// 0x0210 (0x0218 - 0x0008)
struct FTslMenuStyle final : public FSlateWidgetStyle
{
public:
	struct FSlateBrush                            HeaderBackgroundBrush;                             // 0x0008(0x0090)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            LeftBackgroundBrush;                               // 0x0098(0x0090)(Edit, NativeAccessSpecifierPublic)
	struct FSlateBrush                            RightBackgroundBrush;                              // 0x0128(0x0090)(Edit, NativeAccessSpecifierPublic)
	struct FSlateSound                            MenuEnterSound;                                    // 0x01B8(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSlateSound                            MenuBackSound;                                     // 0x01D0(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSlateSound                            OptionChangeSound;                                 // 0x01E8(0x0018)(Edit, NativeAccessSpecifierPublic)
	struct FSlateSound                            MenuItemChangeSound;                               // 0x0200(0x0018)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTslMenuStyle) == 0x000008, "Wrong alignment on FTslMenuStyle");
static_assert(sizeof(FTslMenuStyle) == 0x000218, "Wrong size on FTslMenuStyle");
static_assert(offsetof(FTslMenuStyle, HeaderBackgroundBrush) == 0x000008, "Member 'FTslMenuStyle::HeaderBackgroundBrush' has a wrong offset!");
static_assert(offsetof(FTslMenuStyle, LeftBackgroundBrush) == 0x000098, "Member 'FTslMenuStyle::LeftBackgroundBrush' has a wrong offset!");
static_assert(offsetof(FTslMenuStyle, RightBackgroundBrush) == 0x000128, "Member 'FTslMenuStyle::RightBackgroundBrush' has a wrong offset!");
static_assert(offsetof(FTslMenuStyle, MenuEnterSound) == 0x0001B8, "Member 'FTslMenuStyle::MenuEnterSound' has a wrong offset!");
static_assert(offsetof(FTslMenuStyle, MenuBackSound) == 0x0001D0, "Member 'FTslMenuStyle::MenuBackSound' has a wrong offset!");
static_assert(offsetof(FTslMenuStyle, OptionChangeSound) == 0x0001E8, "Member 'FTslMenuStyle::OptionChangeSound' has a wrong offset!");
static_assert(offsetof(FTslMenuStyle, MenuItemChangeSound) == 0x000200, "Member 'FTslMenuStyle::MenuItemChangeSound' has a wrong offset!");

// ScriptStruct TslGame.PostProcessEffectDynamicMaterialState
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FPostProcessEffectDynamicMaterialState final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPostProcessEffectDynamicMaterialState) == 0x000008, "Wrong alignment on FPostProcessEffectDynamicMaterialState");
static_assert(sizeof(FPostProcessEffectDynamicMaterialState) == 0x000010, "Wrong size on FPostProcessEffectDynamicMaterialState");

// ScriptStruct TslGame.ParticleParameter
// 0x0018 (0x0018 - 0x0000)
struct FParticleParameter final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableRTPC;                                       // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FParticleParameter) == 0x000008, "Wrong alignment on FParticleParameter");
static_assert(sizeof(FParticleParameter) == 0x000018, "Wrong size on FParticleParameter");
static_assert(offsetof(FParticleParameter, Name) == 0x000000, "Member 'FParticleParameter::Name' has a wrong offset!");
static_assert(offsetof(FParticleParameter, Value) == 0x000010, "Member 'FParticleParameter::Value' has a wrong offset!");
static_assert(offsetof(FParticleParameter, bEnableRTPC) == 0x000014, "Member 'FParticleParameter::bEnableRTPC' has a wrong offset!");

// ScriptStruct TslGame.WuLogHackDetection_ContinuousKill
// 0x0048 (0x0070 - 0x0028)
struct FWuLogHackDetection_ContinuousKill final : public FLogBase
{
public:
	struct FWuLogCharacter                        Character;                                         // 0x0028(0x0038)(NativeAccessSpecifierPublic)
	float                                         Reason_DistVics;                                   // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Reason_DistKiller;                                 // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBanned;                                          // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWuLogHackDetection_ContinuousKill) == 0x000008, "Wrong alignment on FWuLogHackDetection_ContinuousKill");
static_assert(sizeof(FWuLogHackDetection_ContinuousKill) == 0x000070, "Wrong size on FWuLogHackDetection_ContinuousKill");
static_assert(offsetof(FWuLogHackDetection_ContinuousKill, Character) == 0x000028, "Member 'FWuLogHackDetection_ContinuousKill::Character' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_ContinuousKill, Reason_DistVics) == 0x000060, "Member 'FWuLogHackDetection_ContinuousKill::Reason_DistVics' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_ContinuousKill, Reason_DistKiller) == 0x000064, "Member 'FWuLogHackDetection_ContinuousKill::Reason_DistKiller' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_ContinuousKill, IsBanned) == 0x000068, "Member 'FWuLogHackDetection_ContinuousKill::IsBanned' has a wrong offset!");

// ScriptStruct TslGame.WuLogHackDetection_IgnoreWall
// 0x0040 (0x0068 - 0x0028)
struct FWuLogHackDetection_IgnoreWall final : public FLogBase
{
public:
	struct FWuLogCharacter                        Character;                                         // 0x0028(0x0038)(NativeAccessSpecifierPublic)
	float                                         Reason_Distance;                                   // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBanned;                                          // 0x0064(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBlockedHit;                                      // 0x0065(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_66[0x2];                                       // 0x0066(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWuLogHackDetection_IgnoreWall) == 0x000008, "Wrong alignment on FWuLogHackDetection_IgnoreWall");
static_assert(sizeof(FWuLogHackDetection_IgnoreWall) == 0x000068, "Wrong size on FWuLogHackDetection_IgnoreWall");
static_assert(offsetof(FWuLogHackDetection_IgnoreWall, Character) == 0x000028, "Member 'FWuLogHackDetection_IgnoreWall::Character' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_IgnoreWall, Reason_Distance) == 0x000060, "Member 'FWuLogHackDetection_IgnoreWall::Reason_Distance' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_IgnoreWall, IsBanned) == 0x000064, "Member 'FWuLogHackDetection_IgnoreWall::IsBanned' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_IgnoreWall, IsBlockedHit) == 0x000065, "Member 'FWuLogHackDetection_IgnoreWall::IsBlockedHit' has a wrong offset!");

// ScriptStruct TslGame.WuLogHackDetection_Ammo
// 0x0070 (0x0098 - 0x0028)
struct FWuLogHackDetection_Ammo final : public FLogBase
{
public:
	struct FWuLogCharacter                        Character;                                         // 0x0028(0x0038)(NativeAccessSpecifierPublic)
	class FString                                 WeaponName;                                        // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WeaponType;                                        // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DetectionType;                                     // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBanned;                                          // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBlockedHit;                                      // 0x0091(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWuLogHackDetection_Ammo) == 0x000008, "Wrong alignment on FWuLogHackDetection_Ammo");
static_assert(sizeof(FWuLogHackDetection_Ammo) == 0x000098, "Wrong size on FWuLogHackDetection_Ammo");
static_assert(offsetof(FWuLogHackDetection_Ammo, Character) == 0x000028, "Member 'FWuLogHackDetection_Ammo::Character' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Ammo, WeaponName) == 0x000060, "Member 'FWuLogHackDetection_Ammo::WeaponName' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Ammo, WeaponType) == 0x000070, "Member 'FWuLogHackDetection_Ammo::WeaponType' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Ammo, DetectionType) == 0x000080, "Member 'FWuLogHackDetection_Ammo::DetectionType' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Ammo, IsBanned) == 0x000090, "Member 'FWuLogHackDetection_Ammo::IsBanned' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Ammo, IsBlockedHit) == 0x000091, "Member 'FWuLogHackDetection_Ammo::IsBlockedHit' has a wrong offset!");

// ScriptStruct TslGame.WuLogHackDetection_AttackRange
// 0x0090 (0x00B8 - 0x0028)
struct FWuLogHackDetection_AttackRange final : public FLogBase
{
public:
	struct FWuLogCharacter                        Character;                                         // 0x0028(0x0038)(NativeAccessSpecifierPublic)
	class FString                                 WeaponName;                                        // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WeaponType;                                        // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DetectionType;                                     // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Reason_Distance;                                   // 0x0090(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Reason_TravelDistance;                             // 0x0094(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Reason_ImpactLocation;                             // 0x0098(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Reason_FireLocation;                               // 0x00A4(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsBanned;                                          // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBlockedHit;                                      // 0x00B1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWuLogHackDetection_AttackRange) == 0x000008, "Wrong alignment on FWuLogHackDetection_AttackRange");
static_assert(sizeof(FWuLogHackDetection_AttackRange) == 0x0000B8, "Wrong size on FWuLogHackDetection_AttackRange");
static_assert(offsetof(FWuLogHackDetection_AttackRange, Character) == 0x000028, "Member 'FWuLogHackDetection_AttackRange::Character' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_AttackRange, WeaponName) == 0x000060, "Member 'FWuLogHackDetection_AttackRange::WeaponName' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_AttackRange, WeaponType) == 0x000070, "Member 'FWuLogHackDetection_AttackRange::WeaponType' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_AttackRange, DetectionType) == 0x000080, "Member 'FWuLogHackDetection_AttackRange::DetectionType' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_AttackRange, Reason_Distance) == 0x000090, "Member 'FWuLogHackDetection_AttackRange::Reason_Distance' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_AttackRange, Reason_TravelDistance) == 0x000094, "Member 'FWuLogHackDetection_AttackRange::Reason_TravelDistance' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_AttackRange, Reason_ImpactLocation) == 0x000098, "Member 'FWuLogHackDetection_AttackRange::Reason_ImpactLocation' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_AttackRange, Reason_FireLocation) == 0x0000A4, "Member 'FWuLogHackDetection_AttackRange::Reason_FireLocation' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_AttackRange, IsBanned) == 0x0000B0, "Member 'FWuLogHackDetection_AttackRange::IsBanned' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_AttackRange, IsBlockedHit) == 0x0000B1, "Member 'FWuLogHackDetection_AttackRange::IsBlockedHit' has a wrong offset!");

// ScriptStruct TslGame.WuLogHackDetection_Attacker
// 0x0090 (0x00B8 - 0x0028)
struct FWuLogHackDetection_Attacker final : public FLogBase
{
public:
	struct FWuLogCharacter                        Character;                                         // 0x0028(0x0038)(NativeAccessSpecifierPublic)
	class FString                                 WeaponName;                                        // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WeaponType;                                        // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DetectionType;                                     // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Reason_Distance;                                   // 0x0090(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Reason_AttakerLocation;                            // 0x0094(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Reason_FireLocation;                               // 0x00A0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Reason_CarVelocity;                                // 0x00AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Reason_IsInCar;                                    // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBanned;                                          // 0x00B1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBlockedHit;                                      // 0x00B2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B3[0x5];                                       // 0x00B3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWuLogHackDetection_Attacker) == 0x000008, "Wrong alignment on FWuLogHackDetection_Attacker");
static_assert(sizeof(FWuLogHackDetection_Attacker) == 0x0000B8, "Wrong size on FWuLogHackDetection_Attacker");
static_assert(offsetof(FWuLogHackDetection_Attacker, Character) == 0x000028, "Member 'FWuLogHackDetection_Attacker::Character' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Attacker, WeaponName) == 0x000060, "Member 'FWuLogHackDetection_Attacker::WeaponName' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Attacker, WeaponType) == 0x000070, "Member 'FWuLogHackDetection_Attacker::WeaponType' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Attacker, DetectionType) == 0x000080, "Member 'FWuLogHackDetection_Attacker::DetectionType' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Attacker, Reason_Distance) == 0x000090, "Member 'FWuLogHackDetection_Attacker::Reason_Distance' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Attacker, Reason_AttakerLocation) == 0x000094, "Member 'FWuLogHackDetection_Attacker::Reason_AttakerLocation' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Attacker, Reason_FireLocation) == 0x0000A0, "Member 'FWuLogHackDetection_Attacker::Reason_FireLocation' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Attacker, Reason_CarVelocity) == 0x0000AC, "Member 'FWuLogHackDetection_Attacker::Reason_CarVelocity' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Attacker, Reason_IsInCar) == 0x0000B0, "Member 'FWuLogHackDetection_Attacker::Reason_IsInCar' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Attacker, IsBanned) == 0x0000B1, "Member 'FWuLogHackDetection_Attacker::IsBanned' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Attacker, IsBlockedHit) == 0x0000B2, "Member 'FWuLogHackDetection_Attacker::IsBlockedHit' has a wrong offset!");

// ScriptStruct TslGame.WuLogHackDetection_Victim
// 0x0090 (0x00B8 - 0x0028)
struct FWuLogHackDetection_Victim final : public FLogBase
{
public:
	struct FWuLogCharacter                        Character;                                         // 0x0028(0x0038)(NativeAccessSpecifierPublic)
	class FString                                 WeaponName;                                        // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WeaponType;                                        // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DetectionType;                                     // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Reason_Distance;                                   // 0x0090(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Reason_VictimLocation;                             // 0x0094(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Reason_ImpactLocation;                             // 0x00A0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Reason_CarVelocity;                                // 0x00AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Reason_IsInCar;                                    // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBanned;                                          // 0x00B1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBlockedHit;                                      // 0x00B2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B3[0x5];                                       // 0x00B3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWuLogHackDetection_Victim) == 0x000008, "Wrong alignment on FWuLogHackDetection_Victim");
static_assert(sizeof(FWuLogHackDetection_Victim) == 0x0000B8, "Wrong size on FWuLogHackDetection_Victim");
static_assert(offsetof(FWuLogHackDetection_Victim, Character) == 0x000028, "Member 'FWuLogHackDetection_Victim::Character' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Victim, WeaponName) == 0x000060, "Member 'FWuLogHackDetection_Victim::WeaponName' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Victim, WeaponType) == 0x000070, "Member 'FWuLogHackDetection_Victim::WeaponType' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Victim, DetectionType) == 0x000080, "Member 'FWuLogHackDetection_Victim::DetectionType' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Victim, Reason_Distance) == 0x000090, "Member 'FWuLogHackDetection_Victim::Reason_Distance' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Victim, Reason_VictimLocation) == 0x000094, "Member 'FWuLogHackDetection_Victim::Reason_VictimLocation' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Victim, Reason_ImpactLocation) == 0x0000A0, "Member 'FWuLogHackDetection_Victim::Reason_ImpactLocation' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Victim, Reason_CarVelocity) == 0x0000AC, "Member 'FWuLogHackDetection_Victim::Reason_CarVelocity' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Victim, Reason_IsInCar) == 0x0000B0, "Member 'FWuLogHackDetection_Victim::Reason_IsInCar' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Victim, IsBanned) == 0x0000B1, "Member 'FWuLogHackDetection_Victim::IsBanned' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Victim, IsBlockedHit) == 0x0000B2, "Member 'FWuLogHackDetection_Victim::IsBlockedHit' has a wrong offset!");

// ScriptStruct TslGame.WuLogHackDetection_Wall
// 0x0078 (0x00A0 - 0x0028)
struct FWuLogHackDetection_Wall final : public FLogBase
{
public:
	struct FWuLogCharacter                        Character;                                         // 0x0028(0x0038)(NativeAccessSpecifierPublic)
	class FString                                 WeaponName;                                        // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WeaponType;                                        // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DetectionType;                                     // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Reason_ImpactLocation;                             // 0x0090(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          IsBanned;                                          // 0x009C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBlockedHit;                                      // 0x009D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9E[0x2];                                       // 0x009E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWuLogHackDetection_Wall) == 0x000008, "Wrong alignment on FWuLogHackDetection_Wall");
static_assert(sizeof(FWuLogHackDetection_Wall) == 0x0000A0, "Wrong size on FWuLogHackDetection_Wall");
static_assert(offsetof(FWuLogHackDetection_Wall, Character) == 0x000028, "Member 'FWuLogHackDetection_Wall::Character' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Wall, WeaponName) == 0x000060, "Member 'FWuLogHackDetection_Wall::WeaponName' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Wall, WeaponType) == 0x000070, "Member 'FWuLogHackDetection_Wall::WeaponType' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Wall, DetectionType) == 0x000080, "Member 'FWuLogHackDetection_Wall::DetectionType' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Wall, Reason_ImpactLocation) == 0x000090, "Member 'FWuLogHackDetection_Wall::Reason_ImpactLocation' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Wall, IsBanned) == 0x00009C, "Member 'FWuLogHackDetection_Wall::IsBanned' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Wall, IsBlockedHit) == 0x00009D, "Member 'FWuLogHackDetection_Wall::IsBlockedHit' has a wrong offset!");

// ScriptStruct TslGame.WuLogHackDetection_Ping
// 0x0070 (0x0098 - 0x0028)
struct FWuLogHackDetection_Ping final : public FLogBase
{
public:
	struct FWuLogCharacter                        Character;                                         // 0x0028(0x0038)(NativeAccessSpecifierPublic)
	class FString                                 WeaponName;                                        // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WeaponType;                                        // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DetectionType;                                     // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Reason_Ping;                                       // 0x0090(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBanned;                                          // 0x0094(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBlockedHit;                                      // 0x0095(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_96[0x2];                                       // 0x0096(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWuLogHackDetection_Ping) == 0x000008, "Wrong alignment on FWuLogHackDetection_Ping");
static_assert(sizeof(FWuLogHackDetection_Ping) == 0x000098, "Wrong size on FWuLogHackDetection_Ping");
static_assert(offsetof(FWuLogHackDetection_Ping, Character) == 0x000028, "Member 'FWuLogHackDetection_Ping::Character' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Ping, WeaponName) == 0x000060, "Member 'FWuLogHackDetection_Ping::WeaponName' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Ping, WeaponType) == 0x000070, "Member 'FWuLogHackDetection_Ping::WeaponType' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Ping, DetectionType) == 0x000080, "Member 'FWuLogHackDetection_Ping::DetectionType' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Ping, Reason_Ping) == 0x000090, "Member 'FWuLogHackDetection_Ping::Reason_Ping' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Ping, IsBanned) == 0x000094, "Member 'FWuLogHackDetection_Ping::IsBanned' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Ping, IsBlockedHit) == 0x000095, "Member 'FWuLogHackDetection_Ping::IsBlockedHit' has a wrong offset!");

// ScriptStruct TslGame.WuLogHackDetection_Seq
// 0x0078 (0x00A0 - 0x0028)
struct FWuLogHackDetection_Seq final : public FLogBase
{
public:
	struct FWuLogCharacter                        Character;                                         // 0x0028(0x0038)(NativeAccessSpecifierPublic)
	class FString                                 WeaponName;                                        // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WeaponType;                                        // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DetectionType;                                     // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Reason_ServerHitSeq;                               // 0x0090(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Reason_ClientHitSeq;                               // 0x0094(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBanned;                                          // 0x0098(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBlockedHit;                                      // 0x0099(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWuLogHackDetection_Seq) == 0x000008, "Wrong alignment on FWuLogHackDetection_Seq");
static_assert(sizeof(FWuLogHackDetection_Seq) == 0x0000A0, "Wrong size on FWuLogHackDetection_Seq");
static_assert(offsetof(FWuLogHackDetection_Seq, Character) == 0x000028, "Member 'FWuLogHackDetection_Seq::Character' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Seq, WeaponName) == 0x000060, "Member 'FWuLogHackDetection_Seq::WeaponName' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Seq, WeaponType) == 0x000070, "Member 'FWuLogHackDetection_Seq::WeaponType' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Seq, DetectionType) == 0x000080, "Member 'FWuLogHackDetection_Seq::DetectionType' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Seq, Reason_ServerHitSeq) == 0x000090, "Member 'FWuLogHackDetection_Seq::Reason_ServerHitSeq' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Seq, Reason_ClientHitSeq) == 0x000094, "Member 'FWuLogHackDetection_Seq::Reason_ClientHitSeq' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Seq, IsBanned) == 0x000098, "Member 'FWuLogHackDetection_Seq::IsBanned' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection_Seq, IsBlockedHit) == 0x000099, "Member 'FWuLogHackDetection_Seq::IsBlockedHit' has a wrong offset!");

// ScriptStruct TslGame.WuLogServerStat
// 0x0030 (0x0058 - 0x0028)
struct FWuLogServerStat final : public FLogBase
{
public:
	int32                                         ElapsedTime;                                       // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumAliveTeams;                                     // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumJoinPlayers;                                    // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumStartPlayers;                                   // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumAlivePlayers;                                   // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PingMin;                                           // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PingMax;                                           // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PingAvg;                                           // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrameRateMin;                                      // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrameRateMax;                                      // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrameRateAvg;                                      // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWuLogServerStat) == 0x000008, "Wrong alignment on FWuLogServerStat");
static_assert(sizeof(FWuLogServerStat) == 0x000058, "Wrong size on FWuLogServerStat");
static_assert(offsetof(FWuLogServerStat, ElapsedTime) == 0x000028, "Member 'FWuLogServerStat::ElapsedTime' has a wrong offset!");
static_assert(offsetof(FWuLogServerStat, NumAliveTeams) == 0x00002C, "Member 'FWuLogServerStat::NumAliveTeams' has a wrong offset!");
static_assert(offsetof(FWuLogServerStat, NumJoinPlayers) == 0x000030, "Member 'FWuLogServerStat::NumJoinPlayers' has a wrong offset!");
static_assert(offsetof(FWuLogServerStat, NumStartPlayers) == 0x000034, "Member 'FWuLogServerStat::NumStartPlayers' has a wrong offset!");
static_assert(offsetof(FWuLogServerStat, NumAlivePlayers) == 0x000038, "Member 'FWuLogServerStat::NumAlivePlayers' has a wrong offset!");
static_assert(offsetof(FWuLogServerStat, PingMin) == 0x00003C, "Member 'FWuLogServerStat::PingMin' has a wrong offset!");
static_assert(offsetof(FWuLogServerStat, PingMax) == 0x000040, "Member 'FWuLogServerStat::PingMax' has a wrong offset!");
static_assert(offsetof(FWuLogServerStat, PingAvg) == 0x000044, "Member 'FWuLogServerStat::PingAvg' has a wrong offset!");
static_assert(offsetof(FWuLogServerStat, FrameRateMin) == 0x000048, "Member 'FWuLogServerStat::FrameRateMin' has a wrong offset!");
static_assert(offsetof(FWuLogServerStat, FrameRateMax) == 0x00004C, "Member 'FWuLogServerStat::FrameRateMax' has a wrong offset!");
static_assert(offsetof(FWuLogServerStat, FrameRateAvg) == 0x000050, "Member 'FWuLogServerStat::FrameRateAvg' has a wrong offset!");

// ScriptStruct TslGame.WuLogHackDetection
// 0x0070 (0x0098 - 0x0028)
struct FWuLogHackDetection final : public FLogBase
{
public:
	struct FWuLogCharacter                        Character;                                         // 0x0028(0x0038)(NativeAccessSpecifierPublic)
	class FString                                 WeaponName;                                        // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DetectionType;                                     // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Reason;                                            // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBanned;                                          // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWuLogHackDetection) == 0x000008, "Wrong alignment on FWuLogHackDetection");
static_assert(sizeof(FWuLogHackDetection) == 0x000098, "Wrong size on FWuLogHackDetection");
static_assert(offsetof(FWuLogHackDetection, Character) == 0x000028, "Member 'FWuLogHackDetection::Character' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection, WeaponName) == 0x000060, "Member 'FWuLogHackDetection::WeaponName' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection, DetectionType) == 0x000070, "Member 'FWuLogHackDetection::DetectionType' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection, Reason) == 0x000080, "Member 'FWuLogHackDetection::Reason' has a wrong offset!");
static_assert(offsetof(FWuLogHackDetection, IsBanned) == 0x000090, "Member 'FWuLogHackDetection::IsBanned' has a wrong offset!");

// ScriptStruct TslGame.WuLogVehicleLeave
// 0x0060 (0x0088 - 0x0028)
struct FWuLogVehicleLeave final : public FLogBase
{
public:
	struct FWuLogCharacter                        Character;                                         // 0x0028(0x0038)(NativeAccessSpecifierPublic)
	struct FWuLogVehicle                          Vehicle;                                           // 0x0060(0x0028)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuLogVehicleLeave) == 0x000008, "Wrong alignment on FWuLogVehicleLeave");
static_assert(sizeof(FWuLogVehicleLeave) == 0x000088, "Wrong size on FWuLogVehicleLeave");
static_assert(offsetof(FWuLogVehicleLeave, Character) == 0x000028, "Member 'FWuLogVehicleLeave::Character' has a wrong offset!");
static_assert(offsetof(FWuLogVehicleLeave, Vehicle) == 0x000060, "Member 'FWuLogVehicleLeave::Vehicle' has a wrong offset!");

// ScriptStruct TslGame.WuLogVehicleSpawn
// 0x0020 (0x0048 - 0x0028)
struct FWuLogVehicleSpawn final : public FLogBase
{
public:
	class FString                                 VehicleId;                                         // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0038(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWuLogVehicleSpawn) == 0x000008, "Wrong alignment on FWuLogVehicleSpawn");
static_assert(sizeof(FWuLogVehicleSpawn) == 0x000048, "Wrong size on FWuLogVehicleSpawn");
static_assert(offsetof(FWuLogVehicleSpawn, VehicleId) == 0x000028, "Member 'FWuLogVehicleSpawn::VehicleId' has a wrong offset!");
static_assert(offsetof(FWuLogVehicleSpawn, Location) == 0x000038, "Member 'FWuLogVehicleSpawn::Location' has a wrong offset!");

// ScriptStruct TslGame.WuLogItemPackage
// 0x0030 (0x0030 - 0x0000)
struct FWuLogItemPackage final
{
public:
	class FString                                 ItemPackageId;                                     // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FWuLogItem>                     Items;                                             // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuLogItemPackage) == 0x000008, "Wrong alignment on FWuLogItemPackage");
static_assert(sizeof(FWuLogItemPackage) == 0x000030, "Wrong size on FWuLogItemPackage");
static_assert(offsetof(FWuLogItemPackage, ItemPackageId) == 0x000000, "Member 'FWuLogItemPackage::ItemPackageId' has a wrong offset!");
static_assert(offsetof(FWuLogItemPackage, Location) == 0x000010, "Member 'FWuLogItemPackage::Location' has a wrong offset!");
static_assert(offsetof(FWuLogItemPackage, Items) == 0x000020, "Member 'FWuLogItemPackage::Items' has a wrong offset!");

// ScriptStruct TslGame.WuLogCarePackageLand
// 0x0030 (0x0058 - 0x0028)
struct FWuLogCarePackageLand final : public FLogBase
{
public:
	struct FWuLogItemPackage                      ItemPackage;                                       // 0x0028(0x0030)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuLogCarePackageLand) == 0x000008, "Wrong alignment on FWuLogCarePackageLand");
static_assert(sizeof(FWuLogCarePackageLand) == 0x000058, "Wrong size on FWuLogCarePackageLand");
static_assert(offsetof(FWuLogCarePackageLand, ItemPackage) == 0x000028, "Member 'FWuLogCarePackageLand::ItemPackage' has a wrong offset!");

// ScriptStruct TslGame.WuLogCharacterRating
// 0x0030 (0x0030 - 0x0000)
struct FWuLogCharacterRating final
{
public:
	class FString                                 AccountId;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NetId;                                             // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WinPoints;                                         // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KillPoints;                                        // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MMR;                                               // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWuLogCharacterRating) == 0x000008, "Wrong alignment on FWuLogCharacterRating");
static_assert(sizeof(FWuLogCharacterRating) == 0x000030, "Wrong size on FWuLogCharacterRating");
static_assert(offsetof(FWuLogCharacterRating, AccountId) == 0x000000, "Member 'FWuLogCharacterRating::AccountId' has a wrong offset!");
static_assert(offsetof(FWuLogCharacterRating, NetId) == 0x000010, "Member 'FWuLogCharacterRating::NetId' has a wrong offset!");
static_assert(offsetof(FWuLogCharacterRating, WinPoints) == 0x000020, "Member 'FWuLogCharacterRating::WinPoints' has a wrong offset!");
static_assert(offsetof(FWuLogCharacterRating, KillPoints) == 0x000024, "Member 'FWuLogCharacterRating::KillPoints' has a wrong offset!");
static_assert(offsetof(FWuLogCharacterRating, MMR) == 0x000028, "Member 'FWuLogCharacterRating::MMR' has a wrong offset!");

// ScriptStruct TslGame.WuLogMatchDefinition
// 0x0020 (0x0048 - 0x0028)
struct FWuLogMatchDefinition final : public FLogBase
{
public:
	class FString                                 MatchId;                                           // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FWuLogCharacterRating>          Ratings;                                           // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuLogMatchDefinition) == 0x000008, "Wrong alignment on FWuLogMatchDefinition");
static_assert(sizeof(FWuLogMatchDefinition) == 0x000048, "Wrong size on FWuLogMatchDefinition");
static_assert(offsetof(FWuLogMatchDefinition, MatchId) == 0x000028, "Member 'FWuLogMatchDefinition::MatchId' has a wrong offset!");
static_assert(offsetof(FWuLogMatchDefinition, Ratings) == 0x000038, "Member 'FWuLogMatchDefinition::Ratings' has a wrong offset!");

// ScriptStruct TslGame.WuLogCarePackageSpawn
// 0x0030 (0x0058 - 0x0028)
struct FWuLogCarePackageSpawn final : public FLogBase
{
public:
	struct FWuLogItemPackage                      ItemPackage;                                       // 0x0028(0x0030)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuLogCarePackageSpawn) == 0x000008, "Wrong alignment on FWuLogCarePackageSpawn");
static_assert(sizeof(FWuLogCarePackageSpawn) == 0x000058, "Wrong size on FWuLogCarePackageSpawn");
static_assert(offsetof(FWuLogCarePackageSpawn, ItemPackage) == 0x000028, "Member 'FWuLogCarePackageSpawn::ItemPackage' has a wrong offset!");

// ScriptStruct TslGame.WuLogItemUse
// 0x0080 (0x00A8 - 0x0028)
struct FWuLogItemUse final : public FLogBase
{
public:
	struct FWuLogCharacter                        Character;                                         // 0x0028(0x0038)(NativeAccessSpecifierPublic)
	struct FWuLogItem                             Item;                                              // 0x0060(0x0048)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuLogItemUse) == 0x000008, "Wrong alignment on FWuLogItemUse");
static_assert(sizeof(FWuLogItemUse) == 0x0000A8, "Wrong size on FWuLogItemUse");
static_assert(offsetof(FWuLogItemUse, Character) == 0x000028, "Member 'FWuLogItemUse::Character' has a wrong offset!");
static_assert(offsetof(FWuLogItemUse, Item) == 0x000060, "Member 'FWuLogItemUse::Item' has a wrong offset!");

// ScriptStruct TslGame.WuLogItemAttach
// 0x00C8 (0x00F0 - 0x0028)
struct FWuLogItemAttach final : public FLogBase
{
public:
	struct FWuLogCharacter                        Character;                                         // 0x0028(0x0038)(NativeAccessSpecifierPublic)
	struct FWuLogItem                             ParentItem;                                        // 0x0060(0x0048)(NativeAccessSpecifierPublic)
	struct FWuLogItem                             ChildItem;                                         // 0x00A8(0x0048)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuLogItemAttach) == 0x000008, "Wrong alignment on FWuLogItemAttach");
static_assert(sizeof(FWuLogItemAttach) == 0x0000F0, "Wrong size on FWuLogItemAttach");
static_assert(offsetof(FWuLogItemAttach, Character) == 0x000028, "Member 'FWuLogItemAttach::Character' has a wrong offset!");
static_assert(offsetof(FWuLogItemAttach, ParentItem) == 0x000060, "Member 'FWuLogItemAttach::ParentItem' has a wrong offset!");
static_assert(offsetof(FWuLogItemAttach, ChildItem) == 0x0000A8, "Member 'FWuLogItemAttach::ChildItem' has a wrong offset!");

// ScriptStruct TslGame.WuLogItemUnequip
// 0x0080 (0x00A8 - 0x0028)
struct FWuLogItemUnequip final : public FLogBase
{
public:
	struct FWuLogCharacter                        Character;                                         // 0x0028(0x0038)(NativeAccessSpecifierPublic)
	struct FWuLogItem                             Item;                                              // 0x0060(0x0048)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuLogItemUnequip) == 0x000008, "Wrong alignment on FWuLogItemUnequip");
static_assert(sizeof(FWuLogItemUnequip) == 0x0000A8, "Wrong size on FWuLogItemUnequip");
static_assert(offsetof(FWuLogItemUnequip, Character) == 0x000028, "Member 'FWuLogItemUnequip::Character' has a wrong offset!");
static_assert(offsetof(FWuLogItemUnequip, Item) == 0x000060, "Member 'FWuLogItemUnequip::Item' has a wrong offset!");

// ScriptStruct TslGame.WuLogItemEquip
// 0x0080 (0x00A8 - 0x0028)
struct FWuLogItemEquip final : public FLogBase
{
public:
	struct FWuLogCharacter                        Character;                                         // 0x0028(0x0038)(NativeAccessSpecifierPublic)
	struct FWuLogItem                             Item;                                              // 0x0060(0x0048)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuLogItemEquip) == 0x000008, "Wrong alignment on FWuLogItemEquip");
static_assert(sizeof(FWuLogItemEquip) == 0x0000A8, "Wrong size on FWuLogItemEquip");
static_assert(offsetof(FWuLogItemEquip, Character) == 0x000028, "Member 'FWuLogItemEquip::Character' has a wrong offset!");
static_assert(offsetof(FWuLogItemEquip, Item) == 0x000060, "Member 'FWuLogItemEquip::Item' has a wrong offset!");

// ScriptStruct TslGame.WuLogItemDrop
// 0x0080 (0x00A8 - 0x0028)
struct FWuLogItemDrop final : public FLogBase
{
public:
	struct FWuLogCharacter                        Character;                                         // 0x0028(0x0038)(NativeAccessSpecifierPublic)
	struct FWuLogItem                             Item;                                              // 0x0060(0x0048)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuLogItemDrop) == 0x000008, "Wrong alignment on FWuLogItemDrop");
static_assert(sizeof(FWuLogItemDrop) == 0x0000A8, "Wrong size on FWuLogItemDrop");
static_assert(offsetof(FWuLogItemDrop, Character) == 0x000028, "Member 'FWuLogItemDrop::Character' has a wrong offset!");
static_assert(offsetof(FWuLogItemDrop, Item) == 0x000060, "Member 'FWuLogItemDrop::Item' has a wrong offset!");

// ScriptStruct TslGame.WuLogItemSpawn
// 0x0018 (0x0040 - 0x0028)
struct FWuLogItemSpawn final : public FLogBase
{
public:
	class FString                                 ItemId;                                            // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnCount;                                        // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StackCount;                                        // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuLogItemSpawn) == 0x000008, "Wrong alignment on FWuLogItemSpawn");
static_assert(sizeof(FWuLogItemSpawn) == 0x000040, "Wrong size on FWuLogItemSpawn");
static_assert(offsetof(FWuLogItemSpawn, ItemId) == 0x000028, "Member 'FWuLogItemSpawn::ItemId' has a wrong offset!");
static_assert(offsetof(FWuLogItemSpawn, SpawnCount) == 0x000038, "Member 'FWuLogItemSpawn::SpawnCount' has a wrong offset!");
static_assert(offsetof(FWuLogItemSpawn, StackCount) == 0x00003C, "Member 'FWuLogItemSpawn::StackCount' has a wrong offset!");

// ScriptStruct TslGame.WuLogReportInfo
// 0x0080 (0x00A8 - 0x0028)
struct FWuLogReportInfo final : public FLogBase
{
public:
	struct FWuLogCharacter                        Reporter;                                          // 0x0028(0x0038)(NativeAccessSpecifierPublic)
	struct FWuLogCharacter                        ReportedPlayer;                                    // 0x0060(0x0038)(NativeAccessSpecifierPublic)
	class FString                                 ReportCauseType;                                   // 0x0098(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuLogReportInfo) == 0x000008, "Wrong alignment on FWuLogReportInfo");
static_assert(sizeof(FWuLogReportInfo) == 0x0000A8, "Wrong size on FWuLogReportInfo");
static_assert(offsetof(FWuLogReportInfo, Reporter) == 0x000028, "Member 'FWuLogReportInfo::Reporter' has a wrong offset!");
static_assert(offsetof(FWuLogReportInfo, ReportedPlayer) == 0x000060, "Member 'FWuLogReportInfo::ReportedPlayer' has a wrong offset!");
static_assert(offsetof(FWuLogReportInfo, ReportCauseType) == 0x000098, "Member 'FWuLogReportInfo::ReportCauseType' has a wrong offset!");

// ScriptStruct TslGame.WuLogPlayerKill
// 0x00A0 (0x00C8 - 0x0028)
struct FWuLogPlayerKill final : public FLogBase
{
public:
	int32                                         AttackId;                                          // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWuLogCharacter                        Killer;                                            // 0x0030(0x0038)(NativeAccessSpecifierPublic)
	struct FWuLogCharacter                        Victim;                                            // 0x0068(0x0038)(NativeAccessSpecifierPublic)
	class FString                                 DamageTypeCategory;                                // 0x00A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DamageCauserName;                                  // 0x00B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWuLogPlayerKill) == 0x000008, "Wrong alignment on FWuLogPlayerKill");
static_assert(sizeof(FWuLogPlayerKill) == 0x0000C8, "Wrong size on FWuLogPlayerKill");
static_assert(offsetof(FWuLogPlayerKill, AttackId) == 0x000028, "Member 'FWuLogPlayerKill::AttackId' has a wrong offset!");
static_assert(offsetof(FWuLogPlayerKill, Killer) == 0x000030, "Member 'FWuLogPlayerKill::Killer' has a wrong offset!");
static_assert(offsetof(FWuLogPlayerKill, Victim) == 0x000068, "Member 'FWuLogPlayerKill::Victim' has a wrong offset!");
static_assert(offsetof(FWuLogPlayerKill, DamageTypeCategory) == 0x0000A0, "Member 'FWuLogPlayerKill::DamageTypeCategory' has a wrong offset!");
static_assert(offsetof(FWuLogPlayerKill, DamageCauserName) == 0x0000B0, "Member 'FWuLogPlayerKill::DamageCauserName' has a wrong offset!");
static_assert(offsetof(FWuLogPlayerKill, Distance) == 0x0000C0, "Member 'FWuLogPlayerKill::Distance' has a wrong offset!");

// ScriptStruct TslGame.WuLogPlayerRevive
// 0x0070 (0x0098 - 0x0028)
struct FWuLogPlayerRevive final : public FLogBase
{
public:
	struct FWuLogCharacter                        Reviver;                                           // 0x0028(0x0038)(NativeAccessSpecifierPublic)
	struct FWuLogCharacter                        Victim;                                            // 0x0060(0x0038)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuLogPlayerRevive) == 0x000008, "Wrong alignment on FWuLogPlayerRevive");
static_assert(sizeof(FWuLogPlayerRevive) == 0x000098, "Wrong size on FWuLogPlayerRevive");
static_assert(offsetof(FWuLogPlayerRevive, Reviver) == 0x000028, "Member 'FWuLogPlayerRevive::Reviver' has a wrong offset!");
static_assert(offsetof(FWuLogPlayerRevive, Victim) == 0x000060, "Member 'FWuLogPlayerRevive::Victim' has a wrong offset!");

// ScriptStruct TslGame.WuLogPlayerTakeDamage
// 0x00B0 (0x00D8 - 0x0028)
struct FWuLogPlayerTakeDamage final : public FLogBase
{
public:
	int32                                         AttackId;                                          // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWuLogCharacter                        Attacker;                                          // 0x0030(0x0038)(NativeAccessSpecifierPublic)
	struct FWuLogCharacter                        Victim;                                            // 0x0068(0x0038)(NativeAccessSpecifierPublic)
	class FString                                 DamageTypeCategory;                                // 0x00A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DamageReason;                                      // 0x00B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DamageCauserName;                                  // 0x00C8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuLogPlayerTakeDamage) == 0x000008, "Wrong alignment on FWuLogPlayerTakeDamage");
static_assert(sizeof(FWuLogPlayerTakeDamage) == 0x0000D8, "Wrong size on FWuLogPlayerTakeDamage");
static_assert(offsetof(FWuLogPlayerTakeDamage, AttackId) == 0x000028, "Member 'FWuLogPlayerTakeDamage::AttackId' has a wrong offset!");
static_assert(offsetof(FWuLogPlayerTakeDamage, Attacker) == 0x000030, "Member 'FWuLogPlayerTakeDamage::Attacker' has a wrong offset!");
static_assert(offsetof(FWuLogPlayerTakeDamage, Victim) == 0x000068, "Member 'FWuLogPlayerTakeDamage::Victim' has a wrong offset!");
static_assert(offsetof(FWuLogPlayerTakeDamage, DamageTypeCategory) == 0x0000A0, "Member 'FWuLogPlayerTakeDamage::DamageTypeCategory' has a wrong offset!");
static_assert(offsetof(FWuLogPlayerTakeDamage, DamageReason) == 0x0000B0, "Member 'FWuLogPlayerTakeDamage::DamageReason' has a wrong offset!");
static_assert(offsetof(FWuLogPlayerTakeDamage, Damage) == 0x0000C0, "Member 'FWuLogPlayerTakeDamage::Damage' has a wrong offset!");
static_assert(offsetof(FWuLogPlayerTakeDamage, DamageCauserName) == 0x0000C8, "Member 'FWuLogPlayerTakeDamage::DamageCauserName' has a wrong offset!");

// ScriptStruct TslGame.WuLogPlayerAttack
// 0x00C0 (0x00E8 - 0x0028)
struct FWuLogPlayerAttack final : public FLogBase
{
public:
	int32                                         AttackId;                                          // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWuLogCharacter                        Attacker;                                          // 0x0030(0x0038)(NativeAccessSpecifierPublic)
	class FString                                 AttackType;                                        // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWuLogItem                             Weapon;                                            // 0x0078(0x0048)(NativeAccessSpecifierPublic)
	struct FWuLogVehicle                          Vehicle;                                           // 0x00C0(0x0028)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuLogPlayerAttack) == 0x000008, "Wrong alignment on FWuLogPlayerAttack");
static_assert(sizeof(FWuLogPlayerAttack) == 0x0000E8, "Wrong size on FWuLogPlayerAttack");
static_assert(offsetof(FWuLogPlayerAttack, AttackId) == 0x000028, "Member 'FWuLogPlayerAttack::AttackId' has a wrong offset!");
static_assert(offsetof(FWuLogPlayerAttack, Attacker) == 0x000030, "Member 'FWuLogPlayerAttack::Attacker' has a wrong offset!");
static_assert(offsetof(FWuLogPlayerAttack, AttackType) == 0x000068, "Member 'FWuLogPlayerAttack::AttackType' has a wrong offset!");
static_assert(offsetof(FWuLogPlayerAttack, Weapon) == 0x000078, "Member 'FWuLogPlayerAttack::Weapon' has a wrong offset!");
static_assert(offsetof(FWuLogPlayerAttack, Vehicle) == 0x0000C0, "Member 'FWuLogPlayerAttack::Vehicle' has a wrong offset!");

// ScriptStruct TslGame.WuLogPlayerPosition
// 0x0048 (0x0070 - 0x0028)
struct FWuLogPlayerPosition final : public FLogBase
{
public:
	struct FWuLogCharacter                        Character;                                         // 0x0028(0x0038)(NativeAccessSpecifierPublic)
	float                                         ElapsedTime;                                       // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumAlivePlayers;                                   // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClientFPS;                                         // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWuLogPlayerPosition) == 0x000008, "Wrong alignment on FWuLogPlayerPosition");
static_assert(sizeof(FWuLogPlayerPosition) == 0x000070, "Wrong size on FWuLogPlayerPosition");
static_assert(offsetof(FWuLogPlayerPosition, Character) == 0x000028, "Member 'FWuLogPlayerPosition::Character' has a wrong offset!");
static_assert(offsetof(FWuLogPlayerPosition, ElapsedTime) == 0x000060, "Member 'FWuLogPlayerPosition::ElapsedTime' has a wrong offset!");
static_assert(offsetof(FWuLogPlayerPosition, NumAlivePlayers) == 0x000064, "Member 'FWuLogPlayerPosition::NumAlivePlayers' has a wrong offset!");
static_assert(offsetof(FWuLogPlayerPosition, ClientFPS) == 0x000068, "Member 'FWuLogPlayerPosition::ClientFPS' has a wrong offset!");

// ScriptStruct TslGame.WuLogPlayerLogout
// 0x0010 (0x0038 - 0x0028)
struct FWuLogPlayerLogout final : public FLogBase
{
public:
	class FString                                 NetId;                                             // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuLogPlayerLogout) == 0x000008, "Wrong alignment on FWuLogPlayerLogout");
static_assert(sizeof(FWuLogPlayerLogout) == 0x000038, "Wrong size on FWuLogPlayerLogout");
static_assert(offsetof(FWuLogPlayerLogout, NetId) == 0x000028, "Member 'FWuLogPlayerLogout::NetId' has a wrong offset!");

// ScriptStruct TslGame.WuLogPlayerLogin
// 0x0028 (0x0050 - 0x0028)
struct FWuLogPlayerLogin final : public FLogBase
{
public:
	class FString                                 NetId;                                             // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ErrorMessage;                                      // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuLogPlayerLogin) == 0x000008, "Wrong alignment on FWuLogPlayerLogin");
static_assert(sizeof(FWuLogPlayerLogin) == 0x000050, "Wrong size on FWuLogPlayerLogin");
static_assert(offsetof(FWuLogPlayerLogin, NetId) == 0x000028, "Member 'FWuLogPlayerLogin::NetId' has a wrong offset!");
static_assert(offsetof(FWuLogPlayerLogin, Result) == 0x000038, "Member 'FWuLogPlayerLogin::Result' has a wrong offset!");
static_assert(offsetof(FWuLogPlayerLogin, ErrorMessage) == 0x000040, "Member 'FWuLogPlayerLogin::ErrorMessage' has a wrong offset!");

// ScriptStruct TslGame.WuLogPlayerCreate
// 0x0038 (0x0060 - 0x0028)
struct FWuLogPlayerCreate final : public FLogBase
{
public:
	struct FWuLogCharacter                        Character;                                         // 0x0028(0x0038)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuLogPlayerCreate) == 0x000008, "Wrong alignment on FWuLogPlayerCreate");
static_assert(sizeof(FWuLogPlayerCreate) == 0x000060, "Wrong size on FWuLogPlayerCreate");
static_assert(offsetof(FWuLogPlayerCreate, Character) == 0x000028, "Member 'FWuLogPlayerCreate::Character' has a wrong offset!");

// ScriptStruct TslGame.WuLogGameStatePeriodic
// 0x0048 (0x0070 - 0x0028)
struct FWuLogGameStatePeriodic final : public FLogBase
{
public:
	struct FWuLogGameState                        GameState;                                         // 0x0028(0x0044)(NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWuLogGameStatePeriodic) == 0x000008, "Wrong alignment on FWuLogGameStatePeriodic");
static_assert(sizeof(FWuLogGameStatePeriodic) == 0x000070, "Wrong size on FWuLogGameStatePeriodic");
static_assert(offsetof(FWuLogGameStatePeriodic, GameState) == 0x000028, "Member 'FWuLogGameStatePeriodic::GameState' has a wrong offset!");

// ScriptStruct TslGame.WuLogMatchEnd
// 0x0010 (0x0038 - 0x0028)
struct FWuLogMatchEnd final : public FLogBase
{
public:
	TArray<struct FWuLogCharacter>                Characters;                                        // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuLogMatchEnd) == 0x000008, "Wrong alignment on FWuLogMatchEnd");
static_assert(sizeof(FWuLogMatchEnd) == 0x000038, "Wrong size on FWuLogMatchEnd");
static_assert(offsetof(FWuLogMatchEnd, Characters) == 0x000028, "Member 'FWuLogMatchEnd::Characters' has a wrong offset!");

// ScriptStruct TslGame.WuGameResultStatsPerPlayer
// 0x0008 (0x0008 - 0x0000)
struct FWuGameResultStatsPerPlayer final
{
public:
	int32                                         KillCount;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Score;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuGameResultStatsPerPlayer) == 0x000004, "Wrong alignment on FWuGameResultStatsPerPlayer");
static_assert(sizeof(FWuGameResultStatsPerPlayer) == 0x000008, "Wrong size on FWuGameResultStatsPerPlayer");
static_assert(offsetof(FWuGameResultStatsPerPlayer, KillCount) == 0x000000, "Member 'FWuGameResultStatsPerPlayer::KillCount' has a wrong offset!");
static_assert(offsetof(FWuGameResultStatsPerPlayer, Score) == 0x000004, "Member 'FWuGameResultStatsPerPlayer::Score' has a wrong offset!");

// ScriptStruct TslGame.WuGameResultPerPlayer
// 0x0038 (0x0038 - 0x0000)
struct FWuGameResultPerPlayer final
{
public:
	class FString                                 PlayerNetId;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rank;                                              // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GameResult;                                        // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamId;                                            // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FWuGameResultStatsPerPlayer            Stats;                                             // 0x002C(0x0008)(NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWuGameResultPerPlayer) == 0x000008, "Wrong alignment on FWuGameResultPerPlayer");
static_assert(sizeof(FWuGameResultPerPlayer) == 0x000038, "Wrong size on FWuGameResultPerPlayer");
static_assert(offsetof(FWuGameResultPerPlayer, PlayerNetId) == 0x000000, "Member 'FWuGameResultPerPlayer::PlayerNetId' has a wrong offset!");
static_assert(offsetof(FWuGameResultPerPlayer, Rank) == 0x000010, "Member 'FWuGameResultPerPlayer::Rank' has a wrong offset!");
static_assert(offsetof(FWuGameResultPerPlayer, GameResult) == 0x000018, "Member 'FWuGameResultPerPlayer::GameResult' has a wrong offset!");
static_assert(offsetof(FWuGameResultPerPlayer, TeamId) == 0x000028, "Member 'FWuGameResultPerPlayer::TeamId' has a wrong offset!");
static_assert(offsetof(FWuGameResultPerPlayer, Stats) == 0x00002C, "Member 'FWuGameResultPerPlayer::Stats' has a wrong offset!");

// ScriptStruct TslGame.WuGameFinishedResult
// 0x0010 (0x0010 - 0x0000)
struct FWuGameFinishedResult final
{
public:
	TArray<struct FWuGameResultPerPlayer>         Results;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuGameFinishedResult) == 0x000008, "Wrong alignment on FWuGameFinishedResult");
static_assert(sizeof(FWuGameFinishedResult) == 0x000010, "Wrong size on FWuGameFinishedResult");
static_assert(offsetof(FWuGameFinishedResult, Results) == 0x000000, "Member 'FWuGameFinishedResult::Results' has a wrong offset!");

// ScriptStruct TslGame.WuGameStartInfoPerPlayer
// 0x0010 (0x0010 - 0x0000)
struct FWuGameStartInfoPerPlayer final
{
public:
	class FString                                 PlayerNetId;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuGameStartInfoPerPlayer) == 0x000008, "Wrong alignment on FWuGameStartInfoPerPlayer");
static_assert(sizeof(FWuGameStartInfoPerPlayer) == 0x000010, "Wrong size on FWuGameStartInfoPerPlayer");
static_assert(offsetof(FWuGameStartInfoPerPlayer, PlayerNetId) == 0x000000, "Member 'FWuGameStartInfoPerPlayer::PlayerNetId' has a wrong offset!");

// ScriptStruct TslGame.WuGameStartInfo
// 0x0010 (0x0010 - 0x0000)
struct FWuGameStartInfo final
{
public:
	TArray<struct FWuGameStartInfoPerPlayer>      Players;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuGameStartInfo) == 0x000008, "Wrong alignment on FWuGameStartInfo");
static_assert(sizeof(FWuGameStartInfo) == 0x000010, "Wrong size on FWuGameStartInfo");
static_assert(offsetof(FWuGameStartInfo, Players) == 0x000000, "Member 'FWuGameStartInfo::Players' has a wrong offset!");

// ScriptStruct TslGame.WuGameInitializedResult
// 0x0008 (0x0008 - 0x0000)
struct FWuGameInitializedResult final
{
public:
	bool                                          IsSuccess;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Port;                                              // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuGameInitializedResult) == 0x000004, "Wrong alignment on FWuGameInitializedResult");
static_assert(sizeof(FWuGameInitializedResult) == 0x000008, "Wrong size on FWuGameInitializedResult");
static_assert(offsetof(FWuGameInitializedResult, IsSuccess) == 0x000000, "Member 'FWuGameInitializedResult::IsSuccess' has a wrong offset!");
static_assert(offsetof(FWuGameInitializedResult, Port) == 0x000004, "Member 'FWuGameInitializedResult::Port' has a wrong offset!");

// ScriptStruct TslGame.WuGameStartRequest
// 0x0010 (0x0010 - 0x0000)
struct FWuGameStartRequest final
{
public:
	TArray<struct FWuStringStringPair>            StringParameters;                                  // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuGameStartRequest) == 0x000008, "Wrong alignment on FWuGameStartRequest");
static_assert(sizeof(FWuGameStartRequest) == 0x000010, "Wrong size on FWuGameStartRequest");
static_assert(offsetof(FWuGameStartRequest, StringParameters) == 0x000000, "Member 'FWuGameStartRequest::StringParameters' has a wrong offset!");

// ScriptStruct TslGame.GaugeAlphaCurveType
// 0x0010 (0x0010 - 0x0000)
struct FGaugeAlphaCurveType final
{
public:
	struct FFloatInterval                         DamageRange;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UCurveVector*                           ColorCurve;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGaugeAlphaCurveType) == 0x000008, "Wrong alignment on FGaugeAlphaCurveType");
static_assert(sizeof(FGaugeAlphaCurveType) == 0x000010, "Wrong size on FGaugeAlphaCurveType");
static_assert(offsetof(FGaugeAlphaCurveType, DamageRange) == 0x000000, "Member 'FGaugeAlphaCurveType::DamageRange' has a wrong offset!");
static_assert(offsetof(FGaugeAlphaCurveType, ColorCurve) == 0x000008, "Member 'FGaugeAlphaCurveType::ColorCurve' has a wrong offset!");

// ScriptStruct TslGame.WuGameInitializeRequest
// 0x0030 (0x0030 - 0x0000)
struct FWuGameInitializeRequest final
{
public:
	bool                                          IsCustomGame;                                      // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MapName;                                           // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinPlayerCount;                                    // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPlayerCount;                                    // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FWuStringStringPair>            StringParameters;                                  // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuGameInitializeRequest) == 0x000008, "Wrong alignment on FWuGameInitializeRequest");
static_assert(sizeof(FWuGameInitializeRequest) == 0x000030, "Wrong size on FWuGameInitializeRequest");
static_assert(offsetof(FWuGameInitializeRequest, IsCustomGame) == 0x000000, "Member 'FWuGameInitializeRequest::IsCustomGame' has a wrong offset!");
static_assert(offsetof(FWuGameInitializeRequest, MapName) == 0x000008, "Member 'FWuGameInitializeRequest::MapName' has a wrong offset!");
static_assert(offsetof(FWuGameInitializeRequest, MinPlayerCount) == 0x000018, "Member 'FWuGameInitializeRequest::MinPlayerCount' has a wrong offset!");
static_assert(offsetof(FWuGameInitializeRequest, MaxPlayerCount) == 0x00001C, "Member 'FWuGameInitializeRequest::MaxPlayerCount' has a wrong offset!");
static_assert(offsetof(FWuGameInitializeRequest, StringParameters) == 0x000020, "Member 'FWuGameInitializeRequest::StringParameters' has a wrong offset!");

// ScriptStruct TslGame.WuCustomizableObjectIdPair
// 0x0020 (0x0020 - 0x0000)
struct FWuCustomizableObjectIdPair final
{
public:
	class FString                                 CustomizableObjectKey;                             // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CustomizableObjectValue;                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWuCustomizableObjectIdPair) == 0x000008, "Wrong alignment on FWuCustomizableObjectIdPair");
static_assert(sizeof(FWuCustomizableObjectIdPair) == 0x000020, "Wrong size on FWuCustomizableObjectIdPair");
static_assert(offsetof(FWuCustomizableObjectIdPair, CustomizableObjectKey) == 0x000000, "Member 'FWuCustomizableObjectIdPair::CustomizableObjectKey' has a wrong offset!");
static_assert(offsetof(FWuCustomizableObjectIdPair, CustomizableObjectValue) == 0x000010, "Member 'FWuCustomizableObjectIdPair::CustomizableObjectValue' has a wrong offset!");

// ScriptStruct TslGame.ReplicatedEquipableItem
// 0x0010 (0x0010 - 0x0000)
struct FReplicatedEquipableItem final
{
public:
	TSubclassOf<class UEquipableItem>             EquipableItemClass;                                // 0x0000(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Durability;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReplicatedEquipableItem) == 0x000008, "Wrong alignment on FReplicatedEquipableItem");
static_assert(sizeof(FReplicatedEquipableItem) == 0x000010, "Wrong size on FReplicatedEquipableItem");
static_assert(offsetof(FReplicatedEquipableItem, EquipableItemClass) == 0x000000, "Member 'FReplicatedEquipableItem::EquipableItemClass' has a wrong offset!");
static_assert(offsetof(FReplicatedEquipableItem, Durability) == 0x000008, "Member 'FReplicatedEquipableItem::Durability' has a wrong offset!");

// ScriptStruct TslGame.TslPlayerScores
// 0x000C (0x000C - 0x0000)
struct FTslPlayerScores final
{
public:
	float                                         ScoreByDamage;                                     // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScoreByKill;                                       // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScoreByRanking;                                    // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTslPlayerScores) == 0x000004, "Wrong alignment on FTslPlayerScores");
static_assert(sizeof(FTslPlayerScores) == 0x00000C, "Wrong size on FTslPlayerScores");
static_assert(offsetof(FTslPlayerScores, ScoreByDamage) == 0x000000, "Member 'FTslPlayerScores::ScoreByDamage' has a wrong offset!");
static_assert(offsetof(FTslPlayerScores, ScoreByKill) == 0x000004, "Member 'FTslPlayerScores::ScoreByKill' has a wrong offset!");
static_assert(offsetof(FTslPlayerScores, ScoreByRanking) == 0x000008, "Member 'FTslPlayerScores::ScoreByRanking' has a wrong offset!");

// ScriptStruct TslGame.PostProcessEffectParameter
// 0x0018 (0x0018 - 0x0000)
struct FPostProcessEffectParameter final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPostProcessEffectParameter) == 0x000008, "Wrong alignment on FPostProcessEffectParameter");
static_assert(sizeof(FPostProcessEffectParameter) == 0x000018, "Wrong size on FPostProcessEffectParameter");
static_assert(offsetof(FPostProcessEffectParameter, Name) == 0x000000, "Member 'FPostProcessEffectParameter::Name' has a wrong offset!");
static_assert(offsetof(FPostProcessEffectParameter, Value) == 0x000010, "Member 'FPostProcessEffectParameter::Value' has a wrong offset!");

// ScriptStruct TslGame.PostProcessMaterial
// 0x0010 (0x0010 - 0x0000)
struct FPostProcessMaterial final
{
public:
	class UMaterialInterface*                     EffectMaterial;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendWeight;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPostProcessMaterial) == 0x000008, "Wrong alignment on FPostProcessMaterial");
static_assert(sizeof(FPostProcessMaterial) == 0x000010, "Wrong size on FPostProcessMaterial");
static_assert(offsetof(FPostProcessMaterial, EffectMaterial) == 0x000000, "Member 'FPostProcessMaterial::EffectMaterial' has a wrong offset!");
static_assert(offsetof(FPostProcessMaterial, BlendWeight) == 0x000008, "Member 'FPostProcessMaterial::BlendWeight' has a wrong offset!");

// ScriptStruct TslGame.ProjectileWeaponData
// 0x0008 (0x0008 - 0x0000)
struct FProjectileWeaponData final
{
public:
	TSubclassOf<class ATslProjectile>             ProjectileClass;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectileWeaponData) == 0x000008, "Wrong alignment on FProjectileWeaponData");
static_assert(sizeof(FProjectileWeaponData) == 0x000008, "Wrong size on FProjectileWeaponData");
static_assert(offsetof(FProjectileWeaponData, ProjectileClass) == 0x000000, "Member 'FProjectileWeaponData::ProjectileClass' has a wrong offset!");

// ScriptStruct TslGame.ProjectileData
// 0x0030 (0x0030 - 0x0000)
struct FProjectileData final
{
public:
	float                                         ProjectileLife;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExplosionDamage;                                   // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExplosionRadius;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DamageCurve;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinImpactVelocityForSound;                         // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenImpactSound;                            // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DestroyAtExplosion;                                // 0x0028(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProjectileData) == 0x000008, "Wrong alignment on FProjectileData");
static_assert(sizeof(FProjectileData) == 0x000030, "Wrong size on FProjectileData");
static_assert(offsetof(FProjectileData, ProjectileLife) == 0x000000, "Member 'FProjectileData::ProjectileLife' has a wrong offset!");
static_assert(offsetof(FProjectileData, ExplosionDamage) == 0x000004, "Member 'FProjectileData::ExplosionDamage' has a wrong offset!");
static_assert(offsetof(FProjectileData, ExplosionRadius) == 0x000008, "Member 'FProjectileData::ExplosionRadius' has a wrong offset!");
static_assert(offsetof(FProjectileData, DamageCurve) == 0x000010, "Member 'FProjectileData::DamageCurve' has a wrong offset!");
static_assert(offsetof(FProjectileData, MinImpactVelocityForSound) == 0x000018, "Member 'FProjectileData::MinImpactVelocityForSound' has a wrong offset!");
static_assert(offsetof(FProjectileData, TimeBetweenImpactSound) == 0x00001C, "Member 'FProjectileData::TimeBetweenImpactSound' has a wrong offset!");
static_assert(offsetof(FProjectileData, DamageType) == 0x000020, "Member 'FProjectileData::DamageType' has a wrong offset!");
static_assert(offsetof(FProjectileData, DestroyAtExplosion) == 0x000028, "Member 'FProjectileData::DestroyAtExplosion' has a wrong offset!");

// ScriptStruct TslGame.DoorBreakingState
// 0x0001 (0x0001 - 0x0000)
struct FDoorBreakingState final
{
public:
	uint8                                         bIsBrokenTop : 1;                                  // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsBrokenCenter : 1;                               // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsBrokenBottom : 1;                               // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FDoorBreakingState) == 0x000001, "Wrong alignment on FDoorBreakingState");
static_assert(sizeof(FDoorBreakingState) == 0x000001, "Wrong size on FDoorBreakingState");

// ScriptStruct TslGame.SavedObPos
// 0x0018 (0x0018 - 0x0000)
struct FSavedObPos final
{
public:
	struct FVector                                Loc;                                               // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Rot;                                               // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSavedObPos) == 0x000004, "Wrong alignment on FSavedObPos");
static_assert(sizeof(FSavedObPos) == 0x000018, "Wrong size on FSavedObPos");
static_assert(offsetof(FSavedObPos, Loc) == 0x000000, "Member 'FSavedObPos::Loc' has a wrong offset!");
static_assert(offsetof(FSavedObPos, Rot) == 0x00000C, "Member 'FSavedObPos::Rot' has a wrong offset!");

// ScriptStruct TslGame.Sequence_Float
// 0x0008 (0x00A0 - 0x0098)
struct FSequence_Float final : public FSequenceBase
{
public:
	class UCurveFloat*                            FloatCurve;                                        // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSequence_Float) == 0x000008, "Wrong alignment on FSequence_Float");
static_assert(sizeof(FSequence_Float) == 0x0000A0, "Wrong size on FSequence_Float");
static_assert(offsetof(FSequence_Float, FloatCurve) == 0x000098, "Member 'FSequence_Float::FloatCurve' has a wrong offset!");

// ScriptStruct TslGame.UmgWidgetBinder_Animation
// 0x0008 (0x0020 - 0x0018)
struct FUmgWidgetBinder_Animation final : public FUmgWidgetBinder
{
public:
	class UWidgetAnimation*                       CachedAnimation;                                   // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FUmgWidgetBinder_Animation) == 0x000008, "Wrong alignment on FUmgWidgetBinder_Animation");
static_assert(sizeof(FUmgWidgetBinder_Animation) == 0x000020, "Wrong size on FUmgWidgetBinder_Animation");
static_assert(offsetof(FUmgWidgetBinder_Animation, CachedAnimation) == 0x000018, "Member 'FUmgWidgetBinder_Animation::CachedAnimation' has a wrong offset!");

// ScriptStruct TslGame.UmgWidgetBinder_UserWidget
// 0x0008 (0x0020 - 0x0018)
struct FUmgWidgetBinder_UserWidget final : public FUmgWidgetBinder
{
public:
	class UUserWidget*                            CachedWidget;                                      // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FUmgWidgetBinder_UserWidget) == 0x000008, "Wrong alignment on FUmgWidgetBinder_UserWidget");
static_assert(sizeof(FUmgWidgetBinder_UserWidget) == 0x000020, "Wrong size on FUmgWidgetBinder_UserWidget");
static_assert(offsetof(FUmgWidgetBinder_UserWidget, CachedWidget) == 0x000018, "Member 'FUmgWidgetBinder_UserWidget::CachedWidget' has a wrong offset!");

// ScriptStruct TslGame.UmgWidgetBinder_SizeBox
// 0x0008 (0x0020 - 0x0018)
struct FUmgWidgetBinder_SizeBox final : public FUmgWidgetBinder
{
public:
	class USizeBox*                               CachedSizeBox;                                     // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FUmgWidgetBinder_SizeBox) == 0x000008, "Wrong alignment on FUmgWidgetBinder_SizeBox");
static_assert(sizeof(FUmgWidgetBinder_SizeBox) == 0x000020, "Wrong size on FUmgWidgetBinder_SizeBox");
static_assert(offsetof(FUmgWidgetBinder_SizeBox, CachedSizeBox) == 0x000018, "Member 'FUmgWidgetBinder_SizeBox::CachedSizeBox' has a wrong offset!");

// ScriptStruct TslGame.MeleeWeaponAnim
// 0x0170 (0x0170 - 0x0000)
struct FMeleeWeaponAnim final
{
public:
	class UAnimMontage*                           AttackAnim;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDecalEffectDataSet                    AttackDecalEffectDataSet;                          // 0x0008(0x0168)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeleeWeaponAnim) == 0x000008, "Wrong alignment on FMeleeWeaponAnim");
static_assert(sizeof(FMeleeWeaponAnim) == 0x000170, "Wrong size on FMeleeWeaponAnim");
static_assert(offsetof(FMeleeWeaponAnim, AttackAnim) == 0x000000, "Member 'FMeleeWeaponAnim::AttackAnim' has a wrong offset!");
static_assert(offsetof(FMeleeWeaponAnim, AttackDecalEffectDataSet) == 0x000008, "Member 'FMeleeWeaponAnim::AttackDecalEffectDataSet' has a wrong offset!");

// ScriptStruct TslGame.UmgWidgetBinder_Border
// 0x0008 (0x0020 - 0x0018)
struct FUmgWidgetBinder_Border final : public FUmgWidgetBinder
{
public:
	class UBorder*                                CachedBorder;                                      // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FUmgWidgetBinder_Border) == 0x000008, "Wrong alignment on FUmgWidgetBinder_Border");
static_assert(sizeof(FUmgWidgetBinder_Border) == 0x000020, "Wrong size on FUmgWidgetBinder_Border");
static_assert(offsetof(FUmgWidgetBinder_Border, CachedBorder) == 0x000018, "Member 'FUmgWidgetBinder_Border::CachedBorder' has a wrong offset!");

// ScriptStruct TslGame.UmgWidgetBinder_TextBlock
// 0x0008 (0x0020 - 0x0018)
struct FUmgWidgetBinder_TextBlock final : public FUmgWidgetBinder
{
public:
	class UTextBlock*                             CachedTextBlock;                                   // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FUmgWidgetBinder_TextBlock) == 0x000008, "Wrong alignment on FUmgWidgetBinder_TextBlock");
static_assert(sizeof(FUmgWidgetBinder_TextBlock) == 0x000020, "Wrong size on FUmgWidgetBinder_TextBlock");
static_assert(offsetof(FUmgWidgetBinder_TextBlock, CachedTextBlock) == 0x000018, "Member 'FUmgWidgetBinder_TextBlock::CachedTextBlock' has a wrong offset!");

// ScriptStruct TslGame.UmgWidgetBinder_WidgetSwitcher
// 0x0008 (0x0020 - 0x0018)
struct FUmgWidgetBinder_WidgetSwitcher final : public FUmgWidgetBinder
{
public:
	class UWidgetSwitcher*                        CachedWidgetSwitcher;                              // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FUmgWidgetBinder_WidgetSwitcher) == 0x000008, "Wrong alignment on FUmgWidgetBinder_WidgetSwitcher");
static_assert(sizeof(FUmgWidgetBinder_WidgetSwitcher) == 0x000020, "Wrong size on FUmgWidgetBinder_WidgetSwitcher");
static_assert(offsetof(FUmgWidgetBinder_WidgetSwitcher, CachedWidgetSwitcher) == 0x000018, "Member 'FUmgWidgetBinder_WidgetSwitcher::CachedWidgetSwitcher' has a wrong offset!");

// ScriptStruct TslGame.UmgWidgetBinder_HorizontalBox
// 0x0008 (0x0020 - 0x0018)
struct FUmgWidgetBinder_HorizontalBox final : public FUmgWidgetBinder
{
public:
	class UHorizontalBox*                         CachedHorizontalBox;                               // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FUmgWidgetBinder_HorizontalBox) == 0x000008, "Wrong alignment on FUmgWidgetBinder_HorizontalBox");
static_assert(sizeof(FUmgWidgetBinder_HorizontalBox) == 0x000020, "Wrong size on FUmgWidgetBinder_HorizontalBox");
static_assert(offsetof(FUmgWidgetBinder_HorizontalBox, CachedHorizontalBox) == 0x000018, "Member 'FUmgWidgetBinder_HorizontalBox::CachedHorizontalBox' has a wrong offset!");

// ScriptStruct TslGame.UmgWidgetBinder_VerticalBox
// 0x0008 (0x0020 - 0x0018)
struct FUmgWidgetBinder_VerticalBox final : public FUmgWidgetBinder
{
public:
	class UVerticalBox*                           CachedVerticalBox;                                 // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FUmgWidgetBinder_VerticalBox) == 0x000008, "Wrong alignment on FUmgWidgetBinder_VerticalBox");
static_assert(sizeof(FUmgWidgetBinder_VerticalBox) == 0x000020, "Wrong size on FUmgWidgetBinder_VerticalBox");
static_assert(offsetof(FUmgWidgetBinder_VerticalBox, CachedVerticalBox) == 0x000018, "Member 'FUmgWidgetBinder_VerticalBox::CachedVerticalBox' has a wrong offset!");

// ScriptStruct TslGame.UmgWidgetBinder_CanvasPanel
// 0x0008 (0x0020 - 0x0018)
struct FUmgWidgetBinder_CanvasPanel final : public FUmgWidgetBinder
{
public:
	class UCanvasPanel*                           CachedCanvasPanel;                                 // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FUmgWidgetBinder_CanvasPanel) == 0x000008, "Wrong alignment on FUmgWidgetBinder_CanvasPanel");
static_assert(sizeof(FUmgWidgetBinder_CanvasPanel) == 0x000020, "Wrong size on FUmgWidgetBinder_CanvasPanel");
static_assert(offsetof(FUmgWidgetBinder_CanvasPanel, CachedCanvasPanel) == 0x000018, "Member 'FUmgWidgetBinder_CanvasPanel::CachedCanvasPanel' has a wrong offset!");

// ScriptStruct TslGame.UmgWidgetBinder_Image
// 0x0010 (0x0028 - 0x0018)
struct FUmgWidgetBinder_Image final : public FUmgWidgetBinder
{
public:
	class UImage*                                 CachedImage;                                       // 0x0018(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               CachedMaterial;                                    // 0x0020(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FUmgWidgetBinder_Image) == 0x000008, "Wrong alignment on FUmgWidgetBinder_Image");
static_assert(sizeof(FUmgWidgetBinder_Image) == 0x000028, "Wrong size on FUmgWidgetBinder_Image");
static_assert(offsetof(FUmgWidgetBinder_Image, CachedImage) == 0x000018, "Member 'FUmgWidgetBinder_Image::CachedImage' has a wrong offset!");
static_assert(offsetof(FUmgWidgetBinder_Image, CachedMaterial) == 0x000020, "Member 'FUmgWidgetBinder_Image::CachedMaterial' has a wrong offset!");

// ScriptStruct TslGame.DurabilityColor
// 0x0018 (0x0018 - 0x0000)
struct FDurabilityColor final
{
public:
	struct FFloatInterval                         DurabilityRatioRange;                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDurabilityColor) == 0x000004, "Wrong alignment on FDurabilityColor");
static_assert(sizeof(FDurabilityColor) == 0x000018, "Wrong size on FDurabilityColor");
static_assert(offsetof(FDurabilityColor, DurabilityRatioRange) == 0x000000, "Member 'FDurabilityColor::DurabilityRatioRange' has a wrong offset!");
static_assert(offsetof(FDurabilityColor, Color) == 0x000008, "Member 'FDurabilityColor::Color' has a wrong offset!");

// ScriptStruct TslGame.DurabilityColorSet
// 0x0010 (0x0010 - 0x0000)
struct FDurabilityColorSet final
{
public:
	TArray<struct FDurabilityColor>               Colors;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDurabilityColorSet) == 0x000008, "Wrong alignment on FDurabilityColorSet");
static_assert(sizeof(FDurabilityColorSet) == 0x000010, "Wrong size on FDurabilityColorSet");
static_assert(offsetof(FDurabilityColorSet, Colors) == 0x000000, "Member 'FDurabilityColorSet::Colors' has a wrong offset!");

// ScriptStruct TslGame.VehicleDebugHit
// 0x0028 (0x0028 - 0x0000)
struct FVehicleDebugHit final
{
public:
	struct FVector                                RelativeNormalImpulse;                             // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                RelativeImpactPoint;                               // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                AbsoluteImpactPoint;                               // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVehicleDebugHit) == 0x000004, "Wrong alignment on FVehicleDebugHit");
static_assert(sizeof(FVehicleDebugHit) == 0x000028, "Wrong size on FVehicleDebugHit");
static_assert(offsetof(FVehicleDebugHit, RelativeNormalImpulse) == 0x000000, "Member 'FVehicleDebugHit::RelativeNormalImpulse' has a wrong offset!");
static_assert(offsetof(FVehicleDebugHit, RelativeImpactPoint) == 0x00000C, "Member 'FVehicleDebugHit::RelativeImpactPoint' has a wrong offset!");
static_assert(offsetof(FVehicleDebugHit, AbsoluteImpactPoint) == 0x000018, "Member 'FVehicleDebugHit::AbsoluteImpactPoint' has a wrong offset!");
static_assert(offsetof(FVehicleDebugHit, Color) == 0x000024, "Member 'FVehicleDebugHit::Color' has a wrong offset!");

// ScriptStruct TslGame.TempComponentInfo
// 0x0028 (0x0028 - 0x0000)
struct FTempComponentInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        ParentComponent;                                   // 0x0018(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        CurrentComponent;                                  // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTempComponentInfo) == 0x000008, "Wrong alignment on FTempComponentInfo");
static_assert(sizeof(FTempComponentInfo) == 0x000028, "Wrong size on FTempComponentInfo");
static_assert(offsetof(FTempComponentInfo, ParentComponent) == 0x000018, "Member 'FTempComponentInfo::ParentComponent' has a wrong offset!");
static_assert(offsetof(FTempComponentInfo, CurrentComponent) == 0x000020, "Member 'FTempComponentInfo::CurrentComponent' has a wrong offset!");

// ScriptStruct TslGame.TrajectoryWeaponData
// 0x0060 (0x0060 - 0x0000)
struct FTrajectoryWeaponData final
{
public:
	float                                         WeaponSpread;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimingSpreadModifier;                              // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScopingSpreadModifier;                             // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FiringSpreadBase;                                  // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandRecoveryTime;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchRecoveryTime;                                // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProneRecoveryTime;                                 // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoveryInterval;                                  // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilSpeed;                                       // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilRecoverySpeed;                               // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilPatternScale;                                // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialSpeed;                                      // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitDamage;                                         // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangeModifier;                                     // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReferenceDistance;                                 // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelDistanceMax;                                 // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPenetrable;                                      // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FRecoilPatternData>             RecoilPatterns;                                    // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrajectoryWeaponData) == 0x000008, "Wrong alignment on FTrajectoryWeaponData");
static_assert(sizeof(FTrajectoryWeaponData) == 0x000060, "Wrong size on FTrajectoryWeaponData");
static_assert(offsetof(FTrajectoryWeaponData, WeaponSpread) == 0x000000, "Member 'FTrajectoryWeaponData::WeaponSpread' has a wrong offset!");
static_assert(offsetof(FTrajectoryWeaponData, AimingSpreadModifier) == 0x000004, "Member 'FTrajectoryWeaponData::AimingSpreadModifier' has a wrong offset!");
static_assert(offsetof(FTrajectoryWeaponData, ScopingSpreadModifier) == 0x000008, "Member 'FTrajectoryWeaponData::ScopingSpreadModifier' has a wrong offset!");
static_assert(offsetof(FTrajectoryWeaponData, FiringSpreadBase) == 0x00000C, "Member 'FTrajectoryWeaponData::FiringSpreadBase' has a wrong offset!");
static_assert(offsetof(FTrajectoryWeaponData, StandRecoveryTime) == 0x000010, "Member 'FTrajectoryWeaponData::StandRecoveryTime' has a wrong offset!");
static_assert(offsetof(FTrajectoryWeaponData, CrouchRecoveryTime) == 0x000014, "Member 'FTrajectoryWeaponData::CrouchRecoveryTime' has a wrong offset!");
static_assert(offsetof(FTrajectoryWeaponData, ProneRecoveryTime) == 0x000018, "Member 'FTrajectoryWeaponData::ProneRecoveryTime' has a wrong offset!");
static_assert(offsetof(FTrajectoryWeaponData, RecoveryInterval) == 0x00001C, "Member 'FTrajectoryWeaponData::RecoveryInterval' has a wrong offset!");
static_assert(offsetof(FTrajectoryWeaponData, RecoilSpeed) == 0x000020, "Member 'FTrajectoryWeaponData::RecoilSpeed' has a wrong offset!");
static_assert(offsetof(FTrajectoryWeaponData, RecoilRecoverySpeed) == 0x000024, "Member 'FTrajectoryWeaponData::RecoilRecoverySpeed' has a wrong offset!");
static_assert(offsetof(FTrajectoryWeaponData, RecoilPatternScale) == 0x000028, "Member 'FTrajectoryWeaponData::RecoilPatternScale' has a wrong offset!");
static_assert(offsetof(FTrajectoryWeaponData, InitialSpeed) == 0x00002C, "Member 'FTrajectoryWeaponData::InitialSpeed' has a wrong offset!");
static_assert(offsetof(FTrajectoryWeaponData, HitDamage) == 0x000030, "Member 'FTrajectoryWeaponData::HitDamage' has a wrong offset!");
static_assert(offsetof(FTrajectoryWeaponData, RangeModifier) == 0x000034, "Member 'FTrajectoryWeaponData::RangeModifier' has a wrong offset!");
static_assert(offsetof(FTrajectoryWeaponData, ReferenceDistance) == 0x000038, "Member 'FTrajectoryWeaponData::ReferenceDistance' has a wrong offset!");
static_assert(offsetof(FTrajectoryWeaponData, TravelDistanceMax) == 0x00003C, "Member 'FTrajectoryWeaponData::TravelDistanceMax' has a wrong offset!");
static_assert(offsetof(FTrajectoryWeaponData, IsPenetrable) == 0x000040, "Member 'FTrajectoryWeaponData::IsPenetrable' has a wrong offset!");
static_assert(offsetof(FTrajectoryWeaponData, DamageType) == 0x000048, "Member 'FTrajectoryWeaponData::DamageType' has a wrong offset!");
static_assert(offsetof(FTrajectoryWeaponData, RecoilPatterns) == 0x000050, "Member 'FTrajectoryWeaponData::RecoilPatterns' has a wrong offset!");

// ScriptStruct TslGame.RecoilInfo
// 0x0068 (0x0068 - 0x0000)
struct FRecoilInfo final
{
public:
	float                                         VerticalRecoilMin;                                 // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalRecoilMax;                                 // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalRecoilVariation;                           // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalRecoveryModifier;                          // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalRecoveryClamp;                             // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalRecoveryMax;                               // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftMax;                                           // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightMax;                                          // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalTendency;                                // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           RecoilCurve;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BulletsPerSwitch;                                  // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimePerSwitch;                                     // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSwitchOnTime;                                     // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecoilSpeed_Vertical;                              // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilSpeed_Horizontal;                            // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoverySpeed_Vertical;                            // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilValue_Climb;                                 // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilValue_Fall;                                  // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilModifier_Stand;                              // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilModifier_Crouch;                             // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilModifier_Prone;                              // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoilHorizontalMinScalar;                         // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRecoilInfo) == 0x000008, "Wrong alignment on FRecoilInfo");
static_assert(sizeof(FRecoilInfo) == 0x000068, "Wrong size on FRecoilInfo");
static_assert(offsetof(FRecoilInfo, VerticalRecoilMin) == 0x000000, "Member 'FRecoilInfo::VerticalRecoilMin' has a wrong offset!");
static_assert(offsetof(FRecoilInfo, VerticalRecoilMax) == 0x000004, "Member 'FRecoilInfo::VerticalRecoilMax' has a wrong offset!");
static_assert(offsetof(FRecoilInfo, VerticalRecoilVariation) == 0x000008, "Member 'FRecoilInfo::VerticalRecoilVariation' has a wrong offset!");
static_assert(offsetof(FRecoilInfo, VerticalRecoveryModifier) == 0x00000C, "Member 'FRecoilInfo::VerticalRecoveryModifier' has a wrong offset!");
static_assert(offsetof(FRecoilInfo, VerticalRecoveryClamp) == 0x000010, "Member 'FRecoilInfo::VerticalRecoveryClamp' has a wrong offset!");
static_assert(offsetof(FRecoilInfo, VerticalRecoveryMax) == 0x000014, "Member 'FRecoilInfo::VerticalRecoveryMax' has a wrong offset!");
static_assert(offsetof(FRecoilInfo, LeftMax) == 0x000018, "Member 'FRecoilInfo::LeftMax' has a wrong offset!");
static_assert(offsetof(FRecoilInfo, RightMax) == 0x00001C, "Member 'FRecoilInfo::RightMax' has a wrong offset!");
static_assert(offsetof(FRecoilInfo, HorizontalTendency) == 0x000020, "Member 'FRecoilInfo::HorizontalTendency' has a wrong offset!");
static_assert(offsetof(FRecoilInfo, RecoilCurve) == 0x000028, "Member 'FRecoilInfo::RecoilCurve' has a wrong offset!");
static_assert(offsetof(FRecoilInfo, BulletsPerSwitch) == 0x000030, "Member 'FRecoilInfo::BulletsPerSwitch' has a wrong offset!");
static_assert(offsetof(FRecoilInfo, TimePerSwitch) == 0x000034, "Member 'FRecoilInfo::TimePerSwitch' has a wrong offset!");
static_assert(offsetof(FRecoilInfo, bSwitchOnTime) == 0x000038, "Member 'FRecoilInfo::bSwitchOnTime' has a wrong offset!");
static_assert(offsetof(FRecoilInfo, RecoilSpeed_Vertical) == 0x00003C, "Member 'FRecoilInfo::RecoilSpeed_Vertical' has a wrong offset!");
static_assert(offsetof(FRecoilInfo, RecoilSpeed_Horizontal) == 0x000040, "Member 'FRecoilInfo::RecoilSpeed_Horizontal' has a wrong offset!");
static_assert(offsetof(FRecoilInfo, RecoverySpeed_Vertical) == 0x000044, "Member 'FRecoilInfo::RecoverySpeed_Vertical' has a wrong offset!");
static_assert(offsetof(FRecoilInfo, RecoilValue_Climb) == 0x000048, "Member 'FRecoilInfo::RecoilValue_Climb' has a wrong offset!");
static_assert(offsetof(FRecoilInfo, RecoilValue_Fall) == 0x00004C, "Member 'FRecoilInfo::RecoilValue_Fall' has a wrong offset!");
static_assert(offsetof(FRecoilInfo, RecoilModifier_Stand) == 0x000050, "Member 'FRecoilInfo::RecoilModifier_Stand' has a wrong offset!");
static_assert(offsetof(FRecoilInfo, RecoilModifier_Crouch) == 0x000054, "Member 'FRecoilInfo::RecoilModifier_Crouch' has a wrong offset!");
static_assert(offsetof(FRecoilInfo, RecoilModifier_Prone) == 0x000058, "Member 'FRecoilInfo::RecoilModifier_Prone' has a wrong offset!");
static_assert(offsetof(FRecoilInfo, RecoilHorizontalMinScalar) == 0x00005C, "Member 'FRecoilInfo::RecoilHorizontalMinScalar' has a wrong offset!");

// ScriptStruct TslGame.ThrowableWeaponData
// 0x0098 (0x0098 - 0x0000)
struct FThrowableWeaponData final
{
public:
	TSubclassOf<class ATslProjectile>             ProjectileClass;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ATslParticle>               PinOffEffectClass;                                 // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     Ring;                                              // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FName                                   RingAttachSocket;                                  // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProjectileExplosionStartType                 ExplosionStartType;                                // 0x0020(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ExplosionDelay;                                    // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FireDelay;                                         // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationTimeLimit;                               // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FThrowableAnim                         StandAnim;                                         // 0x0030(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FThrowableAnim                         CrouchAnim;                                        // 0x0048(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FThrowableAnim                         ProneAnim;                                         // 0x0060(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UCurveFloat*                            SpeedCurve;                                        // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            PitchCurve;                                        // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowTime;                                         // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThrowCooldownDuration;                             // 0x008C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeCooked;                                      // 0x0090(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FThrowableWeaponData) == 0x000008, "Wrong alignment on FThrowableWeaponData");
static_assert(sizeof(FThrowableWeaponData) == 0x000098, "Wrong size on FThrowableWeaponData");
static_assert(offsetof(FThrowableWeaponData, ProjectileClass) == 0x000000, "Member 'FThrowableWeaponData::ProjectileClass' has a wrong offset!");
static_assert(offsetof(FThrowableWeaponData, PinOffEffectClass) == 0x000008, "Member 'FThrowableWeaponData::PinOffEffectClass' has a wrong offset!");
static_assert(offsetof(FThrowableWeaponData, Ring) == 0x000010, "Member 'FThrowableWeaponData::Ring' has a wrong offset!");
static_assert(offsetof(FThrowableWeaponData, RingAttachSocket) == 0x000018, "Member 'FThrowableWeaponData::RingAttachSocket' has a wrong offset!");
static_assert(offsetof(FThrowableWeaponData, ExplosionStartType) == 0x000020, "Member 'FThrowableWeaponData::ExplosionStartType' has a wrong offset!");
static_assert(offsetof(FThrowableWeaponData, ExplosionDelay) == 0x000024, "Member 'FThrowableWeaponData::ExplosionDelay' has a wrong offset!");
static_assert(offsetof(FThrowableWeaponData, FireDelay) == 0x000028, "Member 'FThrowableWeaponData::FireDelay' has a wrong offset!");
static_assert(offsetof(FThrowableWeaponData, ActivationTimeLimit) == 0x00002C, "Member 'FThrowableWeaponData::ActivationTimeLimit' has a wrong offset!");
static_assert(offsetof(FThrowableWeaponData, StandAnim) == 0x000030, "Member 'FThrowableWeaponData::StandAnim' has a wrong offset!");
static_assert(offsetof(FThrowableWeaponData, CrouchAnim) == 0x000048, "Member 'FThrowableWeaponData::CrouchAnim' has a wrong offset!");
static_assert(offsetof(FThrowableWeaponData, ProneAnim) == 0x000060, "Member 'FThrowableWeaponData::ProneAnim' has a wrong offset!");
static_assert(offsetof(FThrowableWeaponData, SpeedCurve) == 0x000078, "Member 'FThrowableWeaponData::SpeedCurve' has a wrong offset!");
static_assert(offsetof(FThrowableWeaponData, PitchCurve) == 0x000080, "Member 'FThrowableWeaponData::PitchCurve' has a wrong offset!");
static_assert(offsetof(FThrowableWeaponData, ThrowTime) == 0x000088, "Member 'FThrowableWeaponData::ThrowTime' has a wrong offset!");
static_assert(offsetof(FThrowableWeaponData, ThrowCooldownDuration) == 0x00008C, "Member 'FThrowableWeaponData::ThrowCooldownDuration' has a wrong offset!");
static_assert(offsetof(FThrowableWeaponData, bCanBeCooked) == 0x000090, "Member 'FThrowableWeaponData::bCanBeCooked' has a wrong offset!");

// ScriptStruct TslGame.WebPopupParam
// 0x0038 (0x0038 - 0x0000)
struct FWebPopupParam final
{
public:
	class FString                                 PopupId;                                           // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Uri;                                               // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Width;                                             // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x002C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 BackgroundColor;                                   // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          UseBackgroundColor;                                // 0x0034(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWebPopupParam) == 0x000008, "Wrong alignment on FWebPopupParam");
static_assert(sizeof(FWebPopupParam) == 0x000038, "Wrong size on FWebPopupParam");
static_assert(offsetof(FWebPopupParam, PopupId) == 0x000000, "Member 'FWebPopupParam::PopupId' has a wrong offset!");
static_assert(offsetof(FWebPopupParam, Uri) == 0x000010, "Member 'FWebPopupParam::Uri' has a wrong offset!");
static_assert(offsetof(FWebPopupParam, X) == 0x000020, "Member 'FWebPopupParam::X' has a wrong offset!");
static_assert(offsetof(FWebPopupParam, Y) == 0x000024, "Member 'FWebPopupParam::Y' has a wrong offset!");
static_assert(offsetof(FWebPopupParam, Width) == 0x000028, "Member 'FWebPopupParam::Width' has a wrong offset!");
static_assert(offsetof(FWebPopupParam, Height) == 0x00002C, "Member 'FWebPopupParam::Height' has a wrong offset!");
static_assert(offsetof(FWebPopupParam, BackgroundColor) == 0x000030, "Member 'FWebPopupParam::BackgroundColor' has a wrong offset!");
static_assert(offsetof(FWebPopupParam, UseBackgroundColor) == 0x000034, "Member 'FWebPopupParam::UseBackgroundColor' has a wrong offset!");

// ScriptStruct TslGame.VivoxConnectionInfo
// 0x0020 (0x0020 - 0x0000)
struct FVivoxConnectionInfo final
{
public:
	class FString                                 ServerURL;                                         // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Domain;                                            // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVivoxConnectionInfo) == 0x000008, "Wrong alignment on FVivoxConnectionInfo");
static_assert(sizeof(FVivoxConnectionInfo) == 0x000020, "Wrong size on FVivoxConnectionInfo");
static_assert(offsetof(FVivoxConnectionInfo, ServerURL) == 0x000000, "Member 'FVivoxConnectionInfo::ServerURL' has a wrong offset!");
static_assert(offsetof(FVivoxConnectionInfo, Domain) == 0x000010, "Member 'FVivoxConnectionInfo::Domain' has a wrong offset!");

}

